//****************************************************************************
//****************************************************************************
//**                                                                        **
//**            (C)Copyright 1993-2017 Supermicro Computer, Inc.            **
//**                                                                        **
//****************************************************************************
//****************************************************************************
//  File History
//
//  Rev. 1.00
//      Bug Fixed:  Log/Show MRC error/warning by major code (refer Intel Purley MRC Error Codes_draft_0.3.xlsx)
//      Reason:     
//      Auditor:    Jimmy Chiu
//      Date:       Jun/05/2017
//
//*****************************************************************************
/**
  This file contains an 'Intel Pre-EFI Module' and is licensed
  for Intel CPUs and Chipsets under the terms of your license
  agreement with Intel or your vendor.  This file may be
  modified by the user, subject to additional terms of the
  license agreement
**/
/*************************************************************************
 *
 * Reference Code
 *
 * ESS - Enterprise Silicon Software
 *
 * INTEL CONFIDENTIAL
 *
 * Copyright 2006 - 2016 Intel Corporation All Rights Reserved.
 *
 * The source code contained or described herein and all documents
 * related to the source code ("Material") are owned by Intel
 * Corporation or its suppliers or licensors. Title to the Material
 * remains with Intel Corporation or its suppliers and licensors.
 * The Material contains trade secrets and proprietary and confidential
 * information of Intel or its suppliers and licensors. The Material
 * is protected by worldwide copyright and trade secret laws and treaty
 * provisions.  No part of the Material may be used, copied, reproduced,
 * modified, published, uploaded, posted, transmitted, distributed, or
 * disclosed in any way without Intel's prior express written permission.
 *
 * No license under any patent, copyright, trade secret or other
 * intellectual property right is granted to or conferred upon you
 * by disclosure or delivery of the Materials, either expressly,
 * by implication, inducement, estoppel or otherwise. Any license
 * under such intellectual property rights must be express and
 * approved by Intel in writing.
 *
 ************************************************************************/

#include "SysHostChip.h"
#include "MemHostChip.h"
#include "SysFunc.h"
#include "MemApiSkx.h"
#include "RcRegs.h"
#include "CpuPciAccess.h"
#define SPD_ARRAY_SIZE  512

#ifdef _MSC_VER
#pragma warning(disable : 4740)
#pragma warning(disable : 4702)
#endif

// DDR4 RTL sim run
static const UINT8 HardCoded_spd_udimm[SPD_ARRAY_SIZE] = {
  0x12, 0x00, 0x0c, 0x02, 0x83, 0x21, 0x04, 0x88,
  0x00, 0x00, 0x00, 0x03, 0x01, 0x0b, 0x00, 0x00,
  0x00, 0x00, 0x0a, 0x0a, 0xf0, 0x03, 0x00, 0x00,
  0x6c, 0x6c, 0x6c, 0x11, 0x18, 0x80, 0x00, 0x05,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x15, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x02, 0xfe, 0x00, 0x11, 0x52, 0x78,
  0x56, 0x34, 0x12, 0x45, 0x4c, 0x50, 0x49, 0x44,
  0x41, 0x52, 0x43, 0x42, 0x31, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x02, 0xfe, 0x02, 0x45, 0x4c, 0x50, 0x49, 0x44,
  0x41, 0x52, 0x43, 0x42, 0x31, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xad, 0xbe, 0xef, 0x00, 0x00, 0x00
};

static const UINT8 HardCoded_spd_rdimm[SPD_ARRAY_SIZE] = {
  0x12, 0x00, 0x0c, 0x01, 0x84, 0x21, 0x04, 0x88,
  0x00, 0x00, 0x00, 0x02, 0x00, 0x1b, 0x00, 0x00,
  0x00, 0x00, 0x0a, 0x0a, 0xf0, 0x03, 0x00, 0x00,
  0x6c, 0x6c, 0x6c, 0x11, 0x18, 0x80, 0x00, 0x05,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x15, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x02, 0xfe, 0x00, 0x11, 0x52, 0x78,
  0x56, 0x34, 0x12, 0x45, 0x4c, 0x50, 0x49, 0x44,
  0x41, 0x52, 0x43, 0x42, 0x31, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x02, 0xfe, 0x02, 0x45, 0x4c, 0x50, 0x49, 0x44,
  0x41, 0x52, 0x43, 0x42, 0x31, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xad, 0xbe, 0xef, 0x00, 0x00, 0x00
};

static const UINT8 HardCoded_spd_lrdimm[SPD_ARRAY_SIZE] = {
  0x23, 0x10, 0x0c, 0x04, 0x84, 0x21, 0x91, 0x08, 0x00, 0x40, 0x00, 0x03, 0x18, 0x0B, 0x80, 0x00, // 0x00
  0x00, 0x00, 0x07, 0x0C, 0xF8, 0x0F, 0x00, 0x00, 0x6E, 0x6E, 0x6E, 0x11, 0x00, 0x6E, 0x20, 0x08, // 0x01
  0x00, 0x05, 0x70, 0x03, 0x00, 0x68, 0x1B, 0x28, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x02
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x0B, 0x0B, 0x0B, // 0x03
  0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x00, 0x00, // 0x04
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x05
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x06
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0xB5, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD6, 0x4A, 0xD5, // 0x07
  0x11, 0x11, 0x03, 0x09, 0x00, 0x80, 0xB3, 0x30, 0x01, 0x76, 0x0A, 0x21, 0x1D, 0x1D, 0x1D, 0x1D, // 0x08
  0x25, 0x15, 0x15, 0x00, 0x00, 0x14, 0x14, 0x00, 0x27, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x09
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0A
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0B
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0C
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0D
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0E
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xD3, // 0x0F
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x10
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x11
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x12
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x13
  0x80, 0xCE, 0x01, 0x14, 0x16, 0x01, 0xDC, 0x4B, 0x97, 0x4D, 0x33, 0x38, 0x36, 0x41, 0x34, 0x47, // 0x14
  0x34, 0x30, 0x44, 0x4D, 0x30, 0x2D, 0x43, 0x52, 0x43, 0x20, 0x20, 0x20, 0x20, 0x00, 0x80, 0xCE, // 0x15
  0x00, 0x34, 0x30, 0x34, 0x41, 0x30, 0x30, 0x30, 0x0C, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x16
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x17
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x18
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x19
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1A
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1B
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1C
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1D
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1E
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1F
};

static const UINT8 HardCoded_spd_3DS_8r_lrdimm[SPD_ARRAY_SIZE] = {
0x24, 0x10, 0x0c, 0x04, 0x84, 0x21, 0xb2, 0x08, 0x00, 0x40, 0x00, 0x03, 0x08, 0x0b, 0x80, 0x00, //0x00
0x00, 0x00, 0x08, 0x0c, 0xf8, 0x0f, 0x00, 0x00, 0x7d, 0x6e, 0x6e, 0x11, 0x08, 0x76, 0x20, 0x08, //0x01
0x00, 0x05, 0x70, 0x03, 0x00, 0x78, 0x1e, 0x2b, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x02
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x0b, 0x0b, 0x0b, //0x03
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x00, 0x0b, 0x00, 0x00, //0x04
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x05
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x06
0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0xb5, 0xce, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc2, 0x1d, 0x51, //0x07
0x11, 0x11, 0x00, 0x09, 0x00, 0x80, 0xb3, 0x30, 0x01, 0x76, 0x0a, 0x21, 0x1f, 0x1f, 0x00, 0x00, //0x08
0x1d, 0x15, 0x15, 0x00, 0x00, 0x14, 0x14, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x09
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x0A
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x0B
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x0C
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x0D
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x0E
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x2f, //0x0F
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x10
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x11
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x12
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x13
0x80, 0xce, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d, 0x33, 0x38, 0x36, 0x41, 0x38, 0x47, //0x14
0x34, 0x30, 0x44, 0x34, 0x30, 0x2d, 0x43, 0x50, 0x42, 0x20, 0x20, 0x20, 0x20, 0x00, 0x80, 0xce, //0x15
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x16
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x17
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x18
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x19
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x1a
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x1b
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x1c
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x1d
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x1e
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x1f

};

static const UINT8 HardCoded_spd_3DS_8r_rdimm[SPD_ARRAY_SIZE] = {
0x24, 0x10, 0x0C, 0x01, 0x84, 0x21, 0xB2, 0x08, 0x00, 0x40, 0x00, 0x03, 0x08, 0x0B, 0x80, 0x00,  //0x00
0x00, 0x00, 0x08, 0x0C, 0xF8, 0x0F, 0x00, 0x00, 0x7D, 0x6E, 0x6E, 0x11, 0x08, 0x76, 0x20, 0x08,  //0x01
0x00, 0x05, 0x70, 0x03, 0x00, 0x78, 0x1E, 0x2B, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x02
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x0B, 0x0B, 0x0B,  //0x03
0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x00, 0x00,  //0x04
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x05
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x06
0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0xB5, 0xCE, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC2, 0xBE, 0x84,  //0x07
0x11, 0x11, 0x00, 0x09, 0x00, 0x80, 0xB3, 0x30, 0x01, 0x65, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x08
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x09
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x0a
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x0b
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x0c
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x0d
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x0e
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB7, 0xD9,  //0x0f
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x10
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x11
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x12
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x13
0x80, 0xCE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4D, 0x33, 0x39, 0x33, 0x41, 0x38, 0x47,  //0x14
0x34, 0x30, 0x44, 0x34, 0x30, 0x2D, 0x43, 0x52, 0x42, 0x20, 0x20, 0x20, 0x20, 0x00, 0x80, 0xCE,  //0x15
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x16
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x17
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x18
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x19
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x1a
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x1b
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x1c
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x1d
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //0x1e
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xA8, 0x72, 0xCF, 0x1A,  //0x1f

};

static const UINT8 HardCoded_spd_UDIMM_DR_x8[SPD_ARRAY_SIZE] = {
0x12, 0x01, 0x0C, 0x02, 0x84, 0x19, 0x00, 0x80, 0x00, 0x00, 0x00, 0x03, 0x09, 0x0B, 0x00, 0x00,
0x00, 0x00, 0x08, 0x0A, 0xFC, 0xAF, 0x02, 0x00, 0x78, 0x78, 0x78, 0x11, 0x08, 0x80, 0x20, 0x08,
0x70, 0x03, 0xD0, 0x02, 0x00, 0xF0, 0x2B, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9D, 0xB5, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC2, 0xAA, 0xAA,
0x15, 0x01, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x11, 0x52, 0x78,
0x56, 0x34, 0x12, 0x53, 0x41, 0x4D, 0x53, 0x55, 0x4E, 0x47, 0x55, 0x52, 0x43, 0x42, 0x30, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0xCE, 0x01, 0x53, 0x41, 0x4D, 0x53, 0x55,
0x4E, 0x47, 0x55, 0x52, 0x43, 0x42, 0x30, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x05, 0xFA, 0x76, 0x00,
};
// DDR4 RTL sim run
static const UINT8 HardCoded_spd_aep[SPD_ARRAY_SIZE] = {
0x23, 0x01, 0x0D, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, // 0x00
0x00, 0x00, 0x0a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x01
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x02
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x21, 0x01, 0x21, // 0x03
0x01, 0x21, 0x01, 0x21, 0x01, 0x21, 0x01, 0x21, 0x01, 0x21, 0x01, 0x21, 0x01, 0x21, 0x00, 0x00, // 0x04
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x05
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x06
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x07
0x00, 0x00, 0x00, 0x00, 0x06, 0x03, 0x01, 0x55, 0x79, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x08
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x09
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0A
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0B
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0C
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, // 0X0D
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0E
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0F
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x10
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x11
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x12
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x13
0xAD, 0xBA, 0xAA, 0x13, 0x51, 0x78, 0x56, 0x34, 0x12, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4D, 0x4D, // 0x14
0x49, 0x44, 0x2D, 0x50, 0x45, 0x41, 0x20, 0x73, 0x63, 0x69, 0x6D, 0x69, 0x53, 0x00, 0x00, 0x00, // 0x15
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x16
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x17
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x18
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x19
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1A
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1B
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1C
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1D
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1E
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // 0x1F

};



//
// Local Prototypes
//
static void   GetChDimmFromSmbAddress(PSYSHOST host, struct smbDevice dev, UINT8 *ch, UINT8 *dimm);
static UINT32 ReadSmbWorkerFunction(PSYSHOST host, UINT8 socket, struct smbDevice dev, UINT8 byteOffset, UINT8 *data);
static void IsSmbusSemaphoreNeeded (PSYSHOST host, UINT8 socket);
static UINT8 GetSmbus (PSYSHOST host, UINT8 socket);
static void ReleaseSmbus (PSYSHOST host, UINT8 socket);
static UINT32 AcquireReleaseAPSystemSemaphore (PSYSHOST host, UINT8 socket, UINT8 LocAPSemaphoreNum, UINT8 OpCode);



/**

  Determines if Semaphore is needed to access SMBus\n\n

    If SBSP is trying to access local SMBus, Semaphore is NOT needed\n
           Access SMBus as normal\n\n

    If Smbus target socket, which is not SBSP, is trying to access AP SMBus, Semaphore IS needed\n
           Get semaphore for AP SMBus access for target AP using\n
           that AP's unique SYSTEMSEMAPHORE0_UBOX_MISC_REG

  @param host        - Pointer to sysHost, the system host (root) structure
  @param socket      - Processor socket ID

  @retval None

**/
static void
IsSmbusSemaphoreNeeded (
                       PSYSHOST    host,
                       UINT8       socket
                        )
{

  //
  // Current thread is SBSP
  //
  if (host->var.common.socketId == host->nvram.common.sbspSocketId) {
    if (socket != host->nvram.common.sbspSocketId) {
      //
      // Smbus target socket wants to access AP SMBUS, semaphore needed
      //
      host->var.common.smbSync = 0x01;
      GetSmbus (host, socket);
    } else {
      //
      // SMBUS target socket is SBSP, semaphore not needed
      //
      host->var.common.smbSync = 0x0;
    }
  } else {
    //
    // Current thread is not SBSP
    //
    if (socket == host->var.common.socketId) {
      //
      // Smbus target socket wants to access AP SMBUS, semaphore needed
      //
      host->var.common.smbSync = 0x01;
      GetSmbus (host, socket);
    } else {
      //
      // Smbus target thread does not equal current thread
      //
      host->var.common.smbSync = 0x0;
      RC_ASSERT (socket != host->var.common.socketId, ERR_RC_INTERNAL, RC_ASSERT_MINOR_CODE_29);
    }
  }

} // IsSmbusSemaphoreNeeded


/**

  Get control of a local AP system semaphore for the calling socket\n
  This should be used with a matching ReleaseSmbus() to gain\n
  exclusive ownership of a local AP system semaphore for a section of\n
  code that blocks/yields to other sockets\n
  host->var.common.smbusDepth is used to handle the nested calls to this function

  @param host   - Pointer to sysHost, the system host (root) structure
  @param socket - Processor socket ID

  @retval 1 - success

**/
static UINT8
GetSmbus (
         PSYSHOST    host,
         UINT8       socket
         )
  /*++

  Get control of a local AP system semaphore for the calling socket
  This should be used with a matching ReleaseSmbus() to gain
  exclusive ownership of a local AP system semaphore for a section of
  code that blocks/yields to other sockets
  host->var.common.smbusDepth is used to handle the nested calls to this function

  @param host  - Pointer to the system host (root) structure

  @retval 1 - success

--*/
{

  if ((host->setup.mem.options & MULTI_THREAD_MRC_EN) && (host->var.common.smbSync)) {

    if (host->var.common.smbusDepth == 0) {

      if (AcquireReleaseAPSystemSemaphore (host, socket, SYSTEMSEMAPHORE0, ACQUIRE_SEMAPHORE) != SUCCESS)
      {
        RC_ASSERT(FALSE, ERR_RC_INTERNAL, RC_ASSERT_MINOR_CODE_30);
      }
      host->var.common.SmbusAPSemaphoreAcquired = 1;
    }

    // increment nested call depth
    host->var.common.smbusDepth++;

    // if count rollover, halt on error
    if (host->var.common.smbusDepth == 0)  {
      HaltOnError(host, 0, 0);
    }
  }
  return 1;
} //GetSmbus


/**

  Release ownership of a local AP system semaphore.
  Must be used to match GetSmbus()

  @param host   - Pointer to sysHost, the system host (root) structure
  @param socket - Processor socket ID

  @retval None

**/
static void
ReleaseSmbus (
             PSYSHOST    host,
             UINT8       socket
             )
/*++

  Release ownership of a local AP system semaphore.
  Must be used to match GetSmbus()

  @param host  - Pointer to the system host (root) structure

  @retval N/A

--*/
{


  if ((host->setup.mem.options & MULTI_THREAD_MRC_EN) && (host->var.common.smbSync)) {

    if (host->var.common.smbusDepth == 1) {

      AcquireReleaseAPSystemSemaphore (host, socket, SYSTEMSEMAPHORE0, RELEASE_SEMAPHORE);
    }

    // decrement nested call depth
    if (host->var.common.smbusDepth != 0) {
      host->var.common.smbusDepth--;
    }
  }

} // ReleaseSmbus


/**
  Accquire or Release the AP system semaphore
  Called by the target socket
  Used for ensuring exclusive access to resources among sockets \n
       IMPORTANT: \n
           This function must be called in the sequence below: \n
                ...... \n
              AcquireReleaseAPSystemSemaphore (host, socket, SYSTEMSEMAPHORE0, ACQUIRE_SEMAPHORE);    //  Acquire ownership of semaphore \n
                do_something();                                                                       //  Perform intended task \n
              AcquireReleaseAPSystemSemaphore (host, socket, SYSTEMSEMAPHORE0, RELEASE_SEMAPHORE);    //  Release ownership of semaphore \n
                ...... \n

  @param host                 - Pointer to sysHost, the system host (root) structure
  @param socket               - target socket
  @param LocAPSemaphoreNum    - SYSTEMSEMAPHORE register number (0 or 1)
  @param OpCode               - 1/0   ACQUIRE_SEMAPHORE / RELEASE_SEMAPHORE

  @retval  None

**/
static UINT32
AcquireReleaseAPSystemSemaphore (
   PSYSHOST  host,
   UINT8     socket,
   UINT8     LocAPSemaphoreNum,
   UINT8     OpCode
   )
/*++
  Accquire or Release the AP system semaphore
  Called by the target socket
  Used for ensuring exclusive access to resources among sockets
       IMPORTANT:
           This function must be called in the sequence below:
                ......
              AcquireReleaseAPSystemSemaphore (host, socket, SYSTEMSEMAPHORE0, ACQUIRE_SEMAPHORE);    //  Acquire ownership of semaphore
                do_something();                                                                       //  Perform intended task
              AcquireReleaseAPSystemSemaphore (host, socket, SYSTEMSEMAPHORE0, RELEASE_SEMAPHORE);    //  Release ownership of semaphore
                ......

  @param host      - Pointer to the system host structure
  @param socket    - target socket
  @param LocAPSemaphoreNum,   - SYSTEMSEMAPHORE register number (0 or 1)
  @param OpCode - 1/0   ACQUIRE_SEMAPHORE / RELEASE_SEMAPHORE

  @retval  None

--*/
{
  UINT32                                RegAddr;
  UINT8                                 MySocId;
  SYSTEMSEMAPHORE0_UBOX_MISC_STRUCT     Reg32;
  UINT32                                status = SUCCESS;

  MySocId = host->var.common.socketId;

  if (LocAPSemaphoreNum == SYSTEMSEMAPHORE0) {
    RegAddr = SYSTEMSEMAPHORE0_UBOX_MISC_REG;
  } else {
    RegAddr = SYSTEMSEMAPHORE1_UBOX_MISC_REG;
  }

  //
  // Read SYSTEMSEMAPHORE0 CSR on target socket
  //
  Reg32.Data = ReadCpuPciCfgEx (host, socket, 0, RegAddr);

  //
  // Set requesternode field
  //
  Reg32.Bits.requesternode = MySocId;

  if (OpCode == RELEASE_SEMAPHORE)   {
    //
    // Release Semaphore -  Write requesternode = socket, and bus_aqu_release = 0
    //
    Reg32.Bits.bus_aqu_release = 0;
    WriteCpuPciCfgEx (host, socket, 0, RegAddr, Reg32.Data);
    host->var.common.SmbusAPSemaphoreAcquired = 0;
  }

  if (OpCode == ACQUIRE_SEMAPHORE)   {
    //
    // Accquire Semaphore - Write requesternode = socket, and bus_aqu_release = 1
    //
    Reg32.Bits.bus_aqu_release = 1;
    WriteCpuPciCfgEx (host, socket, 0, RegAddr, Reg32.Data);

    //
    // Sample and return semaphore status to caller
    //
    Reg32.Data = ReadCpuPciCfgEx (host, socket, 0, RegAddr);
    if (!((Reg32.Bits.bus_aqu_release == 1) && (Reg32.Bits.currentnode == MySocId))) {
      status = FAILURE;
    }
  }
  return status;
}

/**

  Returns the SMBus strap address of the DIMM slot

  @param host    - Pointer to sysHost
  @param socket  - Socket number
  @param ch      - Channel number
  @param dimm    - Dimm number
  @param dev     - Pointer to smbDevice

  @retval MC ID

**/
void
GetSmbAddress (
        PSYSHOST  host,
        UINT8     socket,
        UINT8     ch,
        UINT8     dimm,
        struct smbDevice *dev
        )
{
  dev->mcId = GetMCID(host, socket, ch);
  dev->address.busSegment = ch / MAX_MC_CH;
  dev->address.strapAddress = dimm + ((ch % MAX_MC_CH) * MAX_DIMM);
} // GetSmbAddress


/**

  Returns the SMBus strap address of the DIMM slot

  @param host    - Pointer to sysHost
  @param socket  - Socket number
  @param ch      - Channel number
  @param dimm    - Dimm number
  @param dev     - Pointer to smbDevice

  @retval MC ID

**/
static void
GetChDimmFromSmbAddress (
        PSYSHOST  host,
        struct smbDevice dev,
        UINT8     *ch,
        UINT8     *dimm
        )
{
  *ch = (UINT8)((dev.address.busSegment * MAX_MC_CH) + (dev.address.strapAddress / MAX_DIMM));
  *dimm = dev.address.strapAddress % MAX_DIMM;
} // GetChDimmFromSmbAddress


/**

  Initialize socket SMBUS controller

  @param host  - Pointer to the system host (root) structure
  @param socket  - processor socket ID

  @retval N/A

**/
void
InitSmb (
        PSYSHOST host,
        UINT8    socket
        )
{
  UINT8                         mcId;
  UINT32                        smbCmdReg;
  UINT32                        smbStatReg;
  UINT8                         busSeg;
  UINT8                         reqData;
  UINT8                         reqType;
  UINT32                        base;
  UINT32                        enable;
  SMB_STATUS_CFG_0_PCU_FUN5_STRUCT   smbStat;
  SMB_CMD_CFG_1_PCU_FUN5_STRUCT      smbCmd;
  SMB_PERIOD_CFG_0_PCU_FUN5_STRUCT   smbPeriod;
  MC_INIT_STATE_G_MC_MAIN_STRUCT     mcInitStateG;

  OutputExtendedCheckpoint((host, STS_DIMM_DETECT, SUB_INIT_SMB, socket));

  if (host->var.mem.powerGoodReset) {
    //
    // Assert reset
    //
    mcInitStateG.Data = MemReadPciCfgMC (host, socket, 0, MC_INIT_STATE_G_MC_MAIN_REG);
    mcInitStateG.Bits.ddr_reset = 0;

    for (mcId = 0; mcId < host->var.mem.maxIMC; mcId++) {
      if (host->var.mem.socket[socket].imcEnabled[mcId] == 0) continue;
      MemWritePciCfgMC (host, socket, mcId, MC_INIT_STATE_G_MC_MAIN_REG, mcInitStateG.Data);
    }
  }

  //
  // Get current DCLK ratio
  //
  GetDclkRatio(host, socket, &reqType, &reqData);

  if (!(host->var.common.emulation & SIMICS_FLAG)) {
    if (reqData == 0) {
#ifdef SERIAL_DBG_MSG
      if (checkMsgLevel(host, SDBG_MAX)) {
        rcPrintf ((host, "MC_BIOS_REQ.REQ_DATA = 0\n"));
        rcPrintf ((host, "Req Data = %d and Req Type = %d \n",reqData,reqType));
      }
#endif // SERIAL_DBG_MSG
      //
      // Default to 1066
      //
      reqData = 8;

      //OutputWarning (host, WARN_IMC_DISABLED, 0, socket, 0, 0, 0);
    }
  }

  // Instance 0 is used for both SMB 0 and SMB 1
  smbPeriod.Data = ReadCpuPciCfgEx (host, socket, 0, SMB_PERIOD_CFG_0_PCU_FUN5_REG);

  if (host->setup.mem.SpdSmbSpeed == SMB_CLK_400K) {
    smbPeriod.Bits.smb_clk_prd = 250;
    smbPeriod.Bits.smb_clk_offset = 35;
  } else if (host->setup.mem.SpdSmbSpeed == SMB_CLK_1M) {
    smbPeriod.Bits.smb_clk_prd = 100;
    smbPeriod.Bits.smb_clk_offset = 19;
  } else if (host->setup.mem.SpdSmbSpeed == SMB_CLK_100K){
    smbPeriod.Bits.smb_clk_prd = 1000;
    smbPeriod.Bits.smb_clk_offset = 35;
  } else {
    smbPeriod.Bits.smb_clk_prd = 250;
    smbPeriod.Bits.smb_clk_offset = 35;
  }

  MemDebugPrint((host, SDBG_MAX, socket, NO_CH, NO_DIMM, NO_RANK, NO_STROBE, NO_BIT,
                 "SMB Clock Period = %d\n", smbPeriod.Bits.smb_clk_prd));
  WriteCpuPciCfgEx (host, socket, 0, SMB_PERIOD_CFG_0_PCU_FUN5_REG, smbPeriod.Data);
  if (host->nvram.mem.socket[socket].mcpPresent == 1) {
    WriteCpuPciCfgEx (host, socket, 0, SMB_PERIOD_CFG_1_PCU_FUN5_REG, smbPeriod.Data);
  }

  for (busSeg = 0; busSeg < 2; busSeg++) {

    if (busSeg == 0) {
      smbCmdReg   = SMB_CMD_CFG_0_PCU_FUN5_REG;
      smbStatReg  = SMB_STATUS_CFG_0_PCU_FUN5_REG;
    } else {
      smbCmdReg   = SMB_CMD_CFG_1_PCU_FUN5_REG;
      smbStatReg  = SMB_STATUS_CFG_1_PCU_FUN5_REG;
    }

    //
    // Check if the first controller is busy
    //
    smbStat.Data = ReadCpuPciCfgEx (host, socket, 0, smbStatReg);
    if (smbStat.Bits.smb_busy) {
      smbCmd.Data = ReadCpuPciCfgEx (host, socket, 0, smbCmdReg);

      //
      // Override the clock
      //
      smbCmd.Bits.smb_ckovrd = 0;
      smbCmd.Bits.smb_soft_rst = 1;
      WriteCpuPciCfgEx (host, socket, 0, smbCmdReg, smbCmd.Data);
      //
      // Wait 35ms
      //
      FixedDelay (host, 35000);
      smbCmd.Bits.smb_ckovrd   = 1;
      smbCmd.Bits.smb_soft_rst = 0;
      WriteCpuPciCfgEx (host, socket, 0, smbCmdReg, smbCmd.Data);
    }

    //
    // Make Sure TSOD Polling is disabled
    //
    smbCmd.Data = ReadCpuPciCfgEx (host, socket, 0, smbCmdReg);
    smbCmd.Bits.smb_tsod_poll_en = 0;
    WriteCpuPciCfgEx (host, socket, 0, smbCmdReg, smbCmd.Data);
  }
  //
  // Initialize the PCH SMBUS
  //
  base = ReadPciCfg (host, 0, REG_ADDR (LPC_BUS, LPC_DEVICE, PCH_SMBUS_FUNC, R_PCH_SMBUS_BASE, sizeof (UINT32)));
  enable = ReadPciCfg (host, 0, REG_ADDR (LPC_BUS, LPC_DEVICE, PCH_SMBUS_FUNC, R_PCH_SMBUS_PCICMD, sizeof (UINT8)));
  if (enable & B_PCH_SMBUS_PCICMD_IOSE) {
    host->var.common.smbBase = (UINT16)(base & B_PCH_SMBUS_BASE_BAR);
  } else {
    host->var.common.smbBase = ICH_SMBBASE_ADDR;
    WritePciCfg(host, 0, REG_ADDR (LPC_BUS, LPC_DEVICE, PCH_SMBUS_FUNC, R_PCH_SMBUS_BASE, sizeof (UINT32)), host->var.common.smbBase | BIT0);
    WritePciCfg(host, 0, REG_ADDR (LPC_BUS, LPC_DEVICE, PCH_SMBUS_FUNC, R_PCH_SMBUS_PCICMD, sizeof (UINT8)), (UINT8)enable | B_PCH_SMBUS_PCICMD_IOSE);
    WritePciCfg(host, 0, REG_ADDR (LPC_BUS, LPC_DEVICE, PCH_SMBUS_FUNC, R_PCH_SMBUS_HOSTC, sizeof (UINT8)), B_PCH_SMBUS_HOSTC_HST_EN);
  }
}


/**

  Initialize socket SMBUS controller

  @param host  - Pointer to the system host (root) structure
  @param socket  - processor socket ID

  @retval N/A

**/
void
InitSmbSim (
           PSYSHOST host,
           UINT8    socket
           )
{
} // InitSmbSim


static UINT8 SendPchSmbCmd (
                    PSYSHOST host,
                    UINT8 byteOffset,
                    UINT8 slaveAddress,
                    UINT8 protocolStart,
                    UINT8 *data
                    )
/**

  Initialize socket SMBUS controller

  @param host  - Pointer to the system host (root) structure
  @param socket  - processor socket ID

  @retval N/A

**/
{
  UINT8   status;
  UINT32  startCount;
  UINT8   index;
  UINT8   sizeInBytes;

  status = SUCCESS;

  if (!(host->var.common.emulation & SIMICS_FLAG)) {
    // Wait for host not busy
    startCount = GetCount(host);
    do {
      status = InPort8(host, host->var.common.smbBase + HOST_STATUS_REGISTER);
      if (!(status & HST_STS_HOST_BUSY)) break;

    } while (GetDelay(host, startCount) < SMB_TIMEOUT);
  } else {
    status = InPort8(host, host->var.common.smbBase + HOST_STATUS_REGISTER);
  }
  //
  // Issue the command
  //
  if (!(status & (HST_STS_HOST_BUSY | HST_STS_FAILED))) {
    OutPort8(host,(host->var.common.smbBase + HOST_STATUS_REGISTER), SMBUS_B_HSTS_ALL);  // Clear all status bits
    OutPort8(host,(host->var.common.smbBase + HOST_COMMAND_REGISTER), byteOffset);       // Byte number
    OutPort8(host,(host->var.common.smbBase + XMIT_SLAVE_ADDRESS_REGISTER), slaveAddress);  // Slave address
    // Initialize write data
    if (!(slaveAddress & SMBUS_B_RW_SEL)) {
      if (protocolStart == WORD_DATA) {
        // Assume big-endian format
        OutPort8(host,(host->var.common.smbBase + HOST_DATA_0_REGISTER), *(data + 1));      // Msb data
        OutPort8(host,(host->var.common.smbBase + HOST_DATA_1_REGISTER), *data);            // Lsb data
      } else if (protocolStart == SR_DATA) {
        OutPort8(host,(host->var.common.smbBase + HOST_COMMAND_REGISTER), *data); // Byte data
      } else if (protocolStart == BLOCK_DATA) {
        sizeInBytes = *data;
        OutPort8(host,(host->var.common.smbBase + HOST_DATA_0_REGISTER), sizeInBytes); //# of bytes to transfer
        OutPort8(host,(host->var.common.smbBase + AUXILIARY_CONTROL_REGISTER), SMBUS_B_E32B); //Enable the 32 byte buffer in the Aux Cntrl Reg
        InPort8(host,(host->var.common.smbBase + HOST_CONTROL_REGISTER));  // Read the control register to reset the buffer pointer
        for (index = 1; index <= sizeInBytes; index++) {
          OutPort8(host,(host->var.common.smbBase + HOST_BLOCK_DATA_BYTE_REGISTER), *(data + index)); // Byte data
        }
      } else {
        OutPort8(host,(host->var.common.smbBase + HOST_DATA_0_REGISTER), *data);  // Byte data
      }
    } else {
      //
      // if reading a block, then need to enable the 32 byte buffer
      //
      if (protocolStart == BLOCK_DATA) {
        OutPort8(host,(host->var.common.smbBase + AUXILIARY_CONTROL_REGISTER), SMBUS_B_E32B); //Enable the 32 byte buffer in the Aux Cntrl Reg
        InPort8(host,(host->var.common.smbBase + HOST_CONTROL_REGISTER));  // Read the control register to reset the buffer pointer
      }
    }

    OutPort8(host,(host->var.common.smbBase + HOST_CONTROL_REGISTER), protocolStart);  // Protocol start

    if (!(host->var.common.emulation & SIMICS_FLAG)) {
      // Wait for command completion
      startCount = GetCount(host);
      do {
        status = InPort8(host,(host->var.common.smbBase + HOST_STATUS_REGISTER));
        if (status & (HST_STS_FAILED | HST_STS_BUS_ERR | HST_STS_DEV_ERR | HST_STS_INTR)) break;
      } while (GetDelay(host, startCount) < SMB_TIMEOUT);
    } else {
      status = InPort8(host,(host->var.common.smbBase + HOST_STATUS_REGISTER));
    }

    // Get read data
    if ((status & BIT1) && (slaveAddress & SMBUS_B_RW_SEL)) {

      if (protocolStart == WORD_DATA) {
        // Assume big-endian format
        *(data + 1) = InPort8(host,(host->var.common.smbBase + HOST_DATA_0_REGISTER));
        *data = InPort8(host,(host->var.common.smbBase + HOST_DATA_1_REGISTER));
      } else if (protocolStart == BLOCK_DATA) {
        InPort8(host,(host->var.common.smbBase + HOST_CONTROL_REGISTER));  // Read the control register to reset the buffer pointer
        sizeInBytes = InPort8(host,(host->var.common.smbBase + HOST_DATA_0_REGISTER)); //# of bytes to transfer
        //
        // TODO: Add error checking
        //
        *data = sizeInBytes;
        for (index = 1; index <= sizeInBytes; index++) {
          *(data + index) = InPort8(host,(host->var.common.smbBase + HOST_BLOCK_DATA_BYTE_REGISTER)); // Byte data
        }
      } else {
        *data = InPort8(host,(host->var.common.smbBase + HOST_DATA_0_REGISTER));
      }
    }

    // Clear all status bits
    OutPort8(host,(host->var.common.smbBase + HOST_STATUS_REGISTER), SMBUS_B_HSTS_ALL);
  }
  // Return last status
  return status;
}

/**

  Read SMBUS device at a given device and offset

  @param host        - Pointer to the system host (root) structure
  @param socket        - Processor socket ID
  @param dev         - Device address on SMBUS
  @param byteOffset  - Offset in Device
  @param data        - Pointer to store value
  @param NOTE: For a PCH block read, the array must be 33bytes in length,
  @param and the first data byte pointed to is the number of bytes read.
  @param This implementation only allows a maximum of 32bytes to be read.

  @retval 0 - Success
  @retval 1 - failure

**/
UINT32
ReadSmb (
        PSYSHOST         host,
        UINT8            socket,
        struct smbDevice dev,
        UINT8            byteOffset,
        UINT8            *data
        )
{
  UINT32                status;
  UINT32                            smbCmdReg;
  SMB_CMD_CFG_0_PCU_FUN5_STRUCT     smbCmd;

  //
  // Determines if semaphore is needed to read SMBus
  //
  IsSmbusSemaphoreNeeded (host, socket);

  status  = ReadSmbWorkerFunction (host, socket, dev, byteOffset, data);

  if (status == RETRY) {
    //
    // if SMBus is busy force a soft reset and retry transaction
    //
#ifdef SERIAL_DBG_MSG
//    if (checkMsgLevel(host, SDBG_MAX)) {
//       rcPrintf ((host, "SMBUS issue retry... force SMBUS Reset \n"));
//     }
#endif  // SERIAL_DBG_MSG

    if (dev.address.busSegment == 0) {
      smbCmdReg  = SMB_CMD_CFG_0_PCU_FUN5_REG;
    } else {
      smbCmdReg  = SMB_CMD_CFG_1_PCU_FUN5_REG;
    }

    smbCmd.Data = ReadCpuPciCfgEx (host, socket, 0, smbCmdReg);
    //
    // If slave device is hung, software can write this bit to 1 and
    // the SMB_CKOVRD to 0 (for more than 35ms) to force hung the SMB
    // slaves to time-out and put it in idle state without using power
    // good reset or warm reset.
    //

    //
    // Override the clock
    //
    smbCmd.Bits.smb_ckovrd = 0;
    smbCmd.Bits.smb_soft_rst = 1;
    WriteCpuPciCfgEx (host, socket, 0, smbCmdReg, smbCmd.Data);
    //
    // Wait 35ms
    //
    FixedDelay (host, 35000);
    smbCmd.Bits.smb_ckovrd   = 1;
    smbCmd.Bits.smb_soft_rst = 0;
    WriteCpuPciCfgEx (host, socket, 0, smbCmdReg, smbCmd.Data);

    status  = ReadSmbWorkerFunction (host, socket, dev, byteOffset, data);
  }

  //
  // Release Semaphore
  //
  if (host->var.common.SmbusAPSemaphoreAcquired == 1) {
      ReleaseSmbus(host, socket);
      host->var.common.smbSync = 0x0;
  }

#ifdef PRINT_FUNC
  MemDebugPrint((host, SDBG_MAX, socket, NO_CH, NO_DIMM, NO_RANK, NO_STROBE, NO_BIT,
                 "SMBus read from IMC = %d, Address 0x%1x%1x, Byte Offset %3d = 0x%02x\n",
                 dev.mcId, dev.address.deviceType, dev.address.strapAddress << 1,
                 byteOffset + host->nvram.mem.socket[socket].imc[dev.address.busSegment].spdPageAddr * 256,
                 *data));
#endif

  return status;
}

/**

  Read SMBUS device at a given device and offset

  @param host        - Pointer to the system host (root) structure
  @param socket      - Processor socket ID
  @param dev         - Device address on SMBUS
  @param byteOffset  - Offset in Device
  @param data        - Pointer to store value
  @param NOTE: For a PCH block read, the array must be 33bytes in length,
  @param and the first data byte pointed to is the number of bytes read.
  @param This implementation only allows a maximum of 32bytes to be read.

  @retval 0 - Success
  @retval 1 - failure

**/
static UINT32
ReadSmbWorkerFunction (
                      PSYSHOST         host,
                      UINT8            socket,
                      struct smbDevice dev,
                      UINT8            byteOffset,
                      UINT8            *data
                      )
{
  UINT32                    startCount = 0;
  UINT32                    smbCmdReg;
  UINT32                    smbStatReg;
  UINT32                    smbDataReg;
  UINT8                     status = 0;
  UINT8                     retry;
  UINT8                     protocol;
  SMB_STATUS_CFG_0_PCU_FUN5_STRUCT  smbStat;
  SMB_DATA_CFG_0_PCU_FUN5_STRUCT    smbData;
  SMB_CMD_CFG_0_PCU_FUN5_STRUCT     smbCmd;
  UINT32                    rval;

  rval    = SUCCESS;




  //
  // Call the OEM hook to read the SMBbus.  Return if SUCCESS.
  //
  switch (MemReadSmb (host, socket, dev, byteOffset, data)) {
  //
  // No hook available
  //
  case 0:
    break;

    //
    // read was successful
    //
  case 1:
    return SUCCESS;

    //
    // read failed
    //
  case 2:
    return FAILURE;
  }

  if (dev.address.controller == PLATFORM_SMBUS_CONTROLLER_PROCESSOR) {

    if (dev.address.busSegment == 0) {
      smbCmdReg   = SMB_CMD_CFG_0_PCU_FUN5_REG;
      smbStatReg  = SMB_STATUS_CFG_0_PCU_FUN5_REG;
      smbDataReg  = SMB_DATA_CFG_0_PCU_FUN5_REG;
    } else {
      smbCmdReg   = SMB_CMD_CFG_1_PCU_FUN5_REG;
      smbStatReg  = SMB_STATUS_CFG_1_PCU_FUN5_REG;
      smbDataReg  = SMB_DATA_CFG_1_PCU_FUN5_REG;
    }

    //
    // Ensure TSOD polling is disabled before continuing
    //
    smbCmd.Data = ReadCpuPciCfgEx (host, socket, 0, smbCmdReg);
    if (smbCmd.Bits.smb_tsod_poll_en == 1) {
      //TODO: save and restore tsod_state and force to off in this routine
#ifdef SERIAL_DBG_MSG
      if (checkMsgLevel(host, SDBG_MINMAX)) {
        rcPrintf ((host, "trying to read PROCESSOR SMBUS with TSOD polling enabled...halting!"));
      }
#endif  // SERIAL_DBG_MSG
#if SMCPKG_SUPPORT
      OutputError (host, ERR_SMBUS, TSOD_POLLING_ENABLED_READ, socket, NO_CH, NO_DIMM, NO_RANK);
#else
      FatalError (host, ERR_SMBUS, TSOD_POLLING_ENABLED_READ);
#endif
    }

    //
    // Form read command
    //
    smbCmd.Data = 0;
    smbCmd.Bits.smb_ckovrd = 1;
    smbCmd.Bits.smb_ba = (UINT32) byteOffset;
    smbCmd.Bits.smb_dti = dev.address.deviceType;
    smbCmd.Bits.smb_sa = (UINT32) dev.address.strapAddress;
    smbCmd.Bits.smb_wrt = 0;
    smbCmd.Bits.smb_pntr_sel = 0;
    if (dev.compId == MTS) {
      smbCmd.Bits.smb_word_access = 1;
    } else {
      smbCmd.Bits.smb_word_access = 0;
    }
    smbCmd.Bits.smb_cmd_trigger = 1;

    //
    // Wait for host not busy
    //
    startCount = GetCount (host);
    do {
      smbStat.Data = ReadCpuPciCfgEx (host, socket, 0, smbStatReg);
      if (!smbStat.Bits.smb_busy) break;
      if (host->var.common.emulation & SIMICS_FLAG) break;
      // Wait for timeout
    } while (GetDelay (host, startCount) < SMB_TIMEOUT);

    //
    // Send command
    //
    WriteCpuPciCfgEx (host, socket, 0, smbCmdReg, smbCmd.Data);

    //
    // Wait for host not busy
    //
    startCount = GetCount (host);
    do {
      smbStat.Data = ReadCpuPciCfgEx (host, socket, 0, smbStatReg);
      if (!smbStat.Bits.smb_busy) break;
      if (host->var.common.emulation & SIMICS_FLAG) break;

      // Wait for timeout
    } while (GetDelay (host, startCount) < SMB_TIMEOUT);


    //
    // Wait for the data
    //
    while (!smbStat.Bits.smb_rdo && !smbStat.Bits.smb_sbe) {
      smbStat.Data = ReadCpuPciCfgEx (host, socket, 0, smbStatReg);
    }

    //
    // If read data is valid
    //
    if (smbStat.Bits.smb_rdo && !smbStat.Bits.smb_sbe) {
      smbData.Data = ReadCpuPciCfgEx (host, socket, 0, smbDataReg);
      if (dev.compId == MTS) {
        *data = (UINT8) smbData.Bits.smb_rdata;  //lsb
        *(data + 1) = (UINT8) (smbData.Bits.smb_rdata >> 8); //msb
      } else {
        *data = (UINT8) smbData.Bits.smb_rdata;
      }
    } else {
      rval = RETRY;
    }
  } else if (dev.address.controller == PLATFORM_SMBUS_CONTROLLER_PCH) {
    //
    // Determine which protocol to use
    //
    if (dev.compId == DCP_AD5247) {
      protocol = SR_DATA;
    } else if (dev.compId == RSTPLD) {
      protocol = BLOCK_DATA;
    } else protocol = BYTE_DATA;
    //
    // Issue the command, handling errors
    //
    for (retry = 0; retry < SMB_RETRY_LIMIT; retry++) {
      //
      // Program PCH SMBus controller for given protocol
      //
      status = SendPchSmbCmd(host, byteOffset, (UINT8)((dev.address.deviceType << 4) | (dev.address.strapAddress << 1) | BIT0), protocol, data);

      // Check for bus error or host busy
      if (status & (HST_STS_FAILED | HST_STS_BUS_ERR | HST_STS_HOST_BUSY)) {
        FixedDelay (host, SMB_TIMEOUT);
      } else break;
    }
    if (status & (HST_STS_FAILED | HST_STS_BUS_ERR | HST_STS_DEV_ERR | HST_STS_HOST_BUSY)) rval = FAILURE;
  } else {
    rval = FAILURE;  // supported controller not detected
  }

  return rval;
}

/**

  Write SMBUS dev/offset with specified data

  @param host        - Pointer to the system host (root) structure
  @param socket        - Processor socket ID
  @param dev         - SMBUS device address
  @param byteOffset  - byte offset within device
  @param data        - pointer to data to write
  @param NOTE: For a PCH block write, the first data byte pointed to must be the number of bytes to write.
  @param This implementation only allows a maximum of 32bytes to be written.

  @retval 0 - success
  @retval 1 - failure

**/
UINT32
WriteSmb (
         PSYSHOST         host,
         UINT8            socket,
         struct smbDevice dev,
         UINT8            byteOffset,
         UINT8            *data
         )
{
  UINT32                    rval = SUCCESS;
  UINT32                    startCount = 0;
  UINT32                    smbCmdReg;
  UINT32                    smbStatReg;
  UINT32                    smbDataReg;
  UINT8                     status = 0;
  UINT8                     retry;
  UINT8                     protocol;
  SMB_STATUS_CFG_0_PCU_FUN5_STRUCT    smbStat;
  SMB_CMD_CFG_0_PCU_FUN5_STRUCT       smbCmd;
  SMB_DATA_CFG_0_PCU_FUN5_STRUCT      smbData;



  //
  // Determines if semaphore is needed to read SMBus
  //
  IsSmbusSemaphoreNeeded (host, socket);


  //
  // Call the OEM hook to write the SMBbus.  Return if SUCCESS.
  //
  switch (MemWriteSmb (host, dev, byteOffset, data)) {
  //
  // No hook available
  //
  case 0:
    break;

    //
    // SPD read was successful
    //
  case 1:
    return SUCCESS;

    //
    // SPD read failed
    //
  case 2:
    return FAILURE;
  }

  if (dev.address.controller == PLATFORM_SMBUS_CONTROLLER_PROCESSOR) {

    if (dev.address.busSegment == 0) {
      smbCmdReg   = SMB_CMD_CFG_0_PCU_FUN5_REG;
      smbStatReg  = SMB_STATUS_CFG_0_PCU_FUN5_REG;
      smbDataReg  = SMB_DATA_CFG_0_PCU_FUN5_REG;
    } else {
      smbCmdReg   = SMB_CMD_CFG_1_PCU_FUN5_REG;
      smbStatReg  = SMB_STATUS_CFG_1_PCU_FUN5_REG;
      smbDataReg  = SMB_DATA_CFG_1_PCU_FUN5_REG;
    }

    //
    // Ensure TSOD polling is disabled before continuing
    //
    smbCmd.Data = ReadCpuPciCfgEx (host, socket, 0, smbCmdReg);
    if (smbCmd.Bits.smb_tsod_poll_en == 1) {
      //TODO: save and restore tsod_state and force to off in this routine
#ifdef SERIAL_DBG_MSG
      if (checkMsgLevel(host, SDBG_MINMAX)) {
        rcPrintf ((host, "trying to write to PROCESSOR SMBUS with TSOD polling enabled...halting!"));
      }
#endif  // SERIAL_DBG_MSG
#if SMCPKG_SUPPORT
      OutputError (host, ERR_SMBUS, TSOD_POLLING_ENABLED_WRITE, socket, NO_CH, NO_DIMM, NO_RANK);
#else
      FatalError (host, ERR_SMBUS, TSOD_POLLING_ENABLED_WRITE);
#endif
    }

    //
    // Form write command
    //
    smbCmd.Data = 0;
    smbCmd.Bits.smb_ckovrd = 1;
    smbCmd.Bits.smb_dis_wrt = 0;
    smbCmd.Bits.smb_dti = dev.address.deviceType;
    smbCmd.Bits.smb_ba = (UINT32) byteOffset;
    smbCmd.Bits.smb_sa = (UINT32) dev.address.strapAddress;
    smbCmd.Bits.smb_wrt = 1;
    if (dev.compId == MTS) {
      smbCmd.Bits.smb_word_access = 1;
    } else {
      smbCmd.Bits.smb_word_access = 0;
    }
    smbCmd.Bits.smb_pntr_sel = 0;
    smbCmd.Bits.smb_cmd_trigger = 1;

    //
    // data to write
    //
    smbData.Data = 0;
    if (dev.compId == MTS) {
      smbData.Bits.smb_wdata = (UINT32)*data + ((UINT32)*(data + 1) << 8);
    } else {
      smbData.Bits.smb_wdata = (UINT32) *data;
    }

    //
    // Wait for host not busy
    //
    startCount = GetCount (host);
    do {
      smbStat.Data = ReadCpuPciCfgEx (host, socket, 0, smbStatReg);
      if (!smbStat.Bits.smb_busy) break;
      if (host->var.common.emulation & SIMICS_FLAG) break;
      // Wait for timeout
    } while (GetDelay (host, startCount) < SMB_TIMEOUT);

    //
    // Send command
    //
    WriteCpuPciCfgEx (host, socket, 0, smbDataReg, smbData.Data);
    WriteCpuPciCfgEx (host, socket, 0, smbCmdReg, smbCmd.Data);

    //
    // Wait for the write to complete
    //
    do {
      smbStat.Data = ReadCpuPciCfgEx (host, socket, 0, smbStatReg);
    } while (!smbStat.Bits.smb_wod && !smbStat.Bits.smb_sbe);


  } else if (dev.address.controller == PLATFORM_SMBUS_CONTROLLER_PCH) {
    //
    // Determine which protocol to use
    //
    if (dev.compId == DCP_AD5247) {
      protocol = SR_DATA;
    } else if (dev.compId == RSTPLD) {
      protocol = BLOCK_DATA;
    } else protocol = BYTE_DATA;
    //
    // Issue the command, handling errors
    //
    for (retry = 0; retry < SMB_RETRY_LIMIT; retry++) {
      //
      // Program PLATFORM_SMBUS_CONTROLLER_PCH SMBus controller for given protocol
      //
      status = SendPchSmbCmd(host, byteOffset, (UINT8)((dev.address.deviceType << 4) | (dev.address.strapAddress << 1)), protocol, data);

      // Check for bus error or host busy
      if (status & (HST_STS_FAILED | HST_STS_BUS_ERR | HST_STS_HOST_BUSY)) {
        FixedDelay (host, SMB_TIMEOUT);
      } else break;
    }
    if (status & (HST_STS_FAILED | HST_STS_BUS_ERR | HST_STS_DEV_ERR | HST_STS_HOST_BUSY)) rval = FAILURE;
  } else {
    rval = FAILURE;  // Only supporting PLATFORM_SMBUS_CONTROLLER_PROCESSOR SMBUS controllers for now
  }


  //
  // Release Semaphore
  //
  if (host->var.common.SmbusAPSemaphoreAcquired == 1) {
      ReleaseSmbus(host, socket);
      host->var.common.smbSync = 0x0;
  }

  return rval;
}
