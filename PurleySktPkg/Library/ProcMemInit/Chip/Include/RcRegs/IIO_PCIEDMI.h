//
// This file contains 'Framework Code' and is licensed as such
// under the terms of your license agreement with Intel or your
// vendor.  This file may not be modified, except as allowed by
// additional terms of your license agreement.
//
// **************************************************************************
// *                                                                        *
// *      Intel Restricted Secret                                           *
// *                                                                        *
// *      Reference Code                                                    *
// *                                                                        *
// *      Copyright (c) 2007-2016, Intel Corporation.                       *
// *                                                                        *
// *      This software and associated documentation (if any) is furnished  *
// *      under a license and may only be used or copied in accordance      *
// *      with the terms of the license. Except as permitted by such        *
// *      license, no part of this software or documentation may be         *
// *      reproduced, stored in a retrieval system, or transmitted in any   *
// *      form or by any means without the express written consent of       *
// *      Intel Corporation.                                                *
// *                                                                        *
// *      This program has been developed by Intel Corporation.             *
// *      Licensee has Intel's permission to incorporate this source code   *
// *      into their product, royalty free.  This source code may NOT be    *
// *      redistributed to anyone without Intel's written permission.       *
// *                                                                        *
// *      Intel specifically disclaims all warranties, express or           *
// *      implied, and all liability, including consequential and other     *
// *      indirect damages, for the use of this code, including liability   *
// *      for infringement of any proprietary rights, and including the     *
// *      warranties of merchantability and fitness for a particular        *
// *      purpose.  Intel does not assume any responsibility for any        *
// *      errors which may appear in this code nor any responsibility to    *
// *      update it.                                                        *
// *                                                                        *
// **************************************************************************
// **************************************************************************
// *                                                                        *
// *  PURPOSE:                                                              *
// *                                                                        *
// *      This file contains Silicon register definitions.                  *
// *                                                                        *
// **************************************************************************
//
/* Date Stamp: 9/13/2016 */

#ifndef IIO_PCIEDMI_h
#define IIO_PCIEDMI_h

#include "DataTypes.h"

/* Device and Function specifications:                                        */
/* For all target CPUs:                                                       */
/* IIO_PCIEDMI_DEV 0                                                          */
/* IIO_PCIEDMI_FUN 0                                                          */

/* VID_IIO_PCIEDMI_REG supported on:                                          */
/*       SKX_A0 (0x20000000)                                                  */
/*       SKX (0x20000000)                                                     */
/* Register default value:              0x8086                                */
#define VID_IIO_PCIEDMI_REG 0x0D002000
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x000
 */
typedef union {
  struct {
    UINT16 vendor_identification_number : 16;
    /* vendor_identification_number - Bits[15:0], RO, default = 16'b1000000010000110 
       The value is assigned by PCI-SIG to Intel.
     */
  } Bits;
  UINT16 Data;
} VID_IIO_PCIEDMI_STRUCT;


/* DID_IIO_PCIEDMI_REG supported on:                                          */
/*       SKX_A0 (0x20000002)                                                  */
/*       SKX (0x20000002)                                                     */
/* Register default value:              0x2020                                */
#define DID_IIO_PCIEDMI_REG 0x0D002002
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x002
 */
typedef union {
  struct {
    UINT16 device_identification_number : 16;
    /* device_identification_number - Bits[15:0], RO_V, default = 16'b0010000000100000 
       //TODO_HSXA0_SYNC
       Device ID values vary from function to function. Bits 15:8 are equal to 0x0E for 
       Ivytown. The following list is a breakdown of the function groups.0x0E00 - 
       0x0E1F : PCI Express and DMI ports 
       0x0E20 - 0x0E3F : IO Features (CBDMA, APIC, VT, RAS, LT)
       0x0E40 - 0x0E5F : Performance Monitors
       0x0E60 - 0x0E7F : DFX
       0x0E80 - 0x0E9F : Quick Path Interface
       0x0EA0 - 0x0EBF : Home Agent/Memory Controller
       0x0EC0 - 0x0EDF : Power Management
       0x0EE0 - 0x0EFF : Cbo/Ring
       //TODO_HSXA0_SYNC
       //SKX:Oct 18 2012: Post HSX sync values should be as below
       Device ID values vary from function to function. Bits 15:8 are equal to 0x2F for 
       the processor. The following list is a breakdown of the function groups. 
       0x2F00 - 0x2F1F : PCI Express and DMI ports
       0x2F20 - 0x2F3F : IO Features (CBDMA, APIC, VT, RAS, Intel TXT)
       0x2F40 - 0x2F5F : Performance Monitors
       0x2F60 - 0x2F7F : DFX
       0x2F80 - 0x2F9F : Intel Quick Path Interface
       0x2FA0 - 0x2FBF : Home Agent/Memory Controller
       0x2FC0 - 0x2FDF : Power Management
       0x2FE0 - 0x2FFF : Cbo/Ring
       Hardware sets this field based on the operating mode of this dev/fn:
       DMI => 0x2020
       PCIe => 0x2030
       Hardware sets this field based on the operating mode of this dev/fn:
       PCIe => 0x2038
       NTB-NTB => 0x201B
       NTB-RP => 0x201C
       
     */
  } Bits;
  UINT16 Data;
} DID_IIO_PCIEDMI_STRUCT;


/* PCICMD_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x20000004)                                                  */
/*       SKX (0x20000004)                                                     */
/* Register default value:              0x0000                                */
#define PCICMD_IIO_PCIEDMI_REG 0x0D002004
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x004
 */
typedef union {
  struct {
    UINT16 iose : 1;
    /* iose - Bits[0:0], RW_L, default = 1'b0 
       1
     */
    UINT16 mse : 1;
    /* mse - Bits[1:1], RW_L, default = 1'b0 
       1
     */
    UINT16 bme : 1;
    /* bme - Bits[2:2], RW_L, default = 1'b0  */
    UINT16 sce : 1;
    /* sce - Bits[3:3], RO, default = 1'b0  */
    UINT16 mwie : 1;
    /* mwie - Bits[4:4], RO, default = 1'b0  */
    UINT16 vga_palette_snoop_enable : 1;
    /* vga_palette_snoop_enable - Bits[5:5], RO, default = 1'b0  */
    UINT16 perre : 1;
    /* perre - Bits[6:6], RW, default = 1'b0  */
    UINT16 idsel_stepping_wait_cycle_control : 1;
    /* idsel_stepping_wait_cycle_control - Bits[7:7], RO, default = 1'b0  */
    UINT16 serre : 1;
    /* serre - Bits[8:8], RW, default = 1'b0  */
    UINT16 fast_back_to_back_enable : 1;
    /* fast_back_to_back_enable - Bits[9:9], RO, default = 1'b0  */
    UINT16 interrupt_disable : 1;
    /* interrupt_disable - Bits[10:10], RW, default = 1'b0 
       1
     */
    UINT16 rsvd : 5;
    /* rsvd - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PCICMD_IIO_PCIEDMI_STRUCT;


/* PCISTS_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x20000006)                                                  */
/*       SKX (0x20000006)                                                     */
/* Register default value:              0x0010                                */
#define PCISTS_IIO_PCIEDMI_REG 0x0D002006
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x006
 */
typedef union {
  struct {
    UINT16 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 intx_status : 1;
    /* intx_status - Bits[3:3], RO_V, default = 1'b0 
       Hardwired to 0
     */
    UINT16 capabilities_list : 1;
    /* capabilities_list - Bits[4:4], RO, default = 1'b1  */
    UINT16 pci66mhz_capable : 1;
    /* pci66mhz_capable - Bits[5:5], RO, default = 1'b0  */
    UINT16 rsvd_6 : 1;
    /* rsvd_6 - Bits[6:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 fast_back_to_back : 1;
    /* fast_back_to_back - Bits[7:7], RO, default = 1'b0  */
    UINT16 mdpe : 1;
    /* mdpe - Bits[8:8], RW1C, default = 1'b0  */
    UINT16 devsel_timing : 2;
    /* devsel_timing - Bits[10:9], RO, default = 2'b00  */
    UINT16 sta : 1;
    /* sta - Bits[11:11], RW1C, default = 1'b0  */
    UINT16 rta : 1;
    /* rta - Bits[12:12], RW1C, default = 1'b0  */
    UINT16 rma : 1;
    /* rma - Bits[13:13], RW1C, default = 1'b0  */
    UINT16 sse : 1;
    /* sse - Bits[14:14], RW1C, default = 1'b0  */
    UINT16 dpe : 1;
    /* dpe - Bits[15:15], RW1C, default = 1'b0  */
  } Bits;
  UINT16 Data;
} PCISTS_IIO_PCIEDMI_STRUCT;


/* CLSR_IIO_PCIEDMI_REG supported on:                                         */
/*       SKX_A0 (0x1000000C)                                                  */
/*       SKX (0x1000000C)                                                     */
/* Register default value:              0x00                                  */
#define CLSR_IIO_PCIEDMI_REG 0x0D00100C
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x00c
 */
typedef union {
  struct {
    UINT8 cacheline_size : 8;
    /* cacheline_size - Bits[7:0], RW, default = 8'b00000000 
       This register is set as RW for compatibility reasons only.
     */
  } Bits;
  UINT8 Data;
} CLSR_IIO_PCIEDMI_STRUCT;


/* PLAT_IIO_PCIEDMI_REG supported on:                                         */
/*       SKX_A0 (0x1000000D)                                                  */
/*       SKX (0x1000000D)                                                     */
/* Register default value:              0x00                                  */
#define PLAT_IIO_PCIEDMI_REG 0x0D00100D
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x00d
 */
typedef union {
  struct {
    UINT8 primary_latency_timer : 8;
    /* primary_latency_timer - Bits[7:0], RO, default = 8'b00000000 
       Not applicable to PCI-Express. Hardwired to 00h.
     */
  } Bits;
  UINT8 Data;
} PLAT_IIO_PCIEDMI_STRUCT;


/* HDR_IIO_PCIEDMI_REG supported on:                                          */
/*       SKX_A0 (0x1000000E)                                                  */
/*       SKX (0x1000000E)                                                     */
/* Register default value:              0x00                                  */
#define HDR_IIO_PCIEDMI_REG 0x0D00100E
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x00e
 */
typedef union {
  struct {
    UINT8 cl : 7;
    /* cl - Bits[6:0], RO, default = 7'b0000000 
       1
     */
    UINT8 mfd : 1;
    /* mfd - Bits[7:7], RO, default = 1'b0 
       1
     */
  } Bits;
  UINT8 Data;
} HDR_IIO_PCIEDMI_STRUCT;


/* BIST_IIO_PCIEDMI_REG supported on:                                         */
/*       SKX_A0 (0x1000000F)                                                  */
/*       SKX (0x1000000F)                                                     */
/* Register default value:              0x00                                  */
#define BIST_IIO_PCIEDMI_REG 0x0D00100F
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x00f
 */
typedef union {
  struct {
    UINT8 bist_tests : 8;
    /* bist_tests - Bits[7:0], RO, default = 8'b00000000  */
  } Bits;
  UINT8 Data;
} BIST_IIO_PCIEDMI_STRUCT;


/* SVID_IIO_PCIEDMI_REG supported on:                                         */
/*       SKX_A0 (0x2000002C)                                                  */
/*       SKX (0x2000002C)                                                     */
/* Register default value:              0x8086                                */
#define SVID_IIO_PCIEDMI_REG 0x0D00202C
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x02c
 */
typedef union {
  struct {
    UINT16 subsystem_vendor_id : 16;
    /* subsystem_vendor_id - Bits[15:0], RW_O, default = 16'b1000000010000110  */
  } Bits;
  UINT16 Data;
} SVID_IIO_PCIEDMI_STRUCT;


/* SDID_IIO_PCIEDMI_REG supported on:                                         */
/*       SKX_A0 (0x2000002E)                                                  */
/*       SKX (0x2000002E)                                                     */
/* Register default value:              0x0000                                */
#define SDID_IIO_PCIEDMI_REG 0x0D00202E
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x02e
 */
typedef union {
  struct {
    UINT16 subsystem_device_id : 16;
    /* subsystem_device_id - Bits[15:0], RW_O, default = 16'b0000000000000000  */
  } Bits;
  UINT16 Data;
} SDID_IIO_PCIEDMI_STRUCT;


/* CAPPTR_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x10000034)                                                  */
/*       SKX (0x10000034)                                                     */
/* Register default value:              0x90                                  */
#define CAPPTR_IIO_PCIEDMI_REG 0x0D001034
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x034
 */
typedef union {
  struct {
    UINT8 capability_pointer : 8;
    /* capability_pointer - Bits[7:0], RO_V, default = 8'b10010000 
       Points to the first capability structure for the device which is the PCIe 
       capability. 
     */
  } Bits;
  UINT8 Data;
} CAPPTR_IIO_PCIEDMI_STRUCT;


/* INTL_IIO_PCIEDMI_REG supported on:                                         */
/*       SKX_A0 (0x1000003C)                                                  */
/*       SKX (0x1000003C)                                                     */
/* Register default value:              0x00                                  */
#define INTL_IIO_PCIEDMI_REG 0x0D00103C
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x03c
 */
typedef union {
  struct {
    UINT8 interrupt_line : 8;
    /* interrupt_line - Bits[7:0], RO, default = 8'b00000000 
       N/A for these devices
     */
  } Bits;
  UINT8 Data;
} INTL_IIO_PCIEDMI_STRUCT;


/* INTPIN_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x1000003D)                                                  */
/*       SKX (0x1000003D)                                                     */
/* Register default value:              0x01                                  */
#define INTPIN_IIO_PCIEDMI_REG 0x0D00103D
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x03d
 */
typedef union {
  struct {
    UINT8 intp : 8;
    /* intp - Bits[7:0], RW_O, default = 8'b00000001 
       N/A since these devices do not generate any interrupt on their own
     */
  } Bits;
  UINT8 Data;
} INTPIN_IIO_PCIEDMI_STRUCT;


/* SCAPID_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x10000040)                                                  */
/*       SKX (0x10000040)                                                     */
/* Register default value:              0x0D                                  */
#define SCAPID_IIO_PCIEDMI_REG 0x0D001040
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x040
 */
typedef union {
  struct {
    UINT8 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00001101 
       Assigned by PCI-SIG for subsystem capability ID
     */
  } Bits;
  UINT8 Data;
} SCAPID_IIO_PCIEDMI_STRUCT;


/* SNXTPTR_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x10000041)                                                  */
/*       SKX (0x10000041)                                                     */
/* Register default value:              0x60                                  */
#define SNXTPTR_IIO_PCIEDMI_REG 0x0D001041
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x041
 */
typedef union {
  struct {
    UINT8 next_ptr : 8;
    /* next_ptr - Bits[7:0], RO, default = 8'b01100000 
       This field is set to 60h for the next capability list (MSI capability structure) 
       in the chain. 
     */
  } Bits;
  UINT8 Data;
} SNXTPTR_IIO_PCIEDMI_STRUCT;


/* DMIRCBAR_IIO_PCIEDMI_REG supported on:                                     */
/*       SKX_A0 (0x40000050)                                                  */
/*       SKX (0x40000050)                                                     */
/* Register default value:              0x00000000                            */
#define DMIRCBAR_IIO_PCIEDMI_REG 0x0D004050
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x050
 */
typedef union {
  struct {
    UINT32 dmircbaren : 1;
    /* dmircbaren - Bits[0:0], RW_LB, default = 1'b0 
       0: DMIRCBAR is disabled and does not claim any memory
       1: DMIRCBAR memory mapped accesses are claimed and decoded
       Notes:
       Accesses to registers pointed to by the DMIRCBAR, via message channel or JTAG 
       mini-port are not gated by this enable bit i.e. accesses these registers are 
       honored regardless of the setting of this bit. 
       BIOS sets this bit only when it wishes to update the registers in the DMIRCBAR. 
       It must clear this bit when it has finished changing values. This is required to 
       ensure that the registers cannot be changed during an Intel TXT lock. This bit 
       is protected by Intel TXT mode, but the registers in DMIRCBAR are not protected 
       except by this bit. 
     */
    UINT32 rsvd : 11;
    /* rsvd - Bits[11:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dmircbar : 20;
    /* dmircbar - Bits[31:12], RW_LB, default = 20'b00000000000000000000 
       This field corresponds to bits 32 to 12 of the base address DMI Root Complex 
       register space. BIOS will program this register resulting in a base address for 
       a 4KB block of contiguous memory address space. This register ensures that a 
       naturally aligned 4KB space is allocated within the first 64GB of addressable 
       memory space. System Software uses this base address to program the DMI Root 
       Complex register set. 
       All the Bits in this register are locked in Intel TXT mode.
     */
  } Bits;
  UINT32 Data;
} DMIRCBAR_IIO_PCIEDMI_STRUCT;


/* MSICAPID_IIO_PCIEDMI_REG supported on:                                     */
/*       SKX_A0 (0x10000060)                                                  */
/*       SKX (0x10000060)                                                     */
/* Register default value:              0x05                                  */
#define MSICAPID_IIO_PCIEDMI_REG 0x0D001060
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x060
 */
typedef union {
  struct {
    UINT8 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00000101 
       Assigned by PCI-SIG for MSI (root ports).
     */
  } Bits;
  UINT8 Data;
} MSICAPID_IIO_PCIEDMI_STRUCT;


/* MSINXTPTR_IIO_PCIEDMI_REG supported on:                                    */
/*       SKX_A0 (0x10000061)                                                  */
/*       SKX (0x10000061)                                                     */
/* Register default value:              0x90                                  */
#define MSINXTPTR_IIO_PCIEDMI_REG 0x0D001061
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x061
 */
typedef union {
  struct {
    UINT8 next_ptr : 8;
    /* next_ptr - Bits[7:0], RW_O, default = 8'b10010000 
       This field is set to 90h for the next capability list (PCI Express capability 
       structure) in the chain. 
     */
  } Bits;
  UINT8 Data;
} MSINXTPTR_IIO_PCIEDMI_STRUCT;


/* MSIMSGCTL_IIO_PCIEDMI_REG supported on:                                    */
/*       SKX_A0 (0x20000062)                                                  */
/*       SKX (0x20000062)                                                     */
/* Register default value:              0x0102                                */
#define MSIMSGCTL_IIO_PCIEDMI_REG 0x0D002062
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x062
 */
typedef union {
  struct {
    UINT16 msien : 1;
    /* msien - Bits[0:0], RW, default = 1'b0 
       Software sets this bit to select INTx style interrupt or MSI interrupt for root 
       port generated interrupts. 
       0: INTx interrupt mechanism is used for root port interrupts, provided the 
       override bits in MISCCTRLSTS allow it 
       1: MSI interrupt mechanism is used for root port interrupts, provided the 
       override bits in MISCCTRLSTS allow it 
       Note there bits 4:2 and bit 2 MISCCTRLSTS can disable both MSI and INTx 
       interrupt from being generated on root port interrupt events. 
     */
    UINT16 mmc : 3;
    /* mmc - Bits[3:1], RO, default = 3'b001  */
    UINT16 mme : 3;
    /* mme - Bits[6:4], RW, default = 3'b000 
       Applicable only to PCI Express ports. Software writes to this field to indicate 
       the number of allocated messages which is aligned to a power of two. When MSI is 
       enabled, the software will allocate at least one message to the device. A value 
       of 000 indicates 1 message. Any value greater than or equal to 001 indicates a 
       message of 2. 
       See MSIDR for discussion on how the interrupts are distributed amongst the 
       various sources of interrupt based on the number of messages allocated by 
       software for the PCI Express ports. 
     */
    UINT16 b64ac : 1;
    /* b64ac - Bits[7:7], RO, default = 1'b0 
       This field is hardwired to 0h since the message addresses are only 32-bit 
       addresses (e.g. FEEx_xxxxh). 
     */
    UINT16 pvmc : 1;
    /* pvmc - Bits[8:8], RO, default = 1'b1 
       This bit indicates that PCI Express ports support MSI per-vector masking.
     */
    UINT16 rsvd : 7;
    /* rsvd - Bits[15:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} MSIMSGCTL_IIO_PCIEDMI_STRUCT;


/* MSGADR_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x40000064)                                                  */
/*       SKX (0x40000064)                                                     */
/* Register default value:              0x00000000                            */
#define MSGADR_IIO_PCIEDMI_REG 0x0D004064
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * The MSI Address Register (MSIAR) contains the system specific address 
 * information to route MSI interrupts from the root ports and is broken into its 
 * constituent fields. 
 */
typedef union {
  struct {
    UINT32 rsvd : 2;
    /* rsvd - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 address_id : 30;
    /* address_id - Bits[31:2], RW, default = 30'b000000000000000000000000000000 
       Refer to the Interrupt Chapter for details of how this field is interpreted by 
       IIO hardware. The definition of this field depends on whether interrupt 
       remapping is enabled or disabled. 
     */
  } Bits;
  UINT32 Data;
} MSGADR_IIO_PCIEDMI_STRUCT;


/* MSGDAT_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x40000068)                                                  */
/*       SKX (0x40000068)                                                     */
/* Register default value:              0x00000000                            */
#define MSGDAT_IIO_PCIEDMI_REG 0x0D004068
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x068
 */
typedef union {
  struct {
    UINT32 data : 16;
    /* data - Bits[15:0], RW, default = 16'b0000000000000000 
       Refer to the Interrupt Chapter for details of how this field is interpreted by 
       IIO hardware. The definition of this field depends on whether interrupt 
       remapping is enabled or disabled. 
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MSGDAT_IIO_PCIEDMI_STRUCT;


/* MSIMSK_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x4000006C)                                                  */
/*       SKX (0x4000006C)                                                     */
/* Register default value:              0x00000000                            */
#define MSIMSK_IIO_PCIEDMI_REG 0x0D00406C
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x06c
 */
typedef union {
  struct {
    UINT32 mask_bits : 2;
    /* mask_bits - Bits[1:0], RW, default = 2'b00 
       Relevant only when MSI is enabled and used for interrupts generated by the root 
       port. For each Mask bit that is set, the PCI Express port is prohibited from 
       sending the associated message. When only one message is allocated to the root 
       port by software, only mask bit 0 is relevant and used by hardware. 
     */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MSIMSK_IIO_PCIEDMI_STRUCT;


/* MSIPENDING_IIO_PCIEDMI_REG supported on:                                   */
/*       SKX_A0 (0x40000070)                                                  */
/*       SKX (0x40000070)                                                     */
/* Register default value:              0x00000000                            */
#define MSIPENDING_IIO_PCIEDMI_REG 0x0D004070
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x070
 */
typedef union {
  struct {
    UINT32 pending_bits : 2;
    /* pending_bits - Bits[1:0], RO_V, default = 2'b00 
       Relevant only when MSI is enabled and used for interrupts generated by the root 
       port. When MSI is not enabled or used by the root port, this register always 
       reads a value 0. For each Pending bit that is set, the PCI Express port has a 
       pending associated message. When only one message is allocated to the root port 
       by software, only pending bit 0 is set/cleared by hardware and pending bit 1 
       always reads 0. 
       Hardware sets this bit whenever it has an interrupt pending to be sent. This bit 
       remains set till either the interrupt is sent by hardware or the status bits 
       associated with the interrupt condition are cleared by software. 
     */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MSIPENDING_IIO_PCIEDMI_STRUCT;


/* PXPCAPID_IIO_PCIEDMI_REG supported on:                                     */
/*       SKX_A0 (0x10000090)                                                  */
/*       SKX (0x10000090)                                                     */
/* Register default value:              0x10                                  */
#define PXPCAPID_IIO_PCIEDMI_REG 0x0D001090
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x090
 */
typedef union {
  struct {
    UINT8 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00010000 
       Provides the PCI Express capability ID assigned by PCI-SIG.
     */
  } Bits;
  UINT8 Data;
} PXPCAPID_IIO_PCIEDMI_STRUCT;


/* PXPNXTPTR_IIO_PCIEDMI_REG supported on:                                    */
/*       SKX_A0 (0x10000091)                                                  */
/*       SKX (0x10000091)                                                     */
/* Register default value:              0xE0                                  */
#define PXPNXTPTR_IIO_PCIEDMI_REG 0x0D001091
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x091
 */
typedef union {
  struct {
    UINT8 next_ptr : 8;
    /* next_ptr - Bits[7:0], RO, default = 8'b11100000 
       This field is set to the PCI PM capability.
     */
  } Bits;
  UINT8 Data;
} PXPNXTPTR_IIO_PCIEDMI_STRUCT;


/* PXPCAP_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x20000092)                                                  */
/*       SKX (0x20000092)                                                     */
/* Register default value:              0x0042                                */
#define PXPCAP_IIO_PCIEDMI_REG 0x0D002092
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x092
 */
typedef union {
  struct {
    UINT16 capability_version : 4;
    /* capability_version - Bits[3:0], RW_O, default = 4'b0010 
       This field identifies the version of the PCI Express capability structure, which 
       is 2h as of now. This register field is left as RW-O to cover any unknowns with 
       Gen3. 
     */
    UINT16 device_port_type : 4;
    /* device_port_type - Bits[7:4], RO_V, default = 4'b0100 
       This field identifies the type of device. It is set to 0100 for all the Express 
       ports. 
     */
    UINT16 slot_implemented : 1;
    /* slot_implemented - Bits[8:8], RW_O, default = 1'b0 
       Applies only to the root ports.
       1: indicates that the PCI Express link associated with the port is connected to 
       a slot. 
       0: indicates no slot is connected to this port.
       Notes:
       This register bit is of type 'write once' and is set by BIOS.
     */
    UINT16 interrupt_message_number : 5;
    /* interrupt_message_number - Bits[13:9], RO, default = 5'b00000 
       Applies to root ports. This field indicates the interrupt message number that is 
       generated for Power Management/Hot Plug/Bandwidth-change events. When there are 
       more than one MSI interrupt Number allocated for the root port MSI interrupts, 
       this register field is required to contain the offset between the base Message 
       Data and the MSI Message that is generated when there are these change 
       interrupts. IIO assigns the first vector for these change events and so this 
       field is set to 0. 
     */
    UINT16 rsvd : 2;
    /* rsvd - Bits[15:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PXPCAP_IIO_PCIEDMI_STRUCT;


/* DEVCAP_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x40000094)                                                  */
/*       SKX (0x40000094)                                                     */
/* Register default value:              0x00008000                            */
#define DEVCAP_IIO_PCIEDMI_REG 0x0D004094
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * The PCI Express Device Capabilities register identifies device specific 
 * information for the device. 
 */
typedef union {
  struct {
    UINT32 max_payload_size_supported : 3;
    /* max_payload_size_supported - Bits[2:0], RW_O, default = 3'b000 
       1
     */
    UINT32 phantom_functions_supported : 2;
    /* phantom_functions_supported - Bits[4:3], RO, default = 2'b00 
       CB DMA does not support phantom functions.
     */
    UINT32 extended_tag_field_supported : 1;
    /* extended_tag_field_supported - Bits[5:5], RW_O, default = 1'b0  */
    UINT32 endpoint_l0s_acceptable_latency : 3;
    /* endpoint_l0s_acceptable_latency - Bits[8:6], RO, default = 3'b000 
       N/A
     */
    UINT32 endpoint_l1_acceptable_latency : 3;
    /* endpoint_l1_acceptable_latency - Bits[11:9], RO, default = 3'b000 
       N/A
     */
    UINT32 attention_button_present : 1;
    /* attention_button_present - Bits[12:12], RO, default = 1'b0 
       Does not apply to CB DMA
     */
    UINT32 attention_indicator_present : 1;
    /* attention_indicator_present - Bits[13:13], RO, default = 1'b0 
       Does not apply to CB DMA
     */
    UINT32 power_indicator_present_on_device : 1;
    /* power_indicator_present_on_device - Bits[14:14], RO, default = 1'b0 
       Does not apply to CB DMA
     */
    UINT32 role_based_error_reporting : 1;
    /* role_based_error_reporting - Bits[15:15], RO, default = 1'b1 
       IIO is 1.1 compliant and so supports this feature
     */
    UINT32 rsvd_16 : 2;
    /* rsvd_16 - Bits[17:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 captured_slot_power_limit_value : 8;
    /* captured_slot_power_limit_value - Bits[25:18], RO, default = 8'b00000000 
       Does not apply to CB DMA
     */
    UINT32 captured_slot_power_limit_scale : 2;
    /* captured_slot_power_limit_scale - Bits[27:26], RO, default = 2'b00 
       Does not apply to CB DMA
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} DEVCAP_IIO_PCIEDMI_STRUCT;


/* LNKCAP_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x4000009C)                                                  */
/*       SKX (0x4000009C)                                                     */
/* Register default value:              0x00793841                            */
#define LNKCAP_IIO_PCIEDMI_REG 0x0D00409C
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x09c
 */
typedef union {
  struct {
    UINT32 maxlnkspd : 4;
    /* maxlnkspd - Bits[3:0], RW_O, default = 4'b0001 
       Note: Note: IVT 4948790 - Default value should be 0x2.
       This field indicates the maximum link speed of this Port.
       The encoding is the binary value of the bit location in the Supported Link 
       Speeds Vector (in LNKCAP2) that corresponds to the maximum link speed. 
       0010b = (5Gbps)
       0011b = (8Gbps)
     */
    UINT32 maximum_link_width : 6;
    /* maximum_link_width - Bits[9:4], RW_O, default = 6'b000100 
       This field indicates the maximum width of the given PCI Express Link attached to 
       the port. 
       000001: x1
       000010: x2
       000100: x4
       001000: x8
       010000: x16
       Others: Reserved
       This is left as a RW-O register for bios to update based on the platform usage 
       of the links. 
     */
    UINT32 active_state_link_pm_support : 2;
    /* active_state_link_pm_support - Bits[11:10], RW_O, default = 2'b10 
       This field indicates the level of active state power management supported on the 
       given PCI-Express port. 
       00: Disabled
       01: L0s Entry Supported
       10: L1 Entry Supported (Gen3; spec allows 0x2)
       11: L0s and L1 Supported
       L0s is not supported on the processor.
     */
    UINT32 l0s_exit_latency : 3;
    /* l0s_exit_latency - Bits[14:12], RW_O, default = 3'b011 
       This field indicates the L0s exit latency (i.e L0s to L0) for the PCI-Express 
       port. 
       L0s is not supported on the processor.
     */
    UINT32 l1_exit_latency : 3;
    /* l1_exit_latency - Bits[17:15], RW_O, default = 3'b010 
       This field indicates the L1 exit latency for the given PCI-Express port. It 
       indicates the length of time this port requires to complete transition from L1 
       to L0. 
       000: Less than 1us
       001: 1 us to less than 2 us
       010: 2 us to less than 4 us
       011: 4 us to less than 8 us
       100: 8 us to less than 16 us
       101: 16 us to less than 32 us
       110: 32 us to 64 us
       111: More than 64us
       This register is made writable once by BIOS so that the value is settable based 
       on experiments post-si. 
     */
    UINT32 clock_power_management : 1;
    /* clock_power_management - Bits[18:18], RO, default = 1'b0 
       Does not apply to processor
     */
    UINT32 surprise_down_error_reporting_capable : 1;
    /* surprise_down_error_reporting_capable - Bits[19:19], RO, default = 1'b1 
       IIO supports reporting a surprise down error condition
     */
    UINT32 data_link_layer_link_active_reporting_capable : 1;
    /* data_link_layer_link_active_reporting_capable - Bits[20:20], RO, default = 1'b1 
       IIO supports reporting status of the data link layer so software knows when it 
       can enumerate a device on the link or otherwise know the status of the link. 
     */
    UINT32 link_bandwidth_notification_capability : 1;
    /* link_bandwidth_notification_capability - Bits[21:21], RO_V, default = 1'b1 
       A value of 1b indicates support for the Link Bandwidth Notification status and 
       interrupt mechanisms. 
     */
    UINT32 aspm_optionality_compliance : 1;
    /* aspm_optionality_compliance - Bits[22:22], RW_O, default = 1'b1  */
    UINT32 rsvd : 1;
    /* rsvd - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 port_number : 8;
    /* port_number - Bits[31:24], RW_O, default = 8'b00000000 
       This field indicates the PCI Express port number for the link and is initialized 
       by software/BIOS. IIO hardware does nothing with this bit. 
     */
  } Bits;
  UINT32 Data;
} LNKCAP_IIO_PCIEDMI_STRUCT;


/* SLTCAP_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x400000A4)                                                  */
/*       SKX (0x400000A4)                                                     */
/* Register default value:              0x00000000                            */
#define SLTCAP_IIO_PCIEDMI_REG 0x0D0040A4
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x0a4
 */
typedef union {
  struct {
    UINT32 attention_button_present : 1;
    /* attention_button_present - Bits[0:0], RW_O, default = 1'b0 
       This bit indicates that the Attention Button event signal is routed (from slot 
       or on-board in the chassis) to the IIO's hotplug controller. 
       0: indicates that an Attention Button signal is routed to IIO
       1: indicates that an Attention Button is not routed to IIO
       BIOS programs this field with a 1 for CEM/Express Module FFs, if the slot is 
       hotplug capable. 
     */
    UINT32 power_controller_present : 1;
    /* power_controller_present - Bits[1:1], RW_O, default = 1'b0 
       This bit indicates that a software controllable power controller is implemented 
       on the chassis for this slot. 
       0: indicates that a software controllable power controller is not present
       1: indicates that a software controllable power controller is present
       BIOS programs this field with a 1 for CEM/Express Module FFs, if the slot is 
       hotplug capable. 
     */
    UINT32 mrl_sensor_present : 1;
    /* mrl_sensor_present - Bits[2:2], RW_O, default = 1'b0 
       This bit indicates that an MRL Sensor is implemented on the chassis for this 
       slot. 
       0: indicates that an MRL Sensor is not present
       1: indicates that an MRL Sensor is present
       BIOS programs this field with a 0 for Express Module FF always. If CEM slot is 
       hotplug capable, BIOS programs this field with either 0 or 1 depending on system 
       design. 
     */
    UINT32 attention_indicator_present : 1;
    /* attention_indicator_present - Bits[3:3], RW_O, default = 1'b0 
       This bit indicates that an Attention Indicator is implemented for this slot and 
       is electrically controlled by the chassis 
       0: indicates that an Attention Indicator that is electrically controlled by the 
       chassis is not present 
       1: indicates that an Attention Indicator that is electrically controlled by the 
       chassis is present 
       BIOS programs this field with a 1 for CEM/Express Module FFs, if the slot is 
       hotplug capable. 
     */
    UINT32 power_indicator_present : 1;
    /* power_indicator_present - Bits[4:4], RW_O, default = 1'b0 
       This bit indicates that a Power Indicator is implemented for this slot and is 
       electrically controlled by the chassis. 
       0: indicates that a Power Indicator that is electrically controlled by the 
       chassis is not present 
       1: indicates that Power Indicator that is electrically controlled by the chassis 
       is present 
       BIOS programs this field with a 1 for CEM/Express Module FFs, if the slot is 
       hotplug capable. 
     */
    UINT32 hot_plug_surprise : 1;
    /* hot_plug_surprise - Bits[5:5], RW_O, default = 1'b0 
       This field indicates that a device in this slot may be removed from the system 
       without prior notification. This field is initialized by BIOS. 
       0: indicates that hot-plug surprise is not supported
       1: indicates that hot-plug surprise is supported
       Generally this bit is not expected to be set because the only know usage case 
       for this is the ExpressCard FF. But that is not really expected usage in the 
       processor context. But this bit is present regardless to allow a usage if it 
       arises. 
       This bit is used by IIO hardware to determine if a transition from DL_active to 
       DL_Inactive is to be treated as a surprise down error or not. If a port is 
       associated with a hotpluggable slot and the hotplug surprise bit is set, then 
       any transition to DL_Inactive is not considered an error. Refer to PCI Express 
       Base Specification, Revision 2.0 for further details. 
     */
    UINT32 hot_plug_capable : 1;
    /* hot_plug_capable - Bits[6:6], RW_O, default = 1'b0 
       This field defines hot-plug support capabilities for the PCI Express port.
       0: indicates that this slot is not capable of supporting Hot-plug operations.
       1: indicates that this slot is capable of supporting Hot-plug operations
       This bit is programed by BIOS based on the system design. This bit must be 
       programmed by bios to be consistent with the VPP enable bit for the port. 
     */
    UINT32 rsvd : 10;
    /* rsvd - Bits[16:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 electromechanical_interlock_present : 1;
    /* electromechanical_interlock_present - Bits[17:17], RW_O, default = 1'b0 
       This bit when set indicates that an Electromechanical Interlock is implemented 
       on the chassis for this slot and that lock is controlled by bit 11 in Slot 
       Control register. This field is initialized by BIOS based on the system 
       architecture. 
       BIOS note: this capability is not set if the Electromechanical Interlock control 
       is connected to main slot power control. 
       This is expected to be used only for Express Module hotpluggable slots.
     */
    UINT32 command_complete_not_capable : 1;
    /* command_complete_not_capable - Bits[18:18], RO, default = 1'b0 
       The processor is capable of command complete interrupt.
     */
    UINT32 physical_slot_number : 13;
    /* physical_slot_number - Bits[31:19], RW_O, default = 13'b0000000000000 
       This field indicates the physical slot number of the slot connected to the PCI 
       Express port and is initialized by BIOS. 
     */
  } Bits;
  UINT32 Data;
} SLTCAP_IIO_PCIEDMI_STRUCT;


/* SLTCON_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x200000A8)                                                  */
/*       SKX (0x200000A8)                                                     */
/* Register default value:              0x07C0                                */
#define SLTCON_IIO_PCIEDMI_REG 0x0D0020A8
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * Any write to this register will set the Command Completed bit in the SLTSTS 
 * register, ONLY if the VPP enable bit for the port is set. If the port's VPP 
 * enable bit is set (i.e. hotplug for that slot is enabled), then the required 
 * actions on VPP are completed before the Command Completed bit is set in the 
 * SLTSTS register. If the VPP enable bit for the port is clear, then the write 
 * simply updates this register (see individual bit definitions for details) but 
 * the Command Completed bit in the SLTSTS register is not set 
 */
typedef union {
  struct {
    UINT16 attention_button_pressed_enable : 1;
    /* attention_button_pressed_enable - Bits[0:0], RW, default = 1'b0 
       This bit enables the generation of hot-plug interrupts or wake messages via an 
       attention button pressed event. 
       0: disables generation of hot-plug interrupts or wake messages when the 
       attention button is pressed. 
       1: Enables generation of hot-plug interrupts or wake messages when the attention 
       button is pressed. 
     */
    UINT16 power_fault_detected_enable : 1;
    /* power_fault_detected_enable - Bits[1:1], RW, default = 1'b0 
       This bit enables the generation of hot-plug interrupts or wake messages via a 
       power fault event. 
       0: disables generation of hot-plug interrupts or wake messages when a power 
       fault event happens. 
       1: Enables generation of hot-plug interrupts or wake messages when a power fault 
       event happens. 
     */
    UINT16 mrl_sensor_changed_enable : 1;
    /* mrl_sensor_changed_enable - Bits[2:2], RW, default = 1'b0 
       This bit enables the generation of hot-plug interrupts or wake messages via a 
       MRL Sensor changed event. 
       0: disables generation of hot-plug interrupts or wake messages when an MRL 
       Sensor changed event happens. 
       1: Enables generation of hot-plug interrupts or wake messages when an MRL Sensor 
       changed event happens. 
     */
    UINT16 presence_detect_changed_enable : 1;
    /* presence_detect_changed_enable - Bits[3:3], RW, default = 1'b0 
       This bit enables the generation of hot-plug interrupts or wake messages via a 
       presence detect changed event. 
       0: disables generation of hot-plug interrupts or wake messages when a presence 
       detect changed event happens. 
       1- Enables generation of hot-plug interrupts or wake messages when a presence 
       detect changed event happens. 
     */
    UINT16 command_completed_interrupt_enable : 1;
    /* command_completed_interrupt_enable - Bits[4:4], RW, default = 1'b0 
       This field enables software notification (Interrupt - MSI/INTx or WAKE) when a 
       command is completed by the Hot-plug controller connected to the PCI Express 
       port 
       0: disables hot-plug interrupts on a command completion by a hot-plug Controller
       1: Enables hot-plug interrupts on a command completion by a hot-plug Controller
     */
    UINT16 hot_plug_interrupt_enable : 1;
    /* hot_plug_interrupt_enable - Bits[5:5], RW, default = 1'b0 
       When set to 1b, this bit enables generation of Hot-Plug interrupt (MSI or INTx 
       interrupt depending on the setting of the MSI enable bit on enabled Hot-Plug 
       events, provided ACPI mode for hotplug is disabled. 
       0: disables interrupt generation on Hot-plug events
       1: enables interrupt generation on Hot-plug events
     */
    UINT16 attention_indicator_control : 2;
    /* attention_indicator_control - Bits[7:6], RW, default = 2'b11 
       If an Attention Indicator is implemented, writes to this field will set the 
       Attention Indicator to the written state. Reads of this field reflect the value 
       from the latest write, even if the corresponding hot-plug command is not 
       executed yet at the VPP, unless software issues a write without waiting for the 
       previous command to complete in which case the read value is undefined. 
       00: Reserved.
       01: On
       10: Blink (Processor drives 1 Hz square wave)
       11: Off
       IIO does not generated the Attention_Indicator_On/Off/Blink messages on PCI 
       Express when this field is written to by software. 
     */
    UINT16 power_indicator_control : 2;
    /* power_indicator_control - Bits[9:8], RW, default = 2'b11 
       If a Power Indicator is implemented, writes to this field will set the Power 
       Indicator to the written state. Reads of this field must reflect the value from 
       the latest write, even if the corresponding hot-plug command is not executed yet 
       at the VPP, unless software issues a write without waiting for the previous 
       command to complete in which case the read value is undefined. 
       00: Reserved.
       01: On
       10: Blink (IIO drives 1 Hz square wave for Chassis mounted LEDs)
       11: Off
       IIO does not generated the Power_Indicator_On/Off/Blink messages on PCI Express 
       when this field is written to by software. 
     */
    UINT16 power_controller_control : 1;
    /* power_controller_control - Bits[10:10], RWS, default = 1'b1 
       If a power controller is implemented, when writes to this field will set the 
       power state of the slot per the defined encodings. Reads of this field must 
       reflect the value from the latest write, even if the corresponding hot-plug 
       command is not executed yet at the VPP, unless software issues a write without 
       waiting for the previous command to complete in which case the read value is 
       undefined. 
       0: Power On
       1: Power Off
       Note: If the link experiences an unexpected DL_Down condition that is not the 
       result of a Hot Plug removal, the processor follows the PCI Express 
       specification for logging Surprise Link Down. SW is required to set SLTCON[10] 
       to 0 (Power On) in all devices that do not connect to a slot that supports 
       Hot-Plug to enable logging of this error in that device. 
       For devices connected to slots supporting Hot-Plug operations, SLTCON[10] usage 
       to control PWREN# assertion is as described elsewhere. 
     */
    UINT16 electromechanical_interlock_control : 1;
    /* electromechanical_interlock_control - Bits[11:11], RW, default = 1'b0 
       When software writes either a 1 to this bit, IIO pulses the EMIL pin per PCI 
       Express Server/Workstation Module Electromechanical Spec Rev 1.0. Write of 0 has 
       no effect. This bit always returns a 0 when read. If electromechanical lock is 
       not implemented, then either a write of 1 or 0 to this register has no effect. 
     */
    UINT16 data_link_layer_state_changed_enable : 1;
    /* data_link_layer_state_changed_enable - Bits[12:12], RWS, default = 1'b0 
       When set to 1, this field enables software notification when Data Link Layer 
       Link Active bit in the LNKSTS register changes state 
     */
    UINT16 rsvd : 3;
    /* rsvd - Bits[15:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} SLTCON_IIO_PCIEDMI_STRUCT;


/* SLTSTS_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x200000AA)                                                  */
/*       SKX (0x200000AA)                                                     */
/* Register default value:              0x0000                                */
#define SLTSTS_IIO_PCIEDMI_REG 0x0D0020AA
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x0aa
 */
typedef union {
  struct {
    UINT16 attention_button_pressed : 1;
    /* attention_button_pressed - Bits[0:0], RW1C, default = 1'b0 
       This bit is set by IIO when the attention button is pressed. It is subsequently 
       cleared by software after the field has been read and processed.Refer to RAS 
       Chapter for details of how this bit is shifted in on the VPP bit stream. 
       IIO silently discards the Attention_Button_Pressed message if received from PCI 
       Express link without updating this bit. 
     */
    UINT16 power_fault_detected : 1;
    /* power_fault_detected - Bits[1:1], RW1C, default = 1'b0 
       This bit is set by IIO when a power fault event is detected by the power 
       controller (which is reported via the VPP bit stream). It is subsequently 
       cleared by software after the field has been read and processed. Refer to RAS 
       Chapter for details of how this bit is shifted in on the VPP bit stream. 
     */
    UINT16 mrl_sensor_changed : 1;
    /* mrl_sensor_changed - Bits[2:2], RW1C, default = 1'b0 
       This bit is set if the value reported in bit 5 changes. It is subsequently 
       cleared by software after the field has been read and processed. 
     */
    UINT16 presence_detect_changed : 1;
    /* presence_detect_changed - Bits[3:3], RW1C, default = 1'b0 
       This bit is set by IIO when the value reported in bit 6 is changes. It is 
       subsequently cleared by software after the field has been read and processed. 
     */
    UINT16 command_completed : 1;
    /* command_completed - Bits[4:4], RW1C, default = 1'b0 
       This bit is set by IIO when the hot-plug command has completed and the hot-plug 
       controller is ready to accept a subsequent command. It is subsequently cleared 
       by software after the field has been read and processed. This bit provides no 
       guarantee that the action corresponding to the command is complete. Any write to 
       SLTCON (regardless of the port is capable or enabled for hot-plug) is considered 
       a 'hot-plug' command. 
       If the port is not hot-plug capable or hot-plug enabled, then the hot-plug 
       command does not trigger any action on the VPP port but the command is still 
       completed via this bit. 
     */
    UINT16 mrl_sensor_state : 1;
    /* mrl_sensor_state - Bits[5:5], RO_V, default = 1'b0 
       This bit reports the status of an MRL sensor if it is implemented.
       0: MRL Closed
       1: MRL Open
       Refer to RAS Chapter for details of how this bit is shifted in on the VPP bit 
       stream. 
     */
    UINT16 presence_detect_state : 1;
    /* presence_detect_state - Bits[6:6], RO_V, default = 1'b0 
       For ports with slots (where the Slot Implemented bit of the PCI Express 
       Capabilities Registers is 1b), this field is the logical OR of the Presence 
       Detect status determined via an in-band mechanism and sideband Present Detect 
       pins. Refer to how PCI Express Base Specification, Revision 2.0 for how the 
       inband presence detect mechanism works (certain states in the LTSSM constitute 
       'card present' and others don't). 
       0: Card/Module slot empty
       1: Card/module Present in slot (powered or unpowered)
       For ports with no slots, IIO hardwires this bit to 1b.
       Note: OS could get confused when it sees an empty PCI Express root port i.e. 'no 
       slots + no presence', since this is now disallowed in the spec. So bios must 
       hide all unused root ports devices in IIO config space, via the DEVHIDE 
       register. 
       Refer to RAS Chapter for details of how this bit is shifted in on the VPP bit 
       stream. 
     */
    UINT16 electromechanical_latch_status : 1;
    /* electromechanical_latch_status - Bits[7:7], RO_V, default = 1'b0 
       When read this register returns the current state of the Electromechanical 
       Interlock (the EMILS pin) which has the defined encodings as: 
       0: Electromechanical Interlock Disengaged
       1: Electromechanical Interlock Engaged
     */
    UINT16 data_link_layer_state_changed : 1;
    /* data_link_layer_state_changed - Bits[8:8], RW1C, default = 1'b0 
       This bit is set (if it is not already set) when the state of the Data Link Layer 
       Link Active bit in the Link Status register changes. Software must read Data 
       Link Layer Active field to determine the link state before initiating 
       configuration cycles to the hot plugged device. 
     */
    UINT16 rsvd : 7;
    /* rsvd - Bits[15:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} SLTSTS_IIO_PCIEDMI_STRUCT;


/* ROOTCON_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x200000AC)                                                  */
/*       SKX (0x200000AC)                                                     */
/* Register default value:              0x0000                                */
#define ROOTCON_IIO_PCIEDMI_REG 0x0D0020AC
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x0ac
 */
typedef union {
  struct {
    UINT16 seceen : 1;
    /* seceen - Bits[0:0], RW, default = 1'b0  */
    UINT16 senfeen : 1;
    /* senfeen - Bits[1:1], RW, default = 1'b0  */
    UINT16 sefeen : 1;
    /* sefeen - Bits[2:2], RW, default = 1'b0  */
    UINT16 pmeinten : 1;
    /* pmeinten - Bits[3:3], RW, default = 1'b0 
       This field controls the generation of MSI interrupts/INTx interrupts for PME 
       messages. 
       1: Enables interrupt generation upon receipt of a PME message
       0: Disables interrupt generation for PME messages
     */
    UINT16 crsswvisen : 1;
    /* crsswvisen - Bits[4:4], RW, default = 1'b0  */
    UINT16 rsvd : 11;
    /* rsvd - Bits[15:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} ROOTCON_IIO_PCIEDMI_STRUCT;


/* ROOTCAP_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x200000AE)                                                  */
/*       SKX (0x200000AE)                                                     */
/* Register default value:              0x0000                                */
#define ROOTCAP_IIO_PCIEDMI_REG 0x0D0020AE
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x0ae
 */
typedef union {
  struct {
    UINT16 crs_software_visibility : 1;
    /* crs_software_visibility - Bits[0:0], RW_O, default = 1'b0 
       This bit when set, indicates that the Root Port is capable of returning 
       Configuration Request Retry Status (CRS) Completion Status to software. The 
       processor supports this capability. 
     */
    UINT16 rsvd : 15;
    /* rsvd - Bits[15:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} ROOTCAP_IIO_PCIEDMI_STRUCT;


/* DEVCAP2_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x400000B4)                                                  */
/*       SKX (0x400000B4)                                                     */
/* Register default value:              0x000013BE                            */
#define DEVCAP2_IIO_PCIEDMI_REG 0x0D0040B4
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x0b4
 */
typedef union {
  struct {
    UINT32 cmpltovalsup : 4;
    /* cmpltovalsup - Bits[3:0], RO, default = 4'b1110  */
    UINT32 cmpltodissup : 1;
    /* cmpltodissup - Bits[4:4], RO, default = 1'b1  */
    UINT32 ari_en : 1;
    /* ari_en - Bits[5:5], RW_LB, default = 1'b1 
       1
     */
    UINT32 atomicroutsup : 1;
    /* atomicroutsup - Bits[6:6], RO, default = 1'b0  */
    UINT32 atomic32bcompsup : 1;
    /* atomic32bcompsup - Bits[7:7], RO, default = 1'b1  */
    UINT32 atomic64bcompsup : 1;
    /* atomic64bcompsup - Bits[8:8], RO, default = 1'b1  */
    UINT32 atomic128bcascompsup : 1;
    /* atomic128bcascompsup - Bits[9:9], RO, default = 1'b1  */
    UINT32 rsvd_10 : 1;
    /* rsvd_10 - Bits[10:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ltr_en : 1;
    /* ltr_en - Bits[11:11], RW_LB, default = 1'b0  */
    UINT32 tph_completer_supported : 2;
    /* tph_completer_supported - Bits[13:12], RW_LB, default = 2'b01 
       1
     */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} DEVCAP2_IIO_PCIEDMI_STRUCT;


/* LNKCAP2_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x400000BC)                                                  */
/*       SKX (0x400000BC)                                                     */
/* Register default value:              0x0000000E                            */
#define LNKCAP2_IIO_PCIEDMI_REG 0x0D0040BC
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x0bc
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 lnkspdvec : 7;
    /* lnkspdvec - Bits[7:1], RW_O, default = 7'b0000111 
       Supported Link Speeds Vector - This field indicates the supported Link speed(s) 
       of the associated Port. For each bit, a value of 1b indicates that the 
       corresponding Link speed is supported; otherwise, the Link speed is not 
       supported. 
       Bit definitions are:
       Bit 1 2.5 GT/s
       Bit 2 5.0 GT/s
       Bit 3 8.0 GT/s
       Bits 7:4 reserved
     */
    UINT32 rsvd_8 : 24;
    /* rsvd_8 - Bits[31:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LNKCAP2_IIO_PCIEDMI_STRUCT;


/* PPD_IIO_PCIEDMI_REG supported on:                                          */
/*       SKX_A0 (0x100000D4)                                                  */
/*       SKX (0x100000D4)                                                     */
/* Register default value:              0x00                                  */
#define PPD_IIO_PCIEDMI_REG 0x0D0010D4
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * This register defines the behavior of the PCIE port which can be either a RP, 
 * NTB connected to another NTB or an NTB connected to a Root Complex. This 
 * register is used to set the value in the DID register on the Primary side of the 
 * NTB (located at offset 02h). This value is loaded by BIOS prior to running PCI 
 * enumeration. 
 */
typedef union {
  struct {
    UINT8 port_definition : 2;
    /* port_definition - Bits[1:0], RW_LV, default = 2'b00 
       Value indicating the value to be loaded into the DID register (offset 02h).
       00b - Transparent bridge
       01b - 2 NTBs connected back to back
       10b - NTB connected to a RP
       11b - Reserved
     */
    UINT8 rsvd_2 : 4;
    /* rsvd_2 - Bits[5:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT8 bar45_32bit : 1;
    /* bar45_32bit - Bits[6:6], RW_LV, default = 1'b0  */
    UINT8 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} PPD_IIO_PCIEDMI_STRUCT;


/* PMCAP_IIO_PCIEDMI_REG supported on:                                        */
/*       SKX_A0 (0x400000E0)                                                  */
/*       SKX (0x400000E0)                                                     */
/* Register default value:              0xC8030001                            */
#define PMCAP_IIO_PCIEDMI_REG 0x0D0040E0
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x0e0
 */
typedef union {
  struct {
    UINT32 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00000001 
       Provides the PM capability ID assigned by PCI-SIG.
     */
    UINT32 next_capability_pointer : 8;
    /* next_capability_pointer - Bits[15:8], RO, default = 8'b00000000 
       This is the last capability in the chain and hence set to 0.
     */
    UINT32 version : 3;
    /* version - Bits[18:16], RO, default = 3'b011 
       This field is set to 3h (PM 1.2 compliant) as version number.
     */
    UINT32 pme_clock : 1;
    /* pme_clock - Bits[19:19], RO, default = 1'b0 
       This field is hardwired to 0h as it does not apply to PCI Express.
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[20:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 device_specific_initialization : 1;
    /* device_specific_initialization - Bits[21:21], RO, default = 1'b0  */
    UINT32 aux_current : 3;
    /* aux_current - Bits[24:22], RO, default = 3'b000  */
    UINT32 d1_support : 1;
    /* d1_support - Bits[25:25], RO, default = 1'b0 
       I/OxAPIC does not support power management state D1.
     */
    UINT32 d2_support : 1;
    /* d2_support - Bits[26:26], RO, default = 1'b0 
       I/OxAPIC does not support power management state D2.
     */
    UINT32 pme_support : 5;
    /* pme_support - Bits[31:27], RO_V, default = 5'b11001 
       Bits 31, 30 and 27 must be set to \q1\q for PCI-PCI bridge structures 
       representing ports on root complexes. 
     */
  } Bits;
  UINT32 Data;
} PMCAP_IIO_PCIEDMI_STRUCT;


/* PMCSR_IIO_PCIEDMI_REG supported on:                                        */
/*       SKX_A0 (0x400000E4)                                                  */
/*       SKX (0x400000E4)                                                     */
/* Register default value:              0x00000008                            */
#define PMCSR_IIO_PCIEDMI_REG 0x0D0040E4
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x0e4
 */
typedef union {
  struct {
    UINT32 power_state : 2;
    /* power_state - Bits[1:0], RW_L, default = 2'b00  */
    UINT32 rsvd_2 : 1;
    /* rsvd_2 - Bits[2:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 no_soft_reset : 1;
    /* no_soft_reset - Bits[3:3], RW_O, default = 1'b1 
       Indicates I/OxAPIC does not reset its registers when transitioning from D3hot to 
       D0. 
     */
    UINT32 rsvd_4 : 4;
    /* rsvd_4 - Bits[7:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 pme_enable : 1;
    /* pme_enable - Bits[8:8], RWS, default = 1'b0 
       Not relevant for I/OxAPIC
     */
    UINT32 data_select : 4;
    /* data_select - Bits[12:9], RO, default = 4'b0000  */
    UINT32 data_scale : 2;
    /* data_scale - Bits[14:13], RO, default = 2'b00  */
    UINT32 pme_status : 1;
    /* pme_status - Bits[15:15], RW1CS, default = 1'b0 
       Not relevant for I/OxAPIC
     */
    UINT32 rsvd_16 : 6;
    /* rsvd_16 - Bits[21:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 b2_b3_support : 1;
    /* b2_b3_support - Bits[22:22], RO, default = 1'b0  */
    UINT32 bus_power_clock_control_enable : 1;
    /* bus_power_clock_control_enable - Bits[23:23], RO, default = 1'b0  */
    UINT32 data : 8;
    /* data - Bits[31:24], RO, default = 8'b00000000  */
  } Bits;
  UINT32 Data;
} PMCSR_IIO_PCIEDMI_STRUCT;


/* DEVCTRL_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x200000F0)                                                  */
/*       SKX (0x200000F0)                                                     */
/* Register default value:              0x0000                                */
#define DEVCTRL_IIO_PCIEDMI_REG 0x0D0020F0
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x0f0
 */
typedef union {
  struct {
    UINT16 correctable_error_reporting_enable : 1;
    /* correctable_error_reporting_enable - Bits[0:0], RW, default = 1'b0  */
    UINT16 non_fatal_error_reporting_enable : 1;
    /* non_fatal_error_reporting_enable - Bits[1:1], RW, default = 1'b0  */
    UINT16 fatal_error_reporting_enable : 1;
    /* fatal_error_reporting_enable - Bits[2:2], RW, default = 1'b0  */
    UINT16 unsupported_request_reporting_enable : 1;
    /* unsupported_request_reporting_enable - Bits[3:3], RW, default = 1'b0  */
    UINT16 enable_relaxed_ordering : 1;
    /* enable_relaxed_ordering - Bits[4:4], RO, default = 1'b0  */
    UINT16 max_payload_size : 3;
    /* max_payload_size - Bits[7:5], RW, default = 3'b000 
       000: 128B max payload size
       001: 256B max payload size
       others: alias to 128B
       IIO can receive packets equal to the size set by this field.
       IIO generate read completions as large as the value set by this field.
       IIO generates memory writes of max 64B.
     */
    UINT16 extended_tag_field_enable : 1;
    /* extended_tag_field_enable - Bits[8:8], RO, default = 1'b0  */
    UINT16 phantom_functions_enable : 1;
    /* phantom_functions_enable - Bits[9:9], RO, default = 1'b0  */
    UINT16 auxiliary_power_management_enable : 1;
    /* auxiliary_power_management_enable - Bits[10:10], RO, default = 1'b0  */
    UINT16 enable_no_snoop : 1;
    /* enable_no_snoop - Bits[11:11], RO, default = 1'b0  */
    UINT16 max_read_request_size : 3;
    /* max_read_request_size - Bits[14:12], RO, default = 3'b000  */
    UINT16 rsvd : 1;
    /* rsvd - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} DEVCTRL_IIO_PCIEDMI_STRUCT;


/* DEVSTS_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x200000F2)                                                  */
/*       SKX (0x200000F2)                                                     */
/* Register default value:              0x0000                                */
#define DEVSTS_IIO_PCIEDMI_REG 0x0D0020F2
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x0f2
 */
typedef union {
  struct {
    UINT16 correctable_error_detected : 1;
    /* correctable_error_detected - Bits[0:0], RW1C, default = 1'b0  */
    UINT16 non_fatal_error_detected : 1;
    /* non_fatal_error_detected - Bits[1:1], RW1C, default = 1'b0  */
    UINT16 fatal_error_detected : 1;
    /* fatal_error_detected - Bits[2:2], RW1C, default = 1'b0  */
    UINT16 unsupported_request_detected : 1;
    /* unsupported_request_detected - Bits[3:3], RW1C, default = 1'b0  */
    UINT16 aux_power_detected : 1;
    /* aux_power_detected - Bits[4:4], RO, default = 1'b0  */
    UINT16 transactions_pending : 1;
    /* transactions_pending - Bits[5:5], RO, default = 1'b0  */
    UINT16 rsvd : 10;
    /* rsvd - Bits[15:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} DEVSTS_IIO_PCIEDMI_STRUCT;


/* DEVCTRL2_IIO_PCIEDMI_REG supported on:                                     */
/*       SKX_A0 (0x200000F8)                                                  */
/*       SKX (0x200000F8)                                                     */
/* Register default value:              0x0010                                */
#define DEVCTRL2_IIO_PCIEDMI_REG 0x0D0020F8
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x0f8
 */
typedef union {
  struct {
    UINT16 compltoval : 4;
    /* compltoval - Bits[3:0], RW, default = 4'b0000  */
    UINT16 compltodis : 1;
    /* compltodis - Bits[4:4], RW, default = 1'b1  */
    UINT16 ari : 1;
    /* ari - Bits[5:5], RW_L, default = 1'b0 
       Alternative RID InterpretationEnable
       Applies only to root ports. When set to 1b, ARI is enabled for the Root Port. 
       For Device#0 in DMI mode, this bit is ignored. 
     */
    UINT16 atomicreqen : 1;
    /* atomicreqen - Bits[6:6], RO, default = 1'b0  */
    UINT16 atomicegressblock : 1;
    /* atomicegressblock - Bits[7:7], RO, default = 1'b0  */
    UINT16 rsvd_8 : 2;
    /* rsvd_8 - Bits[9:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 ltr_en : 1;
    /* ltr_en - Bits[10:10], RW_LV, default = 1'b0  */
    UINT16 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} DEVCTRL2_IIO_PCIEDMI_STRUCT;


/* XPREUT_HDR_EXT_IIO_PCIEDMI_REG supported on:                               */
/*       SKX_A0 (0x40000100)                                                  */
/*       SKX (0x40000100)                                                     */
/* Register default value:              0x1101000B                            */
#define XPREUT_HDR_EXT_IIO_PCIEDMI_REG 0x0D004100
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x100
 */
typedef union {
  struct {
    UINT32 pciecapid : 16;
    /* pciecapid - Bits[15:0], RO, default = 16'b0000000000001011  */
    UINT32 pciecapversion : 4;
    /* pciecapversion - Bits[19:16], RO, default = 4'b0001  */
    UINT32 pcienextptr : 12;
    /* pcienextptr - Bits[31:20], RO_V, default = 12'b000100010000  */
  } Bits;
  UINT32 Data;
} XPREUT_HDR_EXT_IIO_PCIEDMI_STRUCT;


/* XPREUT_HDR_CAP_IIO_PCIEDMI_REG supported on:                               */
/*       SKX_A0 (0x40000104)                                                  */
/*       SKX (0x40000104)                                                     */
/* Register default value:              0x00C00002                            */
#define XPREUT_HDR_CAP_IIO_PCIEDMI_REG 0x0D004104
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x104
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000010  */
    UINT32 vsecidrev : 4;
    /* vsecidrev - Bits[19:16], RO, default = 4'b0000  */
    UINT32 vseclength : 12;
    /* vseclength - Bits[31:20], RO, default = 12'b000000001100  */
  } Bits;
  UINT32 Data;
} XPREUT_HDR_CAP_IIO_PCIEDMI_STRUCT;


/* XPREUT_HDR_LEF_IIO_PCIEDMI_REG supported on:                               */
/*       SKX_A0 (0x40000108)                                                  */
/*       SKX (0x40000108)                                                     */
/* Register default value:              0x00003007                            */
#define XPREUT_HDR_LEF_IIO_PCIEDMI_REG 0x0D004108
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x108
 */
typedef union {
  struct {
    UINT32 leafreutengid : 8;
    /* leafreutengid - Bits[7:0], RO_V, default = 8'b00000111  */
    UINT32 leafreutdevnum : 8;
    /* leafreutdevnum - Bits[15:8], RO_V, default = 8'b00110000  */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPREUT_HDR_LEF_IIO_PCIEDMI_STRUCT;


/* APICBASE_IIO_PCIEDMI_REG supported on:                                     */
/*       SKX_A0 (0x20000140)                                                  */
/*       SKX (0x20000140)                                                     */
/* Register default value:              0x0000                                */
#define APICBASE_IIO_PCIEDMI_REG 0x0D002140
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x140
 */
typedef union {
  struct {
    UINT16 en : 1;
    /* en - Bits[0:0], RW, default = 1'b0 
       enables the decode of the APIC window
     */
    UINT16 addr : 11;
    /* addr - Bits[11:1], RW, default = 11'b00000000000 
       Bits 31:20 are assumed to be 0xFECh. Bits 8:0 are a don't care for address 
       decode. Address decoding to the APIC range is done as APICBASE.ADDR[31:8] &lt;= 
       A[31:8] &lt;= APICLIMIT.ADDR[31:8]. 
       Outbound accesses to the APIC range are claimed by the root port and forwarded 
       to PCIe, if bit 0 is set, even if the MSE bit of the root port is clear or the 
       root port itself is in D3hot state. 
     */
    UINT16 rsvd : 4;
    /* rsvd - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} APICBASE_IIO_PCIEDMI_STRUCT;


/* APICLIMIT_IIO_PCIEDMI_REG supported on:                                    */
/*       SKX_A0 (0x20000142)                                                  */
/*       SKX (0x20000142)                                                     */
/* Register default value:              0x0000                                */
#define APICLIMIT_IIO_PCIEDMI_REG 0x0D002142
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x142
 */
typedef union {
  struct {
    UINT16 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 addr : 11;
    /* addr - Bits[11:1], RW, default = 11'b00000000000 
       Applies only to root ports.
       Bits 31:20 are assumed to be 0xFECh. Bits 8:0 are a don't care for address 
       decode. Address decoding to the APIC range is done as APICBASE.ADDR[31:8] &lt;= 
       A[31:8] &lt;= APICLIMIT.ADDR[31:8]. 
       Outbound accesses to the APIC range are claimed by the root port and forwarded 
       to PCIe, if the range is enabled, even if the MSE bit of the root port is clear 
       or the root port itself is in D3hot state. 
     */
    UINT16 rsvd_12 : 4;
    /* rsvd_12 - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} APICLIMIT_IIO_PCIEDMI_STRUCT;


/* VSECPHDR_IIO_PCIEDMI_REG supported on:                                     */
/*       SKX_A0 (0x40000144)                                                  */
/*       SKX (0x40000144)                                                     */
/* Register default value:              0x1D01000B                            */
#define VSECPHDR_IIO_PCIEDMI_REG 0x0D004144
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x144
 */
typedef union {
  struct {
    UINT32 pci_express_extended_cap_id : 16;
    /* pci_express_extended_cap_id - Bits[15:0], RO, default = 16'b0000000000001011  */
    UINT32 capability_version : 4;
    /* capability_version - Bits[19:16], RO, default = 4'b0001  */
    UINT32 next_capability_offset : 12;
    /* next_capability_offset - Bits[31:20], RO, default = 12'b000111010000  */
  } Bits;
  UINT32 Data;
} VSECPHDR_IIO_PCIEDMI_STRUCT;


/* VSHDR_IIO_PCIEDMI_REG supported on:                                        */
/*       SKX_A0 (0x40000148)                                                  */
/*       SKX (0x40000148)                                                     */
/* Register default value:              0x03C10004                            */
#define VSHDR_IIO_PCIEDMI_REG 0x0D004148
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x148
 */
typedef union {
  struct {
    UINT32 vsec_id : 16;
    /* vsec_id - Bits[15:0], RO, default = 16'b0000000000000100  */
    UINT32 vsec_version : 4;
    /* vsec_version - Bits[19:16], RO, default = 4'b0001  */
    UINT32 vsec_length : 12;
    /* vsec_length - Bits[31:20], RO, default = 12'b000000111100  */
  } Bits;
  UINT32 Data;
} VSHDR_IIO_PCIEDMI_STRUCT;


/* UNCERRSTS_IIO_PCIEDMI_REG supported on:                                    */
/*       SKX_A0 (0x4000014C)                                                  */
/*       SKX (0x4000014C)                                                     */
/* Register default value:              0x00000000                            */
#define UNCERRSTS_IIO_PCIEDMI_REG 0x0D00414C
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x14c
 */
typedef union {
  struct {
    UINT32 rsvd_uncerrsts_3_0 : 4;
    /* rsvd_uncerrsts_3_0 - Bits[3:0], RO, default = 4'b0000  */
    UINT32 data_link_protocol_error_status : 1;
    /* data_link_protocol_error_status - Bits[4:4], RW1CS, default = 1'b0  */
    UINT32 surprise_down_error_status : 1;
    /* surprise_down_error_status - Bits[5:5], RW1CS, default = 1'b0  */
    UINT32 rsvd_uncerrsts_11_6 : 6;
    /* rsvd_uncerrsts_11_6 - Bits[11:6], RO, default = 6'b000000  */
    UINT32 poisoned_tlp_status : 1;
    /* poisoned_tlp_status - Bits[12:12], RW1CS, default = 1'b0  */
    UINT32 flow_control_protocol_error_status : 1;
    /* flow_control_protocol_error_status - Bits[13:13], RW1CS, default = 1'b0  */
    UINT32 completion_time_out_status : 1;
    /* completion_time_out_status - Bits[14:14], RW1CS, default = 1'b0  */
    UINT32 completer_abort_status : 1;
    /* completer_abort_status - Bits[15:15], RW1CS, default = 1'b0  */
    UINT32 unexpected_completion_status : 1;
    /* unexpected_completion_status - Bits[16:16], RW1CS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_status : 1;
    /* receiver_buffer_overflow_status - Bits[17:17], RW1CS, default = 1'b0  */
    UINT32 malformed_tlp_status : 1;
    /* malformed_tlp_status - Bits[18:18], RW1CS, default = 1'b0  */
    UINT32 ecrc_error_status : 1;
    /* ecrc_error_status - Bits[19:19], RW1CS, default = 1'b0  */
    UINT32 received_an_unsupported_request : 1;
    /* received_an_unsupported_request - Bits[20:20], RW1CS, default = 1'b0  */
    UINT32 acs_violation_status : 1;
    /* acs_violation_status - Bits[21:21], RW1CS, default = 1'b0  */
    UINT32 rsvd : 10;
    /* rsvd - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRSTS_IIO_PCIEDMI_STRUCT;


/* UNCERRMSK_IIO_PCIEDMI_REG supported on:                                    */
/*       SKX_A0 (0x40000150)                                                  */
/*       SKX (0x40000150)                                                     */
/* Register default value:              0x00000000                            */
#define UNCERRMSK_IIO_PCIEDMI_REG 0x0D004150
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x150
 */
typedef union {
  struct {
    UINT32 rsvd_uncerrmsk_3_0 : 4;
    /* rsvd_uncerrmsk_3_0 - Bits[3:0], RO, default = 4'b0000  */
    UINT32 data_link_layer_protocol_error_mask : 1;
    /* data_link_layer_protocol_error_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_mask : 1;
    /* surprise_down_error_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_uncerrmsk_11_6 : 6;
    /* rsvd_uncerrmsk_11_6 - Bits[11:6], RO, default = 6'b000000  */
    UINT32 poisoned_tlp_mask : 1;
    /* poisoned_tlp_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_mask : 1;
    /* flow_control_protocol_error_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_mask : 1;
    /* completion_time_out_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_mask : 1;
    /* completer_abort_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_mask : 1;
    /* unexpected_completion_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_mask : 1;
    /* receiver_buffer_overflow_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_mask : 1;
    /* malformed_tlp_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 ecrc_error_mask : 1;
    /* ecrc_error_mask - Bits[19:19], RWS, default = 1'b0  */
    UINT32 unsupported_request_error_mask : 1;
    /* unsupported_request_error_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_mask : 1;
    /* acs_violation_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd : 10;
    /* rsvd - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRMSK_IIO_PCIEDMI_STRUCT;


/* UNCERRSEV_IIO_PCIEDMI_REG supported on:                                    */
/*       SKX_A0 (0x40000154)                                                  */
/*       SKX (0x40000154)                                                     */
/* Register default value:              0x00062030                            */
#define UNCERRSEV_IIO_PCIEDMI_REG 0x0D004154
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x154
 */
typedef union {
  struct {
    UINT32 rsvd_uncerr_sev_3_0 : 4;
    /* rsvd_uncerr_sev_3_0 - Bits[3:0], RO, default = 4'b0000  */
    UINT32 data_link_protocol_error_severity : 1;
    /* data_link_protocol_error_severity - Bits[4:4], RWS, default = 1'b1  */
    UINT32 surprise_down_error_severity : 1;
    /* surprise_down_error_severity - Bits[5:5], RWS, default = 1'b1  */
    UINT32 rsvd_uncerr_sev_11_6 : 6;
    /* rsvd_uncerr_sev_11_6 - Bits[11:6], RO, default = 6'b000000  */
    UINT32 poisoned_tlp_severity : 1;
    /* poisoned_tlp_severity - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_severity : 1;
    /* flow_control_protocol_error_severity - Bits[13:13], RWS, default = 1'b1  */
    UINT32 completion_time_out_severity : 1;
    /* completion_time_out_severity - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_severity : 1;
    /* completer_abort_severity - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_severity : 1;
    /* unexpected_completion_severity - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_severity : 1;
    /* receiver_buffer_overflow_severity - Bits[17:17], RWS, default = 1'b1  */
    UINT32 malformed_tlp_severity : 1;
    /* malformed_tlp_severity - Bits[18:18], RWS, default = 1'b1  */
    UINT32 ecrc_error_severity : 1;
    /* ecrc_error_severity - Bits[19:19], RWS, default = 1'b0  */
    UINT32 unsupported_request_error_severity : 1;
    /* unsupported_request_error_severity - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_severity : 1;
    /* acs_violation_severity - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd : 10;
    /* rsvd - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCERRSEV_IIO_PCIEDMI_STRUCT;


/* CORERRSTS_IIO_PCIEDMI_REG supported on:                                    */
/*       SKX_A0 (0x40000158)                                                  */
/*       SKX (0x40000158)                                                     */
/* Register default value:              0x00000000                            */
#define CORERRSTS_IIO_PCIEDMI_REG 0x0D004158
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x158
 */
typedef union {
  struct {
    UINT32 receiver_error_status : 1;
    /* receiver_error_status - Bits[0:0], RW1CS, default = 1'b0  */
    UINT32 rsvd_1 : 5;
    /* rsvd_1 - Bits[5:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bad_tlp_status : 1;
    /* bad_tlp_status - Bits[6:6], RW1CS, default = 1'b0  */
    UINT32 bad_dllp_status : 1;
    /* bad_dllp_status - Bits[7:7], RW1CS, default = 1'b0  */
    UINT32 replay_num_rollover_status : 1;
    /* replay_num_rollover_status - Bits[8:8], RW1CS, default = 1'b0  */
    UINT32 rsvd_9 : 3;
    /* rsvd_9 - Bits[11:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 replay_timer_time_out_status : 1;
    /* replay_timer_time_out_status - Bits[12:12], RW1CS, default = 1'b0  */
    UINT32 advisory_non_fatal_error_status : 1;
    /* advisory_non_fatal_error_status - Bits[13:13], RW1CS, default = 1'b0  */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CORERRSTS_IIO_PCIEDMI_STRUCT;


/* CORERRMSK_IIO_PCIEDMI_REG supported on:                                    */
/*       SKX_A0 (0x4000015C)                                                  */
/*       SKX (0x4000015C)                                                     */
/* Register default value:              0x00002000                            */
#define CORERRMSK_IIO_PCIEDMI_REG 0x0D00415C
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x15c
 */
typedef union {
  struct {
    UINT32 receiver_error_mask : 1;
    /* receiver_error_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd_corerrmsk_5_1 : 5;
    /* rsvd_corerrmsk_5_1 - Bits[5:1], RO, default = 5'b00000  */
    UINT32 bad_tlp_mask : 1;
    /* bad_tlp_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 bad_dllp_mask : 1;
    /* bad_dllp_mask - Bits[7:7], RWS, default = 1'b0  */
    UINT32 replay_num_rollover_mask : 1;
    /* replay_num_rollover_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 rsvd_corerrmsk_11_9 : 3;
    /* rsvd_corerrmsk_11_9 - Bits[11:9], RO, default = 3'b000  */
    UINT32 replay_timer_time_out_mask : 1;
    /* replay_timer_time_out_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 advisory_non_fatal_error_mask : 1;
    /* advisory_non_fatal_error_mask - Bits[13:13], RWS, default = 1'b1  */
    UINT32 rsvd : 18;
    /* rsvd - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CORERRMSK_IIO_PCIEDMI_STRUCT;


/* ERRCAP_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x40000160)                                                  */
/*       SKX (0x40000160)                                                     */
/* Register default value:              0x00000000                            */
#define ERRCAP_IIO_PCIEDMI_REG 0x0D004160
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x160
 */
typedef union {
  struct {
    UINT32 first_error_pointer : 5;
    /* first_error_pointer - Bits[4:0], ROS_V, default = 5'b00000  */
    UINT32 ecrc_generation_capable : 1;
    /* ecrc_generation_capable - Bits[5:5], RW_O, default = 1'b0  */
    UINT32 ecrc_generation_enable : 1;
    /* ecrc_generation_enable - Bits[6:6], RWS_L, default = 1'b0  */
    UINT32 ecrc_check_capable : 1;
    /* ecrc_check_capable - Bits[7:7], RW_O, default = 1'b0  */
    UINT32 ecrc_check_enable : 1;
    /* ecrc_check_enable - Bits[8:8], RWS_L, default = 1'b0  */
    UINT32 rsvd : 23;
    /* rsvd - Bits[31:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} ERRCAP_IIO_PCIEDMI_STRUCT;


/* HDRLOG0_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x40000164)                                                  */
/*       SKX (0x40000164)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG0_IIO_PCIEDMI_REG 0x0D004164
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x164
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} HDRLOG0_IIO_PCIEDMI_STRUCT;


/* HDRLOG1_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x40000168)                                                  */
/*       SKX (0x40000168)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG1_IIO_PCIEDMI_REG 0x0D004168
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x168
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} HDRLOG1_IIO_PCIEDMI_STRUCT;


/* HDRLOG2_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x4000016C)                                                  */
/*       SKX (0x4000016C)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG2_IIO_PCIEDMI_REG 0x0D00416C
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x16c
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} HDRLOG2_IIO_PCIEDMI_STRUCT;


/* HDRLOG3_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x40000170)                                                  */
/*       SKX (0x40000170)                                                     */
/* Register default value:              0x00000000                            */
#define HDRLOG3_IIO_PCIEDMI_REG 0x0D004170
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x170
 */
typedef union {
  struct {
    UINT32 hdr : 32;
    /* hdr - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} HDRLOG3_IIO_PCIEDMI_STRUCT;


/* RPERRCMD_IIO_PCIEDMI_REG supported on:                                     */
/*       SKX_A0 (0x40000174)                                                  */
/*       SKX (0x40000174)                                                     */
/* Register default value:              0x00000000                            */
#define RPERRCMD_IIO_PCIEDMI_REG 0x0D004174
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x174
 */
typedef union {
  struct {
    UINT32 correctable_error_reporting_enable : 1;
    /* correctable_error_reporting_enable - Bits[0:0], RW, default = 1'b0  */
    UINT32 non_fatal_error_reporting_enable : 1;
    /* non_fatal_error_reporting_enable - Bits[1:1], RW, default = 1'b0  */
    UINT32 fatal_error_reporting_enable : 1;
    /* fatal_error_reporting_enable - Bits[2:2], RW, default = 1'b0  */
    UINT32 rsvd : 29;
    /* rsvd - Bits[31:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPERRCMD_IIO_PCIEDMI_STRUCT;


/* RPERRSTS_IIO_PCIEDMI_REG supported on:                                     */
/*       SKX_A0 (0x40000178)                                                  */
/*       SKX (0x40000178)                                                     */
/* Register default value:              0x00000000                            */
#define RPERRSTS_IIO_PCIEDMI_REG 0x0D004178
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x178
 */
typedef union {
  struct {
    UINT32 correctable_error_received : 1;
    /* correctable_error_received - Bits[0:0], RW1CS, default = 1'b0  */
    UINT32 multiple_correctable_error_received : 1;
    /* multiple_correctable_error_received - Bits[1:1], RW1CS, default = 1'b0  */
    UINT32 error_fatal_nonfatal_received : 1;
    /* error_fatal_nonfatal_received - Bits[2:2], RW1CS, default = 1'b0  */
    UINT32 multiple_error_fatal_nonfatal_received : 1;
    /* multiple_error_fatal_nonfatal_received - Bits[3:3], RW1CS, default = 1'b0  */
    UINT32 first_uncorrectable_fatal : 1;
    /* first_uncorrectable_fatal - Bits[4:4], RW1CS, default = 1'b0  */
    UINT32 non_fatal_error_messages_received : 1;
    /* non_fatal_error_messages_received - Bits[5:5], RW1CS, default = 1'b0  */
    UINT32 fatal_error_messages_received : 1;
    /* fatal_error_messages_received - Bits[6:6], RW1CS, default = 1'b0  */
    UINT32 rsvd : 20;
    /* rsvd - Bits[26:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 advanced_error_interrupt_message_number : 5;
    /* advanced_error_interrupt_message_number - Bits[31:27], RO, default = 5'b00000  */
  } Bits;
  UINT32 Data;
} RPERRSTS_IIO_PCIEDMI_STRUCT;


/* ERRSID_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x4000017C)                                                  */
/*       SKX (0x4000017C)                                                     */
/* Register default value:              0x00000000                            */
#define ERRSID_IIO_PCIEDMI_REG 0x0D00417C
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x17c
 */
typedef union {
  struct {
    UINT32 correctable_error_source_id : 16;
    /* correctable_error_source_id - Bits[15:0], ROS_V, default = 16'b0000000000000000  */
    UINT32 fatal_non_fatal_error_source_id : 16;
    /* fatal_non_fatal_error_source_id - Bits[31:16], ROS_V, default = 16'b0000000000000000  */
  } Bits;
  UINT32 Data;
} ERRSID_IIO_PCIEDMI_STRUCT;


/* PERFCTRLSTS_0_IIO_PCIEDMI_REG supported on:                                */
/*       SKX_A0 (0x40000180)                                                  */
/*       SKX (0x40000180)                                                     */
/* Register default value:              0x00183091                            */
#define PERFCTRLSTS_0_IIO_PCIEDMI_REG 0x0D004180
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x180
 */
typedef union {
  struct {
    UINT32 read_stream_policy : 1;
    /* read_stream_policy - Bits[0:0], RW, default = 1'b1  */
    UINT32 read_passing_read_disable : 1;
    /* read_passing_read_disable - Bits[1:1], RW, default = 1'b0  */
    UINT32 nosnoopoprden : 1;
    /* nosnoopoprden - Bits[2:2], RW, default = 1'b0  */
    UINT32 nosnoopopwren : 1;
    /* nosnoopopwren - Bits[3:3], RW, default = 1'b0  */
    UINT32 read_stream_interleave_size : 1;
    /* read_stream_interleave_size - Bits[4:4], RW, default = 1'b1  */
    UINT32 forcenosnoop : 1;
    /* forcenosnoop - Bits[5:5], RW, default = 1'b0  */
    UINT32 rsvd_6 : 1;
    /* rsvd_6 - Bits[6:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 use_allocating_flow_wr : 1;
    /* use_allocating_flow_wr - Bits[7:7], RW, default = 1'b1  */
    UINT32 outstanding_requests_gen2 : 6;
    /* outstanding_requests_gen2 - Bits[13:8], RW, default = 6'b110000  */
    UINT32 rsvd_14 : 2;
    /* rsvd_14 - Bits[15:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 outstanding_requests_gen1 : 5;
    /* outstanding_requests_gen1 - Bits[20:16], RW, default = 5'b11000  */
    UINT32 rsvd_21 : 11;
    /* rsvd_21 - Bits[31:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PERFCTRLSTS_0_IIO_PCIEDMI_STRUCT;


/* PERFCTRLSTS_1_IIO_PCIEDMI_REG supported on:                                */
/*       SKX_A0 (0x40000184)                                                  */
/*       SKX (0x40000184)                                                     */
/* Register default value:              0x00001000                            */
#define PERFCTRLSTS_1_IIO_PCIEDMI_REG 0x0D004184
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x184
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 max_read_completion_combine_size : 1;
    /* max_read_completion_combine_size - Bits[3:3], RW, default = 1'b0  */
    UINT32 rsvd_4 : 4;
    /* rsvd_4 - Bits[7:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dca_reqid_override : 1;
    /* dca_reqid_override - Bits[8:8], RW, default = 1'b0  */
    UINT32 tphdis : 1;
    /* tphdis - Bits[9:9], RW, default = 1'b0  */
    UINT32 partial_cohrd_op : 1;
    /* partial_cohrd_op - Bits[10:10], RW_L, default = 1'b0  */
    UINT32 full_cohrd_op : 1;
    /* full_cohrd_op - Bits[11:11], RW_L, default = 1'b0  */
    UINT32 prioritize_tph : 1;
    /* prioritize_tph - Bits[12:12], RW, default = 1'b1 
       If you receive a Go-G (IODC flow) for a transaction with TPH as well, you can 
       use 
       this bit to decide which flow to use. If set, TPH gets preference and you send
       WbPushHint. If not set, IODC gets preference and you send CLCleanse.
     */
    UINT32 implicit_tph : 1;
    /* implicit_tph - Bits[13:13], RW, default = 1'b0 
       This CSR is for IODC flows for Hybrid Push mode. If set, it issues a WbPushMtoI 
       for an allocating write, if the TPH hint is not set, and we receive a Go-G (the 
       requested line is in remote socket). 
     */
    UINT32 implicit_nosnp : 1;
    /* implicit_nosnp - Bits[14:14], RW, default = 1'b0 
       This CSR is for IODC flows for Hybrid Alloc-Nonallocating mode. If set, it 
       issues a ClFlush for an allocating write, if the TPH hint is not set, and we 
       receive a Go-G (the requested line is in remote socket). 
     */
    UINT32 rsvd_15 : 17;
    /* rsvd_15 - Bits[31:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PERFCTRLSTS_1_IIO_PCIEDMI_STRUCT;


/* MISCCTRLSTS_0_IIO_PCIEDMI_REG supported on:                                */
/*       SKX_A0 (0x40000188)                                                  */
/*       SKX (0x40000188)                                                     */
/* Register default value:              0x60101800                            */
#define MISCCTRLSTS_0_IIO_PCIEDMI_REG 0x0D004188
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x188
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 inbound_configuration_enable : 1;
    /* inbound_configuration_enable - Bits[1:1], RW_O, default = 1'b0  */
    UINT32 enable_acpi_mode_for_pm : 1;
    /* enable_acpi_mode_for_pm - Bits[2:2], RW, default = 1'b0  */
    UINT32 enable_acpi_mode_for_hotplug : 1;
    /* enable_acpi_mode_for_hotplug - Bits[3:3], RW, default = 1'b0  */
    UINT32 enable_system_error_only_for_aer : 1;
    /* enable_system_error_only_for_aer - Bits[4:4], RW, default = 1'b0  */
    UINT32 send_pme_turn_off_message : 1;
    /* send_pme_turn_off_message - Bits[5:5], RW_V, default = 1'b0  */
    UINT32 enable_timeout_for_receiving_pme_to_ack : 1;
    /* enable_timeout_for_receiving_pme_to_ack - Bits[6:6], RW, default = 1'b0  */
    UINT32 pme2acktoctrl : 2;
    /* pme2acktoctrl - Bits[8:7], RW, default = 2'b00  */
    UINT32 dispdspolling : 1;
    /* dispdspolling - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd_10 : 1;
    /* rsvd_10 - Bits[10:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 allow_1nonvc1_after_10vc1s : 1;
    /* allow_1nonvc1_after_10vc1s - Bits[11:11], RWS, default = 1'b1  */
    UINT32 disable_ob_parity_check : 1;
    /* disable_ob_parity_check - Bits[12:12], RWS, default = 1'b1  */
    UINT32 tlp_on_any_lane : 1;
    /* tlp_on_any_lane - Bits[13:13], RWS, default = 1'b0  */
    UINT32 allow_one_np_os : 1;
    /* allow_one_np_os - Bits[14:14], RWS, default = 1'b0  */
    UINT32 dis_hdr_storage : 1;
    /* dis_hdr_storage - Bits[15:15], RWS, default = 1'b0  */
    UINT32 force_ep_biterr : 1;
    /* force_ep_biterr - Bits[16:16], RO, default = 1'b0  */
    UINT32 force_data_perr : 1;
    /* force_data_perr - Bits[17:17], RO, default = 1'b0  */
    UINT32 max_read_completion_combine_size : 1;
    /* max_read_completion_combine_size - Bits[18:18], RWS, default = 1'b0  */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 maltlp_32baddr64bhdr_en : 1;
    /* maltlp_32baddr64bhdr_en - Bits[20:20], RW, default = 1'b1  */
    UINT32 zero_ob_tc : 1;
    /* zero_ob_tc - Bits[21:21], RW_O, default = 1'b0  */
    UINT32 check_cpl_tc : 1;
    /* check_cpl_tc - Bits[22:22], RWS, default = 1'b0  */
    UINT32 phold_disable : 1;
    /* phold_disable - Bits[23:23], RW, default = 1'b0  */
    UINT32 peer2peer_memory_read_disable : 1;
    /* peer2peer_memory_read_disable - Bits[24:24], RW, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 eoifd : 1;
    /* eoifd - Bits[26:26], RW, default = 1'b0  */
    UINT32 system_interrupt_only_on_link_bw_management_status : 1;
    /* system_interrupt_only_on_link_bw_management_status - Bits[27:27], RWS, default = 1'b0  */
    UINT32 to_dis : 1;
    /* to_dis - Bits[28:28], RW, default = 1'b0  */
    UINT32 cfg_to_en : 1;
    /* cfg_to_en - Bits[29:29], RW, default = 1'b1  */
    UINT32 inbound_io_disable : 1;
    /* inbound_io_disable - Bits[30:30], RW_O, default = 1'b1  */
    UINT32 disable_l0s_on_transmitter : 1;
    /* disable_l0s_on_transmitter - Bits[31:31], RW, default = 1'b0 
       L0s is not supported on the processor.
     */
  } Bits;
  UINT32 Data;
} MISCCTRLSTS_0_IIO_PCIEDMI_STRUCT;


/* MISCCTRLSTS_1_IIO_PCIEDMI_REG supported on:                                */
/*       SKX_A0 (0x4000018C)                                                  */
/*       SKX (0x4000018C)                                                     */
/* Register default value:              0x00000000                            */
#define MISCCTRLSTS_1_IIO_PCIEDMI_REG 0x0D00418C
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x18c
 */
typedef union {
  struct {
    UINT32 acpi_pme_inten : 1;
    /* acpi_pme_inten - Bits[0:0], RW, default = 1'b0  */
    UINT32 override_system_error_on_pcie_correctable_error_enable : 1;
    /* override_system_error_on_pcie_correctable_error_enable - Bits[1:1], RW, default = 1'b0  */
    UINT32 override_system_error_on_pcie_non_fatal_error_enable : 1;
    /* override_system_error_on_pcie_non_fatal_error_enable - Bits[2:2], RW, default = 1'b0  */
    UINT32 override_system_error_on_pcie_fatal_error_enable : 1;
    /* override_system_error_on_pcie_fatal_error_enable - Bits[3:3], RW, default = 1'b0  */
    UINT32 formfactor : 1;
    /* formfactor - Bits[4:4], RWS, default = 1'b0  */
    UINT32 disable_mctp_broadcast_to_this_link : 1;
    /* disable_mctp_broadcast_to_this_link - Bits[5:5], RW_LB, default = 1'b0  */
    UINT32 problematic_port_for_lock_flows : 1;
    /* problematic_port_for_lock_flows - Bits[6:6], RW, default = 1'b0  */
    UINT32 rsvd_7 : 2;
    /* rsvd_7 - Bits[8:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 override_socketid_in_cplid : 1;
    /* override_socketid_in_cplid - Bits[9:9], RW, default = 1'b0  */
    UINT32 rsvd_10 : 6;
    /* rsvd_10 - Bits[15:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 received_pme_to_ack : 1;
    /* received_pme_to_ack - Bits[16:16], RW1C, default = 1'b0  */
    UINT32 locked_read_timed_out : 1;
    /* locked_read_timed_out - Bits[17:17], RW1CS, default = 1'b0  */
    UINT32 enable_sris : 1;
    /* enable_sris - Bits[18:18], RW, default = 1'b0  */
    UINT32 vcm_arb_in_vc1 : 1;
    /* vcm_arb_in_vc1 - Bits[19:19], RW, default = 1'b0  */
    UINT32 no_vcm_throttle_in_quiesce : 1;
    /* no_vcm_throttle_in_quiesce - Bits[20:20], RW, default = 1'b0  */
    UINT32 rsvd_21 : 11;
    /* rsvd_21 - Bits[31:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MISCCTRLSTS_1_IIO_PCIEDMI_STRUCT;


/* PCIE_IOU_BIF_CTRL_IIO_PCIEDMI_REG supported on:                            */
/*       SKX_A0 (0x20000190)                                                  */
/*       SKX (0x20000190)                                                     */
/* Register default value:              0x0000                                */
#define PCIE_IOU_BIF_CTRL_IIO_PCIEDMI_REG 0x0D002190
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU.  
 */
typedef union {
  struct {
    UINT16 iou_bifurcation_control : 3;
    /* iou_bifurcation_control - Bits[2:0], RO, default = 3'b000 
       To select a IOU bifurcation, software sets this field and then either
       a) sets bit 3 in this register to initiate training OR
       b) resets the entire processor and on exit from that reset,
       The processor will bifurcate the ports per the setting in this field.
       For Device 1 Function 0:
       000: x4x4 (operate lanes 7:4 as x4, 3:0 as x4)
       001: x8
       others: Reserved
       For Device 2 Function 0:
       000: x4x4x4x4 (operate lanes 15:12 as x4, 11:8 as x4, 7:4 as x4 and 3:0 as x4)
       001: x4x4x8 (operate lanes 15:12 as x4, 11:8 as x4 and 7:0 as x8)
       010: x8x4x4 (operate lanes 15:8 as x8, 7:4 as x4 and 3:0 as x4)
       011: x8x8 (operate lanes 15:8 as x8, 7:0 as x8)
       100: x16
       others: Reserved
     */
    UINT16 iou_start_bifurcation : 1;
    /* iou_start_bifurcation - Bits[3:3], RW_LB, default = 1'b0 
       When software writes a 1 to this bit, IIO starts the port 0 bifurcation process. 
       After writing to this bit, software can poll the Data Link Layer link active bit 
       in the LNKSTS register to determine if a port is up and running. Once a port 
       bifurcation has been initiated by writing a 1 to this bit, software cannot 
       initiate any more write-1 to this bit (write of 0 is ok). 
       Notes:
       That this bit can be written to a 1 in the same write that changes values for 
       bits 2:0 in this register and in that case, the new value from the write to bits 
       2:0 take effect. 
       This bit always reads a 0b.
     */
    UINT16 rsvd : 12;
    /* rsvd - Bits[15:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PCIE_IOU_BIF_CTRL_IIO_PCIEDMI_STRUCT;


/* DMICTRL_N0_IIO_PCIEDMI_REG supported on:                                   */
/*       SKX_A0 (0x400001A0)                                                  */
/*       SKX (0x400001A0)                                                     */
/* Register default value:              0x00000003                            */
#define DMICTRL_N0_IIO_PCIEDMI_REG 0x0D0041A0
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x1a0
 */
typedef union {
  struct {
    UINT32 abort_inbound_requests : 1;
    /* abort_inbound_requests - Bits[0:0], RW, default = 1'b1 
       IVT 4948788 - Requires CPU reset sequence to be completed.
     */
    UINT32 auto_complete_pm : 1;
    /* auto_complete_pm - Bits[1:1], RW, default = 1'b1 
       This bit, if set, enables the DMI port to automatically complete PM message 
       handshakes by generating an Ack_Sx or Rst_Warn_Ack message down DMI for the 
       following DMI messages received: 
       Go_S0
       Go_S1_RW
       Go_S1_Temp
       Go_S1_Final
       Go_S3
       Go_S4
       Go_S5
       Rst_Warn
       Notes:
       This is used by pCode to indicate periods of time when it is not ready to accept 
       messages and there is a risk the messages will be lost. 
     */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], RO, default = 62'b00000000000000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} DMICTRL_N0_IIO_PCIEDMI_STRUCT;


/* DMICTRL_N1_IIO_PCIEDMI_REG supported on:                                   */
/*       SKX_A0 (0x400001A4)                                                  */
/*       SKX (0x400001A4)                                                     */
/* Register default value:              0x00000000                            */
#define DMICTRL_N1_IIO_PCIEDMI_REG 0x0D0041A4
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x1a0
 */
typedef union {
  struct {
    UINT32 rsvd : 32;
    /* rsvd - Bits[31:0], RO, default = 62'b00000000000000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} DMICTRL_N1_IIO_PCIEDMI_STRUCT;


/* DMISTS_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x400001A8)                                                  */
/*       SKX (0x400001A8)                                                     */
/* Register default value:              0x00000000                            */
#define DMISTS_IIO_PCIEDMI_REG 0x0D0041A8
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x1a8
 */
typedef union {
  struct {
    UINT32 received_cpu_reset_done_ack : 1;
    /* received_cpu_reset_done_ack - Bits[0:0], RW1C, default = 1'b0  */
    UINT32 reserved : 31;
    /* reserved - Bits[31:1], RO, default = 31'b0000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} DMISTS_IIO_PCIEDMI_STRUCT;


/* LNKCON_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x200001B0)                                                  */
/*       SKX (0x200001B0)                                                     */
/* Register default value:              0x0000                                */
#define LNKCON_IIO_PCIEDMI_REG 0x0D0021B0
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x1b0
 */
typedef union {
  struct {
    UINT16 active_state_link_pm_control : 2;
    /* active_state_link_pm_control - Bits[1:0], RW, default = 2'b00  */
    UINT16 rsvd_2 : 1;
    /* rsvd_2 - Bits[2:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 read_completion_boundary : 1;
    /* read_completion_boundary - Bits[3:3], RO, default = 1'b0  */
    UINT16 link_disable : 1;
    /* link_disable - Bits[4:4], RW, default = 1'b0  */
    UINT16 retrain_link : 1;
    /* retrain_link - Bits[5:5], WO, default = 1'b0  */
    UINT16 common_clock_configuration : 1;
    /* common_clock_configuration - Bits[6:6], RW_V, default = 1'b0  */
    UINT16 extended_synch : 1;
    /* extended_synch - Bits[7:7], RW, default = 1'b0  */
    UINT16 enable_clock_power_management : 1;
    /* enable_clock_power_management - Bits[8:8], RO, default = 1'b0  */
    UINT16 hardware_autonomous_width_disable : 1;
    /* hardware_autonomous_width_disable - Bits[9:9], RW, default = 1'b0  */
    UINT16 link_bandwidth_management_interrupt_enable : 1;
    /* link_bandwidth_management_interrupt_enable - Bits[10:10], RW, default = 1'b0  */
    UINT16 link_autonomous_bandwidth_interrupt_enable : 1;
    /* link_autonomous_bandwidth_interrupt_enable - Bits[11:11], RW, default = 1'b0  */
    UINT16 rsvd_12 : 4;
    /* rsvd_12 - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LNKCON_IIO_PCIEDMI_STRUCT;


/* LNKSTS_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x200001B2)                                                  */
/*       SKX (0x200001B2)                                                     */
/* Register default value:              0x1001                                */
#define LNKSTS_IIO_PCIEDMI_REG 0x0D0021B2
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x1b2
 */
typedef union {
  struct {
    UINT16 current_link_speed : 4;
    /* current_link_speed - Bits[3:0], RO_V, default = 4'b0001  */
    UINT16 negotiated_link_width : 6;
    /* negotiated_link_width - Bits[9:4], RO_V, default = 6'b000000  */
    UINT16 rsvd : 1;
    /* rsvd - Bits[10:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 link_training : 1;
    /* link_training - Bits[11:11], RO_V, default = 1'b0  */
    UINT16 slot_clock_configuration : 1;
    /* slot_clock_configuration - Bits[12:12], RW_O, default = 1'b1  */
    UINT16 data_link_layer_link_active : 1;
    /* data_link_layer_link_active - Bits[13:13], RO_V, default = 1'b0  */
    UINT16 link_bandwidth_management_status : 1;
    /* link_bandwidth_management_status - Bits[14:14], RW1C, default = 1'b0  */
    UINT16 link_autonomous_bandwidth_status : 1;
    /* link_autonomous_bandwidth_status - Bits[15:15], RW1C, default = 1'b0  */
  } Bits;
  UINT16 Data;
} LNKSTS_IIO_PCIEDMI_STRUCT;


/* LNKCON2_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x200001C0)                                                  */
/*       SKX (0x200001C0)                                                     */
/* Register default value:              0x0001                                */
#define LNKCON2_IIO_PCIEDMI_REG 0x0D0021C0
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x1c0
 */
typedef union {
  struct {
    UINT16 target_link_speed : 4;
    /* target_link_speed - Bits[3:0], RWS_V, default = 4'b0001 
       This field sets an upper limit on link operational speed by restricting the 
       values advertised by the upstream component in its training sequences. Defined 
       encodings are: 
       0001b 2.5Gb/s Target Link Speed
       0010b 5Gb/s Target Link Speed
       Reserved (Dev#0)/0011b (others) 8Gb/s Target Link Speed
       All other encodings are reserved.
       If a value is written to this field that does not correspond to a speed included 
       in the Supported Link Speeds field, IIO will default to Gen1 speed. 
       This field is also used to set the target compliance mode speed when software is 
       using the Enter Compliance bit to force a link into compliance mode. 
     */
    UINT16 enter_compliance : 1;
    /* enter_compliance - Bits[4:4], RWS_V, default = 1'b0 
       Software is permitted to force a link to enter Compliance mode at the speed 
       indicated in the Target Link Speed field by setting this bit to 1b in both 
       components on a link and then initiating a hot reset on the link. 
     */
    UINT16 hardware_autonomous_speed_disable : 1;
    /* hardware_autonomous_speed_disable - Bits[5:5], RWS, default = 1'b0 
       When Set, this bit disables hardware from changing the Link speed for device 
       specific reasons other than attempting to correct unreliable Link operation by 
       reducing Link speed. 
     */
    UINT16 selectable_de_emphasis : 1;
    /* selectable_de_emphasis - Bits[6:6], RW, default = 1'b0 
       When the Link is operating at 5.0 GT/s speed, this bit selects the level of 
       de-emphasis for an Upstream component.Encodings: 
       1b -3.5 dB
       0b -6 dB
       When the Link is operating at 2.5 GT/s speed, the setting of this bit has no 
       effect. 
     */
    UINT16 transmit_margin : 3;
    /* transmit_margin - Bits[9:7], RWS_V, default = 3'b000 
       This field controls the value of the nondeemphasized voltage level at the 
       Transmitter pins. 
     */
    UINT16 enter_modified_compliance : 1;
    /* enter_modified_compliance - Bits[10:10], RWS, default = 1'b0 
       When this bit is set to 1b, the device transmits Modified Compliance Pattern if 
       the LTSSM enters Polling.Compliance substate. 
     */
    UINT16 compliance_sos : 1;
    /* compliance_sos - Bits[11:11], RWS, default = 1'b0 
       When set to 1b, the LTSSM is required to send SKP Ordered Sets periodically in 
       between the (modified) compliance patterns. 
     */
    UINT16 compliance_de_emphasis : 4;
    /* compliance_de_emphasis - Bits[15:12], RWS, default = 4'b0000 
       For 8GT/s Data Rate:
       This bit sets the Transmitter Preset level in Polling.Compliance state if the 
       entry occurred due to the Enter Compliance bit being 1b. The Encodings are 
       defined as follows: 
       0000b: -6 dB for de-emphasis, 0 dB for preshoot
       0001b: -3.5 dB for de-emphasis, 0 dB for preshoot
       0010b: -4.5 dB for de-emphasis, 0 dB for preshoot
       0011b: -2.5 dB for de-emphasis, 0 dB for preshoot
       0100b: 0 dB for de-emphasis, 0 dB for preshoot
       0101b: 0 dB for de-emphasis, 2 dB for preshoot
       0110b: 0 dB for de-emphasis, 2.5 dB for preshoot
       0111b: -6 dB for de-emphasis, 3.5 dB for preshoot
       1000b: -3.5 dB for de-emphasis, 3.5 dB for preshoot
       1001b: 0 dB for de-emphasis, 3.5 dB for preshoot
       Others: reserved
       For 5GT/s Data Rate:
       This bit sets the de-emphasis level in Polling.Compliance state if the entry 
       occurred due to the Enter Compliance bit being 1b. Encodings: 
       0001b: -3.5 dB
       0000b: -6 dB
       For 2.5GT/s Data Rate:
       The setting of this field has no effect. Components that support only 2.5 GT/s 
       speed are permitted to hardwire this field to 0h. 
       Notes:
       This bit is intended for debug, compliance testing purposes. System firmware and 
       software is allowed to modify this bit only during debug or compliance testing. 
     */
  } Bits;
  UINT16 Data;
} LNKCON2_IIO_PCIEDMI_STRUCT;


/* LNKSTS2_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x200001C2)                                                  */
/*       SKX (0x200001C2)                                                     */
/* Register default value:              0x0000                                */
#define LNKSTS2_IIO_PCIEDMI_REG 0x0D0021C2
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x1c2
 */
typedef union {
  struct {
    UINT16 current_de_emphasis_level : 1;
    /* current_de_emphasis_level - Bits[0:0], RO_V, default = 1'b0 
       When operating at Gen2 speed, this reports the current de-emphasis level. This 
       field is Unused for Gen1 speeds 
       1b: -3.5 dB
       0b: -6 dB
     */
    UINT16 eqcmp : 1;
    /* eqcmp - Bits[1:1], RO_V, default = 1'b0 
       When set to 1b, this indicates that the Transmitter Equalization procedure has 
       completed. 
     */
    UINT16 eqph1_succ : 1;
    /* eqph1_succ - Bits[2:2], RO_V, default = 1'b0 
       When set to 1b, this indicates that Phase 1 of the Transmitter Equalization 
       procedure has successfully completed. 
     */
    UINT16 eqph2_succ : 1;
    /* eqph2_succ - Bits[3:3], RO_V, default = 1'b0 
       When set to 1b, this indicates that Phase 2 of the Transmitter Equalization 
       procedure has successfully completed. 
     */
    UINT16 eqph3_succ : 1;
    /* eqph3_succ - Bits[4:4], RO_V, default = 1'b0 
       When set to 1b, this indicates that Phase 3 of the Transmitter Equalization 
       procedure has successfully completed. 
     */
    UINT16 lnkeqreq : 1;
    /* lnkeqreq - Bits[5:5], RW1CS, default = 1'b0 
       This bit is Set by hardware to request Link equalization process to be performed 
       on the link. 
     */
    UINT16 rsvd : 10;
    /* rsvd - Bits[15:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LNKSTS2_IIO_PCIEDMI_STRUCT;


/* ERRINJCAP_IIO_PCIEDMI_REG supported on:                                    */
/*       SKX_A0 (0x400001D0)                                                  */
/*       SKX (0x400001D0)                                                     */
/* Register default value:              0x2501000B                            */
#define ERRINJCAP_IIO_PCIEDMI_REG 0x0D0041D0
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x1d0
 */
typedef union {
  struct {
    UINT32 extcapid : 16;
    /* extcapid - Bits[15:0], RO, default = 16'b0000000000001011  */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001  */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO, default = 12'b001001010000  */
  } Bits;
  UINT32 Data;
} ERRINJCAP_IIO_PCIEDMI_STRUCT;


/* ERRINJHDR_IIO_PCIEDMI_REG supported on:                                    */
/*       SKX_A0 (0x400001D4)                                                  */
/*       SKX (0x400001D4)                                                     */
/* Register default value:              0x00A10003                            */
#define ERRINJHDR_IIO_PCIEDMI_REG 0x0D0041D4
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x1d4
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000011  */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0001  */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000001010  */
  } Bits;
  UINT32 Data;
} ERRINJHDR_IIO_PCIEDMI_STRUCT;


/* ERRINJCON_IIO_PCIEDMI_REG supported on:                                    */
/*       SKX_A0 (0x200001D8)                                                  */
/*       SKX (0x200001D8)                                                     */
/* Register default value:              0x0000                                */
#define ERRINJCON_IIO_PCIEDMI_REG 0x0D0021D8
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x1d8
 */
typedef union {
  struct {
    UINT16 errinjdis : 1;
    /* errinjdis - Bits[0:0], RW_O, default = 1'b0  */
    UINT16 cause_rcverr : 1;
    /* cause_rcverr - Bits[1:1], RW, default = 1'b0  */
    UINT16 cause_ctoerr : 1;
    /* cause_ctoerr - Bits[2:2], RW, default = 1'b0  */
    UINT16 rsvd : 13;
    /* rsvd - Bits[15:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} ERRINJCON_IIO_PCIEDMI_STRUCT;


/* CTOCTRL_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x400001E0)                                                  */
/*       SKX (0x400001E0)                                                     */
/* Register default value:              0x00000000                            */
#define CTOCTRL_IIO_PCIEDMI_REG 0x0D0041E0
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x1e0
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 8;
    /* rsvd_0 - Bits[7:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 xp_to_pcie_timeout_select : 2;
    /* xp_to_pcie_timeout_select - Bits[9:8], RW, default = 2'b00  */
    UINT32 rsvd_10 : 22;
    /* rsvd_10 - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CTOCTRL_IIO_PCIEDMI_STRUCT;


/* PCIE_LER_SS_CTRLSTS_IIO_PCIEDMI_REG supported on:                          */
/*       SKX_A0 (0x400001E4)                                                  */
/*       SKX (0x400001E4)                                                     */
/* Register default value:              0x00000000                            */
#define PCIE_LER_SS_CTRLSTS_IIO_PCIEDMI_REG 0x0D0041E4
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x1e4
 */
typedef union {
  struct {
    UINT32 ler_ss_enable : 1;
    /* ler_ss_enable - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd : 31;
    /* rsvd - Bits[31:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PCIE_LER_SS_CTRLSTS_IIO_PCIEDMI_STRUCT;


/* VPP_INDEX_IIO_PCIEDMI_REG supported on:                                    */
/*       SKX_A0 (0x400001F0)                                                  */
/*       SKX (0x400001F0)                                                     */
/* Register default value:              0x00000000                            */
#define VPP_INDEX_IIO_PCIEDMI_REG 0x0D0041F0
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x1f0
 */
typedef union {
  struct {
    UINT32 index : 4;
    /* index - Bits[3:0], RW, default = 4'b0000 
       VPP Port SLOT Register Index
       This field specifies which of the 16 I/O Extender ports will be used for this 
       Root Port. There are 16 possible ports (8 possible I/O extenders with 2 ports 
       each). 
       
     */
    UINT32 rsvd_4 : 3;
    /* rsvd_4 - Bits[6:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 vpp_enable : 1;
    /* vpp_enable - Bits[7:7], RW, default = 1'b0 
       VPP Hotplug Enable
       Enables this port to send and receive messages to and from the VPP Port.
     */
    UINT32 rsvd_8 : 24;
    /* rsvd_8 - Bits[31:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} VPP_INDEX_IIO_PCIEDMI_STRUCT;


/* XPCORERRSTS_IIO_PCIEDMI_REG supported on:                                  */
/*       SKX_A0 (0x40000200)                                                  */
/*       SKX (0x40000200)                                                     */
/* Register default value:              0x00000000                            */
#define XPCORERRSTS_IIO_PCIEDMI_REG 0x0D004200
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x200
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_status : 1;
    /* pci_link_bandwidth_changed_status - Bits[0:0], RW1CS, default = 1'b0  */
    UINT32 msgd_gt_16dw : 1;
    /* msgd_gt_16dw - Bits[1:1], RW1CS, default = 1'b0  */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCORERRSTS_IIO_PCIEDMI_STRUCT;


/* XPCORERRMSK_IIO_PCIEDMI_REG supported on:                                  */
/*       SKX_A0 (0x40000204)                                                  */
/*       SKX (0x40000204)                                                     */
/* Register default value:              0x00000000                            */
#define XPCORERRMSK_IIO_PCIEDMI_REG 0x0D004204
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x204
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_mask : 1;
    /* pci_link_bandwidth_changed_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 msgd_gt_16dw_errmask : 1;
    /* msgd_gt_16dw_errmask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCORERRMSK_IIO_PCIEDMI_STRUCT;


/* XPUNCERRSTS_IIO_PCIEDMI_REG supported on:                                  */
/*       SKX_A0 (0x40000208)                                                  */
/*       SKX (0x40000208)                                                     */
/* Register default value:              0x00000000                            */
#define XPUNCERRSTS_IIO_PCIEDMI_REG 0x0D004208
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x208
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RW1CS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detected : 1;
    /* outbound_switch_fifo_data_parity_error_detected - Bits[1:1], RW1CS, default = 1'b0  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RW1CS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort : 1;
    /* sent_completion_with_completer_abort - Bits[3:3], RW1CS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request : 1;
    /* sent_completion_with_unsupported_request - Bits[4:4], RW1CS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status : 1;
    /* received_pcie_completion_with_ca_status - Bits[5:5], RW1CS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status : 1;
    /* received_pcie_completion_with_ur_status - Bits[6:6], RW1CS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RW1CS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data : 1;
    /* received_msi_writes_greater_than_a_dword_data - Bits[8:8], RW1CS, default = 1'b0  */
    UINT32 outbound_poisoned_data : 1;
    /* outbound_poisoned_data - Bits[9:9], RW1CS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCERRSTS_IIO_PCIEDMI_STRUCT;


/* XPUNCERRMSK_IIO_PCIEDMI_REG supported on:                                  */
/*       SKX_A0 (0x4000020C)                                                  */
/*       SKX (0x4000020C)                                                     */
/* Register default value:              0x00000000                            */
#define XPUNCERRMSK_IIO_PCIEDMI_REG 0x0D00420C
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x20c
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RWS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detected_mask : 1;
    /* outbound_switch_fifo_data_parity_error_detected_mask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RWS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort_mask : 1;
    /* sent_completion_with_completer_abort_mask - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request_mask : 1;
    /* sent_completion_with_unsupported_request_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status_mask : 1;
    /* received_pcie_completion_with_ca_status_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status_mask : 1;
    /* received_pcie_completion_with_ur_status_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RWS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data_mask : 1;
    /* received_msi_writes_greater_than_a_dword_data_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 outbound_poisoned_data_mask : 1;
    /* outbound_poisoned_data_mask - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCERRMSK_IIO_PCIEDMI_STRUCT;


/* XPUNCERRSEV_IIO_PCIEDMI_REG supported on:                                  */
/*       SKX_A0 (0x40000210)                                                  */
/*       SKX (0x40000210)                                                     */
/* Register default value:              0x00000002                            */
#define XPUNCERRSEV_IIO_PCIEDMI_REG 0x0D004210
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x210
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RWS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detected_severity : 1;
    /* outbound_switch_fifo_data_parity_error_detected_severity - Bits[1:1], RWS, default = 1'b1  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RWS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort_severity : 1;
    /* sent_completion_with_completer_abort_severity - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request_severity : 1;
    /* sent_completion_with_unsupported_request_severity - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status_severity : 1;
    /* received_pcie_completion_with_ca_status_severity - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status_severity : 1;
    /* received_pcie_completion_with_ur_status_severity - Bits[6:6], RWS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RWS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data_severity : 1;
    /* received_msi_writes_greater_than_a_dword_data_severity - Bits[8:8], RWS, default = 1'b0  */
    UINT32 outbound_poisoned_data_severity : 1;
    /* outbound_poisoned_data_severity - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCERRSEV_IIO_PCIEDMI_STRUCT;


/* XPUNCERRPTR_IIO_PCIEDMI_REG supported on:                                  */
/*       SKX_A0 (0x10000214)                                                  */
/*       SKX (0x10000214)                                                     */
/* Register default value:              0x00                                  */
#define XPUNCERRPTR_IIO_PCIEDMI_REG 0x0D001214
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x214
 */
typedef union {
  struct {
    UINT8 xp_uncorrectable_first_error_pointer : 5;
    /* xp_uncorrectable_first_error_pointer - Bits[4:0], ROS_V, default = 5'b00000  */
    UINT8 rsvd : 3;
    /* rsvd - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} XPUNCERRPTR_IIO_PCIEDMI_STRUCT;


/* UNCEDMASK_IIO_PCIEDMI_REG supported on:                                    */
/*       SKX_A0 (0x40000218)                                                  */
/*       SKX (0x40000218)                                                     */
/* Register default value:              0x00000000                            */
#define UNCEDMASK_IIO_PCIEDMI_REG 0x0D004218
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x218
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    UINT32 data_link_layer_protocol_error_detect_mask : 1;
    /* data_link_layer_protocol_error_detect_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_detect_mask : 1;
    /* surprise_down_error_detect_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    UINT32 poisoned_tlp_detect_mask : 1;
    /* poisoned_tlp_detect_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_detect_mask : 1;
    /* flow_control_protocol_error_detect_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_detect_mask : 1;
    /* completion_time_out_detect_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_detect_mask : 1;
    /* completer_abort_detect_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_detect_mask : 1;
    /* unexpected_completion_detect_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_detect_mask : 1;
    /* receiver_buffer_overflow_detect_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_detect_mask : 1;
    /* malformed_tlp_detect_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 ecrc_error_detect_mask : 1;
    /* ecrc_error_detect_mask - Bits[19:19], RWS, default = 1'b0  */
    UINT32 received_an_unsupported_request_detect_mask : 1;
    /* received_an_unsupported_request_detect_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_detect_mask : 1;
    /* acs_violation_detect_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd : 10;
    /* rsvd - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} UNCEDMASK_IIO_PCIEDMI_STRUCT;


/* COREDMASK_IIO_PCIEDMI_REG supported on:                                    */
/*       SKX_A0 (0x4000021C)                                                  */
/*       SKX (0x4000021C)                                                     */
/* Register default value:              0x00000000                            */
#define COREDMASK_IIO_PCIEDMI_REG 0x0D00421C
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x21c
 */
typedef union {
  struct {
    UINT32 receiver_error_detect_mask : 1;
    /* receiver_error_detect_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 rsvd_1 : 5;
    UINT32 bad_tlp_detect_mask : 1;
    /* bad_tlp_detect_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 bad_dllp_detect_mask : 1;
    /* bad_dllp_detect_mask - Bits[7:7], RWS, default = 1'b0  */
    UINT32 replay_num_rollover_detect_mask : 1;
    /* replay_num_rollover_detect_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 rsvd_9 : 3;
    UINT32 replay_timer_time_out_detect_mask : 1;
    /* replay_timer_time_out_detect_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 advisory_non_fatal_error_detect_mask : 1;
    /* advisory_non_fatal_error_detect_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 rsvd : 18;
    /* rsvd - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} COREDMASK_IIO_PCIEDMI_STRUCT;


/* RPEDMASK_IIO_PCIEDMI_REG supported on:                                     */
/*       SKX_A0 (0x40000220)                                                  */
/*       SKX (0x40000220)                                                     */
/* Register default value:              0x00000000                            */
#define RPEDMASK_IIO_PCIEDMI_REG 0x0D004220
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x220
 */
typedef union {
  struct {
    UINT32 correctable_error_detected_status_mask : 1;
    /* correctable_error_detected_status_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 non_fatal_error_detected_status_mask : 1;
    /* non_fatal_error_detected_status_mask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 fatal_error_detected_status_mask : 1;
    /* fatal_error_detected_status_mask - Bits[2:2], RWS, default = 1'b0  */
    UINT32 rsvd : 29;
    /* rsvd - Bits[31:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPEDMASK_IIO_PCIEDMI_STRUCT;


/* XPUNCEDMASK_IIO_PCIEDMI_REG supported on:                                  */
/*       SKX_A0 (0x40000224)                                                  */
/*       SKX (0x40000224)                                                     */
/* Register default value:              0x00000000                            */
#define XPUNCEDMASK_IIO_PCIEDMI_REG 0x0D004224
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x224
 */
typedef union {
  struct {
    UINT32 unused0 : 1;
    /* unused0 - Bits[0:0], RWS, default = 1'b0  */
    UINT32 outbound_switch_fifo_data_parity_error_detect_mask : 1;
    /* outbound_switch_fifo_data_parity_error_detect_mask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 unused2 : 1;
    /* unused2 - Bits[2:2], RWS, default = 1'b0  */
    UINT32 sent_completion_with_completer_abort_detect_mask : 1;
    /* sent_completion_with_completer_abort_detect_mask - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_unsupported_request_detect_mask : 1;
    /* sent_completion_with_unsupported_request_detect_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_detect_mask : 1;
    /* received_pcie_completion_with_ca_detect_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_detect_mask : 1;
    /* received_pcie_completion_with_ur_detect_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 unused7 : 1;
    /* unused7 - Bits[7:7], RWS, default = 1'b0  */
    UINT32 received_msi_writes_greater_than_a_dword_data_detect_mask : 1;
    /* received_msi_writes_greater_than_a_dword_data_detect_mask - Bits[8:8], RWS, default = 1'b0  */
    UINT32 outbound_poisoned_data_detect_mask : 1;
    /* outbound_poisoned_data_detect_mask - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPUNCEDMASK_IIO_PCIEDMI_STRUCT;


/* XPCOREDMASK_IIO_PCIEDMI_REG supported on:                                  */
/*       SKX_A0 (0x40000228)                                                  */
/*       SKX (0x40000228)                                                     */
/* Register default value:              0x00000000                            */
#define XPCOREDMASK_IIO_PCIEDMI_REG 0x0D004228
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x228
 */
typedef union {
  struct {
    UINT32 pci_link_bandwidth_changed_detect_mask : 1;
    /* pci_link_bandwidth_changed_detect_mask - Bits[0:0], RWS, default = 1'b0  */
    UINT32 msgd_gt_16dw_detmask : 1;
    /* msgd_gt_16dw_detmask - Bits[1:1], RWS, default = 1'b0  */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCOREDMASK_IIO_PCIEDMI_STRUCT;


/* XPGLBERRSTS_IIO_PCIEDMI_REG supported on:                                  */
/*       SKX_A0 (0x20000230)                                                  */
/*       SKX (0x20000230)                                                     */
/* Register default value:              0x0000                                */
#define XPGLBERRSTS_IIO_PCIEDMI_REG 0x0D002230
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x230
 */
typedef union {
  struct {
    UINT16 pcie_aer_fatal_error : 1;
    /* pcie_aer_fatal_error - Bits[0:0], RW1CS, default = 1'b0  */
    UINT16 pcie_aer_non_fatal_error : 1;
    /* pcie_aer_non_fatal_error - Bits[1:1], RW1CS, default = 1'b0  */
    UINT16 pcie_aer_correctable_error : 1;
    /* pcie_aer_correctable_error - Bits[2:2], RW1CS, default = 1'b0  */
    UINT16 rsvd : 13;
    /* rsvd - Bits[15:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} XPGLBERRSTS_IIO_PCIEDMI_STRUCT;


/* XPGLBERRPTR_IIO_PCIEDMI_REG supported on:                                  */
/*       SKX_A0 (0x20000232)                                                  */
/*       SKX (0x20000232)                                                     */
/* Register default value:              0x0000                                */
#define XPGLBERRPTR_IIO_PCIEDMI_REG 0x0D002232
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x232
 */
typedef union {
  struct {
    UINT16 xp_cluster_global_first_error_pointer : 3;
    /* xp_cluster_global_first_error_pointer - Bits[2:0], ROS_V, default = 3'b000  */
    UINT16 rsvd : 13;
    /* rsvd - Bits[15:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} XPGLBERRPTR_IIO_PCIEDMI_STRUCT;


/* PXP2CAP_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x40000250)                                                  */
/*       SKX (0x40000250)                                                     */
/* Register default value:              0x28010019                            */
#define PXP2CAP_IIO_PCIEDMI_REG 0x0D004250
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x250
 */
typedef union {
  struct {
    UINT32 id : 16;
    /* id - Bits[15:0], RW_O, default = 16'b0000000000011001 
       This field is a PCI SIG defined ID number that indicates the nature and format 
       of the Extended Capability. PCI Express Extended Capability ID for the Secondary 
       PCI Expresss Extended Capability is 0019h. 
     */
    UINT32 version : 4;
    /* version - Bits[19:16], RW_O, default = 4'b0001 
       This field is a PCI-SIG defined version number that indicates the version of the 
       Capability structure present. 
     */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO, default = 12'b001010000000 
       This field contains the offset to the next PCI Express Extended Capability 
       structure or 000h if no other items exist in the linked list of capabilities. 
     */
  } Bits;
  UINT32 Data;
} PXP2CAP_IIO_PCIEDMI_STRUCT;


/* LNKCON3_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x40000254)                                                  */
/*       SKX (0x40000254)                                                     */
/* Register default value:              0x00000000                            */
#define LNKCON3_IIO_PCIEDMI_REG 0x0D004254
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x254
 */
typedef union {
  struct {
    UINT32 perfeq : 1;
    /* perfeq - Bits[0:0], RW, default = 1'b0 
       When this register is 1b and a 1b is written to the 'Link Retrain' register with 
       'Target Link Speed' set to 8GT/s, the Upstream component must perform 
       Transmitter Equalization. 
     */
    UINT32 lnkeqreqinten : 1;
    /* lnkeqreqinten - Bits[1:1], RW, default = 1'b0 
       When Set, this bit enables the generation of interrupt to indicate that the Link 
       Equalization Request bit has been set. 
       Notes:
       Not implemented in A0
     */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LNKCON3_IIO_PCIEDMI_STRUCT;


/* LNERRSTS_IIO_PCIEDMI_REG supported on:                                     */
/*       SKX_A0 (0x40000258)                                                  */
/*       SKX (0x40000258)                                                     */
/* Register default value:              0x00000000                            */
#define LNERRSTS_IIO_PCIEDMI_REG 0x0D004258
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x258
 */
typedef union {
  struct {
    UINT32 lane : 4;
    /* lane - Bits[3:0], RW1CS, default = 4'b0000 
       A value of 1b in any bit indicates if the corresponding PCIe Express Lane 
       detected lane based error. Contents are valid only when the link is enabled. 
       bit 0 Lane 0 Error Detected
       bit 1 Lane 1 Error Detected
       bit 2 Lane 2 Error Detected
       bit 3 Lane 3 Error Detected
     */
    UINT32 rsvd : 28;
    /* rsvd - Bits[31:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LNERRSTS_IIO_PCIEDMI_STRUCT;


/* LN0EQ_IIO_PCIEDMI_REG supported on:                                        */
/*       SKX_A0 (0x2000025C)                                                  */
/*       SKX (0x2000025C)                                                     */
/* Register default value:              0x2878                                */
#define LN0EQ_IIO_PCIEDMI_REG 0x0D00225C
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x25c
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN0EQ_IIO_PCIEDMI_STRUCT;


/* LN1EQ_IIO_PCIEDMI_REG supported on:                                        */
/*       SKX_A0 (0x2000025E)                                                  */
/*       SKX (0x2000025E)                                                     */
/* Register default value:              0x2878                                */
#define LN1EQ_IIO_PCIEDMI_REG 0x0D00225E
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x25e
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN1EQ_IIO_PCIEDMI_STRUCT;


/* LN2EQ_IIO_PCIEDMI_REG supported on:                                        */
/*       SKX_A0 (0x20000260)                                                  */
/*       SKX (0x20000260)                                                     */
/* Register default value:              0x2878                                */
#define LN2EQ_IIO_PCIEDMI_REG 0x0D002260
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x260
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN2EQ_IIO_PCIEDMI_STRUCT;


/* LN3EQ_IIO_PCIEDMI_REG supported on:                                        */
/*       SKX_A0 (0x20000262)                                                  */
/*       SKX (0x20000262)                                                     */
/* Register default value:              0x2878                                */
#define LN3EQ_IIO_PCIEDMI_REG 0x0D002262
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x262
 */
typedef union {
  struct {
    UINT16 uptxpreset : 4;
    /* uptxpreset - Bits[3:0], RW_O, default = 4'b1000  */
    UINT16 uprxpreset : 3;
    /* uprxpreset - Bits[6:4], RO, default = 3'b111  */
    UINT16 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 dntxpreset : 4;
    /* dntxpreset - Bits[11:8], RW_O, default = 4'b1000  */
    UINT16 dnrxpreset : 3;
    /* dnrxpreset - Bits[14:12], RW_O, default = 3'b010  */
    UINT16 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} LN3EQ_IIO_PCIEDMI_STRUCT;


/* LER_CAP_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x40000280)                                                  */
/*       SKX (0x40000280)                                                     */
/* Register default value:              0x2981000B                            */
#define LER_CAP_IIO_PCIEDMI_REG 0x0D004280
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x280
 */
typedef union {
  struct {
    UINT32 capid : 16;
    /* capid - Bits[15:0], RO, default = 16'b0000000000001011  */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001  */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO_V, default = 12'b001010011000 
       May not point to 0x298 depending on processor type or SKU.
     */
  } Bits;
  UINT32 Data;
} LER_CAP_IIO_PCIEDMI_STRUCT;


/* LER_HDR_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x40000284)                                                  */
/*       SKX (0x40000284)                                                     */
/* Register default value:              0x01830005                            */
#define LER_HDR_IIO_PCIEDMI_REG 0x0D004284
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x284
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000101  */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0011  */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000011000  */
  } Bits;
  UINT32 Data;
} LER_HDR_IIO_PCIEDMI_STRUCT;


/* LER_CTRLSTS_IIO_PCIEDMI_REG supported on:                                  */
/*       SKX_A0 (0x40000288)                                                  */
/*       SKX (0x40000288)                                                     */
/* Register default value:              0x00000000                            */
#define LER_CTRLSTS_IIO_PCIEDMI_REG 0x0D004288
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x288
 */
typedef union {
  struct {
    UINT32 ler_ss_enable : 1;
    /* ler_ss_enable - Bits[0:0], RWS, default = 1'b0  */
    UINT32 ler_ss_severity_en : 1;
    /* ler_ss_severity_en - Bits[1:1], RWS, default = 1'b0  */
    UINT32 ler_ss_drop_txn : 1;
    /* ler_ss_drop_txn - Bits[2:2], RWS, default = 1'b0  */
    UINT32 ler_ss_inten : 1;
    /* ler_ss_inten - Bits[3:3], RWS, default = 1'b0  */
    UINT32 rsvd : 26;
    /* rsvd - Bits[29:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ler_ss_lnk_up_ok : 1;
    /* ler_ss_lnk_up_ok - Bits[30:30], ROS_V, default = 1'b0  */
    UINT32 ler_ss_status : 1;
    /* ler_ss_status - Bits[31:31], RW1CS, default = 1'b0  */
  } Bits;
  UINT32 Data;
} LER_CTRLSTS_IIO_PCIEDMI_STRUCT;


/* LER_UNCERRMSK_IIO_PCIEDMI_REG supported on:                                */
/*       SKX_A0 (0x4000028C)                                                  */
/*       SKX (0x4000028C)                                                     */
/* Register default value:              0x00000000                            */
#define LER_UNCERRMSK_IIO_PCIEDMI_REG 0x0D00428C
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x28c
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 4;
    UINT32 data_link_layer_protocol_error_mask : 1;
    /* data_link_layer_protocol_error_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 surprise_down_error_mask : 1;
    /* surprise_down_error_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 rsvd_6 : 6;
    UINT32 poisoned_tlp_mask : 1;
    /* poisoned_tlp_mask - Bits[12:12], RWS, default = 1'b0  */
    UINT32 flow_control_protocol_error_mask : 1;
    /* flow_control_protocol_error_mask - Bits[13:13], RWS, default = 1'b0  */
    UINT32 completion_time_out_mask : 1;
    /* completion_time_out_mask - Bits[14:14], RWS, default = 1'b0  */
    UINT32 completer_abort_mask : 1;
    /* completer_abort_mask - Bits[15:15], RWS, default = 1'b0  */
    UINT32 unexpected_completion_mask : 1;
    /* unexpected_completion_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 receiver_buffer_overflow_mask : 1;
    /* receiver_buffer_overflow_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 malformed_tlp_mask : 1;
    /* malformed_tlp_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 ecrc_err_mask : 1;
    /* ecrc_err_mask - Bits[19:19], RWS, default = 1'b0  */
    UINT32 unsupported_request_error_mask : 1;
    /* unsupported_request_error_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 acs_violation_mask : 1;
    /* acs_violation_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd : 10;
    /* rsvd - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LER_UNCERRMSK_IIO_PCIEDMI_STRUCT;


/* LER_XPUNCERRMSK_IIO_PCIEDMI_REG supported on:                              */
/*       SKX_A0 (0x40000290)                                                  */
/*       SKX (0x40000290)                                                     */
/* Register default value:              0x00000000                            */
#define LER_XPUNCERRMSK_IIO_PCIEDMI_REG 0x0D004290
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x290
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 sent_completion_with_ca_mask : 1;
    /* sent_completion_with_ca_mask - Bits[3:3], RWS, default = 1'b0  */
    UINT32 sent_completion_with_ur_mask : 1;
    /* sent_completion_with_ur_mask - Bits[4:4], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ca_status_mask : 1;
    /* received_pcie_completion_with_ca_status_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 received_pcie_completion_with_ur_status_mask : 1;
    /* received_pcie_completion_with_ur_status_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 rsvd_7 : 2;
    /* rsvd_7 - Bits[8:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 outbound_poisoned_data_mask : 1;
    /* outbound_poisoned_data_mask - Bits[9:9], RWS, default = 1'b0  */
    UINT32 rsvd_10 : 22;
    /* rsvd_10 - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LER_XPUNCERRMSK_IIO_PCIEDMI_STRUCT;


/* LER_RPERRMSK_IIO_PCIEDMI_REG supported on:                                 */
/*       SKX_A0 (0x40000294)                                                  */
/*       SKX (0x40000294)                                                     */
/* Register default value:              0x00000000                            */
#define LER_RPERRMSK_IIO_PCIEDMI_REG 0x0D004294
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x294
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 5;
    /* rsvd_0 - Bits[4:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 non_fatal_error_message_received_mask : 1;
    /* non_fatal_error_message_received_mask - Bits[5:5], RWS, default = 1'b0  */
    UINT32 fatal_error_message_received_mask : 1;
    /* fatal_error_message_received_mask - Bits[6:6], RWS, default = 1'b0  */
    UINT32 rsvd_7 : 25;
    /* rsvd_7 - Bits[31:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LER_RPERRMSK_IIO_PCIEDMI_STRUCT;


/* RPPIOERR_CAP_IIO_PCIEDMI_REG supported on:                                 */
/*       SKX_A0 (0x40000298)                                                  */
/*       SKX (0x40000298)                                                     */
/* Register default value:              0x3001000B                            */
#define RPPIOERR_CAP_IIO_PCIEDMI_REG 0x0D004298
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * PCIe spec-defined capability register for enhanced root port PIO error 
 * reporting. 
 */
typedef union {
  struct {
    UINT32 capid : 16;
    /* capid - Bits[15:0], RO, default = 16'b0000000000001011 
       PCIe extended capability ID.
       Set to 0xb for vendor-specific capability.
     */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001 
       Capability version.
     */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO_V, default = 12'b001100000000 
       Next capability pointer.
       May not point to 0x300 depending on processor type or SKU.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_CAP_IIO_PCIEDMI_STRUCT;


/* RPPIOERR_HDR_IIO_PCIEDMI_REG supported on:                                 */
/*       SKX_A0 (0x4000029C)                                                  */
/*       SKX (0x4000029C)                                                     */
/* Register default value:              0x02400007                            */
#define RPPIOERR_HDR_IIO_PCIEDMI_REG 0x0D00429C
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * PCIe spec-defined vendor-specific header register for enhanced root port PIO 
 * error reporting. 
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000000111 
       Vendor-specific capability ID. Intel defines 0x7 as the ID for enhanced root 
       port PIO error reporting. 
     */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0000 
       VSEC revision.
     */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000100100 
       VSEC length.
       Length of the RP_PIO_ERR capability in bytes, starting from the capability ID.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDR_IIO_PCIEDMI_STRUCT;


/* RPPIOERR_HF_IIO_PCIEDMI_REG supported on:                                  */
/*       SKX_A0 (0x400002A0)                                                  */
/*       SKX (0x400002A0)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HF_IIO_PCIEDMI_REG 0x0D0042A0
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * Register that controls which PIO errors should cause a poison indication.
 */
typedef union {
  struct {
    UINT32 cfg_ur_hf : 1;
    /* cfg_ur_hf - Bits[0:0], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a UR response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
       Note that while the Root Port is in LER, all configuration requests targeting 
       the PCIe hierarchy below the Root Port will be treated as UR, and will return 
       poison if this bit is set. 
     */
    UINT32 cfg_ca_hf : 1;
    /* cfg_ca_hf - Bits[1:1], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a CA response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 cfg_to_hf : 1;
    /* cfg_to_hf - Bits[2:2], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that does not receive a response within the completion timeout parameter. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 rsvd_3 : 5;
    UINT32 io_ur_hf : 1;
    /* io_ur_hf - Bits[8:8], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a UR response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
       Note that while the Root Port is in LER, all IO requests targeting the PCIe 
       hierarchy below the Root Port will be treated as UR, and will return poison if 
       this bit is set. 
     */
    UINT32 io_ca_hf : 1;
    /* io_ca_hf - Bits[9:9], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a CA response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 io_to_hf : 1;
    /* io_to_hf - Bits[10:10], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that does 
       not receive a response within the completion timeout parameter. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 rsvd_11 : 5;
    UINT32 mem_ur_hf : 1;
    /* mem_ur_hf - Bits[16:16], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a UR response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
       Note that while the Root Port is in LER, all memory requests targeting the PCIe 
       hierarchy below the Root Port will be treated as UR, and will return poison if 
       this bit is set. 
     */
    UINT32 mem_ca_hf : 1;
    /* mem_ca_hf - Bits[17:17], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a CA response. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 mem_to_hf : 1;
    /* mem_to_hf - Bits[18:18], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       does not receive a response within the completion timeout parameter. 
       If set to 1, IIO returns all 1s for data and indicates poison on the data 
       returned to the processor. 
       If set to 0, IIO returns all 1s for data and will not indicate poison on data 
       returned. 
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HF_IIO_PCIEDMI_STRUCT;


/* RPPIOERR_STATUS_IIO_PCIEDMI_REG supported on:                              */
/*       SKX_A0 (0x400002A4)                                                  */
/*       SKX (0x400002A4)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_STATUS_IIO_PCIEDMI_REG 0x0D0042A4
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * Register that logs the PIO errors.  Note that PIO UR errors that occur after LER 
 * has been triggered will not update this register. 
 * If a PIO error is detected and the corresponding RPPIOERR_MASK bit is cleared, 
 * then LER will be triggered if LER is enabled, and pio_err_first_header and 
 * RPPIOERR_HDRLOG[0-3] may update. 
 * Regardless of the state of the corresponding RPPIOERR_MASK bit, a PIO error may 
 * update its status bit in this register. 
 */
typedef union {
  struct {
    UINT32 cfg_ur_err : 1;
    /* cfg_ur_err - Bits[0:0], RW1CS, default = 1'b0 
       If set to 1, indicates a CFG_UR_ERR has occurred (logged regardless of 
       rppioerr_mask.cfg_ur_mask). 
     */
    UINT32 cfg_ca_err : 1;
    /* cfg_ca_err - Bits[1:1], RW1CS, default = 1'b0 
       If set to 1, indicates a CFG_CA_ERR has occurred (logged regardless of 
       rppioerr_mask.cfg_ca_mask). 
     */
    UINT32 cfg_to_err : 1;
    /* cfg_to_err - Bits[2:2], RW1CS, default = 1'b0 
       If set to 1, indicates a CFG_TO_ERR has occurred (logged regardless of 
       rppioerr_mask.cfg_to_mask). 
       Note that the Completion Timeout bit will also be set in the UNCERRSTS register.
     */
    UINT32 rsvd_3 : 5;
    /* rsvd_3 - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 io_ur_err : 1;
    /* io_ur_err - Bits[8:8], RW1CS, default = 1'b0 
       If set to 1, indicates a IO_UR_ERR has occurred (logged regardless of 
       rppioerr_mask.io_ur_mask). 
     */
    UINT32 io_ca_err : 1;
    /* io_ca_err - Bits[9:9], RW1CS, default = 1'b0 
       If set to 1, indicates a IO_CA_ERR has occurred (logged regardless of 
       rppioerr_mask.io_ca_mask). 
     */
    UINT32 io_to_err : 1;
    /* io_to_err - Bits[10:10], RW1CS, default = 1'b0 
       If set to 1, indicates a IO_TO_ERR has occurred (logged regardless of 
       rppioerr_mask.io_to_mask). 
       Note that the Completion Timeout bit will also be set in the UNCERRSTS register.
     */
    UINT32 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mem_ur_err : 1;
    /* mem_ur_err - Bits[16:16], RW1CS, default = 1'b0 
       If set to 1, indicates a MEM_UR_ERR has occurred (logged regardless of 
       rppioerr_mask.mem_ur_mask). 
     */
    UINT32 mem_ca_err : 1;
    /* mem_ca_err - Bits[17:17], RW1CS, default = 1'b0 
       If set to 1, indicates a MEM_CA_ERR has occurred (logged regardless of 
       rppioerr_mask.mem_ca_mask). 
     */
    UINT32 mem_to_err : 1;
    /* mem_to_err - Bits[18:18], RW1CS, default = 1'b0 
       If set to 1, indicates a MEM_TO_ERR has occurred (logged regardless of 
       rppioerr_mask.mem_to_mask). 
       Note that the Completion Timeout bit will also be set in the UNCERRSTS register.
     */
    UINT32 pio_err_first_header : 5;
    /* pio_err_first_header - Bits[23:19], RW1CS, default = 5'b00000 
       These 5 bits identify the first unmasked (by rppioerr_mask) RPPIO error that was 
       observed. The encoding is as follows: 
       00: No Error
       01: CFG_UR_ERR
       02: CFG_CA_ERR
       03: CFG_TO_ERR
       04: IO_UR_ERR
       05: IO_CA_ERR
       06: IO_TO_ERR
       07: MEM_UR_ERR
       08: MEM_CA_ERR
       09: MEM_TO_ERR
       Others: undefined
       Note these bits will not record subsequent errors until the first error is 
       cleared by SW. 
     */
    UINT32 rsvd_24 : 8;
    /* rsvd_24 - Bits[31:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_STATUS_IIO_PCIEDMI_STRUCT;


/* RPPIOERR_MASK_IIO_PCIEDMI_REG supported on:                                */
/*       SKX_A0 (0x400002A8)                                                  */
/*       SKX (0x400002A8)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_MASK_IIO_PCIEDMI_REG 0x0D0042A8
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * Register that masks triggering of LER on PIO errors.  When clear, LER will be 
 * triggered when LER is enabled and an error sets the corresponding bit in the 
 * RPPIOERR_STATUS. 
 * When RPPIOERR_STATUS is used to trigger LER, it is expected the end user will 
 * program the LER_XPUNCERRMSK and XPUNCERRMSK registers correctly so that they do 
 * not trigger a LER event also. 
 * If LER_CTRLSTS.LER_Enable is not set, LER will not be triggered, regardless of 
 * the setting of the RPPIOERR_MASK registers. 
 * Poison may still be returned to the requester, based on the RPPIOERR_HF 
 * register, even when the corresponding error is masked in this register. 
 */
typedef union {
  struct {
    UINT32 cfg_ur_mask : 1;
    /* cfg_ur_mask - Bits[0:0], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a UR response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 cfg_ca_mask : 1;
    /* cfg_ca_mask - Bits[1:1], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that receives a CA response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 cfg_to_mask : 1;
    /* cfg_to_mask - Bits[2:2], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound configuration read request 
       that does not receive a response within the completion timeout parameter. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 rsvd_3 : 5;
    UINT32 io_ur_mask : 1;
    /* io_ur_mask - Bits[8:8], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a UR response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 io_ca_mask : 1;
    /* io_ca_mask - Bits[9:9], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that 
       receives a CA response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 io_to_mask : 1;
    /* io_to_mask - Bits[10:10], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound IO read request that does 
       not receive a response within the completion timeout parameter. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 rsvd_11 : 5;
    UINT32 mem_ur_mask : 1;
    /* mem_ur_mask - Bits[16:16], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a UR response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 mem_ca_mask : 1;
    /* mem_ca_mask - Bits[17:17], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       receives a CA response. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 mem_to_mask : 1;
    /* mem_to_mask - Bits[18:18], RW_L, default = 1'b0 
       Controls the IIO behavior in the case of an outbound memory read request that 
       does not receive a response within the completion timeout parameter. 
       If set to 0, IIO triggers LER if LER is enabled and may update 
       RPPIOERR_STATUS.pio_err_first_header and RPPIOERR_HDRLOG[0-3]. 
       If set to 1, LER and all other forms of escalation (such as IO MCA, NMI, or SMI) 
       will be masked. 
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_MASK_IIO_PCIEDMI_STRUCT;


/* RPPIOERR_HDRLOG0_IIO_PCIEDMI_REG supported on:                             */
/*       SKX_A0 (0x400002AC)                                                  */
/*       SKX (0x400002AC)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG0_IIO_PCIEDMI_REG 0x0D0042AC
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 0 ([31:24]), 1 ([23:16]), 2 ([15:8]), and 3 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG0_IIO_PCIEDMI_STRUCT;


/* RPPIOERR_HDRLOG1_IIO_PCIEDMI_REG supported on:                             */
/*       SKX_A0 (0x400002B0)                                                  */
/*       SKX (0x400002B0)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG1_IIO_PCIEDMI_REG 0x0D0042B0
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 4 ([31:24]), 5 ([23:16]), 6 ([15:8]), and 7 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG1_IIO_PCIEDMI_STRUCT;


/* RPPIOERR_HDRLOG2_IIO_PCIEDMI_REG supported on:                             */
/*       SKX_A0 (0x400002B4)                                                  */
/*       SKX (0x400002B4)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG2_IIO_PCIEDMI_REG 0x0D0042B4
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 8 ([31:24]), 9 ([23:16]), 10 ([15:8]), and 11 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG2_IIO_PCIEDMI_STRUCT;


/* RPPIOERR_HDRLOG3_IIO_PCIEDMI_REG supported on:                             */
/*       SKX_A0 (0x400002B8)                                                  */
/*       SKX (0x400002B8)                                                     */
/* Register default value:              0x00000000                            */
#define RPPIOERR_HDRLOG3_IIO_PCIEDMI_REG 0x0D0042B8
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * RPPIOERR_HDRLOG[0-3] is a set of 4 32-bit registers that log the TLP header of 
 * the first unmasked PIO error event.  The type of the first error should be 
 * logged in RPPIOERR_STATUS.pio_err_first_header. 
 * The header is logged in the same format as the AER Header Log register, 
 * specified in section 7.10.8 of the PCI Express Spec version 3.0.  The TLP 
 * headers are mapped to the register bits in the following manner: 
 * RPPIOERR_HDRLOG0 -> {header byte 0,  header byte 1,  header byte 2,  header byte 
 * 3 } 
 * RPPIOERR_HDRLOG1 -> {header byte 4,  header byte 5,  header byte 6,  header byte 
 * 7 } 
 * RPPIOERR_HDRLOG2 -> {header byte 8,  header byte 9,  header byte 10, header byte 
 * 11} 
 * RPPIOERR_HDRLOG3 -> {header byte 12, header byte 13, header byte 14, header byte 
 * 15} 
 */
typedef union {
  struct {
    UINT32 tlp_header_data : 32;
    /* tlp_header_data - Bits[31:0], RW1CS, default = 32'b00000000000000000000000000000000 
       TLP header bytes 12 ([31:24]), 13 ([23:16]), 14 ([15:8]), and 15 ([7:0]).
     */
  } Bits;
  UINT32 Data;
} RPPIOERR_HDRLOG3_IIO_PCIEDMI_STRUCT;










/* MCAST_CAP_HDR_IIO_PCIEDMI_REG supported on:                                */
/*       SKX_A0 (0x40000300)                                                  */
/*       SKX (0x40000300)                                                     */
/* Register default value:              0x0001000B                            */
#define MCAST_CAP_HDR_IIO_PCIEDMI_REG 0x0D004300
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * Dualcast Capability Header Register (Dualcast is specialized version of PCIe 
 * Multicast supported on the Haswell-EN processor and the EP/EP 4S processor used 
 * in conjunction with Non-transparent Bridge Application). 
 */
typedef union {
  struct {
    UINT32 capid : 16;
    /* capid - Bits[15:0], RO, default = 16'b0000000000001011  */
    UINT32 capver : 4;
    /* capver - Bits[19:16], RO, default = 4'b0001  */
    UINT32 nxtptr : 12;
    /* nxtptr - Bits[31:20], RO, default = 12'b000000000000  */
  } Bits;
  UINT32 Data;
} MCAST_CAP_HDR_IIO_PCIEDMI_STRUCT;


/* MCAST_CAP_EXT_IIO_PCIEDMI_REG supported on:                                */
/*       SKX_A0 (0x40000304)                                                  */
/*       SKX (0x40000304)                                                     */
/* Register default value:              0x03800008                            */
#define MCAST_CAP_EXT_IIO_PCIEDMI_REG 0x0D004304
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * Dualcast Extended Capability Register (Dualcast is specialized version of PCIe 
 * Multicast supported on the Haswell-EN processor and the EP/EP 4S processor used 
 * in conjunction with Non-transparent Bridge Application). 
 */
typedef union {
  struct {
    UINT32 vsecid : 16;
    /* vsecid - Bits[15:0], RO, default = 16'b0000000000001000 
       Vendor-specific capability ID. Intel defines 0x8 as the ID for dualcast.
     */
    UINT32 vsecrev : 4;
    /* vsecrev - Bits[19:16], RO, default = 4'b0000  */
    UINT32 vseclen : 12;
    /* vseclen - Bits[31:20], RO, default = 12'b000000111000  */
  } Bits;
  UINT32 Data;
} MCAST_CAP_EXT_IIO_PCIEDMI_STRUCT;


/* MCAST_CAP_IIO_PCIEDMI_REG supported on:                                    */
/*       SKX_A0 (0x2000030C)                                                  */
/*       SKX (0x2000030C)                                                     */
/* Register default value:              0x000F                                */
#define MCAST_CAP_IIO_PCIEDMI_REG 0x0D00230C
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * Dualcast Capability Register (Dualcast is specialized version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined Multicast 
 * Capability Register (see section 7.21.2 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT16 mc_max_group : 6;
    /* mc_max_group - Bits[5:0], RO, default = 6'b001111  */
    UINT16 rsvd_mc_cap_dev0_7_6 : 2;
    /* rsvd_mc_cap_dev0_7_6 - Bits[7:6], RO, default = 2'b00  */
    UINT16 mc_window_size_req : 6;
    /* mc_window_size_req - Bits[13:8], RO, default = 6'b000000  */
    UINT16 rsvd_mc_cap_dev0_14 : 1;
    /* rsvd_mc_cap_dev0_14 - Bits[14:14], RO, default = 1'b0  */
    UINT16 mc_ecrc_regen_sup : 1;
    /* mc_ecrc_regen_sup - Bits[15:15], RW_O, default = 1'b0  */
  } Bits;
  UINT16 Data;
} MCAST_CAP_IIO_PCIEDMI_STRUCT;


/* MCAST_CTRL_IIO_PCIEDMI_REG supported on:                                   */
/*       SKX_A0 (0x2000030E)                                                  */
/*       SKX (0x2000030E)                                                     */
/* Register default value:              0x0000                                */
#define MCAST_CTRL_IIO_PCIEDMI_REG 0x0D00230E
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * Dualcast Control Register (Dualcast is specialized version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined Multicast 
 * Control Register (see section 7.21.3 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT16 mc_num_group : 6;
    /* mc_num_group - Bits[5:0], RW_L, default = 6'b000000 
       This field only supports and implements bits [3:0]. Bits [5:4] are not 
       supported. 
     */
    UINT16 rsvd_mc_ctrl_14_6 : 9;
    /* rsvd_mc_ctrl_14_6 - Bits[14:6], RO, default = 9'b000000000  */
    UINT16 mc_enable : 1;
    /* mc_enable - Bits[15:15], RW_L, default = 1'b0  */
  } Bits;
  UINT16 Data;
} MCAST_CTRL_IIO_PCIEDMI_STRUCT;


/* MCAST_BASE_N0_IIO_PCIEDMI_REG supported on:                                */
/*       SKX_A0 (0x40000310)                                                  */
/*       SKX (0x40000310)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BASE_N0_IIO_PCIEDMI_REG 0x0D004310
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * Dualcast Base Address Register (Dualcast is specialized version of PCIe 
 * Multicast supported on the Haswell-EN processor and the EP/EP 4S processor used 
 * in conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Base_Address Register (see section 7.21.4 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_index_position : 6;
    /* mc_index_position - Bits[5:0], RW_L, default = 6'b000000  */
    UINT32 rsvd_mc_base_11_6 : 6;
    /* rsvd_mc_base_11_6 - Bits[11:6], RO, default = 6'b000000  */
    UINT32 mc_base_address : 20;
    /* mc_base_address - Bits[31:12], RW_L, default = 52'b0000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_BASE_N0_IIO_PCIEDMI_STRUCT;


/* MCAST_BASE_N1_IIO_PCIEDMI_REG supported on:                                */
/*       SKX_A0 (0x40000314)                                                  */
/*       SKX (0x40000314)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BASE_N1_IIO_PCIEDMI_REG 0x0D004314
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * Dualcast Base Address Register (Dualcast is specialized version of PCIe 
 * Multicast supported on the Haswell-EN processor and the EP/EP 4S processor used 
 * in conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Base_Address Register (see section 7.21.4 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_base_address : 32;
    /* mc_base_address - Bits[31:0], RW_L, default = 52'b0000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_BASE_N1_IIO_PCIEDMI_STRUCT;


/* MCAST_RCV_N0_IIO_PCIEDMI_REG supported on:                                 */
/*       SKX_A0 (0x40000318)                                                  */
/*       SKX (0x40000318)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_RCV_N0_IIO_PCIEDMI_REG 0x0D004318
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * Dualcast Receive Register (Dualcast is specialized version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Receive Register (see section 7.21.5 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_rcv : 16;
    /* mc_rcv - Bits[15:0], RW_L, default = 16'b0000000000000000  */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCAST_RCV_N0_IIO_PCIEDMI_STRUCT;




/* MCAST_BLK_ALL_N0_IIO_PCIEDMI_REG supported on:                             */
/*       SKX_A0 (0x40000320)                                                  */
/*       SKX (0x40000320)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BLK_ALL_N0_IIO_PCIEDMI_REG 0x0D004320
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * Dualcast Block All Register (Dualcast is specialized version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Block_All Register (see section 7.21.6 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_blk_all : 16;
    /* mc_blk_all - Bits[15:0], RW_L, default = 16'b0000000000000000  */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCAST_BLK_ALL_N0_IIO_PCIEDMI_STRUCT;




/* MCAST_BLK_UNT_N0_IIO_PCIEDMI_REG supported on:                             */
/*       SKX_A0 (0x40000328)                                                  */
/*       SKX (0x40000328)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_BLK_UNT_N0_IIO_PCIEDMI_REG 0x0D004328
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * Dualcast Block Untranslated Register (Dualcast is specialized version of PCIe 
 * Multicast supported on the Haswell-EN processor and the EP/EP 4S processor used 
 * in conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Block_Untranslated Register (see section 7.21.7 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_blk_unt : 16;
    /* mc_blk_unt - Bits[15:0], RW_L, default = 16'b0000000000000000  */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCAST_BLK_UNT_N0_IIO_PCIEDMI_STRUCT;




/* MCAST_OVERLAY_BAR_N0_IIO_PCIEDMI_REG supported on:                         */
/*       SKX_A0 (0x40000330)                                                  */
/*       SKX (0x40000330)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_OVERLAY_BAR_N0_IIO_PCIEDMI_REG 0x0D004330
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * Dualcast Overlay Bar Register (Dualcast is specialized version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Overlay_BAR (see section 7.21.8 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_overlay_size : 6;
    /* mc_overlay_size - Bits[5:0], RW_L, default = 6'b000000  */
    UINT32 mc_overlay_addr : 26;
    /* mc_overlay_addr - Bits[31:6], RW_L, default = 58'b0000000000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_OVERLAY_BAR_N0_IIO_PCIEDMI_STRUCT;


/* MCAST_OVERLAY_BAR_N1_IIO_PCIEDMI_REG supported on:                         */
/*       SKX_A0 (0x40000334)                                                  */
/*       SKX (0x40000334)                                                     */
/* Register default value:              0x00000000                            */
#define MCAST_OVERLAY_BAR_N1_IIO_PCIEDMI_REG 0x0D004334
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * Dualcast Overlay Bar Register (Dualcast is specialized version of PCIe Multicast 
 * supported on the Haswell-EN processor and the EP/EP 4S processor used in 
 * conjunction with Non-transparent Bridge Application). 
 * The fields in this register mirror the fields in the PCIe spec-defined 
 * MC_Overlay_BAR (see section 7.21.8 of the PCIe 3.0 spec). 
 */
typedef union {
  struct {
    UINT32 mc_overlay_addr : 32;
    /* mc_overlay_addr - Bits[31:0], RW_L, default = 58'b0000000000000000000000000000000000000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MCAST_OVERLAY_BAR_N1_IIO_PCIEDMI_STRUCT;


/* XPPMDL0_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x40000480)                                                  */
/*       SKX (0x40000480)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMDL0_IIO_PCIEDMI_REG 0x0D004480
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 pm_data_counter_low_value : 32;
    /* pm_data_counter_low_value - Bits[31:0], RW_V, default = 32'b00000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} XPPMDL0_IIO_PCIEDMI_STRUCT;


/* XPPMDL1_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x40000484)                                                  */
/*       SKX (0x40000484)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMDL1_IIO_PCIEDMI_REG 0x0D004484
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 pm_data_counter_low_value : 32;
    /* pm_data_counter_low_value - Bits[31:0], RW_V, default = 32'b00000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} XPPMDL1_IIO_PCIEDMI_STRUCT;


/* XPPMCL0_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x40000488)                                                  */
/*       SKX (0x40000488)                                                     */
/* Register default value:              0xFFFFFFFF                            */
#define XPPMCL0_IIO_PCIEDMI_REG 0x0D004488
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 pm_compare_low_value : 32;
    /* pm_compare_low_value - Bits[31:0], RW_V, default = 32'b11111111111111111111111111111111  */
  } Bits;
  UINT32 Data;
} XPPMCL0_IIO_PCIEDMI_STRUCT;


/* XPPMCL1_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x4000048C)                                                  */
/*       SKX (0x4000048C)                                                     */
/* Register default value:              0xFFFFFFFF                            */
#define XPPMCL1_IIO_PCIEDMI_REG 0x0D00448C
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 pm_compare_low_value : 32;
    /* pm_compare_low_value - Bits[31:0], RW_V, default = 32'b11111111111111111111111111111111  */
  } Bits;
  UINT32 Data;
} XPPMCL1_IIO_PCIEDMI_STRUCT;


/* XPPMDH_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x20000490)                                                  */
/*       SKX (0x20000490)                                                     */
/* Register default value:              0x0000                                */
#define XPPMDH_IIO_PCIEDMI_REG 0x0D002490
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT16 high_nibble_pex_counter0_value : 4;
    /* high_nibble_pex_counter0_value - Bits[3:0], RW_V, default = 4'b0000  */
    UINT16 rsvd_4 : 4;
    /* rsvd_4 - Bits[7:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 high_nibble_pex_counter1_value : 4;
    /* high_nibble_pex_counter1_value - Bits[11:8], RW_V, default = 4'b0000  */
    UINT16 rsvd_12 : 4;
    /* rsvd_12 - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} XPPMDH_IIO_PCIEDMI_STRUCT;


/* XPPMCH_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x20000492)                                                  */
/*       SKX (0x20000492)                                                     */
/* Register default value:              0x0F0F                                */
#define XPPMCH_IIO_PCIEDMI_REG 0x0D002492
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT16 high_nibble_pex_compare0_value : 4;
    /* high_nibble_pex_compare0_value - Bits[3:0], RW_V, default = 4'b1111  */
    UINT16 rsvd_4 : 4;
    /* rsvd_4 - Bits[7:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 high_nibble_pex_compare1_value : 4;
    /* high_nibble_pex_compare1_value - Bits[11:8], RW_V, default = 4'b1111  */
    UINT16 rsvd_12 : 4;
    /* rsvd_12 - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} XPPMCH_IIO_PCIEDMI_STRUCT;


/* XPPMR0_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x40000494)                                                  */
/*       SKX (0x40000494)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMR0_IIO_PCIEDMI_REG 0x0D004494
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 counter_reset : 1;
    /* counter_reset - Bits[0:0], RW, default = 1'b0  */
    UINT32 overflow_status_bit : 1;
    /* overflow_status_bit - Bits[1:1], RW1C, default = 1'b0  */
    UINT32 compare_status : 1;
    /* compare_status - Bits[2:2], RW1C, default = 1'b0  */
    UINT32 cto : 2;
    /* cto - Bits[4:3], RW, default = 2'b00  */
    UINT32 pm_status_signal_output : 1;
    /* pm_status_signal_output - Bits[5:5], RW, default = 1'b0  */
    UINT32 compare_mode : 2;
    /* compare_mode - Bits[7:6], RW, default = 2'b00  */
    UINT32 reset_event_select : 3;
    /* reset_event_select - Bits[10:8], RW, default = 3'b000  */
    UINT32 counter_enable_source : 3;
    /* counter_enable_source - Bits[13:11], RW, default = 3'b000  */
    UINT32 count_mode : 2;
    /* count_mode - Bits[15:14], RW, default = 2'b00  */
    UINT32 event_polarity_invert : 1;
    /* event_polarity_invert - Bits[16:16], RW, default = 1'b0  */
    UINT32 count_event_select : 2;
    /* count_event_select - Bits[18:17], RW, default = 2'b00  */
    UINT32 event_group_selection : 2;
    /* event_group_selection - Bits[20:19], RW, default = 2'b00  */
    UINT32 local_dft_event_select : 1;
    /* local_dft_event_select - Bits[21:21], RW, default = 1'b0  */
    UINT32 rsvd_22 : 2;
    UINT32 rsvd_24 : 3;
    /* rsvd_24 - Bits[26:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 reset_pulse_enable : 1;
    /* reset_pulse_enable - Bits[27:27], RW, default = 1'b0  */
    UINT32 latched_count_enable_select : 1;
    /* latched_count_enable_select - Bits[28:28], RW, default = 1'b0  */
    UINT32 force_pmd_counter_to_add_zero_to_input : 1;
    /* force_pmd_counter_to_add_zero_to_input - Bits[29:29], RW, default = 1'b0  */
    UINT32 not_greater_than_comparison : 1;
    /* not_greater_than_comparison - Bits[30:30], RW, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPPMR0_IIO_PCIEDMI_STRUCT;


/* XPPMR1_IIO_PCIEDMI_REG supported on:                                       */
/*       SKX_A0 (0x40000498)                                                  */
/*       SKX (0x40000498)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMR1_IIO_PCIEDMI_REG 0x0D004498
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 counter_reset : 1;
    /* counter_reset - Bits[0:0], RW, default = 1'b0  */
    UINT32 overflow_status_bit : 1;
    /* overflow_status_bit - Bits[1:1], RW1C, default = 1'b0  */
    UINT32 compare_status : 1;
    /* compare_status - Bits[2:2], RW1C, default = 1'b0  */
    UINT32 cto : 2;
    /* cto - Bits[4:3], RW, default = 2'b00  */
    UINT32 pm_status_signal_output : 1;
    /* pm_status_signal_output - Bits[5:5], RW, default = 1'b0  */
    UINT32 compare_mode : 2;
    /* compare_mode - Bits[7:6], RW, default = 2'b00  */
    UINT32 reset_event_select : 3;
    /* reset_event_select - Bits[10:8], RW, default = 3'b000  */
    UINT32 counter_enable_source : 3;
    /* counter_enable_source - Bits[13:11], RW, default = 3'b000  */
    UINT32 count_mode : 2;
    /* count_mode - Bits[15:14], RW, default = 2'b00  */
    UINT32 event_polarity_invert : 1;
    /* event_polarity_invert - Bits[16:16], RW, default = 1'b0  */
    UINT32 count_event_select : 2;
    /* count_event_select - Bits[18:17], RW, default = 2'b00  */
    UINT32 event_group_selection : 2;
    /* event_group_selection - Bits[20:19], RW, default = 2'b00  */
    UINT32 local_dft_event_select : 1;
    /* local_dft_event_select - Bits[21:21], RW, default = 1'b0  */
    UINT32 rsvd_22 : 2;
    UINT32 rsvd_24 : 3;
    /* rsvd_24 - Bits[26:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 reset_pulse_enable : 1;
    /* reset_pulse_enable - Bits[27:27], RW, default = 1'b0  */
    UINT32 latched_count_enable_select : 1;
    /* latched_count_enable_select - Bits[28:28], RW, default = 1'b0  */
    UINT32 force_pmd_counter_to_add_zero_to_input : 1;
    /* force_pmd_counter_to_add_zero_to_input - Bits[29:29], RW, default = 1'b0  */
    UINT32 not_greater_than_comparison : 1;
    /* not_greater_than_comparison - Bits[30:30], RW, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPPMR1_IIO_PCIEDMI_STRUCT;


/* XPPMEVL0_IIO_PCIEDMI_REG supported on:                                     */
/*       SKX_A0 (0x4000049C)                                                  */
/*       SKX (0x4000049C)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMEVL0_IIO_PCIEDMI_REG 0x0D00449C
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 for_completion_packet_or_message_encoding_for_request_packet : 4;
    /* for_completion_packet_or_message_encoding_for_request_packet - Bits[3:0], RW, default = 4'b0000  */
    UINT32 data_length : 7;
    /* data_length - Bits[10:4], RW, default = 7'b0000000  */
    UINT32 fmttyp : 5;
    /* fmttyp - Bits[15:11], RW, default = 5'b00000  */
    UINT32 cfgtyp : 2;
    /* cfgtyp - Bits[17:16], RW, default = 2'b00  */
    UINT32 extended_addressing_header : 2;
    /* extended_addressing_header - Bits[19:18], RW, default = 2'b00  */
    UINT32 lock_attribute_selection : 2;
    /* lock_attribute_selection - Bits[21:20], RW, default = 2'b00  */
    UINT32 request_packet_only : 2;
    /* request_packet_only - Bits[23:22], RW, default = 2'b00  */
    UINT32 read_or_write_selection : 2;
    /* read_or_write_selection - Bits[25:24], RW, default = 2'b00  */
    UINT32 request_or_completion_packet_selection : 2;
    /* request_or_completion_packet_selection - Bits[27:26], RW, default = 2'b00  */
    UINT32 snoop_attribute : 2;
    /* snoop_attribute - Bits[29:28], RW, default = 2'b00  */
    UINT32 data_or_no_data_attribute : 2;
    /* data_or_no_data_attribute - Bits[31:30], RW, default = 2'b00  */
  } Bits;
  UINT32 Data;
} XPPMEVL0_IIO_PCIEDMI_STRUCT;


/* XPPMEVL1_IIO_PCIEDMI_REG supported on:                                     */
/*       SKX_A0 (0x400004A0)                                                  */
/*       SKX (0x400004A0)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMEVL1_IIO_PCIEDMI_REG 0x0D0044A0
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 for_completion_packet_or_message_encoding_for_request_packet : 4;
    /* for_completion_packet_or_message_encoding_for_request_packet - Bits[3:0], RW, default = 4'b0000  */
    UINT32 data_length : 7;
    /* data_length - Bits[10:4], RW, default = 7'b0000000  */
    UINT32 fmttyp : 5;
    /* fmttyp - Bits[15:11], RW, default = 5'b00000  */
    UINT32 cfgtyp : 2;
    /* cfgtyp - Bits[17:16], RW, default = 2'b00  */
    UINT32 extended_addressing_header : 2;
    /* extended_addressing_header - Bits[19:18], RW, default = 2'b00  */
    UINT32 lock_attribute_selection : 2;
    /* lock_attribute_selection - Bits[21:20], RW, default = 2'b00  */
    UINT32 cmpreq : 2;
    /* cmpreq - Bits[23:22], RW, default = 2'b00  */
    UINT32 read_or_write_selection : 2;
    /* read_or_write_selection - Bits[25:24], RW, default = 2'b00  */
    UINT32 request_or_completion_packet_selection : 2;
    /* request_or_completion_packet_selection - Bits[27:26], RW, default = 2'b00  */
    UINT32 snoop_attribute : 2;
    /* snoop_attribute - Bits[29:28], RW, default = 2'b00  */
    UINT32 data_or_no_data_attribute : 2;
    /* data_or_no_data_attribute - Bits[31:30], RW, default = 2'b00  */
  } Bits;
  UINT32 Data;
} XPPMEVL1_IIO_PCIEDMI_STRUCT;


/* XPPMEVH0_IIO_PCIEDMI_REG supported on:                                     */
/*       SKX_A0 (0x400004A4)                                                  */
/*       SKX (0x400004A4)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMEVH0_IIO_PCIEDMI_REG 0x0D0044A4
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 inbound_or_outbound_selection : 2;
    /* inbound_or_outbound_selection - Bits[1:0], RW, default = 2'b00  */
    UINT32 global_event_selection : 6;
    /* global_event_selection - Bits[7:2], RW, default = 6'b000000  */
    UINT32 rsvd : 24;
    /* rsvd - Bits[31:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPPMEVH0_IIO_PCIEDMI_STRUCT;


/* XPPMEVH1_IIO_PCIEDMI_REG supported on:                                     */
/*       SKX_A0 (0x400004A8)                                                  */
/*       SKX (0x400004A8)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMEVH1_IIO_PCIEDMI_REG 0x0D0044A8
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 inbound_or_outbound_selection : 2;
    /* inbound_or_outbound_selection - Bits[1:0], RW, default = 2'b00  */
    UINT32 global_event_selection : 6;
    /* global_event_selection - Bits[7:2], RW, default = 6'b000000  */
    UINT32 rsvd : 24;
    /* rsvd - Bits[31:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPPMEVH1_IIO_PCIEDMI_STRUCT;


/* XPPMER0_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x400004AC)                                                  */
/*       SKX (0x400004AC)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMER0_IIO_PCIEDMI_REG 0x0D0044AC
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 qbussel : 6;
    /* qbussel - Bits[5:0], RW, default = 6'b000000  */
    UINT32 flowcntrclass : 2;
    /* flowcntrclass - Bits[7:6], RW, default = 2'b00  */
    UINT32 rsvd_8 : 5;
    UINT32 link_send_utilization : 4;
    /* link_send_utilization - Bits[16:13], RW, default = 4'b0000  */
    UINT32 xp_resource_assignment : 4;
    /* xp_resource_assignment - Bits[20:17], RW, default = 4'b0000  */
    UINT32 rsvd : 11;
    /* rsvd - Bits[31:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPPMER0_IIO_PCIEDMI_STRUCT;


/* XPPMER1_IIO_PCIEDMI_REG supported on:                                      */
/*       SKX_A0 (0x400004B0)                                                  */
/*       SKX (0x400004B0)                                                     */
/* Register default value:              0x00000000                            */
#define XPPMER1_IIO_PCIEDMI_REG 0x0D0044B0
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * This register is only implemented in function 0 of the IOU, and does not exist 
 * in other functions of the IOU. 
 */
typedef union {
  struct {
    UINT32 qbussel : 6;
    /* qbussel - Bits[5:0], RW, default = 6'b000000  */
    UINT32 flowcntrclass : 2;
    /* flowcntrclass - Bits[7:6], RW, default = 2'b00  */
    UINT32 rsvd_8 : 5;
    UINT32 link_send_utilization : 4;
    /* link_send_utilization - Bits[16:13], RW, default = 4'b0000  */
    UINT32 xp_resource_assignment : 4;
    /* xp_resource_assignment - Bits[20:17], RW, default = 4'b0000  */
    UINT32 rsvd : 11;
    /* rsvd - Bits[31:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPPMER1_IIO_PCIEDMI_STRUCT;


/* PLSR0_IIO_PCIEDMI_REG supported on:                                        */
/*       SKX_A0 (0x400004B4)                                                  */
/*       SKX (0x400004B4)                                                     */
/* Register default value:              0x00000000                            */
#define PLSR0_IIO_PCIEDMI_REG 0x0D0044B4
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x4b4
 */
typedef union {
  struct {
    UINT32 poison_log_type : 2;
    /* poison_log_type - Bits[1:0], ROS_V, default = 2'b00 
       Value of 00 = IIO generated inbound poison
       Value of 01 = Inbound from PCIe
       Value of 10 = Poison coming from ring
       Value of 11 = IIO generated outbound poison
     */
    UINT32 poison_log_rid : 16;
    /* poison_log_rid - Bits[17:2], ROS_V, default = 16'b0000000000000000 
       Requestor id
     */
    UINT32 poison_log_len : 10;
    /* poison_log_len - Bits[27:18], ROS_V, default = 10'b0000000000 
       Request Length
     */
    UINT32 poison_log_addr_vld : 1;
    /* poison_log_addr_vld - Bits[28:28], RW1CS_LBV, default = 1'b0 
       If this bit is set then it indicates that the address logged in the plsr1 and 
       plsr2 is valid. 
     */
    UINT32 poison_log_overflow : 1;
    /* poison_log_overflow - Bits[29:29], RW1CS_LBV, default = 1'b0 
       Poison detection event was observed when valid=1. In this case, the register 
       will retain the information about the first error. This is consistent with 
       UCNA/UCNA overwrite rules in Machine Check Architecture. 
     */
    UINT32 poison_log_valid : 1;
    /* poison_log_valid - Bits[30:30], RW1CS_LBV, default = 1'b0 
       If Valid=0, the log does not contain any valid information.
       If Valid=1, the log contain valid information. Any additional ring poison 
       detection events will set overflow bit. 
     */
    UINT32 poison_log_en : 1;
    /* poison_log_en - Bits[31:31], RWS_LB, default = 1'b0 
       This bit indicates if the shadow logging is enabled or disabled. A value of 0 is 
       disabled and a value of 1 is enabled. If not enabled no logging takes place in 
       this register. 
     */
  } Bits;
  UINT32 Data;
} PLSR0_IIO_PCIEDMI_STRUCT;


/* PLSR1_IIO_PCIEDMI_REG supported on:                                        */
/*       SKX_A0 (0x400004B8)                                                  */
/*       SKX (0x400004B8)                                                     */
/* Register default value:              0x00000000                            */
#define PLSR1_IIO_PCIEDMI_REG 0x0D0044B8
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x4b8
 */
typedef union {
  struct {
    UINT32 poison_log_addr_lo : 32;
    /* poison_log_addr_lo - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000 
       Address 31:0 associated with the poison data (e.g. Address field in poisoned BL 
       packet). 
     */
  } Bits;
  UINT32 Data;
} PLSR1_IIO_PCIEDMI_STRUCT;


/* PLSR2_IIO_PCIEDMI_REG supported on:                                        */
/*       SKX_A0 (0x400004BC)                                                  */
/*       SKX (0x400004BC)                                                     */
/* Register default value:              0x00000000                            */
#define PLSR2_IIO_PCIEDMI_REG 0x0D0044BC
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x4bc
 */
typedef union {
  struct {
    UINT32 poison_log_addr_hi : 32;
    /* poison_log_addr_hi - Bits[31:0], ROS_V, default = 32'b00000000000000000000000000000000 
       Address 63:32 associated with the poison data
     */
  } Bits;
  UINT32 Data;
} PLSR2_IIO_PCIEDMI_STRUCT;




/* XPCORERRCOUNTER_IIO_PCIEDMI_REG supported on:                              */
/*       SKX_A0 (0x400004D0)                                                  */
/*       SKX (0x400004D0)                                                     */
/* Register default value:              0x00000000                            */
#define XPCORERRCOUNTER_IIO_PCIEDMI_REG 0x0D0044D0
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x4D0
 */
typedef union {
  struct {
    UINT32 error_count : 16;
    /* error_count - Bits[15:0], RWS_V, default = 16'b0  */
    UINT32 receiver_error_mask : 1;
    /* receiver_error_mask - Bits[16:16], RWS, default = 1'b0  */
    UINT32 bad_tlp_mask : 1;
    /* bad_tlp_mask - Bits[17:17], RWS, default = 1'b0  */
    UINT32 bad_dllp_mask : 1;
    /* bad_dllp_mask - Bits[18:18], RWS, default = 1'b0  */
    UINT32 replay_num_rollover_mask : 1;
    /* replay_num_rollover_mask - Bits[19:19], RWS, default = 1'b0  */
    UINT32 replay_timer_timeout_mask : 1;
    /* replay_timer_timeout_mask - Bits[20:20], RWS, default = 1'b0  */
    UINT32 advisory_nonfatal_mask : 1;
    /* advisory_nonfatal_mask - Bits[21:21], RWS, default = 1'b0  */
    UINT32 rsvd : 10;
    /* rsvd - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCORERRCOUNTER_IIO_PCIEDMI_STRUCT;


/* XPCORERRTHRESHOLD_IIO_PCIEDMI_REG supported on:                            */
/*       SKX_A0 (0x400004D4)                                                  */
/*       SKX (0x400004D4)                                                     */
/* Register default value:              0x00000000                            */
#define XPCORERRTHRESHOLD_IIO_PCIEDMI_REG 0x0D0044D4
/* Struct format extracted from XML file SKX\0.0.0.CFG_DMI.xml.
 * generated by critter 00_0_0x4D4
 */
typedef union {
  struct {
    UINT32 error_threshold : 15;
    /* error_threshold - Bits[14:0], RWS, default = 15'b0  */
    UINT32 error_threshold_enable : 1;
    /* error_threshold_enable - Bits[15:15], RWS, default = 1'b0  */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} XPCORERRTHRESHOLD_IIO_PCIEDMI_STRUCT;


#endif /* IIO_PCIEDMI_h */
