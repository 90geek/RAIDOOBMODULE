//
// This file contains 'Framework Code' and is licensed as such
// under the terms of your license agreement with Intel or your
// vendor.  This file may not be modified, except as allowed by
// additional terms of your license agreement.
//
// **************************************************************************
// *                                                                        *
// *      Intel Restricted Secret                                           *
// *                                                                        *
// *      Reference Code                                                    *
// *                                                                        *
// *      Copyright (c) 2007-2016, Intel Corporation.                       *
// *                                                                        *
// *      This software and associated documentation (if any) is furnished  *
// *      under a license and may only be used or copied in accordance      *
// *      with the terms of the license. Except as permitted by such        *
// *      license, no part of this software or documentation may be         *
// *      reproduced, stored in a retrieval system, or transmitted in any   *
// *      form or by any means without the express written consent of       *
// *      Intel Corporation.                                                *
// *                                                                        *
// *      This program has been developed by Intel Corporation.             *
// *      Licensee has Intel's permission to incorporate this source code   *
// *      into their product, royalty free.  This source code may NOT be    *
// *      redistributed to anyone without Intel's written permission.       *
// *                                                                        *
// *      Intel specifically disclaims all warranties, express or           *
// *      implied, and all liability, including consequential and other     *
// *      indirect damages, for the use of this code, including liability   *
// *      for infringement of any proprietary rights, and including the     *
// *      warranties of merchantability and fitness for a particular        *
// *      purpose.  Intel does not assume any responsibility for any        *
// *      errors which may appear in this code nor any responsibility to    *
// *      update it.                                                        *
// *                                                                        *
// **************************************************************************
// **************************************************************************
// *                                                                        *
// *  PURPOSE:                                                              *
// *                                                                        *
// *      This file contains Silicon register definitions.                  *
// *                                                                        *
// **************************************************************************
//
/* Date Stamp: 9/13/2016 */

#ifndef M2UPCIE_PMON_h
#define M2UPCIE_PMON_h

#include "DataTypes.h"

/* Device and Function specifications:                                        */
/* For all target CPUs:                                                       */
/* M2UPCIE_PMON_DEV 21                                                        */
/* M2UPCIE_PMON_FUN 1                                                         */

/* SVID_1_M2UPCIE_PMON_REG supported on:                                      */
/*       SKX_A0 (0x203A902C)                                                  */
/*       SKX (0x203A902C)                                                     */
/* Register default value:              0x8086                                */
#define SVID_1_M2UPCIE_PMON_REG 0x0C01202C
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * generated by critter 16_1_0x02c
 */
typedef union {
  struct {
    UINT16 subsystem_vendor_identification_number : 16;
    /* subsystem_vendor_identification_number - Bits[15:0], RW_O, default = 16'b1000000010000110  */
  } Bits;
  UINT16 Data;
} SVID_1_M2UPCIE_PMON_STRUCT;


/* SDID_1_M2UPCIE_PMON_REG supported on:                                      */
/*       SKX_A0 (0x203A902E)                                                  */
/*       SKX (0x203A902E)                                                     */
/* Register default value:              0x0000                                */
#define SDID_1_M2UPCIE_PMON_REG 0x0C01202E
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * generated by critter 16_1_0x02e
 */
typedef union {
  struct {
    UINT16 subsystem_device_identification_number : 16;
    /* subsystem_device_identification_number - Bits[15:0], RW_O, default = 16'b0000000000000000  */
  } Bits;
  UINT16 Data;
} SDID_1_M2UPCIE_PMON_STRUCT;


/* PMONCNTRLOWER0_0_M2UPCIE_PMON_REG supported on:                            */
/*       SKX_A0 (0x403A90A0)                                                  */
/*       SKX (0x403A90A0)                                                     */
/* Register default value:              0x00000000                            */
#define PMONCNTRLOWER0_0_M2UPCIE_PMON_REG 0x0C0140A0
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * This register is a perfmon counter. Software can both read it and write it.
 */
typedef union {
  struct {
    UINT32 pmonctrdata : 32;
    /* pmonctrdata - Bits[31:0], RW_V, default = 32'b00000000000000000000000000000000 
       This is the current value of the counter.
     */
  } Bits;
  UINT32 Data;
} PMONCNTRLOWER0_0_M2UPCIE_PMON_STRUCT;


/* PMONCNTRUPPER0_0_M2UPCIE_PMON_REG supported on:                            */
/*       SKX_A0 (0x403A90A4)                                                  */
/*       SKX (0x403A90A4)                                                     */
/* Register default value:              0x00000000                            */
#define PMONCNTRUPPER0_0_M2UPCIE_PMON_REG 0x0C0140A4
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * This register is a perfmon counter. Software can both read it and write it.
 */
typedef union {
  struct {
    UINT32 pmonctrdata : 16;
    /* pmonctrdata - Bits[15:0], RW_V, default = 16'b0000000000000000 
       This is the current value of the counter.
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PMONCNTRUPPER0_0_M2UPCIE_PMON_STRUCT;


/* PMONCNTRLOWER0_1_M2UPCIE_PMON_REG supported on:                            */
/*       SKX_A0 (0x403A90A8)                                                  */
/*       SKX (0x403A90A8)                                                     */
/* Register default value:              0x00000000                            */
#define PMONCNTRLOWER0_1_M2UPCIE_PMON_REG 0x0C0140A8
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * This register is a perfmon counter. Software can both read it and write it.
 */
typedef union {
  struct {
    UINT32 pmonctrdata : 32;
    /* pmonctrdata - Bits[31:0], RW_V, default = 32'b00000000000000000000000000000000 
       This is the current value of the counter.
     */
  } Bits;
  UINT32 Data;
} PMONCNTRLOWER0_1_M2UPCIE_PMON_STRUCT;


/* PMONCNTRUPPER0_1_M2UPCIE_PMON_REG supported on:                            */
/*       SKX_A0 (0x403A90AC)                                                  */
/*       SKX (0x403A90AC)                                                     */
/* Register default value:              0x00000000                            */
#define PMONCNTRUPPER0_1_M2UPCIE_PMON_REG 0x0C0140AC
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * This register is a perfmon counter. Software can both read it and write it.
 */
typedef union {
  struct {
    UINT32 pmonctrdata : 16;
    /* pmonctrdata - Bits[15:0], RW_V, default = 16'b0000000000000000 
       This is the current value of the counter.
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PMONCNTRUPPER0_1_M2UPCIE_PMON_STRUCT;


/* PMONCNTRLOWER0_2_M2UPCIE_PMON_REG supported on:                            */
/*       SKX_A0 (0x403A90B0)                                                  */
/*       SKX (0x403A90B0)                                                     */
/* Register default value:              0x00000000                            */
#define PMONCNTRLOWER0_2_M2UPCIE_PMON_REG 0x0C0140B0
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * This register is a perfmon counter. Software can both read it and write it.
 */
typedef union {
  struct {
    UINT32 pmonctrdata : 32;
    /* pmonctrdata - Bits[31:0], RW_V, default = 32'b00000000000000000000000000000000 
       This is the current value of the counter.
     */
  } Bits;
  UINT32 Data;
} PMONCNTRLOWER0_2_M2UPCIE_PMON_STRUCT;


/* PMONCNTRUPPER0_2_M2UPCIE_PMON_REG supported on:                            */
/*       SKX_A0 (0x403A90B4)                                                  */
/*       SKX (0x403A90B4)                                                     */
/* Register default value:              0x00000000                            */
#define PMONCNTRUPPER0_2_M2UPCIE_PMON_REG 0x0C0140B4
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * This register is a perfmon counter. Software can both read it and write it.
 */
typedef union {
  struct {
    UINT32 pmonctrdata : 16;
    /* pmonctrdata - Bits[15:0], RW_V, default = 16'b0000000000000000 
       This is the current value of the counter.
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PMONCNTRUPPER0_2_M2UPCIE_PMON_STRUCT;


/* PMONCNTRLOWER0_3_M2UPCIE_PMON_REG supported on:                            */
/*       SKX_A0 (0x403A90B8)                                                  */
/*       SKX (0x403A90B8)                                                     */
/* Register default value:              0x00000000                            */
#define PMONCNTRLOWER0_3_M2UPCIE_PMON_REG 0x0C0140B8
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * This register is a perfmon counter. Software can both read it and write it.
 */
typedef union {
  struct {
    UINT32 pmonctrdata : 32;
    /* pmonctrdata - Bits[31:0], RW_V, default = 32'b00000000000000000000000000000000 
       This is the current value of the counter.
     */
  } Bits;
  UINT32 Data;
} PMONCNTRLOWER0_3_M2UPCIE_PMON_STRUCT;


/* PMONCNTRUPPER0_3_M2UPCIE_PMON_REG supported on:                            */
/*       SKX_A0 (0x403A90BC)                                                  */
/*       SKX (0x403A90BC)                                                     */
/* Register default value:              0x00000000                            */
#define PMONCNTRUPPER0_3_M2UPCIE_PMON_REG 0x0C0140BC
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * This register is a perfmon counter. Software can both read it and write it.
 */
typedef union {
  struct {
    UINT32 pmonctrdata : 16;
    /* pmonctrdata - Bits[15:0], RW_V, default = 16'b0000000000000000 
       This is the current value of the counter.
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PMONCNTRUPPER0_3_M2UPCIE_PMON_STRUCT;


/* PMONCNTRCFG0_0_M2UPCIE_PMON_REG supported on:                              */
/*       SKX_A0 (0x403A90D8)                                                  */
/*       SKX (0x403A90D8)                                                     */
/* Register default value:              0x00000000                            */
#define PMONCNTRCFG0_0_M2UPCIE_PMON_REG 0x0C0140D8
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * Perfmon Counter Control Register
 */
typedef union {
  struct {
    UINT32 evslct : 8;
    /* evslct - Bits[7:0], RW_V, default = 8'b00000000 
       This field is used to decode the PerfMon event which is selected. The encodings 
       for each of the valid UnCore PerfMon events can be found in the respective 
       Perfmon documentation. 
     */
    UINT32 unitmask : 8;
    /* unitmask - Bits[15:8], RW_V, default = 8'b00000000 
       This mask selects the sub-events to be selected for creation of the event. The 
       selected sub-events are bitwise OR-ed together to create event. At least one 
       sub-event must be selected otherwise the PerfMon event signals will not ever get 
       asserted. Events with no sub-events listed effectively have only one sub-event 
       -- bit 8 must be set to 1 in this case. 
     */
    UINT32 rsvd_16 : 1;
    /* rsvd_16 - Bits[16:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 counterreset : 1;
    /* counterreset - Bits[17:17], WO, default = 1'b0 
       When this bit is set, the corresponding counter will be reset to 0. This allows 
       for a quick reset of the counter when changing event encodings. 
     */
    UINT32 edgedet : 1;
    /* edgedet - Bits[18:18], RW_V, default = 1'b0 
       Edge detect only works in conjunction with threshholding. This is true even for 
       events that can only increment by 1 in a given cycle (like the L1 example 
       above). In this case, one should set a threshhold of 1. One can also use Edge 
       Detect with queue occupancy events. For example, if one wanted to count the 
       number of times when the TOR occupancy was larger than 5, one would selet the 
       TOR occupancy event with a threshold of 5 and set the Edge Detect bit. 
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ovfenable : 1;
    /* ovfenable - Bits[20:20], RW_V, default = 1'b0 
       Setting this bit will enable the counter to send an overflow signal. If this bit 
       is not set, the counter will wrap around when it overflows without triggering 
       anything. If this bit is set and the Unit's configuration register has Overflow 
       enabled, then a signal will be transmitted to the Ubox. 
     */
    UINT32 internal : 1;
    /* internal - Bits[21:21], RW_V, default = 1'b0 
       This bit needs to be asserted if the event which needs to be selected is an 
       internal event.  
         
         Internal events are events that are only accessible on unlocked parts. One can 
       basically think of the internal bit as an extension of the event select bits 
       [7:0], as it allows the use to gain access to additional events. It will not be 
       possible to use these events on locked parts. For perfmons that exist in MSR 
       space, the MSR write mask is set on this bit, and the ucode handler will trigger 
       a GP fault if one attempts to write to these bits. Writing to these bits is 
       controlled in other ways in the other units. 
     */
    UINT32 counteren : 1;
    /* counteren - Bits[22:22], RW_V, default = 1'b0 
       This field is the local enable for the PerfMon Counter. This bit must be 
       asserted in order for the PerfMon counter to begin counting the events selected 
       by the event select, unit mask, and internal bits (see the fields below). There 
       is one bit per PerfMon Counter. Note that if this bit is set to 1 but the Unit 
       Control Registers have determined that counting is disabled, then the counter 
       will not count. 
     */
    UINT32 invert : 1;
    /* invert - Bits[23:23], RW_V, default = 1'b0 
       This bit indicates how the threshold field will be compared to the incoming 
       event. When 0, the comparison that will be done is threshold >= event. When set 
       to 1, the comparison that will be done is inverted from the case where this bit 
       is set to 0, i.e., threshold < event. The invert bit only works when Threshhold 
       != 0. So, if one would like to invert a non-occupancy event (like LLC Hit), one 
       needs to set the threshhold to 1. 
     */
    UINT32 threshold : 8;
    /* threshold - Bits[31:24], RW_V, default = 8'b00000000 
       This field is compared directly against an incoming event value for events that 
       can increment by 1 or more in a given cycle. Since the widest event from the 
       UnCore is 7bits (queue occupancy), bit 31 is unused. The result of the 
       comparison is effectively a 1 bit wide event, i.e., the counter will be 
       incremented by 1 when the comparison is true (the type of comparison depends on 
       the setting of the 'invert' bit - see bit 23 below) no matter how wide the 
       original event was. When this field is zero, threshold comparison is disabled 
       and the event is passed without modification. 
     */
  } Bits;
  UINT32 Data;
} PMONCNTRCFG0_0_M2UPCIE_PMON_STRUCT;


/* PMONCNTRCFG0_1_M2UPCIE_PMON_REG supported on:                              */
/*       SKX_A0 (0x403A90DC)                                                  */
/*       SKX (0x403A90DC)                                                     */
/* Register default value:              0x00000000                            */
#define PMONCNTRCFG0_1_M2UPCIE_PMON_REG 0x0C0140DC
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 */
typedef union {
  struct {
    UINT32 evslct : 8;
    /* evslct - Bits[7:0], RW_V, default = 8'b00000000 
       This field is used to decode the PerfMon event which is selected. The encodings 
       for each of the valid UnCore PerfMon events can be found in the respective 
       Perfmon documentation. 
     */
    UINT32 unitmask : 8;
    /* unitmask - Bits[15:8], RW_V, default = 8'b00000000 
       This mask selects the sub-events to be selected for creation of the event. The 
       selected sub-events are bitwise OR-ed together to create event. At least one 
       sub-event must be selected otherwise the PerfMon event signals will not ever get 
       asserted. Events with no sub-events listed effectively have only one sub-event 
       -- bit 8 must be set to 1 in this case. 
     */
    UINT32 rsvd_16 : 1;
    /* rsvd_16 - Bits[16:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 counterreset : 1;
    /* counterreset - Bits[17:17], WO, default = 1'b0 
       When this bit is set, the corresponding counter will be reset to 0. This allows 
       for a quick reset of the counter when changing event encodings. 
     */
    UINT32 edgedet : 1;
    /* edgedet - Bits[18:18], RW_V, default = 1'b0 
       Edge detect only works in conjunction with threshholding. This is true even for 
       events that can only increment by 1 in a given cycle (like the L1 example 
       above). In this case, one should set a threshhold of 1. One can also use Edge 
       Detect with queue occupancy events. For example, if one wanted to count the 
       number of times when the TOR occupancy was larger than 5, one would selet the 
       TOR occupancy event with a threshold of 5 and set the Edge Detect bit. 
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ovfenable : 1;
    /* ovfenable - Bits[20:20], RW_V, default = 1'b0 
       Setting this bit will enable the counter to send an overflow signal. If this bit 
       is not set, the counter will wrap around when it overflows without triggering 
       anything. If this bit is set and the Unit's configuration register has Overflow 
       enabled, then a signal will be transmitted to the Ubox. 
     */
    UINT32 internal : 1;
    /* internal - Bits[21:21], RW_V, default = 1'b0 
       This bit needs to be asserted if the event which needs to be selected is an 
       internal event.  
         
         Internal events are events that are only accessible on unlocked parts. One can 
       basically think of the internal bit as an extension of the event select bits 
       [7:0], as it allows the use to gain access to additional events. It will not be 
       possible to use these events on locked parts. For perfmons that exist in MSR 
       space, the MSR write mask is set on this bit, and the ucode handler will trigger 
       a GP fault if one attempts to write to these bits. Writing to these bits is 
       controlled in other ways in the other units. 
     */
    UINT32 counteren : 1;
    /* counteren - Bits[22:22], RW_V, default = 1'b0 
       This field is the local enable for the PerfMon Counter. This bit must be 
       asserted in order for the PerfMon counter to begin counting the events selected 
       by the event select, unit mask, and internal bits (see the fields below). There 
       is one bit per PerfMon Counter. Note that if this bit is set to 1 but the Unit 
       Control Registers have determined that counting is disabled, then the counter 
       will not count. 
     */
    UINT32 invert : 1;
    /* invert - Bits[23:23], RW_V, default = 1'b0 
       This bit indicates how the threshold field will be compared to the incoming 
       event. When 0, the comparison that will be done is threshold >= event. When set 
       to 1, the comparison that will be done is inverted from the case where this bit 
       is set to 0, i.e., threshold < event. The invert bit only works when Threshhold 
       != 0. So, if one would like to invert a non-occupancy event (like LLC Hit), one 
       needs to set the threshhold to 1. 
     */
    UINT32 threshold : 8;
    /* threshold - Bits[31:24], RW_V, default = 8'b00000000 
       This field is compared directly against an incoming event value for events that 
       can increment by 1 or more in a given cycle. Since the widest event from the 
       UnCore is 7bits (queue occupancy), bit 31 is unused. The result of the 
       comparison is effectively a 1 bit wide event, i.e., the counter will be 
       incremented by 1 when the comparison is true (the type of comparison depends on 
       the setting of the 'invert' bit - see bit 23 below) no matter how wide the 
       original event was. When this field is zero, threshold comparison is disabled 
       and the event is passed without modification. 
     */
  } Bits;
  UINT32 Data;
} PMONCNTRCFG0_1_M2UPCIE_PMON_STRUCT;


/* PMONCNTRCFG0_2_M2UPCIE_PMON_REG supported on:                              */
/*       SKX_A0 (0x403A90E0)                                                  */
/*       SKX (0x403A90E0)                                                     */
/* Register default value:              0x00000000                            */
#define PMONCNTRCFG0_2_M2UPCIE_PMON_REG 0x0C0140E0
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 */
typedef union {
  struct {
    UINT32 evslct : 8;
    /* evslct - Bits[7:0], RW_V, default = 8'b00000000 
       This field is used to decode the PerfMon event which is selected. The encodings 
       for each of the valid UnCore PerfMon events can be found in the respective 
       Perfmon documentation. 
     */
    UINT32 unitmask : 8;
    /* unitmask - Bits[15:8], RW_V, default = 8'b00000000 
       This mask selects the sub-events to be selected for creation of the event. The 
       selected sub-events are bitwise OR-ed together to create event. At least one 
       sub-event must be selected otherwise the PerfMon event signals will not ever get 
       asserted. Events with no sub-events listed effectively have only one sub-event 
       -- bit 8 must be set to 1 in this case. 
     */
    UINT32 rsvd_16 : 1;
    /* rsvd_16 - Bits[16:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 counterreset : 1;
    /* counterreset - Bits[17:17], WO, default = 1'b0 
       When this bit is set, the corresponding counter will be reset to 0. This allows 
       for a quick reset of the counter when changing event encodings. 
     */
    UINT32 edgedet : 1;
    /* edgedet - Bits[18:18], RW_V, default = 1'b0 
       Edge detect only works in conjunction with threshholding. This is true even for 
       events that can only increment by 1 in a given cycle (like the L1 example 
       above). In this case, one should set a threshhold of 1. One can also use Edge 
       Detect with queue occupancy events. For example, if one wanted to count the 
       number of times when the TOR occupancy was larger than 5, one would selet the 
       TOR occupancy event with a threshold of 5 and set the Edge Detect bit. 
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ovfenable : 1;
    /* ovfenable - Bits[20:20], RW_V, default = 1'b0 
       Setting this bit will enable the counter to send an overflow signal. If this bit 
       is not set, the counter will wrap around when it overflows without triggering 
       anything. If this bit is set and the Unit's configuration register has Overflow 
       enabled, then a signal will be transmitted to the Ubox. 
     */
    UINT32 internal : 1;
    /* internal - Bits[21:21], RW_V, default = 1'b0 
       This bit needs to be asserted if the event which needs to be selected is an 
       internal event.  
         
         Internal events are events that are only accessible on unlocked parts. One can 
       basically think of the internal bit as an extension of the event select bits 
       [7:0], as it allows the use to gain access to additional events. It will not be 
       possible to use these events on locked parts. For perfmons that exist in MSR 
       space, the MSR write mask is set on this bit, and the ucode handler will trigger 
       a GP fault if one attempts to write to these bits. Writing to these bits is 
       controlled in other ways in the other units. 
     */
    UINT32 counteren : 1;
    /* counteren - Bits[22:22], RW_V, default = 1'b0 
       This field is the local enable for the PerfMon Counter. This bit must be 
       asserted in order for the PerfMon counter to begin counting the events selected 
       by the event select, unit mask, and internal bits (see the fields below). There 
       is one bit per PerfMon Counter. Note that if this bit is set to 1 but the Unit 
       Control Registers have determined that counting is disabled, then the counter 
       will not count. 
     */
    UINT32 invert : 1;
    /* invert - Bits[23:23], RW_V, default = 1'b0 
       This bit indicates how the threshold field will be compared to the incoming 
       event. When 0, the comparison that will be done is threshold >= event. When set 
       to 1, the comparison that will be done is inverted from the case where this bit 
       is set to 0, i.e., threshold < event. The invert bit only works when Threshhold 
       != 0. So, if one would like to invert a non-occupancy event (like LLC Hit), one 
       needs to set the threshhold to 1. 
     */
    UINT32 threshold : 8;
    /* threshold - Bits[31:24], RW_V, default = 8'b00000000 
       This field is compared directly against an incoming event value for events that 
       can increment by 1 or more in a given cycle. Since the widest event from the 
       UnCore is 7bits (queue occupancy), bit 31 is unused. The result of the 
       comparison is effectively a 1 bit wide event, i.e., the counter will be 
       incremented by 1 when the comparison is true (the type of comparison depends on 
       the setting of the 'invert' bit - see bit 23 below) no matter how wide the 
       original event was. When this field is zero, threshold comparison is disabled 
       and the event is passed without modification. 
     */
  } Bits;
  UINT32 Data;
} PMONCNTRCFG0_2_M2UPCIE_PMON_STRUCT;


/* PMONCNTRCFG0_3_M2UPCIE_PMON_REG supported on:                              */
/*       SKX_A0 (0x403A90E4)                                                  */
/*       SKX (0x403A90E4)                                                     */
/* Register default value:              0x00000000                            */
#define PMONCNTRCFG0_3_M2UPCIE_PMON_REG 0x0C0140E4
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 */
typedef union {
  struct {
    UINT32 evslct : 8;
    /* evslct - Bits[7:0], RW_V, default = 8'b00000000 
       This field is used to decode the PerfMon event which is selected. The encodings 
       for each of the valid UnCore PerfMon events can be found in the respective 
       Perfmon documentation. 
     */
    UINT32 unitmask : 8;
    /* unitmask - Bits[15:8], RW_V, default = 8'b00000000 
       This mask selects the sub-events to be selected for creation of the event. The 
       selected sub-events are bitwise OR-ed together to create event. At least one 
       sub-event must be selected otherwise the PerfMon event signals will not ever get 
       asserted. Events with no sub-events listed effectively have only one sub-event 
       -- bit 8 must be set to 1 in this case. 
     */
    UINT32 rsvd_16 : 1;
    /* rsvd_16 - Bits[16:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 counterreset : 1;
    /* counterreset - Bits[17:17], WO, default = 1'b0 
       When this bit is set, the corresponding counter will be reset to 0. This allows 
       for a quick reset of the counter when changing event encodings. 
     */
    UINT32 edgedet : 1;
    /* edgedet - Bits[18:18], RW_V, default = 1'b0 
       Edge detect only works in conjunction with threshholding. This is true even for 
       events that can only increment by 1 in a given cycle (like the L1 example 
       above). In this case, one should set a threshhold of 1. One can also use Edge 
       Detect with queue occupancy events. For example, if one wanted to count the 
       number of times when the TOR occupancy was larger than 5, one would selet the 
       TOR occupancy event with a threshold of 5 and set the Edge Detect bit. 
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ovfenable : 1;
    /* ovfenable - Bits[20:20], RW_V, default = 1'b0 
       Setting this bit will enable the counter to send an overflow signal. If this bit 
       is not set, the counter will wrap around when it overflows without triggering 
       anything. If this bit is set and the Unit's configuration register has Overflow 
       enabled, then a signal will be transmitted to the Ubox. 
     */
    UINT32 internal : 1;
    /* internal - Bits[21:21], RW_V, default = 1'b0 
       This bit needs to be asserted if the event which needs to be selected is an 
       internal event.  
         
         Internal events are events that are only accessible on unlocked parts. One can 
       basically think of the internal bit as an extension of the event select bits 
       [7:0], as it allows the use to gain access to additional events. It will not be 
       possible to use these events on locked parts. For perfmons that exist in MSR 
       space, the MSR write mask is set on this bit, and the ucode handler will trigger 
       a GP fault if one attempts to write to these bits. Writing to these bits is 
       controlled in other ways in the other units. 
     */
    UINT32 counteren : 1;
    /* counteren - Bits[22:22], RW_V, default = 1'b0 
       This field is the local enable for the PerfMon Counter. This bit must be 
       asserted in order for the PerfMon counter to begin counting the events selected 
       by the event select, unit mask, and internal bits (see the fields below). There 
       is one bit per PerfMon Counter. Note that if this bit is set to 1 but the Unit 
       Control Registers have determined that counting is disabled, then the counter 
       will not count. 
     */
    UINT32 invert : 1;
    /* invert - Bits[23:23], RW_V, default = 1'b0 
       This bit indicates how the threshold field will be compared to the incoming 
       event. When 0, the comparison that will be done is threshold >= event. When set 
       to 1, the comparison that will be done is inverted from the case where this bit 
       is set to 0, i.e., threshold < event. The invert bit only works when Threshhold 
       != 0. So, if one would like to invert a non-occupancy event (like LLC Hit), one 
       needs to set the threshhold to 1. 
     */
    UINT32 threshold : 8;
    /* threshold - Bits[31:24], RW_V, default = 8'b00000000 
       This field is compared directly against an incoming event value for events that 
       can increment by 1 or more in a given cycle. Since the widest event from the 
       UnCore is 7bits (queue occupancy), bit 31 is unused. The result of the 
       comparison is effectively a 1 bit wide event, i.e., the counter will be 
       incremented by 1 when the comparison is true (the type of comparison depends on 
       the setting of the 'invert' bit - see bit 23 below) no matter how wide the 
       original event was. When this field is zero, threshold comparison is disabled 
       and the event is passed without modification. 
     */
  } Bits;
  UINT32 Data;
} PMONCNTRCFG0_3_M2UPCIE_PMON_STRUCT;


/* PMONUNITCTRL0_M2UPCIE_PMON_REG supported on:                               */
/*       SKX_A0 (0x403A90F4)                                                  */
/*       SKX (0x403A90F4)                                                     */
/* Register default value:              0x00030000                            */
#define PMONUNITCTRL0_M2UPCIE_PMON_REG 0x0C0140F4
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * Unit Control
 */
typedef union {
  struct {
    UINT32 resetcounterconfigs : 1;
    /* resetcounterconfigs - Bits[0:0], WO, default = 1'b0 
       When this bit is written to, the counter configuration registers will be reset. 
       This does not effect the values in the counters. 
     */
    UINT32 resetcounters : 1;
    /* resetcounters - Bits[1:1], WO, default = 1'b0 
       When this bit is written to, the counters data fields will be reset. The 
       configuration values will not be reset. 
     */
    UINT32 rsvd_2 : 6;
    /* rsvd_2 - Bits[7:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 freezecounters : 1;
    /* freezecounters - Bits[8:8], RW_V, default = 1'b0 
       When this bit is written to, the counters data fields will be reset. The 
       configuration values will not be reset. 
     */
    UINT32 rsvd_9 : 7;
    /* rsvd_9 - Bits[15:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 freezeenable : 1;
    /* freezeenable - Bits[16:16], RW, default = 1'b1 
       This bit controls what the counters in the unit will do when they receive a 
       freeze signal. When set, the counters will be allowed to freeze. When not set, 
       the counters will ignore the freeze signal. 
     */
    UINT32 overflowenable : 1;
    /* overflowenable - Bits[17:17], RW, default = 1'b1 
       This bit controls the behavior of counters when they overflow. When set, the 
       system will trigger the overflow handling process throughout the rest of the 
       uncore, potentially triggering a PMI and freezing counters. When it is not set, 
       the counters will simply wrap around and continue to count. 
     */
    UINT32 rsvd_18 : 14;
    /* rsvd_18 - Bits[31:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PMONUNITCTRL0_M2UPCIE_PMON_STRUCT;


/* PMONCTRSTATUS0_M2UPCIE_PMON_REG supported on:                              */
/*       SKX_A0 (0x403A90F8)                                                  */
/*       SKX (0x403A90F8)                                                     */
/* Register default value:              0x00000000                            */
#define PMONCTRSTATUS0_M2UPCIE_PMON_REG 0x0C0140F8
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * Pmon Counter Status
 */
typedef union {
  struct {
    UINT32 counter0ovf : 1;
    /* counter0ovf - Bits[0:0], RW1C, default = 1'b0 
       counter 0 overflowed
     */
    UINT32 counter1ovf : 1;
    /* counter1ovf - Bits[1:1], RW1C, default = 1'b0 
       counter 1 overflowed
     */
    UINT32 counter2ovf : 1;
    /* counter2ovf - Bits[2:2], RW1C, default = 1'b0 
       counter 2 overflowed
     */
    UINT32 counter3ovf : 1;
    /* counter3ovf - Bits[3:3], RW1C, default = 1'b0 
       counter 3 overflowed
     */
    UINT32 rsvd : 28;
    /* rsvd - Bits[31:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PMONCTRSTATUS0_M2UPCIE_PMON_STRUCT;


/* VID_M2UPCIE_PMON_REG supported on:                                         */
/*       SKX (0x203A9000)                                                     */
/* Register default value:              0x8086                                */
#define VID_M2UPCIE_PMON_REG 0x0C012000
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * PCI Vendor ID Register
 */
typedef union {
  struct {
    UINT16 vendor_identification_number : 16;
    /* vendor_identification_number - Bits[15:0], RO, default = 16'h8086 
       The value is assigned by PCI-SIG to Intel.
     */
  } Bits;
  UINT16 Data;
} VID_M2UPCIE_PMON_STRUCT;


/* DID_M2UPCIE_PMON_REG supported on:                                         */
/*       SKX (0x203A9002)                                                     */
/* Register default value:              0x2088                                */
#define DID_M2UPCIE_PMON_REG 0x0C012002
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * PCI Device Identification Number
 */
typedef union {
  struct {
    UINT16 device_identification_number : 16;
    /* device_identification_number - Bits[15:0], RO, default = 16'h2088 
        
       Start (h)	End (h)	Device
       0x203F		0x203F	
       0x2040		0x204B	MC
       0x204C		0x204F	M3KTI
       0x2054		0x2054	CHASADALL
       0x2055		0x2055	CHAUTILALL
       0x2056		0x2056	CHAUTILALL1
       0x2057		0x2057	CHAPMAALL
       0x2058		0x205B	KTI
       0x2066		0x2067	M2MEM
       0x2068		0x206F	MC DDRIO
       0x2078		0x207F	VCU
       0x2080		0x2087	PCU
       0x2088		0x2088	
       0x2089		0x2089	
       0x208A		0x208A	
       0x208B		0x208B	
       0x208C		0x208C	
       0x208D		0x208D	CHAUTIL
       0x208E		0x208E	CHASAD
       0x208F		0x208F	CMSCHA
       0x2090		0x209F	RSVD FOR PCU FUNCTION 3
       	
     */
  } Bits;
  UINT16 Data;
} DID_M2UPCIE_PMON_STRUCT;


/* PCICMD_M2UPCIE_PMON_REG supported on:                                      */
/*       SKX (0x203A9004)                                                     */
/* Register default value:              0x0000                                */
#define PCICMD_M2UPCIE_PMON_REG 0x0C012004
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * PCI Command Register
 */
typedef union {
  struct {
    UINT16 io_space_enable : 1;
    /* io_space_enable - Bits[0:0], RO, default = 1'b0 
       Hardwired to 0 since these devices don't decode any IO BARs
     */
    UINT16 memory_space_enable : 1;
    /* memory_space_enable - Bits[1:1], RO, default = 1'b0 
       Hardwired to 0 since these devices don't decode any memory BARs
     */
    UINT16 bus_master_enable : 1;
    /* bus_master_enable - Bits[2:2], RO, default = 1'b0 
       Hardwired to 0 since these devices don't generate any transactions
     */
    UINT16 special_cycle_enable : 1;
    /* special_cycle_enable - Bits[3:3], RO, default = 1'b0 
       Not applicable. Hardwired to 0.
     */
    UINT16 memory_write_and_invalidate_enable : 1;
    /* memory_write_and_invalidate_enable - Bits[4:4], RO, default = 1'b0 
       Not applicable to internal devices. Hardwired to 0.
     */
    UINT16 vga_palette_snoop_enable : 1;
    /* vga_palette_snoop_enable - Bits[5:5], RO, default = 1'b0 
       Not applicable to internal devices. Hardwired to 0.
     */
    UINT16 parity_error_response : 1;
    /* parity_error_response - Bits[6:6], RO, default = 1'b0 
       This bit has no impact on error reporting from these devices
     */
    UINT16 idsel_stepping_wait_cycle_control : 1;
    /* idsel_stepping_wait_cycle_control - Bits[7:7], RO, default = 1'b0 
       Not applicable to internal devices. Hardwired to 0.
     */
    UINT16 serr_enable : 1;
    /* serr_enable - Bits[8:8], RO, default = 1'b0 
       This bit has no impact on error reporting from these devices
     */
    UINT16 fast_back_to_back_enable : 1;
    /* fast_back_to_back_enable - Bits[9:9], RO, default = 1'b0 
       Not applicable to PCI Express and is hardwired to 0
     */
    UINT16 intx_disable : 1;
    /* intx_disable - Bits[10:10], RO, default = 1'b0 
       N/A for these devices
     */
    UINT16 rsvd : 5;
    /* rsvd - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PCICMD_M2UPCIE_PMON_STRUCT;


/* PCISTS_M2UPCIE_PMON_REG supported on:                                      */
/*       SKX (0x203A9006)                                                     */
/* Register default value:              0x0000                                */
#define PCISTS_M2UPCIE_PMON_REG 0x0C012006
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * PCI Status Register
 */
typedef union {
  struct {
    UINT16 rsvd : 3;
    /* rsvd - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 intx_status : 1;
    /* intx_status - Bits[3:3], RO, default = 1'b0 
       Reflects the state of the INTA# signal at the input of the enable/disable 
       circuit.  This bit is set by HW to 1 when the INTA# is asserted.  This bit is 
       reset by HW to 0 after the interrupt is cleared (independent of the state of the 
       Interrupt Disable bit in the PCICMD register). 
       Hardwired to 0 on the processor
     */
    UINT16 capabilities_list : 1;
    /* capabilities_list - Bits[4:4], RO, default = 1'b0 
       This bit indicates the presence of a capabilities list structure. When set to 1, 
       indicates the register at 34h provides an offset into the function. 
     */
    UINT16 x66mhz_capable : 1;
    /* x66mhz_capable - Bits[5:5], RO, default = 1'b0 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 reserved : 1;
    /* reserved - Bits[6:6], RO, default = 1'b0 
       Reserved
     */
    UINT16 fast_back_to_back : 1;
    /* fast_back_to_back - Bits[7:7], RO, default = 1'b0 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 master_data_parity_error : 1;
    /* master_data_parity_error - Bits[8:8], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 devsel_timing : 2;
    /* devsel_timing - Bits[10:9], RO, default = 2'b00 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 signaled_target_abort : 1;
    /* signaled_target_abort - Bits[11:11], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 received_target_abort : 1;
    /* received_target_abort - Bits[12:12], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 received_master_abort : 1;
    /* received_master_abort - Bits[13:13], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 signaled_system_error : 1;
    /* signaled_system_error - Bits[14:14], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 detected_parity_error : 1;
    /* detected_parity_error - Bits[15:15], RO, default = 1'b0 
       This bit is set when the device receives a packet on the primary side with an 
       uncorrectable data error (including a packet with poison bit set) or an 
       uncorrectable address/control parity error. The setting of this bit is 
       regardless of the Parity Error Response bit (PERRE) in the PCICMD register. 
     */
  } Bits;
  UINT16 Data;
} PCISTS_M2UPCIE_PMON_STRUCT;


/* RID_M2UPCIE_PMON_REG supported on:                                         */
/*       SKX (0x103A9008)                                                     */
/* Register default value:              0x00                                  */
#define RID_M2UPCIE_PMON_REG 0x0C011008
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * "PCIe header Revision ID register"
 */
typedef union {
  struct {
    UINT8 revision_id : 8;
    /* revision_id - Bits[7:0], ROS_V, default = 8'b00000000 
       Reflects the Uncore Revision ID after reset.
       Reflects the Compatibility Revision ID after BIOS writes 0x69 to any RID 
       register in the processor uncore. 
               
     */
  } Bits;
  UINT8 Data;
} RID_M2UPCIE_PMON_STRUCT;


/* CCR_N0_M2UPCIE_PMON_REG supported on:                                      */
/*       SKX (0x103A9009)                                                     */
/* Register default value:              0x00                                  */
#define CCR_N0_M2UPCIE_PMON_REG 0x0C011009
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * PCIe header ClassCode register
 */
typedef union {
  struct {
    UINT8 register_level_programming_interface : 8;
    /* register_level_programming_interface - Bits[7:0], RO_V, default = 8'b00000000  */
  } Bits;
  UINT8 Data;
} CCR_N0_M2UPCIE_PMON_STRUCT;


/* CCR_N1_M2UPCIE_PMON_REG supported on:                                      */
/*       SKX (0x203A900A)                                                     */
/* Register default value:              0x0880                                */
#define CCR_N1_M2UPCIE_PMON_REG 0x0C01200A
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * PCIe header ClassCode register
 */
typedef union {
  struct {
    UINT16 sub_class : 8;
    /* sub_class - Bits[7:0], RO_V, default = 8'b10000000 
       The value changes dependent upon the dev/func accessed. A table of the values 
       can be found in the Class-code tab of the msgch spread-sheet  
          Most dev-func will return 8'h80 for this field except for the following 
       dev-func0,func1,... combinations. The following exceptions will return 8'h01. 
       Please refer to /src/uncore/ncu/f_ccr_reg.vh for the full lookingup table. 
                 bus-0, dev-8 func-1 
                 bus-3, dev-14 to 16, func-0
                 bus-3, dev-18, func-0, 1, 4, 5
               
     */
    UINT16 base_class : 8;
    /* base_class - Bits[15:8], RO_V, default = 8'b00001000 
       The value changes dependent upon the dev-func accessed. A table of the values 
       can be found in the Class-code tab of the msgch spread-sheet  
          Most bus-dev-func will return 8'h08 for this field except for the following 
       bus-dev-func0,func1,... combinations. The following exceptions will return 
       8'h11. Please refer to /src/uncore/ncu/f_ccr_reg.vhfor the full lookingup table. 
                 bus-0, dev-8 func-1 
                 bus-3, dev-14 to 16, func-0
                 bus-3, dev-18, func-0, 1, 4, 5
               
     */
  } Bits;
  UINT16 Data;
} CCR_N1_M2UPCIE_PMON_STRUCT;


/* CLSR_M2UPCIE_PMON_REG supported on:                                        */
/*       SKX (0x103A900C)                                                     */
/* Register default value:              0x00                                  */
#define CLSR_M2UPCIE_PMON_REG 0x0C01100C
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * PCI Cache Line Size Register
 */
typedef union {
  struct {
    UINT8 cacheline_size : 8;
    /* cacheline_size - Bits[7:0], RO, default = 8'b00000000 
       Size of Cacheline
     */
  } Bits;
  UINT8 Data;
} CLSR_M2UPCIE_PMON_STRUCT;


/* HDR_M2UPCIE_PMON_REG supported on:                                         */
/*       SKX (0x103A900E)                                                     */
/* Register default value:              0x80                                  */
#define HDR_M2UPCIE_PMON_REG 0x0C01100E
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * PCI Header Type
 */
typedef union {
  struct {
    UINT8 configuration_layout : 7;
    /* configuration_layout - Bits[6:0], RO, default = 7'b0 
       Type 0 header
     */
    UINT8 multi_function_device : 1;
    /* multi_function_device - Bits[7:7], RO, default = 1'b1 
       This bit defaults to 1b since all these devices are multi-function
     */
  } Bits;
  UINT8 Data;
} HDR_M2UPCIE_PMON_STRUCT;


/* BIST_M2UPCIE_PMON_REG supported on:                                        */
/*       SKX (0x103A900F)                                                     */
/* Register default value:              0x00                                  */
#define BIST_M2UPCIE_PMON_REG 0x0C01100F
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * PCI BIST Register
 */
typedef union {
  struct {
    UINT8 bist_tests : 8;
    /* bist_tests - Bits[7:0], RO, default = 8'b0 
       Not supported. Hardwired to 00h
     */
  } Bits;
  UINT8 Data;
} BIST_M2UPCIE_PMON_STRUCT;


/* CAPPTR_M2UPCIE_PMON_REG supported on:                                      */
/*       SKX (0x103A9034)                                                     */
/* Register default value:              0x00                                  */
#define CAPPTR_M2UPCIE_PMON_REG 0x0C011034
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * PCI Capability Pointer Register
 */
typedef union {
  struct {
    UINT8 capability_pointer : 8;
    /* capability_pointer - Bits[7:0], RO, default = 8'h00 
       Points to the first capability structure for the device which is the PCIe 
       capability. 
     */
  } Bits;
  UINT8 Data;
} CAPPTR_M2UPCIE_PMON_STRUCT;


/* INTL_M2UPCIE_PMON_REG supported on:                                        */
/*       SKX (0x103A903C)                                                     */
/* Register default value:              0x00                                  */
#define INTL_M2UPCIE_PMON_REG 0x0C01103C
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * PCI Interrupt Line Register
 */
typedef union {
  struct {
    UINT8 interrupt_line : 8;
    /* interrupt_line - Bits[7:0], RO, default = 8'b0 
       N/A for these devices
     */
  } Bits;
  UINT8 Data;
} INTL_M2UPCIE_PMON_STRUCT;


/* INTPIN_M2UPCIE_PMON_REG supported on:                                      */
/*       SKX (0x103A903D)                                                     */
/* Register default value:              0x00                                  */
#define INTPIN_M2UPCIE_PMON_REG 0x0C01103D
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * PCI Interrupt Pin Register
 */
typedef union {
  struct {
    UINT8 interrupt_pin : 8;
    /* interrupt_pin - Bits[7:0], RO, default = 8'b0 
       N/A since these devices do not generate any interrupt on their own
     */
  } Bits;
  UINT8 Data;
} INTPIN_M2UPCIE_PMON_STRUCT;


/* MINGNT_M2UPCIE_PMON_REG supported on:                                      */
/*       SKX (0x103A903E)                                                     */
/* Register default value:              0x00                                  */
#define MINGNT_M2UPCIE_PMON_REG 0x0C01103E
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * PCI Min Grant Register
 */
typedef union {
  struct {
    UINT8 mgv : 8;
    /* mgv - Bits[7:0], RO, default = 8'b0 
       The device does not burst as a PCI compliant master.
     */
  } Bits;
  UINT8 Data;
} MINGNT_M2UPCIE_PMON_STRUCT;


/* MAXLAT_M2UPCIE_PMON_REG supported on:                                      */
/*       SKX (0x103A903F)                                                     */
/* Register default value:              0x00                                  */
#define MAXLAT_M2UPCIE_PMON_REG 0x0C01103F
/* Struct format extracted from XML file SKX\3.21.1.CFG.xml.
 * PCI Max Latency Register
 */
typedef union {
  struct {
    UINT8 mlv : 8;
    /* mlv - Bits[7:0], RO, default = 8'b00000000 
       The device has no specific requirements for how often it needs to access the PCI 
       bus. 
     */
  } Bits;
  UINT8 Data;
} MAXLAT_M2UPCIE_PMON_STRUCT;


#endif /* M2UPCIE_PMON_h */
