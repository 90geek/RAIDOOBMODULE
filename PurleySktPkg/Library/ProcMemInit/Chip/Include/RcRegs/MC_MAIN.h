//
// This file contains 'Framework Code' and is licensed as such
// under the terms of your license agreement with Intel or your
// vendor.  This file may not be modified, except as allowed by
// additional terms of your license agreement.
//
// **************************************************************************
// *                                                                        *
// *      Intel Restricted Secret                                           *
// *                                                                        *
// *      Reference Code                                                    *
// *                                                                        *
// *      Copyright (c) 2007-2016, Intel Corporation.                       *
// *                                                                        *
// *      This software and associated documentation (if any) is furnished  *
// *      under a license and may only be used or copied in accordance      *
// *      with the terms of the license. Except as permitted by such        *
// *      license, no part of this software or documentation may be         *
// *      reproduced, stored in a retrieval system, or transmitted in any   *
// *      form or by any means without the express written consent of       *
// *      Intel Corporation.                                                *
// *                                                                        *
// *      This program has been developed by Intel Corporation.             *
// *      Licensee has Intel's permission to incorporate this source code   *
// *      into their product, royalty free.  This source code may NOT be    *
// *      redistributed to anyone without Intel's written permission.       *
// *                                                                        *
// *      Intel specifically disclaims all warranties, express or           *
// *      implied, and all liability, including consequential and other     *
// *      indirect damages, for the use of this code, including liability   *
// *      for infringement of any proprietary rights, and including the     *
// *      warranties of merchantability and fitness for a particular        *
// *      purpose.  Intel does not assume any responsibility for any        *
// *      errors which may appear in this code nor any responsibility to    *
// *      update it.                                                        *
// *                                                                        *
// **************************************************************************
// **************************************************************************
// *                                                                        *
// *  PURPOSE:                                                              *
// *                                                                        *
// *      This file contains Silicon register definitions.                  *
// *                                                                        *
// **************************************************************************
//
/* Date Stamp: 9/13/2016 */

#ifndef MC_MAIN_h
#define MC_MAIN_h

#include "DataTypes.h"

/* Device and Function specifications:                                        */
/* For all target CPUs:                                                       */
/* MC_MAIN_DEV 10                                                             */
/* MC_MAIN_FUN 0                                                              */

/* VID_MC_MAIN_REG supported on:                                              */
/*       SKX_A0 (0x20250000)                                                  */
/*       SKX (0x20250000)                                                     */
/* Register default value:              0x8086                                */
#define VID_MC_MAIN_REG 0x07002000
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * PCI Vendor ID Register
 */
typedef union {
  struct {
    UINT16 vendor_identification_number : 16;
    /* vendor_identification_number - Bits[15:0], RO, default = 16'h8086 
       The value is assigned by PCI-SIG to Intel.
     */
  } Bits;
  UINT16 Data;
} VID_MC_MAIN_STRUCT;


/* DID_MC_MAIN_REG supported on:                                              */
/*       SKX_A0 (0x20250002)                                                  */
/*       SKX (0x20250002)                                                     */
/* Register default value:              0x2040                                */
#define DID_MC_MAIN_REG 0x07002002
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * PCI Device Identification Number
 */
typedef union {
  struct {
    UINT16 device_identification_number : 16;
    /* device_identification_number - Bits[15:0], RO, default = 16'h2040 
        
       Start (h)	End (h)	Device
       0x203F		0x203F	
       0x2040		0x204B	MC
       0x204C		0x204F	M3KTI
       0x2054		0x2054	CHASADALL
       0x2055		0x2055	CHAUTILALL
       0x2056		0x2056	CHAUTILALL1
       0x2057		0x2057	CHAPMAALL
       0x2058		0x205B	KTI
       0x2066		0x2067	M2MEM
       0x2068		0x206F	MC DDRIO
       0x2078		0x207F	VCU
       0x2080		0x2087	PCU
       0x2088		0x2088	
       0x2089		0x2089	
       0x208A		0x208A	
       0x208B		0x208B	
       0x208C		0x208C	
       0x208D		0x208D	CHAUTIL
       0x208E		0x208E	CHASAD
       0x208F		0x208F	CMSCHA
       0x2090		0x209F	RSVD FOR PCU FUNCTION 3
       	
     */
  } Bits;
  UINT16 Data;
} DID_MC_MAIN_STRUCT;


/* PCICMD_MC_MAIN_REG supported on:                                           */
/*       SKX_A0 (0x20250004)                                                  */
/*       SKX (0x20250004)                                                     */
/* Register default value:              0x0000                                */
#define PCICMD_MC_MAIN_REG 0x07002004
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * PCI Command Register
 */
typedef union {
  struct {
    UINT16 io_space_enable : 1;
    /* io_space_enable - Bits[0:0], RO, default = 1'b0 
       Hardwired to 0 since these devices don't decode any IO BARs
     */
    UINT16 memory_space_enable : 1;
    /* memory_space_enable - Bits[1:1], RO, default = 1'b0 
       Hardwired to 0 since these devices don't decode any memory BARs
     */
    UINT16 bus_master_enable : 1;
    /* bus_master_enable - Bits[2:2], RO, default = 1'b0 
       Hardwired to 0 since these devices don't generate any transactions
     */
    UINT16 special_cycle_enable : 1;
    /* special_cycle_enable - Bits[3:3], RO, default = 1'b0 
       Not applicable. Hardwired to 0.
     */
    UINT16 memory_write_and_invalidate_enable : 1;
    /* memory_write_and_invalidate_enable - Bits[4:4], RO, default = 1'b0 
       Not applicable to internal devices. Hardwired to 0.
     */
    UINT16 vga_palette_snoop_enable : 1;
    /* vga_palette_snoop_enable - Bits[5:5], RO, default = 1'b0 
       Not applicable to internal devices. Hardwired to 0.
     */
    UINT16 parity_error_response : 1;
    /* parity_error_response - Bits[6:6], RO, default = 1'b0 
       This bit has no impact on error reporting from these devices
     */
    UINT16 idsel_stepping_wait_cycle_control : 1;
    /* idsel_stepping_wait_cycle_control - Bits[7:7], RO, default = 1'b0 
       Not applicable to internal devices. Hardwired to 0.
     */
    UINT16 serr_enable : 1;
    /* serr_enable - Bits[8:8], RO, default = 1'b0 
       This bit has no impact on error reporting from these devices
     */
    UINT16 fast_back_to_back_enable : 1;
    /* fast_back_to_back_enable - Bits[9:9], RO, default = 1'b0 
       Not applicable to PCI Express and is hardwired to 0
     */
    UINT16 intx_disable : 1;
    /* intx_disable - Bits[10:10], RO, default = 1'b0 
       N/A for these devices
     */
    UINT16 rsvd : 5;
    /* rsvd - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PCICMD_MC_MAIN_STRUCT;


/* PCISTS_MC_MAIN_REG supported on:                                           */
/*       SKX_A0 (0x20250006)                                                  */
/*       SKX (0x20250006)                                                     */
/* Register default value:              0x0010                                */
#define PCISTS_MC_MAIN_REG 0x07002006
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * PCI Status Register
 */
typedef union {
  struct {
    UINT16 rsvd : 3;
    /* rsvd - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 intx_status : 1;
    /* intx_status - Bits[3:3], RO, default = 1'b0 
       Reflects the state of the INTA# signal at the input of the enable/disable 
       circuit.  This bit is set by HW to 1 when the INTA# is asserted.  This bit is 
       reset by HW to 0 after the interrupt is cleared (independent of the state of the 
       Interrupt Disable bit in the PCICMD register). 
       Hardwired to 0 on the processor
     */
    UINT16 capabilities_list : 1;
    /* capabilities_list - Bits[4:4], RO, default = 1'b1 
       This bit indicates the presence of a capabilities list structure. When set to 1, 
       indicates the register at 34h provides an offset into the function. 
     */
    UINT16 x66mhz_capable : 1;
    /* x66mhz_capable - Bits[5:5], RO, default = 1'b0 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 reserved : 1;
    /* reserved - Bits[6:6], RO, default = 1'b0 
       Reserved
     */
    UINT16 fast_back_to_back : 1;
    /* fast_back_to_back - Bits[7:7], RO, default = 1'b0 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 master_data_parity_error : 1;
    /* master_data_parity_error - Bits[8:8], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 devsel_timing : 2;
    /* devsel_timing - Bits[10:9], RO, default = 2'b00 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 signaled_target_abort : 1;
    /* signaled_target_abort - Bits[11:11], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 received_target_abort : 1;
    /* received_target_abort - Bits[12:12], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 received_master_abort : 1;
    /* received_master_abort - Bits[13:13], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 signaled_system_error : 1;
    /* signaled_system_error - Bits[14:14], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 detected_parity_error : 1;
    /* detected_parity_error - Bits[15:15], RO, default = 1'b0 
       This bit is set when the device receives a packet on the primary side with an 
       uncorrectable data error (including a packet with poison bit set) or an 
       uncorrectable address/control parity error. The setting of this bit is 
       regardless of the Parity Error Response bit (PERRE) in the PCICMD register. 
     */
  } Bits;
  UINT16 Data;
} PCISTS_MC_MAIN_STRUCT;


/* RID_MC_MAIN_REG supported on:                                              */
/*       SKX_A0 (0x10250008)                                                  */
/*       SKX (0x10250008)                                                     */
/* Register default value:              0x00                                  */
#define RID_MC_MAIN_REG 0x07001008
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * "PCIe header Revision ID register"
 */
typedef union {
  struct {
    UINT8 revision_id : 8;
    /* revision_id - Bits[7:0], ROS_V, default = 8'b00000000 
       Reflects the Uncore Revision ID after reset.
       Reflects the Compatibility Revision ID after BIOS writes 0x69 to any RID 
       register in the processor uncore. 
               
     */
  } Bits;
  UINT8 Data;
} RID_MC_MAIN_STRUCT;


/* CCR_N0_MC_MAIN_REG supported on:                                           */
/*       SKX_A0 (0x10250009)                                                  */
/*       SKX (0x10250009)                                                     */
/* Register default value:              0x00                                  */
#define CCR_N0_MC_MAIN_REG 0x07001009
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * PCIe header ClassCode register
 */
typedef union {
  struct {
    UINT8 register_level_programming_interface : 8;
    /* register_level_programming_interface - Bits[7:0], RO_V, default = 8'b00000000  */
  } Bits;
  UINT8 Data;
} CCR_N0_MC_MAIN_STRUCT;


/* CCR_N1_MC_MAIN_REG supported on:                                           */
/*       SKX_A0 (0x2025000A)                                                  */
/*       SKX (0x2025000A)                                                     */
/* Register default value:              0x0880                                */
#define CCR_N1_MC_MAIN_REG 0x0700200A
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * PCIe header ClassCode register
 */
typedef union {
  struct {
    UINT16 sub_class : 8;
    /* sub_class - Bits[7:0], RO_V, default = 8'b10000000 
       The value changes dependent upon the dev/func accessed. A table of the values 
       can be found in the Class-code tab of the msgch spread-sheet  
          Most dev-func will return 8'h80 for this field except for the following 
       dev-func0,func1,... combinations. The following exceptions will return 8'h01. 
       Please refer to /src/uncore/ncu/f_ccr_reg.vh for the full lookingup table. 
                 bus-0, dev-8 func-1 
                 bus-3, dev-14 to 16, func-0
                 bus-3, dev-18, func-0, 1, 4, 5
               
     */
    UINT16 base_class : 8;
    /* base_class - Bits[15:8], RO_V, default = 8'b00001000 
       The value changes dependent upon the dev-func accessed. A table of the values 
       can be found in the Class-code tab of the msgch spread-sheet  
          Most bus-dev-func will return 8'h08 for this field except for the following 
       bus-dev-func0,func1,... combinations. The following exceptions will return 
       8'h11. Please refer to /src/uncore/ncu/f_ccr_reg.vhfor the full lookingup table. 
                 bus-0, dev-8 func-1 
                 bus-3, dev-14 to 16, func-0
                 bus-3, dev-18, func-0, 1, 4, 5
               
     */
  } Bits;
  UINT16 Data;
} CCR_N1_MC_MAIN_STRUCT;


/* CLSR_MC_MAIN_REG supported on:                                             */
/*       SKX_A0 (0x1025000C)                                                  */
/*       SKX (0x1025000C)                                                     */
/* Register default value:              0x00                                  */
#define CLSR_MC_MAIN_REG 0x0700100C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * PCI Cache Line Size Register
 */
typedef union {
  struct {
    UINT8 cacheline_size : 8;
    /* cacheline_size - Bits[7:0], RO, default = 8'b00000000 
       Size of Cacheline
     */
  } Bits;
  UINT8 Data;
} CLSR_MC_MAIN_STRUCT;


/* PLAT_MC_MAIN_REG supported on:                                             */
/*       SKX_A0 (0x1025000D)                                                  */
/*       SKX (0x1025000D)                                                     */
/* Register default value:              0x00                                  */
#define PLAT_MC_MAIN_REG 0x0700100D
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * PCI Latency Timer
 */
typedef union {
  struct {
    UINT8 primary_latency_timer : 8;
    /* primary_latency_timer - Bits[7:0], RO, default = 8'b00000000 
       Not applicable to PCI-Express. Hardwired to 00h.
     */
  } Bits;
  UINT8 Data;
} PLAT_MC_MAIN_STRUCT;


/* HDR_MC_MAIN_REG supported on:                                              */
/*       SKX_A0 (0x1025000E)                                                  */
/*       SKX (0x1025000E)                                                     */
/* Register default value:              0x80                                  */
#define HDR_MC_MAIN_REG 0x0700100E
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * PCI Header Type
 */
typedef union {
  struct {
    UINT8 configuration_layout : 7;
    /* configuration_layout - Bits[6:0], RO, default = 7'b0 
       Type 0 header
     */
    UINT8 multi_function_device : 1;
    /* multi_function_device - Bits[7:7], RO, default = 1'b1 
       This bit defaults to 1b since all these devices are multi-function
     */
  } Bits;
  UINT8 Data;
} HDR_MC_MAIN_STRUCT;


/* BIST_MC_MAIN_REG supported on:                                             */
/*       SKX_A0 (0x1025000F)                                                  */
/*       SKX (0x1025000F)                                                     */
/* Register default value:              0x00                                  */
#define BIST_MC_MAIN_REG 0x0700100F
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * PCI BIST Register
 */
typedef union {
  struct {
    UINT8 bist_tests : 8;
    /* bist_tests - Bits[7:0], RO, default = 8'b0 
       Not supported. Hardwired to 00h
     */
  } Bits;
  UINT8 Data;
} BIST_MC_MAIN_STRUCT;


/* SVID_MC_MAIN_REG supported on:                                             */
/*       SKX_A0 (0x2025002C)                                                  */
/*       SKX (0x2025002C)                                                     */
/* Register default value:              0x8086                                */
#define SVID_MC_MAIN_REG 0x0700202C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * generated by critter 19_2_0x02c
 */
typedef union {
  struct {
    UINT16 subsystem_vendor_identification_number : 16;
    /* subsystem_vendor_identification_number - Bits[15:0], RW_O, default = 16'b1000000010000110 
       The default value specifies Intel but can be set to any value once after reset.
     */
  } Bits;
  UINT16 Data;
} SVID_MC_MAIN_STRUCT;


/* SDID_MC_MAIN_REG supported on:                                             */
/*       SKX_A0 (0x2025002E)                                                  */
/*       SKX (0x2025002E)                                                     */
/* Register default value:              0x0000                                */
#define SDID_MC_MAIN_REG 0x0700202E
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * generated by critter 19_2_0x02e
 */
typedef union {
  struct {
    UINT16 subsystem_device_identification_number : 16;
    /* subsystem_device_identification_number - Bits[15:0], RW_O, default = 16'b0000000000000000 
       Assigned by the subsystem vendor to uniquely identify the subsystem
     */
  } Bits;
  UINT16 Data;
} SDID_MC_MAIN_STRUCT;


/* CAPPTR_MC_MAIN_REG supported on:                                           */
/*       SKX_A0 (0x10250034)                                                  */
/*       SKX (0x10250034)                                                     */
/* Register default value:              0x40                                  */
#define CAPPTR_MC_MAIN_REG 0x07001034
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * PCI Capability Pointer Register
 */
typedef union {
  struct {
    UINT8 capability_pointer : 8;
    /* capability_pointer - Bits[7:0], RO, default = 8'h40 
       Points to the first capability structure for the device which is the PCIe 
       capability. 
     */
  } Bits;
  UINT8 Data;
} CAPPTR_MC_MAIN_STRUCT;


/* INTL_MC_MAIN_REG supported on:                                             */
/*       SKX_A0 (0x1025003C)                                                  */
/*       SKX (0x1025003C)                                                     */
/* Register default value:              0x00                                  */
#define INTL_MC_MAIN_REG 0x0700103C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * PCI Interrupt Line Register
 */
typedef union {
  struct {
    UINT8 interrupt_line : 8;
    /* interrupt_line - Bits[7:0], RO, default = 8'b0 
       N/A for these devices
     */
  } Bits;
  UINT8 Data;
} INTL_MC_MAIN_STRUCT;


/* INTPIN_MC_MAIN_REG supported on:                                           */
/*       SKX_A0 (0x1025003D)                                                  */
/*       SKX (0x1025003D)                                                     */
/* Register default value:              0x00                                  */
#define INTPIN_MC_MAIN_REG 0x0700103D
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * PCI Interrupt Pin Register
 */
typedef union {
  struct {
    UINT8 interrupt_pin : 8;
    /* interrupt_pin - Bits[7:0], RO, default = 8'b0 
       N/A since these devices do not generate any interrupt on their own
     */
  } Bits;
  UINT8 Data;
} INTPIN_MC_MAIN_STRUCT;


/* MINGNT_MC_MAIN_REG supported on:                                           */
/*       SKX_A0 (0x1025003E)                                                  */
/*       SKX (0x1025003E)                                                     */
/* Register default value:              0x00                                  */
#define MINGNT_MC_MAIN_REG 0x0700103E
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * PCI Min Grant Register
 */
typedef union {
  struct {
    UINT8 mgv : 8;
    /* mgv - Bits[7:0], RO, default = 8'b0 
       The device does not burst as a PCI compliant master.
     */
  } Bits;
  UINT8 Data;
} MINGNT_MC_MAIN_STRUCT;


/* MAXLAT_MC_MAIN_REG supported on:                                           */
/*       SKX_A0 (0x1025003F)                                                  */
/*       SKX (0x1025003F)                                                     */
/* Register default value:              0x00                                  */
#define MAXLAT_MC_MAIN_REG 0x0700103F
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * PCI Max Latency Register
 */
typedef union {
  struct {
    UINT8 mlv : 8;
    /* mlv - Bits[7:0], RO, default = 8'b00000000 
       The device has no specific requirements for how often it needs to access the PCI 
       bus. 
     */
  } Bits;
  UINT8 Data;
} MAXLAT_MC_MAIN_STRUCT;


/* PXPCAP_MC_MAIN_REG supported on:                                           */
/*       SKX_A0 (0x40250040)                                                  */
/*       SKX (0x40250040)                                                     */
/* Register default value:              0x00910010                            */
#define PXPCAP_MC_MAIN_REG 0x07004040
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * generated by critter 19_2_0x040
 */
typedef union {
  struct {
    UINT32 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00010000 
       Provides the PCI Express capability ID assigned by PCI-SIG.
     */
    UINT32 next_ptr : 8;
    /* next_ptr - Bits[15:8], RO, default = 8'b00000000 
       Pointer to the next capability. Set to 0 to indicate there are no more 
       capability structures. 
     */
    UINT32 capability_version : 4;
    /* capability_version - Bits[19:16], RO, default = 4'b0001 
       PCI Express Capability is Compliant with Version 1.0 of the PCI Express Spec.
       Note:
       This capability structure is not compliant with Versions beyond 1.0, since they 
       require additional capability registers to be reserved. The only purpose for 
       this capability structure is to make enhanced configuration space available. 
       Minimizing the size of this structure is accomplished by reporting version 1.0 
       compliancy and reporting that this is an integrated root port device. As such, 
       only three Dwords of configuration space are required for this structure. 
     */
    UINT32 device_port_type : 4;
    /* device_port_type - Bits[23:20], RO, default = 4'b1001 
       Device type is Root Complex Integrated Endpoint
     */
    UINT32 slot_implemented : 1;
    /* slot_implemented - Bits[24:24], RO, default = 1'b0 
       N/A for integrated endpoints
     */
    UINT32 interrupt_message_number : 5;
    /* interrupt_message_number - Bits[29:25], RO, default = 5'b00000 
       N/A for this device
     */
    UINT32 rsvd : 2;
    /* rsvd - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PXPCAP_MC_MAIN_STRUCT;


/* DIMMMTR_0_MC_MAIN_REG supported on:                                        */
/*       SKX_A0 (0x40250080)                                                  */
/*       SKX (0x40250080)                                                     */
/* Register default value:              0x0000000C                            */
#define DIMMMTR_0_MC_MAIN_REG 0x07004080
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Per-DIMM configurability for DIMM 0.
 */
typedef union {
  struct {
    UINT32 ca_width : 2;
    /* ca_width - Bits[1:0], RWS_LB, default = 2'b00 
       00 - 10 bits
       01 - 11 bits
       10 - 12 bits
       11 - reserved
     */
    UINT32 ra_width : 3;
    /* ra_width - Bits[4:2], RWS_LB, default = 3'b011 
       000 - reserved 
       001 - 13 bits
       010 - 14 bits
       011 - 15 bits
       100 - 16 bits
       101 - 17 bits
       110 - 18 bits
       111: reserved
     */
    UINT32 ddr3_dnsty : 3;
    /* ddr3_dnsty - Bits[7:5], RWS_LB, default = 3'b000 
       000 - Reserved
       001 - 2Gb
       010 - 4Gb
       011 - 8Gb
       100 - 16Gb
       101 - 12Gb
       This field applies to ddr4.
       
     */
    UINT32 ddr3_width : 2;
    /* ddr3_width - Bits[9:8], RWS_LB, default = 2'b00 
       00 - x4
       01 - x8
       10 - x16
       11 - reserved
       This field applies to ddr4.
       
     */
    UINT32 rsvd_10 : 2;
    /* rsvd_10 - Bits[11:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_cnt : 2;
    /* rank_cnt - Bits[13:12], RWS_LB, default = 2'b00 
       
       00 - SR
       01 - DR
       10 - QR
       11 - reserved
       
     */
    UINT32 rsvd_14 : 1;
    /* rsvd_14 - Bits[14:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dimm_pop : 1;
    /* dimm_pop - Bits[15:15], RWS_LB, default = 1'b0 
       
                   DDR4 DIMM populated if set; otherwise, unpopulated.
                   Should be set to 0 when this slot is populated with a DDR-T DIMM.
               
     */
    UINT32 rank_disable : 4;
    /* rank_disable - Bits[19:16], RWS_LB, default = 4'b0000 
       RANK Disable Control to disable refresh and ZQCAL operation. This bit setting 
       must be set consistently with TERM_RNK_MSK, i.e. both corresponding bits cannot 
       be set at the same time. In the other word, a disabled rank must not be selected 
       for the terminaton rank. 
       RANK_DISABLE[3], i.e. bit 19: rank 3 disable. Note DIMMMTR_2.RANK_DISABLE[3] is 
       don't care since DIMM 2 must not be quad-rank 
       RANK_DISABLE[2], i.e. bit 18: rank 2 disable. Note DIMMMTR_2.RANK_DISABLE[2] is 
       don't care since DIMM 2 must not be quad-rank 
       RANK_DISABLE[1], i.e. bit 17: rank 1 disable
       RANK_DISABLE[0], i.e. bit 16: rank 0 disable
       when set, no refresh will be perform on this rank. ODT termination is not 
       affected by this bit. 
       Note that patrols are disabled by dimm*_pat_rank_disable of amap register now 
       and not affected by this bit field. 
     */
    UINT32 rsvd_20 : 1;
    /* rsvd_20 - Bits[20:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 hdrl : 1;
    /* hdrl - Bits[21:21], RWS_LB, default = 1'b0 
       When set, will enable High Density Reduced Load mode which will transmit Row 
       address bits 17:16 on chip select lines 
       7:6 and 3:2.
     */
    UINT32 hdrl_parity : 1;
    /* hdrl_parity - Bits[22:22], RWS_LB, default = 1'b0 
       When set, will enable parity calculation to include address bits 17:16 which are 
       sent on chip select lines 
       7:6 and 3:2.
     */
    UINT32 ddr4_3dsnumranks_cs : 2;
    /* ddr4_3dsnumranks_cs - Bits[24:23], RWS_LB, default = 2'b00 
       Number of sub ranks per chip select per dimm of DDR4 3DS and non3ds_lrdimm (this 
       is a dimm 
       specific field. There are restriction on rank_cnt field if this field is nonzero 
       fro 3ds devices. 
       Can not mix 2 chip_select parts and 1 chip_select part on the same channel)
       00- 3ds/non3ds_lrdimm ddr4 multiple ranks/chip select disabled
       01- 2 ranks per chip select
       10- 4 ranks per chip select
       11- 8 ranks per chip select
     */
    UINT32 rsvd_25 : 7;
    /* rsvd_25 - Bits[31:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} DIMMMTR_0_MC_MAIN_STRUCT;


/* DIMMMTR_1_MC_MAIN_REG supported on:                                        */
/*       SKX_A0 (0x40250084)                                                  */
/*       SKX (0x40250084)                                                     */
/* Register default value:              0x0000000C                            */
#define DIMMMTR_1_MC_MAIN_REG 0x07004084
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Option 1 indicates the option 1 mapping is automatically selected when 3rd DIMM 
 * slot (DS#2) is 
 * unpopulated (DIMMMTR2), including single, dual, and quad-rank DIMMs in any of 
 * the 2 slots. Default 
 * mapping is automatically selected any time a DIMM is loaded in the 3th slot 
 * (DS#2). 
 */
typedef union {
  struct {
    UINT32 ca_width : 2;
    /* ca_width - Bits[1:0], RWS_LB, default = 2'b00 
       00 - 10 bits
       01 - 11 bits
       10 - 12 bits
       11 - reserved
     */
    UINT32 ra_width : 3;
    /* ra_width - Bits[4:2], RWS_LB, default = 3'b011 
       000 - reserved 
       001 - 13 bits
       010 - 14 bits
       011 - 15 bits
       100 - 16 bits
       101 - 17 bits
       110 - 18 bits
       111: reserved
     */
    UINT32 ddr3_dnsty : 3;
    /* ddr3_dnsty - Bits[7:5], RWS_LB, default = 3'b000 
       000 - Reserved
       001 - 2Gb
       010 - 4Gb
       011 - 8Gb
       100 - 16Gb
       101 - 12Gb
       This field applies to ddr4.
       
     */
    UINT32 ddr3_width : 2;
    /* ddr3_width - Bits[9:8], RWS_LB, default = 2'b00 
       00 - x4
       01 - x8
       10 - x16
       11 - reserved
       This field applies to ddr4.
       
     */
    UINT32 rsvd_10 : 2;
    /* rsvd_10 - Bits[11:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_cnt : 2;
    /* rank_cnt - Bits[13:12], RWS_LB, default = 2'b00 
       
       00 - SR
       01 - DR
       10 - QR
       11 - reserved
       
     */
    UINT32 rsvd_14 : 1;
    /* rsvd_14 - Bits[14:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dimm_pop : 1;
    /* dimm_pop - Bits[15:15], RWS_LB, default = 1'b0 
       
                   DDR4 DIMM populated if set; otherwise, unpopulated.
                   Should be set to 0 when this slot is populated with a DDR-T DIMM.
               
     */
    UINT32 rank_disable : 4;
    /* rank_disable - Bits[19:16], RWS_LB, default = 4'b0000 
       RANK Disable Control to disable refresh and ZQCAL operation. This bit setting 
       must be set consistently with TERM_RNK_MSK, i.e. both corresponding bits cannot 
       be set at the same time. In the other word, a disabled rank must not be selected 
       for the terminaton rank. 
       RANK_DISABLE[3], i.e. bit 19: rank 3 disable. Note DIMMMTR_2.RANK_DISABLE[3] is 
       don't care since DIMM 2 must not be quad-rank 
       RANK_DISABLE[2], i.e. bit 18: rank 2 disable. Note DIMMMTR_2.RANK_DISABLE[2] is 
       don't care since DIMM 2 must not be quad-rank 
       RANK_DISABLE[1], i.e. bit 17: rank 1 disable
       RANK_DISABLE[0], i.e. bit 16: rank 0 disable
       when set, no refresh will be perform on this rank. ODT termination is not 
       affected by this bit. 
       Note that patrols are disabled by dimm*_pat_rank_disable of amap register now 
       and not affected by this bit field. 
     */
    UINT32 rsvd_20 : 3;
    /* rsvd_20 - Bits[22:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ddr4_3dsnumranks_cs : 2;
    /* ddr4_3dsnumranks_cs - Bits[24:23], RWS_LB, default = 2'b00  */
    UINT32 rsvd_25 : 7;
    /* rsvd_25 - Bits[31:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} DIMMMTR_1_MC_MAIN_STRUCT;


/* DIMMMTR_2_MC_MAIN_REG supported on:                                        */
/*       SKX_A0 (0x40250088)                                                  */
/*       SKX (0x40250088)                                                     */
/* Register default value:              0x0000000C                            */
#define DIMMMTR_2_MC_MAIN_REG 0x07004088
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Option 1 mapping is automatically selected when 3rd DIMM slot (DS#2) is
 * unpopulated (DIMMMTR2), including single, dual, and quad-rank DIMMs in any of 
 * the 2 slots. Default 
 * mapping is automatically selected any time a DIMM is loaded in the 3th slot 
 * (DS#2). 
 */
typedef union {
  struct {
    UINT32 ca_width : 2;
    /* ca_width - Bits[1:0], RWS_LB, default = 2'b00 
       00 - 10 bits
       01 - 11 bits
       10 - 12 bits
       11 - reserved
     */
    UINT32 ra_width : 3;
    /* ra_width - Bits[4:2], RWS_LB, default = 3'b011 
       000 - reserved 
       001 - 13 bits
       010 - 14 bits
       011 - 15 bits
       100 - 16 bits
       101 - 17 bits
       110 - 18 bits
       111: reserved
     */
    UINT32 ddr3_dnsty : 3;
    /* ddr3_dnsty - Bits[7:5], RWS_LB, default = 3'b000 
       000 - Reserved
       001 - 2Gb
       010 - 4Gb
       011 - 8Gb
       100 - 16Gb
       101 - 12Gb
       This field applies to ddr4.
       
     */
    UINT32 ddr3_width : 2;
    /* ddr3_width - Bits[9:8], RWS_LB, default = 2'b00 
       00 - x4
       01 - x8
       10 - x16
       11 - reserved
       This field applies to ddr4.
       
     */
    UINT32 rsvd_10 : 2;
    /* rsvd_10 - Bits[11:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_cnt : 2;
    /* rank_cnt - Bits[13:12], RWS_LB, default = 2'b00 
       
       00 - SR
       01 - DR
       10 - QR
       11 - reserved
       
     */
    UINT32 rsvd_14 : 1;
    /* rsvd_14 - Bits[14:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dimm_pop : 1;
    /* dimm_pop - Bits[15:15], RWS_LB, default = 1'b0 
       
                   DDR4 DIMM populated if set; otherwise, unpopulated.
                   Should be set to 0 when this slot is populated with a DDR-T DIMM.
               
     */
    UINT32 rank_disable : 4;
    /* rank_disable - Bits[19:16], RWS_LB, default = 4'b0000 
       RANK Disable Control to disable refresh and ZQCAL operation. This bit setting 
       must be set consistently with TERM_RNK_MSK, i.e. both corresponding bits cannot 
       be set at the same time. In the other word, a disabled rank must not be selected 
       for the terminaton rank. 
       RANK_DISABLE[3], i.e. bit 19: rank 3 disable. Note DIMMMTR_2.RANK_DISABLE[3] is 
       don't care since DIMM 2 must not be quad-rank 
       RANK_DISABLE[2], i.e. bit 18: rank 2 disable. Note DIMMMTR_2.RANK_DISABLE[2] is 
       don't care since DIMM 2 must not be quad-rank 
       RANK_DISABLE[1], i.e. bit 17: rank 1 disable
       RANK_DISABLE[0], i.e. bit 16: rank 0 disable
       when set, no refresh will be perform on this rank. ODT termination is not 
       affected by this bit. 
       Note that patrols are disabled by dimm*_pat_rank_disable of amap register now 
       and not affected by this bit field. 
     */
    UINT32 rsvd_20 : 3;
    /* rsvd_20 - Bits[22:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ddr4_3dsnumranks_cs : 2;
    /* ddr4_3dsnumranks_cs - Bits[24:23], RWS_LB, default = 2'b00  */
    UINT32 rsvd_25 : 7;
    /* rsvd_25 - Bits[31:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} DIMMMTR_2_MC_MAIN_STRUCT;


/* AMAP_MC_MAIN_REG supported on:                                             */
/*       SKX_A0 (0x4025008C)                                                  */
/*       SKX (0x4025008C)                                                     */
/* Register default value:              0x00000000                            */
#define AMAP_MC_MAIN_REG 0x0700408C
/* Struct format extracted from XML file SKX_A0\2.10.0.CFG.xml.
 * address map variations.
 */
typedef union {
  struct {
    UINT32 fine_grain_bank_interleaving : 1;
    /* fine_grain_bank_interleaving - Bits[0:0], RW_LB, default = 1'b0 
       Enable DDR4 fine grain bank interleaving. 
     */
    UINT32 force_lat : 1;
    /* force_lat - Bits[1:1], RW_LB, default = 1'b0 
       When setting to 1, force additional 1 cycle latency in decoding logic (same 
       latency as 3 channel mode); expected to set to 1 when channel mirroring is 
       enabled. 
     */
    UINT32 rsvd_2 : 13;
    /* rsvd_2 - Bits[14:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dimm0_pat_rank_disable : 4;
    /* dimm0_pat_rank_disable - Bits[18:15], RW_LB, default = 4'b0000 
       This field is similar to dimmmtr_*.rank_disable; but it affects only patrol 
       operations. 
       Each bit controls 1 Chip_select's patrol in a given dimm. If 1, patrol engine 
       will skip that 
       ChipSelect; other wise it will patrol it if dimm is populted and all other 
       patrol conditions are 
       true. This is intended to be used after rank_sparing to skip patrol of the 
       spared rank. 
     */
    UINT32 dimm1_pat_rank_disable : 4;
    /* dimm1_pat_rank_disable - Bits[22:19], RW_LB, default = 4'b0000 
       This field is similar to dimmmtr_*.rank_disable; but it affects only patrol 
       operations. 
       Each bit controls 1 Chip_select's patrol in a given dimm. If 1, patrol engine 
       will skip that 
       ChipSelect; other wise it will patrol it if dimm is populted and all other 
       patrol conditions are 
       true. This is intended to be used after rank_sparing to skip patrol of the 
       spared rank. 
     */
    UINT32 dimm2_pat_rank_disable : 4;
    /* dimm2_pat_rank_disable - Bits[26:23], RW_LB, default = 4'b0000 
       This field is similar to dimmmtr_*.rank_disable; but it affects only patrol 
       operations. 
       Each bit controls 1 Chip_select's patrol in a given dimm. If 1, patrol engine 
       will skip that 
       ChipSelect; other wise it will patrol it if dimm is populted and all other 
       patrol conditions are 
       true. This is intended to be used after rank_sparing to skip patrol of the 
       spared rank. 
     */
    UINT32 rsvd_27 : 5;
    /* rsvd_27 - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} AMAP_MC_MAIN_A0_STRUCT;

/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * address map variations.
 */
typedef union {
  struct {
    UINT32 fine_grain_bank_interleaving : 1;
    /* fine_grain_bank_interleaving - Bits[0:0], RW_LB, default = 1'b0 
       Enable DDR4 fine grain bank interleaving. 
     */
    UINT32 force_lat : 1;
    /* force_lat - Bits[1:1], RW_LB, default = 1'b0 
       When setting to 1, force additional 1 cycle latency in decoding logic (same 
       latency as 3 channel mode); expected to set to 1 when channel mirroring is 
       enabled. 
     */
    UINT32 mirr_adddc_en : 1;
    /* mirr_adddc_en - Bits[2:2], RW_LB, default = 1'b0 
       Enabling special spare copy mode for ADDDC and mirroring enable. In this mode, 
       system addresses will be gone through 3 times, with first pass for non-mirror 
       addresses, second pass for mirror primary addresses, and third pass for mirror 
       secondary addresses. This bit should be set to 1 in the channel where spare copy 
       is done. This function will only work if sparing_control.mirr_adddc_en is set to 
       1. 
     */
    UINT32 rsvd_3 : 12;
    /* rsvd_3 - Bits[14:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dimm0_pat_rank_disable : 4;
    /* dimm0_pat_rank_disable - Bits[18:15], RW_LB, default = 4'b0000 
       This field is similar to dimmmtr_*.rank_disable; but it affects only patrol 
       operations. 
       Each bit controls 1 Chip_select's patrol in a given dimm. If 1, patrol engine 
       will skip that 
       ChipSelect; other wise it will patrol it if dimm is populted and all other 
       patrol conditions are 
       true. This is intended to be used after rank_sparing to skip patrol of the 
       spared rank. 
     */
    UINT32 dimm1_pat_rank_disable : 4;
    /* dimm1_pat_rank_disable - Bits[22:19], RW_LB, default = 4'b0000 
       This field is similar to dimmmtr_*.rank_disable; but it affects only patrol 
       operations. 
       Each bit controls 1 Chip_select's patrol in a given dimm. If 1, patrol engine 
       will skip that 
       ChipSelect; other wise it will patrol it if dimm is populted and all other 
       patrol conditions are 
       true. This is intended to be used after rank_sparing to skip patrol of the 
       spared rank. 
     */
    UINT32 dimm2_pat_rank_disable : 4;
    /* dimm2_pat_rank_disable - Bits[26:23], RW_LB, default = 4'b0000 
       This field is similar to dimmmtr_*.rank_disable; but it affects only patrol 
       operations. 
       Each bit controls 1 Chip_select's patrol in a given dimm. If 1, patrol engine 
       will skip that 
       ChipSelect; other wise it will patrol it if dimm is populted and all other 
       patrol conditions are 
       true. This is intended to be used after rank_sparing to skip patrol of the 
       spared rank. 
     */
    UINT32 rsvd_27 : 5;
    /* rsvd_27 - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} AMAP_MC_MAIN_STRUCT;



/* TADCHNILVOFFSET_0_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250090)                                                  */
/*       SKX (0x40250090)                                                     */
/* Register default value:              0x00000000                            */
#define TADCHNILVOFFSET_0_MC_MAIN_REG 0x07004090
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           TAD Interleaves and Offsets
 *           This register should be programmned while training_mode=1 or else the 
 * register write will be missed.   
 *           Will be available 0x4F DCLK cycles after we enter normal mode.
 *       
 */
typedef union {
  struct {
    UINT32 skt_ways : 2;
    /* skt_ways - Bits[1:0], RW_LB, default = 2'b00 
        socket interleave wayness
                               00 = 1 way,
                               01 = 2 way,
                               10 = 4 way,
                               11 = 8 way.
                 
     */
    UINT32 chn_ways : 2;
    /* chn_ways - Bits[3:2], RW_LB, default = 2'b00 
        Channel interleave wayness
                               00 = 1 way
                               01 = 2 way
                               10 = 3 way
                 
     */
    UINT32 tad_offset : 20;
    /* tad_offset - Bits[23:4], RW_LB, default = 20'b00000000000000000000 
       channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i 
       offset, 64MB granularity. When negative offset is programmed (2's complement), 
       this field only support +/-32T and the upper bit is used to indicate the 
       polarity of the offset. 
     */
    UINT32 chn_idx_offset : 2;
    /* chn_idx_offset - Bits[25:24], RW_LB, default = 2'b00 
       This field should be removed for SKX.  
     */
    UINT32 imc_wayness_x3 : 1;
    /* imc_wayness_x3 - Bits[26:26], RW_LB, default = 1'b0 
       This field should be removed for SKX.  
     */
    UINT32 skt_granularity : 2;
    /* skt_granularity - Bits[28:27], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the skt_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11   1GB (based off PA[30] and up) {used for PMem only, though 
       the standard PMem mode will be 4KB) 
                 
     */
    UINT32 ch_granularity : 2;
    /* ch_granularity - Bits[30:29], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the ch_way interleave
                     b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM 
       only) 
                     b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, 
       DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
                     b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT 
       PMem) 
                     b'11   reserved
                     Note:  using the same ch_granularity encoding for both DDRT and 
       DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
                 
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TADCHNILVOFFSET_0_MC_MAIN_STRUCT;


/* TADCHNILVOFFSET_1_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250094)                                                  */
/*       SKX (0x40250094)                                                     */
/* Register default value:              0x00000000                            */
#define TADCHNILVOFFSET_1_MC_MAIN_REG 0x07004094
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           TAD Interleaves and Offsets
 *           This register should be programmned while training_mode=1 or else the 
 * register write will be missed.   
 *           Will be available 0x4F DCLK cycles after we enter normal mode.
 *       
 */
typedef union {
  struct {
    UINT32 skt_ways : 2;
    /* skt_ways - Bits[1:0], RW_LB, default = 2'b00 
        socket interleave wayness
                               00 = 1 way,
                               01 = 2 way,
                               10 = 4 way,
                               11 = 8 way.
                 
     */
    UINT32 chn_ways : 2;
    /* chn_ways - Bits[3:2], RW_LB, default = 2'b00 
        Channel interleave wayness
                               00 = 1 way
                               01 = 2 way
                               10 = 3 way
                 
     */
    UINT32 tad_offset : 20;
    /* tad_offset - Bits[23:4], RW_LB, default = 20'b00000000000000000000 
       channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i 
       offset, 64MB granularity. When negative offset is programmed (2's complement), 
       this field only support +/-32T and the upper bit is used to indicate the 
       polarity of the offset. 
     */
    UINT32 rsvd_24 : 2;
    UINT32 imc_wayness_x3 : 1;
    /* imc_wayness_x3 - Bits[26:26], RW_LB, default = 1'b0 
       This field should be removed for SKX.  
     */
    UINT32 skt_granularity : 2;
    /* skt_granularity - Bits[28:27], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the skt_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11   1GB (based off PA[30] and up) {used for PMem only, though 
       the standard PMem mode will be 4KB) 
                 
     */
    UINT32 ch_granularity : 2;
    /* ch_granularity - Bits[30:29], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the ch_way interleave
                     b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM 
       only) 
                     b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, 
       DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
                     b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT 
       PMem) 
                     b'11   reserved
                     Note:  using the same ch_granularity encoding for both DDRT and 
       DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
                 
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TADCHNILVOFFSET_1_MC_MAIN_STRUCT;


/* TADCHNILVOFFSET_2_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250098)                                                  */
/*       SKX (0x40250098)                                                     */
/* Register default value:              0x00000000                            */
#define TADCHNILVOFFSET_2_MC_MAIN_REG 0x07004098
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           TAD Interleaves and Offsets
 *           This register should be programmned while training_mode=1 or else the 
 * register write will be missed.   
 *           Will be available 0x4F DCLK cycles after we enter normal mode.
 *       
 */
typedef union {
  struct {
    UINT32 skt_ways : 2;
    /* skt_ways - Bits[1:0], RW_LB, default = 2'b00 
        socket interleave wayness
                               00 = 1 way,
                               01 = 2 way,
                               10 = 4 way,
                               11 = 8 way.
                 
     */
    UINT32 chn_ways : 2;
    /* chn_ways - Bits[3:2], RW_LB, default = 2'b00 
        Channel interleave wayness
                               00 = 1 way
                               01 = 2 way
                               10 = 3 way
                 
     */
    UINT32 tad_offset : 20;
    /* tad_offset - Bits[23:4], RW_LB, default = 20'b00000000000000000000 
       channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i 
       offset, 64MB granularity. When negative offset is programmed (2's complement), 
       this field only support +/-32T and the upper bit is used to indicate the 
       polarity of the offset. 
     */
    UINT32 rsvd_24 : 2;
    UINT32 imc_wayness_x3 : 1;
    /* imc_wayness_x3 - Bits[26:26], RW_LB, default = 1'b0 
       This field should be removed for SKX.  
     */
    UINT32 skt_granularity : 2;
    /* skt_granularity - Bits[28:27], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the skt_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11   1GB (based off PA[30] and up) {used for PMem only, though 
       the standard PMem mode will be 4KB) 
                 
     */
    UINT32 ch_granularity : 2;
    /* ch_granularity - Bits[30:29], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the ch_way interleave
                     b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM 
       only) 
                     b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, 
       DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
                     b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT 
       PMem) 
                     b'11   reserved
                     Note:  using the same ch_granularity encoding for both DDRT and 
       DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
                 
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TADCHNILVOFFSET_2_MC_MAIN_STRUCT;


/* TADCHNILVOFFSET_3_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x4025009C)                                                  */
/*       SKX (0x4025009C)                                                     */
/* Register default value:              0x00000000                            */
#define TADCHNILVOFFSET_3_MC_MAIN_REG 0x0700409C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           TAD Interleaves and Offsets
 *           This register should be programmned while training_mode=1 or else the 
 * register write will be missed.   
 *           Will be available 0x4F DCLK cycles after we enter normal mode.
 *       
 */
typedef union {
  struct {
    UINT32 skt_ways : 2;
    /* skt_ways - Bits[1:0], RW_LB, default = 2'b00 
        socket interleave wayness
                               00 = 1 way,
                               01 = 2 way,
                               10 = 4 way,
                               11 = 8 way.
                 
     */
    UINT32 chn_ways : 2;
    /* chn_ways - Bits[3:2], RW_LB, default = 2'b00 
        Channel interleave wayness
                               00 = 1 way
                               01 = 2 way
                               10 = 3 way
                 
     */
    UINT32 tad_offset : 20;
    /* tad_offset - Bits[23:4], RW_LB, default = 20'b00000000000000000000 
       channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i 
       offset, 64MB granularity. When negative offset is programmed (2's complement), 
       this field only support +/-32T and the upper bit is used to indicate the 
       polarity of the offset. 
     */
    UINT32 rsvd_24 : 2;
    UINT32 imc_wayness_x3 : 1;
    /* imc_wayness_x3 - Bits[26:26], RW_LB, default = 1'b0 
       This field should be removed for SKX.  
     */
    UINT32 skt_granularity : 2;
    /* skt_granularity - Bits[28:27], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the skt_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11   1GB (based off PA[30] and up) {used for PMem only, though 
       the standard PMem mode will be 4KB) 
                 
     */
    UINT32 ch_granularity : 2;
    /* ch_granularity - Bits[30:29], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the ch_way interleave
                     b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM 
       only) 
                     b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, 
       DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
                     b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT 
       PMem) 
                     b'11   reserved
                     Note:  using the same ch_granularity encoding for both DDRT and 
       DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
                 
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TADCHNILVOFFSET_3_MC_MAIN_STRUCT;


/* TADCHNILVOFFSET_4_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x402500A0)                                                  */
/*       SKX (0x402500A0)                                                     */
/* Register default value:              0x00000000                            */
#define TADCHNILVOFFSET_4_MC_MAIN_REG 0x070040A0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           TAD Interleaves and Offsets
 *           This register should be programmned while training_mode=1 or else the 
 * register write will be missed.   
 *           Will be available 0x4F DCLK cycles after we enter normal mode.
 *       
 */
typedef union {
  struct {
    UINT32 skt_ways : 2;
    /* skt_ways - Bits[1:0], RW_LB, default = 2'b00 
        socket interleave wayness
                               00 = 1 way,
                               01 = 2 way,
                               10 = 4 way,
                               11 = 8 way.
                 
     */
    UINT32 chn_ways : 2;
    /* chn_ways - Bits[3:2], RW_LB, default = 2'b00 
        Channel interleave wayness
                               00 = 1 way
                               01 = 2 way
                               10 = 3 way
                 
     */
    UINT32 tad_offset : 20;
    /* tad_offset - Bits[23:4], RW_LB, default = 20'b00000000000000000000 
       channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i 
       offset, 64MB granularity. When negative offset is programmed (2's complement), 
       this field only support +/-32T and the upper bit is used to indicate the 
       polarity of the offset. 
     */
    UINT32 rsvd_24 : 2;
    UINT32 imc_wayness_x3 : 1;
    /* imc_wayness_x3 - Bits[26:26], RW_LB, default = 1'b0 
       This field should be removed for SKX.  
     */
    UINT32 skt_granularity : 2;
    /* skt_granularity - Bits[28:27], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the skt_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11   1GB (based off PA[30] and up) {used for PMem only, though 
       the standard PMem mode will be 4KB) 
                 
     */
    UINT32 ch_granularity : 2;
    /* ch_granularity - Bits[30:29], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the ch_way interleave
                     b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM 
       only) 
                     b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, 
       DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
                     b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT 
       PMem) 
                     b'11   reserved
                     Note:  using the same ch_granularity encoding for both DDRT and 
       DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
                 
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TADCHNILVOFFSET_4_MC_MAIN_STRUCT;


/* TADCHNILVOFFSET_5_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x402500A4)                                                  */
/*       SKX (0x402500A4)                                                     */
/* Register default value:              0x00000000                            */
#define TADCHNILVOFFSET_5_MC_MAIN_REG 0x070040A4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           TAD Interleaves and Offsets
 *           This register should be programmned while training_mode=1 or else the 
 * register write will be missed.   
 *           Will be available 0x4F DCLK cycles after we enter normal mode.
 *       
 */
typedef union {
  struct {
    UINT32 skt_ways : 2;
    /* skt_ways - Bits[1:0], RW_LB, default = 2'b00 
        socket interleave wayness
                               00 = 1 way,
                               01 = 2 way,
                               10 = 4 way,
                               11 = 8 way.
                 
     */
    UINT32 chn_ways : 2;
    /* chn_ways - Bits[3:2], RW_LB, default = 2'b00 
        Channel interleave wayness
                               00 = 1 way
                               01 = 2 way
                               10 = 3 way
                 
     */
    UINT32 tad_offset : 20;
    /* tad_offset - Bits[23:4], RW_LB, default = 20'b00000000000000000000 
       channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i 
       offset, 64MB granularity. When negative offset is programmed (2's complement), 
       this field only support +/-32T and the upper bit is used to indicate the 
       polarity of the offset. 
     */
    UINT32 rsvd_24 : 2;
    UINT32 imc_wayness_x3 : 1;
    /* imc_wayness_x3 - Bits[26:26], RW_LB, default = 1'b0 
       This field should be removed for SKX.  
     */
    UINT32 skt_granularity : 2;
    /* skt_granularity - Bits[28:27], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the skt_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11   1GB (based off PA[30] and up) {used for PMem only, though 
       the standard PMem mode will be 4KB) 
                 
     */
    UINT32 ch_granularity : 2;
    /* ch_granularity - Bits[30:29], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the ch_way interleave
                     b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM 
       only) 
                     b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, 
       DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
                     b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT 
       PMem) 
                     b'11   reserved
                     Note:  using the same ch_granularity encoding for both DDRT and 
       DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
                 
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TADCHNILVOFFSET_5_MC_MAIN_STRUCT;


/* TADCHNILVOFFSET_6_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x402500A8)                                                  */
/*       SKX (0x402500A8)                                                     */
/* Register default value:              0x00000000                            */
#define TADCHNILVOFFSET_6_MC_MAIN_REG 0x070040A8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           TAD Interleaves and Offsets
 *           This register should be programmned while training_mode=1 or else the 
 * register write will be missed.   
 *           Will be available 0x4F DCLK cycles after we enter normal mode.
 *       
 */
typedef union {
  struct {
    UINT32 skt_ways : 2;
    /* skt_ways - Bits[1:0], RW_LB, default = 2'b00 
        socket interleave wayness
                               00 = 1 way,
                               01 = 2 way,
                               10 = 4 way,
                               11 = 8 way.
                 
     */
    UINT32 chn_ways : 2;
    /* chn_ways - Bits[3:2], RW_LB, default = 2'b00 
        Channel interleave wayness
                               00 = 1 way
                               01 = 2 way
                               10 = 3 way
                 
     */
    UINT32 tad_offset : 20;
    /* tad_offset - Bits[23:4], RW_LB, default = 20'b00000000000000000000 
       channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i 
       offset, 64MB granularity. When negative offset is programmed (2's complement), 
       this field only support +/-32T and the upper bit is used to indicate the 
       polarity of the offset. 
     */
    UINT32 rsvd_24 : 2;
    UINT32 imc_wayness_x3 : 1;
    /* imc_wayness_x3 - Bits[26:26], RW_LB, default = 1'b0 
       This field should be removed for SKX.  
     */
    UINT32 skt_granularity : 2;
    /* skt_granularity - Bits[28:27], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the skt_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11   1GB (based off PA[30] and up) {used for PMem only, though 
       the standard PMem mode will be 4KB) 
                 
     */
    UINT32 ch_granularity : 2;
    /* ch_granularity - Bits[30:29], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the ch_way interleave
                     b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM 
       only) 
                     b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, 
       DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
                     b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT 
       PMem) 
                     b'11   reserved
                     Note:  using the same ch_granularity encoding for both DDRT and 
       DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
                 
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TADCHNILVOFFSET_6_MC_MAIN_STRUCT;


/* TADCHNILVOFFSET_7_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x402500AC)                                                  */
/*       SKX (0x402500AC)                                                     */
/* Register default value:              0x00000000                            */
#define TADCHNILVOFFSET_7_MC_MAIN_REG 0x070040AC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           TAD Interleaves and Offsets
 *           This register should be programmned while training_mode=1 or else the 
 * register write will be missed.   
 *           Will be available 0x4F DCLK cycles after we enter normal mode.
 *       
 */
typedef union {
  struct {
    UINT32 skt_ways : 2;
    /* skt_ways - Bits[1:0], RW_LB, default = 2'b00 
        socket interleave wayness
                               00 = 1 way,
                               01 = 2 way,
                               10 = 4 way,
                               11 = 8 way.
                 
     */
    UINT32 chn_ways : 2;
    /* chn_ways - Bits[3:2], RW_LB, default = 2'b00 
        Channel interleave wayness
                               00 = 1 way
                               01 = 2 way
                               10 = 3 way
                 
     */
    UINT32 tad_offset : 20;
    /* tad_offset - Bits[23:4], RW_LB, default = 20'b00000000000000000000 
       channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i 
       offset, 64MB granularity. When negative offset is programmed (2's complement), 
       this field only support +/-32T and the upper bit is used to indicate the 
       polarity of the offset. 
     */
    UINT32 rsvd_24 : 2;
    UINT32 imc_wayness_x3 : 1;
    /* imc_wayness_x3 - Bits[26:26], RW_LB, default = 1'b0 
       This field should be removed for SKX.  
     */
    UINT32 skt_granularity : 2;
    /* skt_granularity - Bits[28:27], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the skt_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11   1GB (based off PA[30] and up) {used for PMem only, though 
       the standard PMem mode will be 4KB) 
                 
     */
    UINT32 ch_granularity : 2;
    /* ch_granularity - Bits[30:29], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the ch_way interleave
                     b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM 
       only) 
                     b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, 
       DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
                     b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT 
       PMem) 
                     b'11   reserved
                     Note:  using the same ch_granularity encoding for both DDRT and 
       DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
                 
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TADCHNILVOFFSET_7_MC_MAIN_STRUCT;


/* MEM_SIZE_CONTROL_MC_MAIN_REG supported on:                                 */
/*       SKX_A0 (0x402500C0)                                                  */
/*       SKX (0x402500C0)                                                     */
/* Register default value:              0x00000000                            */
#define MEM_SIZE_CONTROL_MC_MAIN_REG 0x070040C0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Controls memory address generation for fast div-3
 */
typedef union {
  struct {
    UINT32 enable : 1;
    /* enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable address crop for fast div-3
     */
    UINT32 nm_chn_cap : 4;
    /* nm_chn_cap - Bits[4:1], RW_LB, default = 4'b0000 
       Per Channel Near Memory Capacity.
       4'h0 - 4GB
       4'h1 - 8GB
       4'h2 - 16GB
       4'h3 - 32GB
       4'h4 - 64GB
       4'h5 - 128GB
       4'h6 - 256GB
       4'h7 - 512GB
       4'b1xxx - Reserved
       This field can be programmed on the per-channel basis.
       
     */
    UINT32 rsvd : 27;
    /* rsvd - Bits[31:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MEM_SIZE_CONTROL_MC_MAIN_STRUCT;


/* PXPENHCAP_MC_MAIN_REG supported on:                                        */
/*       SKX_A0 (0x40250100)                                                  */
/*       SKX (0x40250100)                                                     */
/* Register default value:              0x00000000                            */
#define PXPENHCAP_MC_MAIN_REG 0x07004100
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * This field points to the next Capability in extended configuration space.
 */
typedef union {
  struct {
    UINT32 capability_id : 16;
    /* capability_id - Bits[15:0], RO, default = 16'b0000000000000000 
       Indicates there are no capability structures in the enhanced configuration 
       space. 
     */
    UINT32 capability_version : 4;
    /* capability_version - Bits[19:16], RO, default = 4'b0000 
       Indicates there are no capability structures in the enhanced configuration 
       space. 
     */
    UINT32 next_capability_offset : 12;
    /* next_capability_offset - Bits[31:20], RO, default = 12'b000000000000  */
  } Bits;
  UINT32 Data;
} PXPENHCAP_MC_MAIN_STRUCT;


/* RIRWAYNESSLIMIT_0_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250108)                                                  */
/*       SKX (0x40250108)                                                     */
/* Register default value:              0x00000000                            */
#define RIRWAYNESSLIMIT_0_MC_MAIN_REG 0x07004108
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are 4 RIR ranges (represents how many rank interleave ranges supported to 
 * cover DIMM configurations). 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_limit : 11;
    /* rir_limit - Bits[11:1], RW_LB, default = 11'b00000000000 
       RIR[4:0].LIMIT[39:29] == highest address of the range in channel address space, 
       384GB in lock-step/192GB in independent channel, 512MB granularity.  
     */
    UINT32 rsvd_12 : 16;
    /* rsvd_12 - Bits[27:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_way : 2;
    /* rir_way - Bits[29:28], RW_LB, default = 2'b00 
       rank interleave wayness00 = 1 way,
                  01 = 2 way,
                  10 = 4 way,
                  11 = 8 way.
     */
    UINT32 rsvd_30 : 1;
    /* rsvd_30 - Bits[30:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_val : 1;
    /* rir_val - Bits[31:31], RW_LB, default = 1'b0 
       Range Valid when set; otherwise, invalid
     */
  } Bits;
  UINT32 Data;
} RIRWAYNESSLIMIT_0_MC_MAIN_STRUCT;


/* RIRWAYNESSLIMIT_1_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x4025010C)                                                  */
/*       SKX (0x4025010C)                                                     */
/* Register default value:              0x00000000                            */
#define RIRWAYNESSLIMIT_1_MC_MAIN_REG 0x0700410C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are 4 RIR ranges (represents how many rank interleave ranges supported to 
 * cover DIMM configurations). 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_limit : 11;
    /* rir_limit - Bits[11:1], RW_LB, default = 11'b00000000000 
       RIR[4:0].LIMIT[39:29] == highest address of the range in channel address space, 
       384GB in lock-step/192GB in independent channel, 512MB granularity.  
     */
    UINT32 rsvd_12 : 16;
    /* rsvd_12 - Bits[27:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_way : 2;
    /* rir_way - Bits[29:28], RW_LB, default = 2'b00 
       rank interleave wayness00 = 1 way,
                  01 = 2 way,
                  10 = 4 way,
                  11 = 8 way.
     */
    UINT32 rsvd_30 : 1;
    /* rsvd_30 - Bits[30:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_val : 1;
    /* rir_val - Bits[31:31], RW_LB, default = 1'b0 
       Range Valid when set; otherwise, invalid
     */
  } Bits;
  UINT32 Data;
} RIRWAYNESSLIMIT_1_MC_MAIN_STRUCT;


/* RIRWAYNESSLIMIT_2_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250110)                                                  */
/*       SKX (0x40250110)                                                     */
/* Register default value:              0x00000000                            */
#define RIRWAYNESSLIMIT_2_MC_MAIN_REG 0x07004110
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are 4 RIR ranges (represents how many rank interleave ranges supported to 
 * cover DIMM configurations). 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_limit : 11;
    /* rir_limit - Bits[11:1], RW_LB, default = 11'b00000000000 
       RIR[4:0].LIMIT[39:29] == highest address of the range in channel address space, 
       384GB in lock-step/192GB in independent channel, 512MB granularity.  
     */
    UINT32 rsvd_12 : 16;
    /* rsvd_12 - Bits[27:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_way : 2;
    /* rir_way - Bits[29:28], RW_LB, default = 2'b00 
       rank interleave wayness00 = 1 way,
                  01 = 2 way,
                  10 = 4 way,
                  11 = 8 way.
     */
    UINT32 rsvd_30 : 1;
    /* rsvd_30 - Bits[30:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_val : 1;
    /* rir_val - Bits[31:31], RW_LB, default = 1'b0 
       Range Valid when set; otherwise, invalid
     */
  } Bits;
  UINT32 Data;
} RIRWAYNESSLIMIT_2_MC_MAIN_STRUCT;


/* RIRWAYNESSLIMIT_3_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250114)                                                  */
/*       SKX (0x40250114)                                                     */
/* Register default value:              0x00000000                            */
#define RIRWAYNESSLIMIT_3_MC_MAIN_REG 0x07004114
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are 4 RIR ranges (represents how many rank interleave ranges supported to 
 * cover DIMM configurations). 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_limit : 11;
    /* rir_limit - Bits[11:1], RW_LB, default = 11'b00000000000 
       RIR[4:0].LIMIT[39:29] == highest address of the range in channel address space, 
       384GB in lock-step/192GB in independent channel, 512MB granularity.  
     */
    UINT32 rsvd_12 : 16;
    /* rsvd_12 - Bits[27:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_way : 2;
    /* rir_way - Bits[29:28], RW_LB, default = 2'b00 
       rank interleave wayness00 = 1 way,
                  01 = 2 way,
                  10 = 4 way,
                  11 = 8 way.
     */
    UINT32 rsvd_30 : 1;
    /* rsvd_30 - Bits[30:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_val : 1;
    /* rir_val - Bits[31:31], RW_LB, default = 1'b0 
       Range Valid when set; otherwise, invalid
     */
  } Bits;
  UINT32 Data;
} RIRWAYNESSLIMIT_3_MC_MAIN_STRUCT;


/* RIRILV0OFFSET_0_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250120)                                                  */
/*       SKX (0x40250120)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV0OFFSET_0_MC_MAIN_REG 0x07004120
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv0offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset0 : 14;
    /* rir_offset0 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET0[39:26] == rank interleave 0 offset, 64MB granularity 
     */
    UINT32 rir_rnk_tgt0 : 4;
    /* rir_rnk_tgt0 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 0 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV0OFFSET_0_MC_MAIN_STRUCT;


/* RIRILV0OFFSET_1_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250124)                                                  */
/*       SKX (0x40250124)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV0OFFSET_1_MC_MAIN_REG 0x07004124
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv0offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset0 : 14;
    /* rir_offset0 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET0[39:26] == rank interleave 0 offset, 64MB granularity 
     */
    UINT32 rir_rnk_tgt0 : 4;
    /* rir_rnk_tgt0 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 0 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV0OFFSET_1_MC_MAIN_STRUCT;


/* RIRILV0OFFSET_2_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250128)                                                  */
/*       SKX (0x40250128)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV0OFFSET_2_MC_MAIN_REG 0x07004128
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv0offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset0 : 14;
    /* rir_offset0 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET0[39:26] == rank interleave 0 offset, 64MB granularity 
     */
    UINT32 rir_rnk_tgt0 : 4;
    /* rir_rnk_tgt0 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 0 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV0OFFSET_2_MC_MAIN_STRUCT;


/* RIRILV0OFFSET_3_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x4025012C)                                                  */
/*       SKX (0x4025012C)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV0OFFSET_3_MC_MAIN_REG 0x0700412C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv0offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset0 : 14;
    /* rir_offset0 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET0[39:26] == rank interleave 0 offset, 64MB granularity 
     */
    UINT32 rir_rnk_tgt0 : 4;
    /* rir_rnk_tgt0 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 0 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV0OFFSET_3_MC_MAIN_STRUCT;


/* RIRILV1OFFSET_0_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250130)                                                  */
/*       SKX (0x40250130)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV1OFFSET_0_MC_MAIN_REG 0x07004130
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv1offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset1 : 14;
    /* rir_offset1 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET1[39:26] == rank interleave 1 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
               
     */
    UINT32 rir_rnk_tgt1 : 4;
    /* rir_rnk_tgt1 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 1 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV1OFFSET_0_MC_MAIN_STRUCT;


/* RIRILV1OFFSET_1_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250134)                                                  */
/*       SKX (0x40250134)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV1OFFSET_1_MC_MAIN_REG 0x07004134
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv1offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset1 : 14;
    /* rir_offset1 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET1[39:26] == rank interleave 1 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
               
     */
    UINT32 rir_rnk_tgt1 : 4;
    /* rir_rnk_tgt1 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 1 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV1OFFSET_1_MC_MAIN_STRUCT;


/* RIRILV1OFFSET_2_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250138)                                                  */
/*       SKX (0x40250138)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV1OFFSET_2_MC_MAIN_REG 0x07004138
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv1offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset1 : 14;
    /* rir_offset1 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET1[39:26] == rank interleave 1 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
               
     */
    UINT32 rir_rnk_tgt1 : 4;
    /* rir_rnk_tgt1 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 1 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV1OFFSET_2_MC_MAIN_STRUCT;


/* RIRILV1OFFSET_3_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x4025013C)                                                  */
/*       SKX (0x4025013C)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV1OFFSET_3_MC_MAIN_REG 0x0700413C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv1offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset1 : 14;
    /* rir_offset1 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET1[39:26] == rank interleave 1 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
               
     */
    UINT32 rir_rnk_tgt1 : 4;
    /* rir_rnk_tgt1 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 1 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV1OFFSET_3_MC_MAIN_STRUCT;


/* RIRILV2OFFSET_0_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250140)                                                  */
/*       SKX (0x40250140)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV2OFFSET_0_MC_MAIN_REG 0x07004140
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv2offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset2 : 14;
    /* rir_offset2 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET2[39:26] == rank interleave 2 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt2 : 4;
    /* rir_rnk_tgt2 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 2 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV2OFFSET_0_MC_MAIN_STRUCT;


/* RIRILV2OFFSET_1_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250144)                                                  */
/*       SKX (0x40250144)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV2OFFSET_1_MC_MAIN_REG 0x07004144
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv2offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset2 : 14;
    /* rir_offset2 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET2[39:26] == rank interleave 2 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt2 : 4;
    /* rir_rnk_tgt2 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 2 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV2OFFSET_1_MC_MAIN_STRUCT;


/* RIRILV2OFFSET_2_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250148)                                                  */
/*       SKX (0x40250148)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV2OFFSET_2_MC_MAIN_REG 0x07004148
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv2offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset2 : 14;
    /* rir_offset2 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET2[39:26] == rank interleave 2 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt2 : 4;
    /* rir_rnk_tgt2 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 2 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV2OFFSET_2_MC_MAIN_STRUCT;


/* RIRILV2OFFSET_3_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x4025014C)                                                  */
/*       SKX (0x4025014C)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV2OFFSET_3_MC_MAIN_REG 0x0700414C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv2offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset2 : 14;
    /* rir_offset2 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET2[39:26] == rank interleave 2 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt2 : 4;
    /* rir_rnk_tgt2 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 2 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV2OFFSET_3_MC_MAIN_STRUCT;


/* RIRILV3OFFSET_0_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250150)                                                  */
/*       SKX (0x40250150)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV3OFFSET_0_MC_MAIN_REG 0x07004150
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv3offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset3 : 14;
    /* rir_offset3 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET3[39:26] == rank interleave 3 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt3 : 4;
    /* rir_rnk_tgt3 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 3 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV3OFFSET_0_MC_MAIN_STRUCT;


/* RIRILV3OFFSET_1_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250154)                                                  */
/*       SKX (0x40250154)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV3OFFSET_1_MC_MAIN_REG 0x07004154
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv3offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset3 : 14;
    /* rir_offset3 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET3[39:26] == rank interleave 3 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt3 : 4;
    /* rir_rnk_tgt3 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 3 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV3OFFSET_1_MC_MAIN_STRUCT;


/* RIRILV3OFFSET_2_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250158)                                                  */
/*       SKX (0x40250158)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV3OFFSET_2_MC_MAIN_REG 0x07004158
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv3offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset3 : 14;
    /* rir_offset3 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET3[39:26] == rank interleave 3 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt3 : 4;
    /* rir_rnk_tgt3 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 3 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV3OFFSET_2_MC_MAIN_STRUCT;


/* RIRILV3OFFSET_3_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x4025015C)                                                  */
/*       SKX (0x4025015C)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV3OFFSET_3_MC_MAIN_REG 0x0700415C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv3offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset3 : 14;
    /* rir_offset3 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET3[39:26] == rank interleave 3 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt3 : 4;
    /* rir_rnk_tgt3 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 3 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV3OFFSET_3_MC_MAIN_STRUCT;


/* RIRILV4OFFSET_0_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250160)                                                  */
/*       SKX (0x40250160)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV4OFFSET_0_MC_MAIN_REG 0x07004160
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv4offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset4 : 14;
    /* rir_offset4 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET4[39:26] == rank interleave 4 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt4 : 4;
    /* rir_rnk_tgt4 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 4 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV4OFFSET_0_MC_MAIN_STRUCT;


/* RIRILV4OFFSET_1_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250164)                                                  */
/*       SKX (0x40250164)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV4OFFSET_1_MC_MAIN_REG 0x07004164
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv4offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset4 : 14;
    /* rir_offset4 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET4[39:26] == rank interleave 4 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt4 : 4;
    /* rir_rnk_tgt4 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 4 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV4OFFSET_1_MC_MAIN_STRUCT;


/* RIRILV4OFFSET_2_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250168)                                                  */
/*       SKX (0x40250168)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV4OFFSET_2_MC_MAIN_REG 0x07004168
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv4offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset4 : 14;
    /* rir_offset4 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET4[39:26] == rank interleave 4 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt4 : 4;
    /* rir_rnk_tgt4 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 4 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV4OFFSET_2_MC_MAIN_STRUCT;


/* RIRILV4OFFSET_3_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x4025016C)                                                  */
/*       SKX (0x4025016C)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV4OFFSET_3_MC_MAIN_REG 0x0700416C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv4offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset4 : 14;
    /* rir_offset4 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET4[39:26] == rank interleave 4 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt4 : 4;
    /* rir_rnk_tgt4 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 4 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV4OFFSET_3_MC_MAIN_STRUCT;


/* RIRILV5OFFSET_0_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250170)                                                  */
/*       SKX (0x40250170)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV5OFFSET_0_MC_MAIN_REG 0x07004170
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv5offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset5 : 14;
    /* rir_offset5 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET5[39:26] == rank interleave 5 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt5 : 4;
    /* rir_rnk_tgt5 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 5 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV5OFFSET_0_MC_MAIN_STRUCT;


/* RIRILV5OFFSET_1_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250174)                                                  */
/*       SKX (0x40250174)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV5OFFSET_1_MC_MAIN_REG 0x07004174
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv5offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset5 : 14;
    /* rir_offset5 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET5[39:26] == rank interleave 5 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt5 : 4;
    /* rir_rnk_tgt5 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 5 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV5OFFSET_1_MC_MAIN_STRUCT;


/* RIRILV5OFFSET_2_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250178)                                                  */
/*       SKX (0x40250178)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV5OFFSET_2_MC_MAIN_REG 0x07004178
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv5offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset5 : 14;
    /* rir_offset5 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET5[39:26] == rank interleave 5 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt5 : 4;
    /* rir_rnk_tgt5 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 5 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV5OFFSET_2_MC_MAIN_STRUCT;


/* RIRILV5OFFSET_3_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x4025017C)                                                  */
/*       SKX (0x4025017C)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV5OFFSET_3_MC_MAIN_REG 0x0700417C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv5offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset5 : 14;
    /* rir_offset5 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET5[39:26] == rank interleave 5 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt5 : 4;
    /* rir_rnk_tgt5 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 5 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV5OFFSET_3_MC_MAIN_STRUCT;


/* RIRILV6OFFSET_0_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250180)                                                  */
/*       SKX (0x40250180)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV6OFFSET_0_MC_MAIN_REG 0x07004180
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv6offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset6 : 14;
    /* rir_offset6 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET6[39:26] == rank interleave 6 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt6 : 4;
    /* rir_rnk_tgt6 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 6 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV6OFFSET_0_MC_MAIN_STRUCT;


/* RIRILV6OFFSET_1_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250184)                                                  */
/*       SKX (0x40250184)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV6OFFSET_1_MC_MAIN_REG 0x07004184
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv6offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset6 : 14;
    /* rir_offset6 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET6[39:26] == rank interleave 6 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt6 : 4;
    /* rir_rnk_tgt6 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 6 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV6OFFSET_1_MC_MAIN_STRUCT;


/* RIRILV6OFFSET_2_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250188)                                                  */
/*       SKX (0x40250188)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV6OFFSET_2_MC_MAIN_REG 0x07004188
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv6offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset6 : 14;
    /* rir_offset6 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET6[39:26] == rank interleave 6 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt6 : 4;
    /* rir_rnk_tgt6 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 6 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV6OFFSET_2_MC_MAIN_STRUCT;


/* RIRILV6OFFSET_3_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x4025018C)                                                  */
/*       SKX (0x4025018C)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV6OFFSET_3_MC_MAIN_REG 0x0700418C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv6offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset6 : 14;
    /* rir_offset6 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET6[39:26] == rank interleave 6 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt6 : 4;
    /* rir_rnk_tgt6 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 6 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV6OFFSET_3_MC_MAIN_STRUCT;


/* RIRILV7OFFSET_0_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250190)                                                  */
/*       SKX (0x40250190)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV7OFFSET_0_MC_MAIN_REG 0x07004190
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv7offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset7 : 14;
    /* rir_offset7 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET7[39:26] == rank interleave 0 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt7 : 4;
    /* rir_rnk_tgt7 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 7 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV7OFFSET_0_MC_MAIN_STRUCT;


/* RIRILV7OFFSET_1_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250194)                                                  */
/*       SKX (0x40250194)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV7OFFSET_1_MC_MAIN_REG 0x07004194
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv7offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset7 : 14;
    /* rir_offset7 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET7[39:26] == rank interleave 0 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt7 : 4;
    /* rir_rnk_tgt7 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 7 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV7OFFSET_1_MC_MAIN_STRUCT;


/* RIRILV7OFFSET_2_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250198)                                                  */
/*       SKX (0x40250198)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV7OFFSET_2_MC_MAIN_REG 0x07004198
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv7offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset7 : 14;
    /* rir_offset7 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET7[39:26] == rank interleave 0 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt7 : 4;
    /* rir_rnk_tgt7 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 7 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV7OFFSET_2_MC_MAIN_STRUCT;


/* RIRILV7OFFSET_3_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x4025019C)                                                  */
/*       SKX (0x4025019C)                                                     */
/* Register default value:              0x00000000                            */
#define RIRILV7OFFSET_3_MC_MAIN_REG 0x0700419C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Four instances of ririlv7offset, one per RIR
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 2;
    /* rsvd_0 - Bits[1:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rir_offset7 : 14;
    /* rir_offset7 - Bits[15:2], RW_LB, default = 14'b00000000000000 
       RIR[5:0].RANKOFFSET7[39:26] == rank interleave 0 offset, 64MB granularity 
                   (The processor's minimum rank size is 512MB. 512MB/8 interleave = 
       64MB per 8-way interleave.) 
     */
    UINT32 rir_rnk_tgt7 : 4;
    /* rir_rnk_tgt7 - Bits[19:16], RW_LB, default = 4'b0000 
       target rank ID for rank interleave 7 (used for 1/2/4/8-way RIR interleaving).
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RIRILV7OFFSET_3_MC_MAIN_STRUCT;


/* RSP_FUNC_ADDR_MATCH_LO_MC_MAIN_REG supported on:                           */
/*       SKX_A0 (0x402501C0)                                                  */
/*       SKX (0x402501C0)                                                     */
/* Register default value:              0x00000000                            */
#define RSP_FUNC_ADDR_MATCH_LO_MC_MAIN_REG 0x070041C0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Complete address match (Addr[45:3]) and mask is supported for all M2M writes. 
 * The error injection logic uses the address match mask logic output to determine 
 * which memory writes need to get error injection. Users can program up to two x4 
 * device masks (8-bits per chunk - 64 bits per cacheline).  
 */
typedef union {
  struct {
    UINT32 addr_match_lower : 32;
    /* addr_match_lower - Bits[31:0], RWS, default = 32'b00000000000000000000000000000000 
       Addr Match Lower: 32-bits (Match Addr[34:3])
     */
  } Bits;
  UINT32 Data;
} RSP_FUNC_ADDR_MATCH_LO_MC_MAIN_STRUCT;


/* RSP_FUNC_ADDR_MATCH_HI_MC_MAIN_REG supported on:                           */
/*       SKX_A0 (0x402501C4)                                                  */
/*       SKX (0x402501C4)                                                     */
/* Register default value:              0x00000000                            */
#define RSP_FUNC_ADDR_MATCH_HI_MC_MAIN_REG 0x070041C4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Complete address match (Addr[45:3]) and mask is supported for all HA writes. The 
 * error injection logic uses the address match mask logic output to determine 
 * which memory writes need to get error injection. Users can program up to two x4 
 * device masks (8-bits per chunk - 64 bits per cacheline). In Lockstep mode, only 
 * one device can be programmed in each lockstep channel. 
 */
typedef union {
  struct {
    UINT32 addr_match_higher : 11;
    /* addr_match_higher - Bits[10:0], RWS, default = 11'b00000000000 
       Addr Match Higher : 11-Bits (Match Addr[45:35])
     */
    UINT32 rsp_func_addr_match_en : 1;
    /* rsp_func_addr_match_en - Bits[11:11], RWS_LV, default = 1'b0 
       Enabling the Address Match Response Function when set.
     */
    UINT32 rsvd_12 : 1;
    UINT32 rsvd_13 : 3;
    /* rsvd_13 - Bits[15:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rsvd_16 : 8;
    UINT32 rsvd_24 : 1;
    /* rsvd_24 - Bits[24:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mirror_match : 3;
    /* mirror_match - Bits[27:25], RWS, default = 3'b000 
       Additional match configuration: Bit 0 matches with Mirror field; Bit 1 matches 
       with mirr_pri (primary channel); Bit 2 matches with demand scrub request 
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RSP_FUNC_ADDR_MATCH_HI_MC_MAIN_STRUCT;


/* RSP_FUNC_ADDR_MASK_LO_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x402501C8)                                                  */
/*       SKX (0x402501C8)                                                     */
/* Register default value:              0xFFFFFFFF                            */
#define RSP_FUNC_ADDR_MASK_LO_MC_MAIN_REG 0x070041C8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Complete address match (Addr[45:3]) and mask is supported for all HA writes. 
 * Error injection does not use the response logic triggers and uses the match mask 
 * logic output to determine which writes need to get error injection. Users can 
 * program up to two x4 device masks (8-bits per chunk - 64 bits per cacheline). In 
 * Lockstep mode, only one device can be programmed in each lockstep channel. 
 */
typedef union {
  struct {
    UINT32 addr_mask_lower : 32;
    /* addr_mask_lower - Bits[31:0], RWS, default = 32'hffffffff 
       Address Mask to deselect (when set) the corresponding Addr[34:3] for the address 
       match. 
     */
  } Bits;
  UINT32 Data;
} RSP_FUNC_ADDR_MASK_LO_MC_MAIN_STRUCT;


/* RSP_FUNC_ADDR_MASK_HI_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x402501CC)                                                  */
/*       SKX (0x402501CC)                                                     */
/* Register default value:              0x0E0007FF                            */
#define RSP_FUNC_ADDR_MASK_HI_MC_MAIN_REG 0x070041CC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Complete address match (Addr[45:3]) and mask is supported for all HA writes. 
 * Error injection does not use the response logic triggers and uses the match mask 
 * logic output to determine which writes need to get error injection. Users can 
 * program up to two x4 device masks (8-bits per chunk - 64 bits per cacheline). In 
 * Lockstep mode, only one device can be programmed in each lockstep channel. 
 */
typedef union {
  struct {
    UINT32 addr_mask_higher : 11;
    /* addr_mask_higher - Bits[10:0], RWS, default = 11'b11111111111 
       Address Mask to deselect (when set) the corresponding Addr[45:35] for the 
       address match. 
     */
    UINT32 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rsvd_16 : 8;
    UINT32 rsvd_24 : 1;
    /* rsvd_24 - Bits[24:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mirror_mask : 3;
    /* mirror_mask - Bits[27:25], RWS, default = 3'b111 
       Additional mask to deselect (when set) the corresponding bits in mirror_mask 
       field. Bit 0 is mask for Mirror field; Bit 1 is mask for mirr_pri (primary 
       channel); Bit 2 is mask for demand scrub request 
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RSP_FUNC_ADDR_MASK_HI_MC_MAIN_STRUCT;


/* RSP_FUNC_RANK_BANK_MATCH_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x402501D0)                                                  */
/*       SKX (0x402501D0)                                                     */
/* Register default value:              0x00000000                            */
#define RSP_FUNC_RANK_BANK_MATCH_MC_MAIN_REG 0x070041D0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Enables targetting injection to a particular bank in a particular logical rank.  
 * When enabled, programmed rank and bank will be matched, system address match 
 * will not be used. 
 */
typedef union {
  struct {
    UINT32 bank : 4;
    /* bank - Bits[3:0], RW, default = 4'b0000 
       Bank to match
     */
    UINT32 rank : 3;
    /* rank - Bits[6:4], RW, default = 3'b000 
       Rank to match
     */
    UINT32 rsvd : 23;
    /* rsvd - Bits[29:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dis_patspr : 1;
    /* dis_patspr - Bits[30:30], RW, default = 1'b0 
       Disable any injection matching on Patrol or Spare transactions. This applies to 
       rank/bank match and system address match. 
     */
    UINT32 en : 1;
    /* en - Bits[31:31], RW, default = 1'b0 
       Enable rank and bank matching
     */
  } Bits;
  UINT32 Data;
} RSP_FUNC_RANK_BANK_MATCH_MC_MAIN_STRUCT;




/* ECC_MODE_RANK0_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x10250210)                                                  */
/*       SKX (0x10250210)                                                     */
/* Register default value:              0x00                                  */
#define ECC_MODE_RANK0_MC_MAIN_REG 0x07001210
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           This register specifies the current ECC configuration for each rank, 
 * for portions of the rank not participating in an ADDDC region. 
 *       
 */
typedef union {
  struct {
    UINT8 mode : 1;
    /* mode - Bits[0:0], RW_LB, default = 1'b0 
       
                   This field specifies the ECC in use for this rank, for portions of 
       the rank not participating in an ADDDC region. 
                   0 = No failure
                   1 = Parity substitution.  EP:  Detect only, EX:  Single bit 
       correction 
                   This field is set by software at the beginning of a sparing flow.
               
     */
    UINT8 rsvd : 7;
    /* rsvd - Bits[7:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} ECC_MODE_RANK0_MC_MAIN_STRUCT;


/* ECC_MODE_RANK1_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x10250211)                                                  */
/*       SKX (0x10250211)                                                     */
/* Register default value:              0x00                                  */
#define ECC_MODE_RANK1_MC_MAIN_REG 0x07001211
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           This register specifies the current ECC configuration for each rank, 
 * for portions of the rank not participating in an ADDDC region. 
 *       
 */
typedef union {
  struct {
    UINT8 mode : 1;
    /* mode - Bits[0:0], RW_LB, default = 1'b0 
       
                   This field specifies the ECC in use for this rank, for portions of 
       the rank not participating in an ADDDC region. 
                   0 = No failure
                   1 = Parity substitution.  EP:  Detect only, EX:  Single bit 
       correction 
                   This field is set by software at the beginning of a sparing flow.
               
     */
    UINT8 rsvd : 7;
    /* rsvd - Bits[7:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} ECC_MODE_RANK1_MC_MAIN_STRUCT;


/* ECC_MODE_RANK2_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x10250212)                                                  */
/*       SKX (0x10250212)                                                     */
/* Register default value:              0x00                                  */
#define ECC_MODE_RANK2_MC_MAIN_REG 0x07001212
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           This register specifies the current ECC configuration for each rank, 
 * for portions of the rank not participating in an ADDDC region. 
 *       
 */
typedef union {
  struct {
    UINT8 mode : 1;
    /* mode - Bits[0:0], RW_LB, default = 1'b0 
       
                   This field specifies the ECC in use for this rank, for portions of 
       the rank not participating in an ADDDC region. 
                   0 = No failure
                   1 = Parity substitution.  EP:  Detect only, EX:  Single bit 
       correction 
                   This field is set by software at the beginning of a sparing flow.
               
     */
    UINT8 rsvd : 7;
    /* rsvd - Bits[7:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} ECC_MODE_RANK2_MC_MAIN_STRUCT;


/* ECC_MODE_RANK3_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x10250213)                                                  */
/*       SKX (0x10250213)                                                     */
/* Register default value:              0x00                                  */
#define ECC_MODE_RANK3_MC_MAIN_REG 0x07001213
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           This register specifies the current ECC configuration for each rank, 
 * for portions of the rank not participating in an ADDDC region. 
 *       
 */
typedef union {
  struct {
    UINT8 mode : 1;
    /* mode - Bits[0:0], RW_LB, default = 1'b0 
       
                   This field specifies the ECC in use for this rank, for portions of 
       the rank not participating in an ADDDC region. 
                   0 = No failure
                   1 = Parity substitution.  EP:  Detect only, EX:  Single bit 
       correction 
                   This field is set by software at the beginning of a sparing flow.
               
     */
    UINT8 rsvd : 7;
    /* rsvd - Bits[7:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} ECC_MODE_RANK3_MC_MAIN_STRUCT;


/* ECC_MODE_RANK4_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x10250214)                                                  */
/*       SKX (0x10250214)                                                     */
/* Register default value:              0x00                                  */
#define ECC_MODE_RANK4_MC_MAIN_REG 0x07001214
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           This register specifies the current ECC configuration for each rank, 
 * for portions of the rank not participating in an ADDDC region. 
 *       
 */
typedef union {
  struct {
    UINT8 mode : 1;
    /* mode - Bits[0:0], RW_LB, default = 1'b0 
       
                   This field specifies the ECC in use for this rank, for portions of 
       the rank not participating in an ADDDC region. 
                   0 = No failure
                   1 = Parity substitution.  EP:  Detect only, EX:  Single bit 
       correction 
                   This field is set by software at the beginning of a sparing flow.
               
     */
    UINT8 rsvd : 7;
    /* rsvd - Bits[7:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} ECC_MODE_RANK4_MC_MAIN_STRUCT;


/* ECC_MODE_RANK5_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x10250215)                                                  */
/*       SKX (0x10250215)                                                     */
/* Register default value:              0x00                                  */
#define ECC_MODE_RANK5_MC_MAIN_REG 0x07001215
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           This register specifies the current ECC configuration for each rank, 
 * for portions of the rank not participating in an ADDDC region. 
 *       
 */
typedef union {
  struct {
    UINT8 mode : 1;
    /* mode - Bits[0:0], RW_LB, default = 1'b0 
       
                   This field specifies the ECC in use for this rank, for portions of 
       the rank not participating in an ADDDC region. 
                   0 = No failure
                   1 = Parity substitution.  EP:  Detect only, EX:  Single bit 
       correction 
                   This field is set by software at the beginning of a sparing flow.
               
     */
    UINT8 rsvd : 7;
    /* rsvd - Bits[7:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} ECC_MODE_RANK5_MC_MAIN_STRUCT;


/* ECC_MODE_RANK6_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x10250216)                                                  */
/*       SKX (0x10250216)                                                     */
/* Register default value:              0x00                                  */
#define ECC_MODE_RANK6_MC_MAIN_REG 0x07001216
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           This register specifies the current ECC configuration for each rank, 
 * for portions of the rank not participating in an ADDDC region. 
 *       
 */
typedef union {
  struct {
    UINT8 mode : 1;
    /* mode - Bits[0:0], RW_LB, default = 1'b0 
       
                   This field specifies the ECC in use for this rank, for portions of 
       the rank not participating in an ADDDC region. 
                   0 = No failure
                   1 = Parity substitution.  EP:  Detect only, EX:  Single bit 
       correction 
                   This field is set by software at the beginning of a sparing flow.
               
     */
    UINT8 rsvd : 7;
    /* rsvd - Bits[7:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} ECC_MODE_RANK6_MC_MAIN_STRUCT;


/* ECC_MODE_RANK7_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x10250217)                                                  */
/*       SKX (0x10250217)                                                     */
/* Register default value:              0x00                                  */
#define ECC_MODE_RANK7_MC_MAIN_REG 0x07001217
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           This register specifies the current ECC configuration for each rank, 
 * for portions of the rank not participating in an ADDDC region. 
 *       
 */
typedef union {
  struct {
    UINT8 mode : 1;
    /* mode - Bits[0:0], RW_LB, default = 1'b0 
       
                   This field specifies the ECC in use for this rank, for portions of 
       the rank not participating in an ADDDC region. 
                   0 = No failure
                   1 = Parity substitution.  EP:  Detect only, EX:  Single bit 
       correction 
                   This field is set by software at the beginning of a sparing flow.
               
     */
    UINT8 rsvd : 7;
    /* rsvd - Bits[7:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} ECC_MODE_RANK7_MC_MAIN_STRUCT;


/* ADDDC_REGION0_CONTROL_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x40250230)                                                  */
/*       SKX (0x40250230)                                                     */
/* Register default value:              0x00000000                            */
#define ADDDC_REGION0_CONTROL_MC_MAIN_REG 0x07004230
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           This register specifies the configuration for the regions using ADDDC 
 * for operation after the sparing copy is finished for the region. 
 *       
 */
typedef union {
  struct {
    UINT32 region_enable : 1;
    /* region_enable - Bits[0:0], RW_LB, default = 1'b0 
       
                   This bit specifies whether the ADDDC region is in use.
                   0=ADDDC not enabled for this region
                   1=ADDDC enabled for this region
                   This bit should be set by software before the beginning of the ADDDC 
       sparing copy flow. 
               
     */
    UINT32 rsvd_1 : 1;
    /* rsvd_1 - Bits[1:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 region_size : 2;
    /* region_size - Bits[3:2], RW_LB, default = 1'b0 
       
                   Granularity for this ADDDC region:
                   00=bank
                   01=rank
                   10=reserved 
                   11=reserved
               
     */
    UINT32 failed_cs : 3;
    /* failed_cs - Bits[6:4], RW_LB, default = 1'b0 
       
                   This field specifies the Chip Select (rank) to match when 
       determining if this is the failed region participating in either ADDDC or Static 
       Virtual Lockstep.  The value in this field is encoded (Chip Selects are normally 
       1-hot), corresponding to CS0-CS7.  When the failed region is a DIMM, two region 
       registers should be programmed corresponding to both Chip Selects of the failed 
       DIMM. 
               
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 failed_c : 3;
    /* failed_c - Bits[10:8], RW_LB, default = 1'b0 
       
                   This field specifies the subrank to match when determining if this 
       is the failed region participating in ADDDC.  Only used when region_size=bank. 
               
     */
    UINT32 rsvd_11 : 1;
    /* rsvd_11 - Bits[11:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 failed_ba : 2;
    /* failed_ba - Bits[13:12], RW_LB, default = 1'b0 
       
                   This field specifies the bank address to match when determining if 
       this is the failed region participating in ADDDC.  Only used when 
       region_size=bank. 
               
     */
    UINT32 failed_bg : 2;
    /* failed_bg - Bits[15:14], RW_LB, default = 1'b0 
       
                   This field specifies the bank group to match when determining if 
       this is the failed region participating in ADDDC.  Only used when 
       region_size=bank. 
               
     */
    UINT32 nonfailed_cs : 3;
    /* nonfailed_cs - Bits[18:16], RW_LB, default = 1'b0 
       
                   This field specifies the Chip Select (rank) to match when 
       determining if this is the failed region participating in either ADDDC or Static 
       Virtual Lockstep.  The value in this field is encoded (Chip Selects are normally 
       1-hot), corresponding to CS0-CS7.  When the failed region is a DIMM, two region 
       registers should be programmed corresponding to both Chip Selects of the failed 
       DIMM. 
               
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 nonfailed_c : 3;
    /* nonfailed_c - Bits[22:20], RW_LB, default = 1'b0 
       
                   This field specifies the subrank to match when determining if this 
       is the failed region participating in ADDDC.  Only used when region_size=bank. 
               
     */
    UINT32 rsvd_23 : 1;
    /* rsvd_23 - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 nonfailed_ba : 2;
    /* nonfailed_ba - Bits[25:24], RW_LB, default = 1'b0 
       
                   This field specifies the bank address to match when determining if 
       this is the failed region participating in ADDDC.  Only used when 
       region_size=bank. 
               
     */
    UINT32 nonfailed_bg : 2;
    /* nonfailed_bg - Bits[27:26], RW_LB, default = 1'b0 
       
                   This field specifies the bank group to match when determining if 
       this is the failed region participating in ADDDC.  Only used when 
       region_size=bank. 
               
     */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 copy_in_progress : 1;
    /* copy_in_progress - Bits[29:29], RW_LBV, default = 1'b0 
       
                   This field specifies that ADDDC spare copy is on-going for this 
       region. 
                   This bit should be set by BIOS before starting the ADDDC sparing 
       copy flow. 
                   This bit should be cleared by hardware at the end of the sparing 
       copy flow. 
               
     */
    UINT32 rsvd_30 : 2;
    /* rsvd_30 - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} ADDDC_REGION0_CONTROL_MC_MAIN_STRUCT;


/* ADDDC_REGION1_CONTROL_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x40250234)                                                  */
/*       SKX (0x40250234)                                                     */
/* Register default value:              0x00000000                            */
#define ADDDC_REGION1_CONTROL_MC_MAIN_REG 0x07004234
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           This register specifies the configuration for the regions using ADDDC 
 * for operation after the sparing copy is finished for the region. 
 *       
 */
typedef union {
  struct {
    UINT32 region_enable : 1;
    /* region_enable - Bits[0:0], RW_LB, default = 1'b0 
       
                   This bit specifies whether the ADDDC region is in use.
                   0=ADDDC not enabled for this region
                   1=ADDDC enabled for this region
               
     */
    UINT32 rsvd_1 : 1;
    /* rsvd_1 - Bits[1:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 region_size : 2;
    /* region_size - Bits[3:2], RW_LB, default = 1'b0 
       
                   Granularity for this ADDDC region:
                   00=bank
                   01=rank
                   10=reserved 
                   11=reserved
               
     */
    UINT32 failed_cs : 3;
    /* failed_cs - Bits[6:4], RW_LB, default = 1'b0 
       
                   This field specifies the Chip Select (rank) to match when 
       determining if this is the failed region participating in either ADDDC or Static 
       Virtual Lockstep.  The value in this field is encoded (Chip Selects are normally 
       1-hot), corresponding to CS0-CS7.  When the failed region is a DIMM, two region 
       registers should be programmed corresponding to both Chip Selects of the failed 
       DIMM. 
               
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 failed_c : 3;
    /* failed_c - Bits[10:8], RW_LB, default = 1'b0 
       
                   This field specifies the subrank to match when determining if this 
       is the failed region participating in either ADDDC or Static Virtual Lockstep.  
       Only used when region_size=bank. 
               
     */
    UINT32 rsvd_11 : 1;
    /* rsvd_11 - Bits[11:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 failed_ba : 2;
    /* failed_ba - Bits[13:12], RW_LB, default = 1'b0 
       
                   This field specifies the bank address to match when determining if 
       this is the failed region participating in either ADDDC or Static Virtual 
       Lockstep.  Only used when region_size=bank. 
               
     */
    UINT32 failed_bg : 2;
    /* failed_bg - Bits[15:14], RW_LB, default = 1'b0 
       
                   This field specifies the bank group to match when determining if 
       this is the failed region participating in either ADDDC or Static Virtual 
       Lockstep.  Only used when region_size=bank. 
               
     */
    UINT32 nonfailed_cs : 3;
    /* nonfailed_cs - Bits[18:16], RW_LB, default = 1'b0 
       
                   This field specifies the Chip Select (rank) to match when 
       determining if this is the failed region participating in either ADDDC or Static 
       Virtual Lockstep.  The value in this field is encoded (Chip Selects are normally 
       1-hot), corresponding to CS0-CS7.  When the failed region is a DIMM, two region 
       registers should be programmed corresponding to both Chip Selects of the failed 
       DIMM. 
               
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 nonfailed_c : 3;
    /* nonfailed_c - Bits[22:20], RW_LB, default = 1'b0 
       
                   This field specifies the subrank to match when determining if this 
       is the failed region participating in either ADDDC or Static Virtual Lockstep.  
       Only used when region_size=bank. 
               
     */
    UINT32 rsvd_23 : 1;
    /* rsvd_23 - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 nonfailed_ba : 2;
    /* nonfailed_ba - Bits[25:24], RW_LB, default = 1'b0 
       
                   This field specifies the bank address to match when determining if 
       this is the failed region participating in either ADDDC or Static Virtual 
       Lockstep.  Only used when region_size=bank. 
               
     */
    UINT32 nonfailed_bg : 2;
    /* nonfailed_bg - Bits[27:26], RW_LB, default = 1'b0 
       
                   This field specifies the bank group to match when determining if 
       this is the failed region participating in either ADDDC or Static Virtual 
       Lockstep.  Only used when region_size=bank. 
               
     */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 copy_in_progress : 1;
    /* copy_in_progress - Bits[29:29], RW_LB, default = 1'b0 
       
                 This field specifies that ADDDC spare copy is on-going for this region
               
     */
    UINT32 rsvd_30 : 2;
    /* rsvd_30 - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} ADDDC_REGION1_CONTROL_MC_MAIN_STRUCT;


/* ADDDC_REGION2_CONTROL_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x40250238)                                                  */
/*       SKX (0x40250238)                                                     */
/* Register default value:              0x00000000                            */
#define ADDDC_REGION2_CONTROL_MC_MAIN_REG 0x07004238
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           This register specifies the configuration for the regions using ADDDC 
 * for operation after the sparing copy is finished for the region. 
 *       
 */
typedef union {
  struct {
    UINT32 region_enable : 1;
    /* region_enable - Bits[0:0], RW_LB, default = 1'b0 
       
                   This bit specifies whether the ADDDC region is in use.
                   0=ADDDC not enabled for this region
                   1=ADDDC enabled for this region
               
     */
    UINT32 rsvd_1 : 1;
    /* rsvd_1 - Bits[1:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 region_size : 2;
    /* region_size - Bits[3:2], RW_LB, default = 1'b0 
       
                   Granularity for this ADDDC region:
                   00=bank
                   01=rank
                   10=reserved 
                   11=reserved
               
     */
    UINT32 failed_cs : 3;
    /* failed_cs - Bits[6:4], RW_LB, default = 1'b0 
       
                   This field specifies the Chip Select (rank) to match when 
       determining if this is the failed region participating in either ADDDC or Static 
       Virtual Lockstep.  The value in this field is encoded (Chip Selects are normally 
       1-hot), corresponding to CS0-CS7.  When the failed region is a DIMM, two region 
       registers should be programmed corresponding to both Chip Selects of the failed 
       DIMM. 
               
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 failed_c : 3;
    /* failed_c - Bits[10:8], RW_LB, default = 1'b0 
       
                   This field specifies the subrank to match when determining if this 
       is the failed region participating in either ADDDC or Static Virtual Lockstep.  
       Only used when region_size=bank. 
               
     */
    UINT32 rsvd_11 : 1;
    /* rsvd_11 - Bits[11:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 failed_ba : 2;
    /* failed_ba - Bits[13:12], RW_LB, default = 1'b0 
       
                   This field specifies the bank address to match when determining if 
       this is the failed region participating in either ADDDC or Static Virtual 
       Lockstep.  Only used when region_size=bank. 
               
     */
    UINT32 failed_bg : 2;
    /* failed_bg - Bits[15:14], RW_LB, default = 1'b0 
       
                   This field specifies the bank group to match when determining if 
       this is the failed region participating in either ADDDC or Static Virtual 
       Lockstep.  Only used when region_size=bank. 
               
     */
    UINT32 nonfailed_cs : 3;
    /* nonfailed_cs - Bits[18:16], RW_LB, default = 1'b0 
       
                   This field specifies the Chip Select (rank) to match when 
       determining if this is the failed region participating in either ADDDC or Static 
       Virtual Lockstep.  The value in this field is encoded (Chip Selects are normally 
       1-hot), corresponding to CS0-CS7.  When the failed region is a DIMM, two region 
       registers should be programmed corresponding to both Chip Selects of the failed 
       DIMM. 
               
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 nonfailed_c : 3;
    /* nonfailed_c - Bits[22:20], RW_LB, default = 1'b0 
       
                   This field specifies the subrank to match when determining if this 
       is the failed region participating in either ADDDC or Static Virtual Lockstep.  
       Only used when region_size=bank. 
               
     */
    UINT32 rsvd_23 : 1;
    /* rsvd_23 - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 nonfailed_ba : 2;
    /* nonfailed_ba - Bits[25:24], RW_LB, default = 1'b0 
       
                   This field specifies the bank address to match when determining if 
       this is the failed region participating in either ADDDC or Static Virtual 
       Lockstep.  Only used when region_size=bank. 
               
     */
    UINT32 nonfailed_bg : 2;
    /* nonfailed_bg - Bits[27:26], RW_LB, default = 1'b0 
       
                   This field specifies the bank group to match when determining if 
       this is the failed region participating in either ADDDC or Static Virtual 
       Lockstep.  Only used when region_size=bank. 
               
     */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 copy_in_progress : 1;
    /* copy_in_progress - Bits[29:29], RW_LB, default = 1'b0 
       
                 This field specifies that ADDDC spare copy is on-going for this region
               
     */
    UINT32 rsvd_30 : 2;
    /* rsvd_30 - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} ADDDC_REGION2_CONTROL_MC_MAIN_STRUCT;


/* ADDDC_REGION3_CONTROL_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x4025023C)                                                  */
/*       SKX (0x4025023C)                                                     */
/* Register default value:              0x00000000                            */
#define ADDDC_REGION3_CONTROL_MC_MAIN_REG 0x0700423C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           This register specifies the configuration for the regions using ADDDC 
 * for operation after the sparing copy is finished for the region. 
 *       
 */
typedef union {
  struct {
    UINT32 region_enable : 1;
    /* region_enable - Bits[0:0], RW_LB, default = 1'b0 
       
                   This bit specifies whether the ADDDC region is in use.
                   0=ADDDC not enabled for this region
                   1=ADDDC enabled for this region
               
     */
    UINT32 rsvd_1 : 1;
    /* rsvd_1 - Bits[1:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 region_size : 2;
    /* region_size - Bits[3:2], RW_LB, default = 1'b0 
       
                   Granularity for this ADDDC region:
                   00=bank
                   01=rank
                   10=reserved 
                   11=reserved
               
     */
    UINT32 failed_cs : 3;
    /* failed_cs - Bits[6:4], RW_LB, default = 1'b0 
       
                   This field specifies the Chip Select (rank) to match when 
       determining if this is the failed region participating in either ADDDC or Static 
       Virtual Lockstep.  The value in this field is encoded (Chip Selects are normally 
       1-hot), corresponding to CS0-CS7.  When the failed region is a DIMM, two region 
       registers should be programmed corresponding to both Chip Selects of the failed 
       DIMM. 
               
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 failed_c : 3;
    /* failed_c - Bits[10:8], RW_LB, default = 1'b0 
       
                   This field specifies the subrank to match when determining if this 
       is the failed region participating in either ADDDC or Static Virtual Lockstep.  
       Only used when region_size=bank. 
               
     */
    UINT32 rsvd_11 : 1;
    /* rsvd_11 - Bits[11:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 failed_ba : 2;
    /* failed_ba - Bits[13:12], RW_LB, default = 1'b0 
       
                   This field specifies the bank address to match when determining if 
       this is the failed region participating in either ADDDC or Static Virtual 
       Lockstep.  Only used when region_size=bank. 
               
     */
    UINT32 failed_bg : 2;
    /* failed_bg - Bits[15:14], RW_LB, default = 1'b0 
       
                   This field specifies the bank group to match when determining if 
       this is the failed region participating in either ADDDC or Static Virtual 
       Lockstep.  Only used when region_size=bank. 
               
     */
    UINT32 nonfailed_cs : 3;
    /* nonfailed_cs - Bits[18:16], RW_LB, default = 1'b0 
       
                   This field specifies the Chip Select (rank) to match when 
       determining if this is the failed region participating in either ADDDC or Static 
       Virtual Lockstep.  The value in this field is encoded (Chip Selects are normally 
       1-hot), corresponding to CS0-CS7.  When the failed region is a DIMM, two region 
       registers should be programmed corresponding to both Chip Selects of the failed 
       DIMM. 
               
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 nonfailed_c : 3;
    /* nonfailed_c - Bits[22:20], RW_LB, default = 1'b0 
       
                   This field specifies the subrank to match when determining if this 
       is the failed region participating in either ADDDC or Static Virtual Lockstep.  
       Only used when region_size=bank. 
               
     */
    UINT32 rsvd_23 : 1;
    /* rsvd_23 - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 nonfailed_ba : 2;
    /* nonfailed_ba - Bits[25:24], RW_LB, default = 1'b0 
       
                   This field specifies the bank address to match when determining if 
       this is the failed region participating in either ADDDC or Static Virtual 
       Lockstep.  Only used when region_size=bank. 
               
     */
    UINT32 nonfailed_bg : 2;
    /* nonfailed_bg - Bits[27:26], RW_LB, default = 1'b0 
       
                   This field specifies the bank group to match when determining if 
       this is the failed region participating in either ADDDC or Static Virtual 
       Lockstep.  Only used when region_size=bank. 
               
     */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 copy_in_progress : 1;
    /* copy_in_progress - Bits[29:29], RW_LB, default = 1'b0 
       
                 This field specifies that ADDDC spare copy is on-going for this region
               
     */
    UINT32 rsvd_30 : 2;
    /* rsvd_30 - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} ADDDC_REGION3_CONTROL_MC_MAIN_STRUCT;


/* SCRATCHPAD2_MC_MAIN_REG supported on:                                      */
/*       SKX_A0 (0x40250240)                                                  */
/*       SKX (0x40250240)                                                     */
/* Register default value:              0x00000000                            */
#define SCRATCHPAD2_MC_MAIN_REG 0x07004240
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * 
 *           second scratch pad register in MCDECS_CSR for validation.  last one 
 * locates in mcmains and was only specific to MCDECS_CSR_CH0.  this one are 
 * channel specific. 
 *       
 */
typedef union {
  struct {
    UINT32 scratchpad2 : 32;
    /* scratchpad2 - Bits[31:0], RW, default = 32'b00000000000000000000000000000000 
       SCRATCHPAD2
     */
  } Bits;
  UINT32 Data;
} SCRATCHPAD2_MC_MAIN_STRUCT;




/* MCDECS_RCB_GATE_CTL_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x40250248)                                                  */
/*       SKX (0x40250248)                                                     */
/* Register default value:              0x00000040                            */
#define MCDECS_RCB_GATE_CTL_MC_MAIN_REG 0x07004248
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Control information for RCB clock gating in mcdecs
 */
typedef union {
  struct {
    UINT32 rcb_gate_mcdecs_timer : 10;
    /* rcb_gate_mcdecs_timer - Bits[9:0], RW_LB, default = 10'b0001000000 
       Time clock keeps running after triggering events
     */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCDECS_RCB_GATE_CTL_MC_MAIN_STRUCT;


/* MCDECS_ERR_LOG_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x4025024C)                                                  */
/*       SKX (0x4025024C)                                                     */
/* Register default value:              0x00000000                            */
#define MCDECS_ERR_LOG_MC_MAIN_REG 0x0700424C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Error information in mcdecs
 */
typedef union {
  struct {
    UINT32 critical_chunk_err : 1;
    /* critical_chunk_err - Bits[0:0], RW_LB, default = 1'b0 
       Error indication when critical chunk bit is set for ADDDC or PlusOne transaction
     */
    UINT32 rsvd : 31;
    /* rsvd - Bits[31:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCDECS_ERR_LOG_MC_MAIN_STRUCT;


/* MCDECS_CHICKEN_BITS_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x10250300)                                                  */
/*       SKX (0x10250300)                                                     */
/* Register default value:              0x00                                  */
#define MCDECS_CHICKEN_BITS_MC_MAIN_REG 0x07001300
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * MCDECS_CHICKEN_BITS
 */
typedef union {
  struct {
    UINT8 dis_ck_gate_addr_dec : 1;
    /* dis_ck_gate_addr_dec - Bits[0:0], RW_LB, default = 1'b0 
       Disable clock gating addr_decode
     */
    UINT8 dis_isoch_wr : 1;
    /* dis_isoch_wr - Bits[1:1], RW_LB, default = 1'b0 
       Converts isoch writes to non isoch in decoder
     */
    UINT8 dis_isoch_rd : 1;
    /* dis_isoch_rd - Bits[2:2], RW_LB, default = 1'b0 
       Converts isoch reads to non isoch in decoder
     */
    UINT8 defeature_2 : 1;
    /* defeature_2 - Bits[3:3], RW_LB, default = 1'b0 
       When set to 1, Select system address instead of channel address for determining 
       if an incoming M2M request has been spare copied or not during rank or sddc 
       sparing flow. Should be set to 1 when mirroring is enabled. Should be kept at 0 
       in 2LM mode. 
     */
    UINT8 defeature_3 : 1;
    /* defeature_3 - Bits[4:4], RW_LB, default = 1'b0 
       Reserved Unused
     */
    UINT8 en_cpgc_adddc : 1;
    /* en_cpgc_adddc - Bits[5:5], RW_LB, default = 1'b0 
       Enable ADDDC format for CPGC transactions. Use for x8 virtual lockstep mode 
       only. 
     */
    UINT8 rsvd : 2;
    /* rsvd - Bits[7:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} MCDECS_CHICKEN_BITS_MC_MAIN_STRUCT;


/* MCDDRTCFG_MC_MAIN_REG supported on:                                        */
/*       SKX_A0 (0x40250400)                                                  */
/*       SKX (0x40250400)                                                     */
/* Register default value:              0x00000000                            */
#define MCDDRTCFG_MC_MAIN_REG 0x07004400
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 slot0 : 1;
    /* slot0 - Bits[0:0], RW_L, default = 1'b0 
       
                   DDR-T DIMM populated if set; otherwise, unpopulated.
                   Should be set to 0 when this slot is populated with a DDR4 DIMM.
               
     */
    UINT32 slot1 : 1;
    /* slot1 - Bits[1:1], RW_L, default = 1'b0 
       
                   DDR-T DIMM populated if set; otherwise, unpopulated.
                   Should be set to 0 when this slot is populated with a DDR4 DIMM.
               
     */
    UINT32 rsvd : 30;
    /* rsvd - Bits[31:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCDDRTCFG_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG0_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250600)                                                  */
/*       SKX (0x40250600)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG0_MC_MAIN_REG 0x07004600
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG0_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG1_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250604)                                                  */
/*       SKX (0x40250604)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG1_MC_MAIN_REG 0x07004604
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG1_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG2_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250608)                                                  */
/*       SKX (0x40250608)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG2_MC_MAIN_REG 0x07004608
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG2_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG3_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x4025060C)                                                  */
/*       SKX (0x4025060C)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG3_MC_MAIN_REG 0x0700460C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG3_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG4_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250610)                                                  */
/*       SKX (0x40250610)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG4_MC_MAIN_REG 0x07004610
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG4_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG5_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250614)                                                  */
/*       SKX (0x40250614)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG5_MC_MAIN_REG 0x07004614
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG5_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG6_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250618)                                                  */
/*       SKX (0x40250618)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG6_MC_MAIN_REG 0x07004618
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG6_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG7_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x4025061C)                                                  */
/*       SKX (0x4025061C)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG7_MC_MAIN_REG 0x0700461C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG7_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG8_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250620)                                                  */
/*       SKX (0x40250620)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG8_MC_MAIN_REG 0x07004620
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG8_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG9_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250624)                                                  */
/*       SKX (0x40250624)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG9_MC_MAIN_REG 0x07004624
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG9_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG10_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x40250628)                                                  */
/*       SKX (0x40250628)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG10_MC_MAIN_REG 0x07004628
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG10_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG11_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x4025062C)                                                  */
/*       SKX (0x4025062C)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG11_MC_MAIN_REG 0x0700462C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG11_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG12_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x40250630)                                                  */
/*       SKX (0x40250630)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG12_MC_MAIN_REG 0x07004630
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG12_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG13_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x40250634)                                                  */
/*       SKX (0x40250634)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG13_MC_MAIN_REG 0x07004634
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG13_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG14_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x40250638)                                                  */
/*       SKX (0x40250638)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG14_MC_MAIN_REG 0x07004638
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG14_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG15_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x4025063C)                                                  */
/*       SKX (0x4025063C)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG15_MC_MAIN_REG 0x0700463C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG15_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG16_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x40250640)                                                  */
/*       SKX (0x40250640)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG16_MC_MAIN_REG 0x07004640
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG16_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG17_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x40250644)                                                  */
/*       SKX (0x40250644)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG17_MC_MAIN_REG 0x07004644
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG17_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG18_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x40250648)                                                  */
/*       SKX (0x40250648)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG18_MC_MAIN_REG 0x07004648
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG18_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG19_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x4025064C)                                                  */
/*       SKX (0x4025064C)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG19_MC_MAIN_REG 0x0700464C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG19_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG20_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x40250650)                                                  */
/*       SKX (0x40250650)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG20_MC_MAIN_REG 0x07004650
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG20_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG21_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x40250654)                                                  */
/*       SKX (0x40250654)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG21_MC_MAIN_REG 0x07004654
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG21_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG22_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x40250658)                                                  */
/*       SKX (0x40250658)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG22_MC_MAIN_REG 0x07004658
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG22_MC_MAIN_STRUCT;


/* NM_DRAM_RULE_CFG23_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x4025065C)                                                  */
/*       SKX (0x4025065C)                                                     */
/* Register default value:              0x00000000                            */
#define NM_DRAM_RULE_CFG23_MC_MAIN_REG 0x0700465C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used to generate addresses for for patrol and sparing transactions. 
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG23_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG0_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250660)                                                  */
/*       SKX (0x40250660)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG0_MC_MAIN_REG 0x07004660
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG0_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG1_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250664)                                                  */
/*       SKX (0x40250664)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG1_MC_MAIN_REG 0x07004664
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG1_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG2_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250668)                                                  */
/*       SKX (0x40250668)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG2_MC_MAIN_REG 0x07004668
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG2_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG3_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x4025066C)                                                  */
/*       SKX (0x4025066C)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG3_MC_MAIN_REG 0x0700466C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG3_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG4_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250670)                                                  */
/*       SKX (0x40250670)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG4_MC_MAIN_REG 0x07004670
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG4_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG5_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250674)                                                  */
/*       SKX (0x40250674)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG5_MC_MAIN_REG 0x07004674
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG5_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG6_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250678)                                                  */
/*       SKX (0x40250678)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG6_MC_MAIN_REG 0x07004678
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG6_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG7_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x4025067C)                                                  */
/*       SKX (0x4025067C)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG7_MC_MAIN_REG 0x0700467C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG7_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG8_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250680)                                                  */
/*       SKX (0x40250680)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG8_MC_MAIN_REG 0x07004680
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG8_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG9_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250684)                                                  */
/*       SKX (0x40250684)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG9_MC_MAIN_REG 0x07004684
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG9_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG10_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x40250688)                                                  */
/*       SKX (0x40250688)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG10_MC_MAIN_REG 0x07004688
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG10_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG11_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x4025068C)                                                  */
/*       SKX (0x4025068C)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG11_MC_MAIN_REG 0x0700468C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG11_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG12_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x40250690)                                                  */
/*       SKX (0x40250690)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG12_MC_MAIN_REG 0x07004690
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG12_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG13_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x40250694)                                                  */
/*       SKX (0x40250694)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG13_MC_MAIN_REG 0x07004694
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG13_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG14_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x40250698)                                                  */
/*       SKX (0x40250698)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG14_MC_MAIN_REG 0x07004698
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG14_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG15_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x4025069C)                                                  */
/*       SKX (0x4025069C)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG15_MC_MAIN_REG 0x0700469C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG15_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG16_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x402506A0)                                                  */
/*       SKX (0x402506A0)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG16_MC_MAIN_REG 0x070046A0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG16_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG17_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x402506A4)                                                  */
/*       SKX (0x402506A4)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG17_MC_MAIN_REG 0x070046A4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG17_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG18_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x402506A8)                                                  */
/*       SKX (0x402506A8)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG18_MC_MAIN_REG 0x070046A8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG18_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG19_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x402506AC)                                                  */
/*       SKX (0x402506AC)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG19_MC_MAIN_REG 0x070046AC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG19_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG20_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x402506B0)                                                  */
/*       SKX (0x402506B0)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG20_MC_MAIN_REG 0x070046B0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG20_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG21_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x402506B4)                                                  */
/*       SKX (0x402506B4)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG21_MC_MAIN_REG 0x070046B4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG21_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG22_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x402506B8)                                                  */
/*       SKX (0x402506B8)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG22_MC_MAIN_REG 0x070046B8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG22_MC_MAIN_STRUCT;


/* NM_INTERLEAVE_LIST_CFG23_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x402506BC)                                                  */
/*       SKX (0x402506BC)                                                     */
/* Register default value:              0x00000000                            */
#define NM_INTERLEAVE_LIST_CFG23_MC_MAIN_REG 0x070046BC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} NM_INTERLEAVE_LIST_CFG23_MC_MAIN_STRUCT;


/* MC_NM_ROUTE_TABLE_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x402506C0)                                                  */
/*       SKX (0x402506C0)                                                     */
/* Register default value:              0x00000000                            */
#define MC_NM_ROUTE_TABLE_MC_MAIN_REG 0x070046C0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 12;
    /* rsvd_0 - Bits[11:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 channelid0 : 2;
    /* channelid0 - Bits[13:12], RW_LB, default = 2'b00 
       Physical Channel ID
     */
    UINT32 channelid1 : 2;
    /* channelid1 - Bits[15:14], RW_LB, default = 2'b00 
       Physical Channel ID
     */
    UINT32 channelid2 : 2;
    /* channelid2 - Bits[17:16], RW_LB, default = 2'b00 
       Physical Channel ID
     */
    UINT32 channelid3 : 2;
    /* channelid3 - Bits[19:18], RW_LB, default = 2'b00 
       Physical Channel ID
     */
    UINT32 channelid4 : 2;
    /* channelid4 - Bits[21:20], RW_LB, default = 2'b00 
       Physical Channel ID
     */
    UINT32 channelid5 : 2;
    /* channelid5 - Bits[23:22], RW_LB, default = 2'b00 
       Physical Channel ID
     */
    UINT32 rsvd_24 : 8;
    /* rsvd_24 - Bits[31:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MC_NM_ROUTE_TABLE_MC_MAIN_STRUCT;


/* MC_SAD2TAD_CFG0_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x402506C4)                                                  */
/*       SKX (0x402506C4)                                                     */
/* Register default value:              0x00000000                            */
#define MC_SAD2TAD_CFG0_MC_MAIN_REG 0x070046C4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 sad2tad0 : 4;
    /* sad2tad0 - Bits[3:0], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 0 for write through
     */
    UINT32 sad2tad1 : 4;
    /* sad2tad1 - Bits[7:4], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 1 for write through
     */
    UINT32 sad2tad2 : 4;
    /* sad2tad2 - Bits[11:8], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 2 for write through
     */
    UINT32 sad2tad3 : 4;
    /* sad2tad3 - Bits[15:12], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 3 for write through
     */
    UINT32 sad2tad4 : 4;
    /* sad2tad4 - Bits[19:16], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 4 for write through
     */
    UINT32 sad2tad5 : 4;
    /* sad2tad5 - Bits[23:20], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 5 for write through
     */
    UINT32 sad2tad6 : 4;
    /* sad2tad6 - Bits[27:24], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 6 for write through
     */
    UINT32 sad2tad7 : 4;
    /* sad2tad7 - Bits[31:28], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 7 for write through
     */
  } Bits;
  UINT32 Data;
} MC_SAD2TAD_CFG0_MC_MAIN_STRUCT;


/* MC_SAD2TAD_CFG1_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x402506C8)                                                  */
/*       SKX (0x402506C8)                                                     */
/* Register default value:              0x00000000                            */
#define MC_SAD2TAD_CFG1_MC_MAIN_REG 0x070046C8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 sad2tad8 : 4;
    /* sad2tad8 - Bits[3:0], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 8 for write through
     */
    UINT32 sad2tad9 : 4;
    /* sad2tad9 - Bits[7:4], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 9 for write through
     */
    UINT32 sad2tad10 : 4;
    /* sad2tad10 - Bits[11:8], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 10 for write through
     */
    UINT32 sad2tad11 : 4;
    /* sad2tad11 - Bits[15:12], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 11 for write through
     */
    UINT32 sad2tad12 : 4;
    /* sad2tad12 - Bits[19:16], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 12 for write through
     */
    UINT32 sad2tad13 : 4;
    /* sad2tad13 - Bits[23:20], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 13 for write through
     */
    UINT32 sad2tad14 : 4;
    /* sad2tad14 - Bits[27:24], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 14 for write through
     */
    UINT32 sad2tad15 : 4;
    /* sad2tad15 - Bits[31:28], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 15 for write through
     */
  } Bits;
  UINT32 Data;
} MC_SAD2TAD_CFG1_MC_MAIN_STRUCT;


/* MC_SAD2TAD_CFG2_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x402506CC)                                                  */
/*       SKX (0x402506CC)                                                     */
/* Register default value:              0x00000000                            */
#define MC_SAD2TAD_CFG2_MC_MAIN_REG 0x070046CC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 sad2tad16 : 4;
    /* sad2tad16 - Bits[3:0], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 16 for write through
     */
    UINT32 sad2tad17 : 4;
    /* sad2tad17 - Bits[7:4], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 17 for write through
     */
    UINT32 sad2tad18 : 4;
    /* sad2tad18 - Bits[11:8], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 18 for write through
     */
    UINT32 sad2tad19 : 4;
    /* sad2tad19 - Bits[15:12], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 19 for write through
     */
    UINT32 sad2tad20 : 4;
    /* sad2tad20 - Bits[19:16], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 20 for write through
     */
    UINT32 sad2tad21 : 4;
    /* sad2tad21 - Bits[23:20], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 21 for write through
     */
    UINT32 sad2tad22 : 4;
    /* sad2tad22 - Bits[27:24], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 22 for write through
     */
    UINT32 sad2tad23 : 4;
    /* sad2tad23 - Bits[31:28], RW_LB, default = 4'b0000 
       SAD2TAD mapping entry 23 for write through
     */
  } Bits;
  UINT32 Data;
} MC_SAD2TAD_CFG2_MC_MAIN_STRUCT;


/* PCOMMIT_CONTROL_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x202506D0)                                                  */
/*       SKX (0x202506D0)                                                     */
/* Register default value:              0x0000                                */
#define PCOMMIT_CONTROL_MC_MAIN_REG 0x070026D0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  This register controls whether Pcommits target DDR4 or DDRT.
 */
typedef union {
  struct {
    UINT16 nvdimm_chn_msk : 3;
    /* nvdimm_chn_msk - Bits[2:0], RW_LB, default = 3'b000 
       
                                One bit per MC channel.
                                When the bit is set, then a Pcommit will target DDR4 on 
       that channel. 
                                When the bit is clear, then a Pcommit will target DDRT 
       on that channel. 
                            
     */
    UINT16 rsvd : 13;
    /* rsvd - Bits[15:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PCOMMIT_CONTROL_MC_MAIN_STRUCT;


/* MCBGF_U2D_OVER0_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x402506E0)                                                  */
/*       SKX (0x402506E0)                                                     */
/* Register default value:              0x00000000                            */
#define MCBGF_U2D_OVER0_MC_MAIN_REG 0x070046E0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Override value for slow down MC data rate at a given Memory frequency. 
 * Programmed by BIOS at start up when Memory frequency is known. 
 */
typedef union {
  struct {
    UINT32 override700 : 7;
    /* override700 - Bits[6:0], RWS_LB, default = 7'b0 
       Override value at UCLK = 700 or URATIO = 21.
     */
    UINT32 en_override700 : 1;
    /* en_override700 - Bits[7:7], RWS_LB, default = 1'b0 
       Enable override at UCLK = 700 or URATIO = 21.
     */
    UINT32 override800 : 7;
    /* override800 - Bits[14:8], RWS_LB, default = 7'b0 
       Override value at UCLK = 800 or URATIO = 24.
     */
    UINT32 en_override800 : 1;
    /* en_override800 - Bits[15:15], RWS_LB, default = 1'b0 
       Enable override at UCLK = 800 or URATIO = 24.
     */
    UINT32 override900 : 7;
    /* override900 - Bits[22:16], RWS_LB, default = 7'b0 
       Override value at UCLK = 900 or URATIO = 27.
     */
    UINT32 en_override900 : 1;
    /* en_override900 - Bits[23:23], RWS_LB, default = 1'b0 
       Enable override at UCLK = 900 or URATIO = 27.
     */
    UINT32 override1000 : 7;
    /* override1000 - Bits[30:24], RWS_LB, default = 7'b0 
       Override value at UCLK = 1000 or URATIO = 30.
     */
    UINT32 en_override1000 : 1;
    /* en_override1000 - Bits[31:31], RWS_LB, default = 1'b0 
       Enable override at UCLK = 1000 or URATIO = 30.
     */
  } Bits;
  UINT32 Data;
} MCBGF_U2D_OVER0_MC_MAIN_STRUCT;


/* MCBGF_U2D_OVER1_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x402506E4)                                                  */
/*       SKX (0x402506E4)                                                     */
/* Register default value:              0x00000000                            */
#define MCBGF_U2D_OVER1_MC_MAIN_REG 0x070046E4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Override value for slow down MC data rate at a given Memory frequency. 
 * Programmed by BIOS at start up when Memory frequency is known. 
 */
typedef union {
  struct {
    UINT32 override1100 : 7;
    /* override1100 - Bits[6:0], RWS_LB, default = 7'b0 
       Override value at UCLK = 1100 or URATIO = 33.
     */
    UINT32 en_override1100 : 1;
    /* en_override1100 - Bits[7:7], RWS_LB, default = 1'b0 
       Enable override at UCLK = 1100 or URATIO = 33.
     */
    UINT32 override1200 : 7;
    /* override1200 - Bits[14:8], RWS_LB, default = 7'b0 
       Override value at UCLK = 1200 or URATIO = 36.
     */
    UINT32 en_override1200 : 1;
    /* en_override1200 - Bits[15:15], RWS_LB, default = 1'b0 
       Enable override at UCLK = 1200 or URATIO = 36.
     */
    UINT32 override1300 : 7;
    /* override1300 - Bits[22:16], RWS_LB, default = 7'b0 
       Override value at UCLK = 1300 or URATIO = 39.
     */
    UINT32 en_override1300 : 1;
    /* en_override1300 - Bits[23:23], RWS_LB, default = 1'b0 
       Enable override at UCLK = 1300 or URATIO = 39.
     */
    UINT32 override1400 : 7;
    /* override1400 - Bits[30:24], RWS_LB, default = 7'b0 
       Override value at UCLK = 1400 or URATIO = 42.
     */
    UINT32 en_override1400 : 1;
    /* en_override1400 - Bits[31:31], RWS_LB, default = 1'b0 
       Enable override at UCLK = 1400 or URATIO = 42.
     */
  } Bits;
  UINT32 Data;
} MCBGF_U2D_OVER1_MC_MAIN_STRUCT;


/* MCBGF_U2D_OVER2_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x402506E8)                                                  */
/*       SKX (0x402506E8)                                                     */
/* Register default value:              0x00000000                            */
#define MCBGF_U2D_OVER2_MC_MAIN_REG 0x070046E8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Override value for slow down MC data rate at a given Memory frequency. 
 * Programmed by BIOS at start up when Memory frequency is known. 
 */
typedef union {
  struct {
    UINT32 override1500 : 7;
    /* override1500 - Bits[6:0], RWS_LB, default = 7'b0 
       Override value at UCLK = 1500 or URATIO = 45.
     */
    UINT32 en_override1500 : 1;
    /* en_override1500 - Bits[7:7], RWS_LB, default = 1'b0 
       Enable override at UCLK = 1500 or URATIO = 45.
     */
    UINT32 override1600 : 7;
    /* override1600 - Bits[14:8], RWS_LB, default = 7'b0 
       Override value at UCLK = 1600 or URATIO = 48.
     */
    UINT32 en_override1600 : 1;
    /* en_override1600 - Bits[15:15], RWS_LB, default = 1'b0 
       Enable override at UCLK = 1600 or URATIO = 48.
     */
    UINT32 override1700 : 7;
    /* override1700 - Bits[22:16], RWS_LB, default = 7'b0 
       Override value at UCLK = 1700 or URATIO = 51.
     */
    UINT32 en_override1700 : 1;
    /* en_override1700 - Bits[23:23], RWS_LB, default = 1'b0 
       Enable override at UCLK = 1700 or URATIO = 51.
     */
    UINT32 override1800 : 7;
    /* override1800 - Bits[30:24], RWS_LB, default = 7'b0 
       Override value at UCLK = 1800 or URATIO = 54.
     */
    UINT32 en_override1800 : 1;
    /* en_override1800 - Bits[31:31], RWS_LB, default = 1'b0 
       Enable override at UCLK = 1800 or URATIO = 54.
     */
  } Bits;
  UINT32 Data;
} MCBGF_U2D_OVER2_MC_MAIN_STRUCT;


/* MCBGF_U2D_OVER3_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x402506EC)                                                  */
/*       SKX (0x402506EC)                                                     */
/* Register default value:              0x00000000                            */
#define MCBGF_U2D_OVER3_MC_MAIN_REG 0x070046EC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Override value for slow down MC data rate at a given Memory frequency. 
 * Programmed by BIOS at start up when Memory frequency is known. 
 */
typedef union {
  struct {
    UINT32 override1900 : 7;
    /* override1900 - Bits[6:0], RWS_LB, default = 7'b0 
       Override value at UCLK = 1900 or URATIO = 57.
     */
    UINT32 en_override1900 : 1;
    /* en_override1900 - Bits[7:7], RWS_LB, default = 1'b0 
       Enable override at UCLK = 1900 or URATIO = 57.
     */
    UINT32 override2000 : 7;
    /* override2000 - Bits[14:8], RWS_LB, default = 7'b0 
       Override value at UCLK = 2000 or URATIO = 60.
     */
    UINT32 en_override2000 : 1;
    /* en_override2000 - Bits[15:15], RWS_LB, default = 1'b0 
       Enable override at UCLK = 2000 or URATIO = 60.
     */
    UINT32 override2100 : 7;
    /* override2100 - Bits[22:16], RWS_LB, default = 7'b0 
       Override value at UCLK = 2100 or URATIO = 63.
     */
    UINT32 en_override2100 : 1;
    /* en_override2100 - Bits[23:23], RWS_LB, default = 1'b0 
       Enable override at UCLK = 2100 or URATIO = 63.
     */
    UINT32 override2200 : 7;
    /* override2200 - Bits[30:24], RWS_LB, default = 7'b0 
       Override value at UCLK = 2200 or above (URATIO = 66 or above).
     */
    UINT32 en_override2200 : 1;
    /* en_override2200 - Bits[31:31], RWS_LB, default = 1'b0 
       Enable override at UCLK = 2200 or above (URATIO = 66 or above).
     */
  } Bits;
  UINT32 Data;
} MCBGF_U2D_OVER3_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG0_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x40250700)                                                  */
/*       SKX (0x40250700)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG0_MC_MAIN_REG 0x07004700
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG0_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG1_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x40250704)                                                  */
/*       SKX (0x40250704)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG1_MC_MAIN_REG 0x07004704
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG1_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG2_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x40250708)                                                  */
/*       SKX (0x40250708)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG2_MC_MAIN_REG 0x07004708
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG2_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG3_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x4025070C)                                                  */
/*       SKX (0x4025070C)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG3_MC_MAIN_REG 0x0700470C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG3_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG4_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x40250710)                                                  */
/*       SKX (0x40250710)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG4_MC_MAIN_REG 0x07004710
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG4_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG5_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x40250714)                                                  */
/*       SKX (0x40250714)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG5_MC_MAIN_REG 0x07004714
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG5_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG6_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x40250718)                                                  */
/*       SKX (0x40250718)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG6_MC_MAIN_REG 0x07004718
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG6_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG7_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x4025071C)                                                  */
/*       SKX (0x4025071C)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG7_MC_MAIN_REG 0x0700471C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG7_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG8_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x40250720)                                                  */
/*       SKX (0x40250720)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG8_MC_MAIN_REG 0x07004720
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG8_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG9_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x40250724)                                                  */
/*       SKX (0x40250724)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG9_MC_MAIN_REG 0x07004724
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG9_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG10_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250728)                                                  */
/*       SKX (0x40250728)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG10_MC_MAIN_REG 0x07004728
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG10_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG11_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x4025072C)                                                  */
/*       SKX (0x4025072C)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG11_MC_MAIN_REG 0x0700472C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG11_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG12_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250730)                                                  */
/*       SKX (0x40250730)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG12_MC_MAIN_REG 0x07004730
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG12_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG13_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250734)                                                  */
/*       SKX (0x40250734)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG13_MC_MAIN_REG 0x07004734
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG13_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG14_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250738)                                                  */
/*       SKX (0x40250738)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG14_MC_MAIN_REG 0x07004738
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG14_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG15_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x4025073C)                                                  */
/*       SKX (0x4025073C)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG15_MC_MAIN_REG 0x0700473C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG15_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG16_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250740)                                                  */
/*       SKX (0x40250740)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG16_MC_MAIN_REG 0x07004740
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG16_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG17_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250744)                                                  */
/*       SKX (0x40250744)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG17_MC_MAIN_REG 0x07004744
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG17_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG18_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250748)                                                  */
/*       SKX (0x40250748)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG18_MC_MAIN_REG 0x07004748
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG18_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG19_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x4025074C)                                                  */
/*       SKX (0x4025074C)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG19_MC_MAIN_REG 0x0700474C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG19_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG20_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250750)                                                  */
/*       SKX (0x40250750)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG20_MC_MAIN_REG 0x07004750
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG20_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG21_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250754)                                                  */
/*       SKX (0x40250754)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG21_MC_MAIN_REG 0x07004754
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG21_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG22_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250758)                                                  */
/*       SKX (0x40250758)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG22_MC_MAIN_REG 0x07004758
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG22_MC_MAIN_STRUCT;


/* DRAM_RULE_CFG23_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x4025075C)                                                  */
/*       SKX (0x4025075C)                                                     */
/* Register default value:              0x00000000                            */
#define DRAM_RULE_CFG23_MC_MAIN_REG 0x0700475C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  
 *           24 instances of DRAM_RULE_CFG, one for each of the existing DRAM 
 * decoder  
 *           Used for 2LM and Write-Through Fill and Evict flows.
 *       
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 1'b0 
       Enable for this DRAM rule.
     */
    UINT32 interleave_mode : 2;
    /* interleave_mode - Bits[2:1], RW_LB, default = 2'b0 
       DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index 
       into the corresponding interleave_list to determain which package the DRAM 
       belongs to. This mode selects how that number is computed. 00: Address bits 
       {8,7,6}. 01: Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address 
       bits {32,31,30} 
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_asamod2 : 2;
    /* mod3_asamod2 - Bits[6:5], RW_LB, default = 2'b0 
       2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case, 
       several options available, depending on how the mod2 result is mapped to 2 of 
       the 3 possible channels. 
                   00->use mod3;
                   01->use mod2, channels 0,1;
                   10->use mod2, channels 1,2;
                   11->use mod2, channels 0,2;
               
     */
    UINT32 limit : 20;
    /* limit - Bits[26:7], RW_LB, default = 20'b00000000000000000000 
       This correspond to Addr[45:26] of the DRAM rule top limit address. Must be 
       strickly greater then previous rule, even if this rule is disabled, unless this 
       rule and all following rules are disabled. Lower limit is the previous rule (or 
       0 if this is the first rule) 
     */
    UINT32 mod3 : 1;
    /* mod3 - Bits[27:27], RW_LB, default = 1'b0 
       Use mod3/mod2 in target idx calculation
     */
    UINT32 rsvd_28 : 2;
    /* rsvd_28 - Bits[29:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mod3_mode : 2;
    /* mod3_mode - Bits[31:30], RW_LB, default = 2'b00 
       Define the range of bits used for the mod3/mod2 calculation.
                   00->Compute mod3/mod2 over PA[45:6]
                   01->Compute mod3/mod2 over PA[45:8]
                   10->Compute mod3/mod2 over PA[45:12]
                   11->Unused
               
     */
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG23_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG0_MC_MAIN_REG supported on:                             */
/*       SKX_A0 (0x40250760)                                                  */
/*       SKX (0x40250760)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG0_MC_MAIN_REG 0x07004760
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG0_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG1_MC_MAIN_REG supported on:                             */
/*       SKX_A0 (0x40250764)                                                  */
/*       SKX (0x40250764)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG1_MC_MAIN_REG 0x07004764
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG1_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG2_MC_MAIN_REG supported on:                             */
/*       SKX_A0 (0x40250768)                                                  */
/*       SKX (0x40250768)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG2_MC_MAIN_REG 0x07004768
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG2_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG3_MC_MAIN_REG supported on:                             */
/*       SKX_A0 (0x4025076C)                                                  */
/*       SKX (0x4025076C)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG3_MC_MAIN_REG 0x0700476C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG3_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG4_MC_MAIN_REG supported on:                             */
/*       SKX_A0 (0x40250770)                                                  */
/*       SKX (0x40250770)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG4_MC_MAIN_REG 0x07004770
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG4_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG5_MC_MAIN_REG supported on:                             */
/*       SKX_A0 (0x40250774)                                                  */
/*       SKX (0x40250774)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG5_MC_MAIN_REG 0x07004774
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG5_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG6_MC_MAIN_REG supported on:                             */
/*       SKX_A0 (0x40250778)                                                  */
/*       SKX (0x40250778)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG6_MC_MAIN_REG 0x07004778
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG6_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG7_MC_MAIN_REG supported on:                             */
/*       SKX_A0 (0x4025077C)                                                  */
/*       SKX (0x4025077C)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG7_MC_MAIN_REG 0x0700477C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG7_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG8_MC_MAIN_REG supported on:                             */
/*       SKX_A0 (0x40250780)                                                  */
/*       SKX (0x40250780)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG8_MC_MAIN_REG 0x07004780
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG8_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG9_MC_MAIN_REG supported on:                             */
/*       SKX_A0 (0x40250784)                                                  */
/*       SKX (0x40250784)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG9_MC_MAIN_REG 0x07004784
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG9_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG10_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x40250788)                                                  */
/*       SKX (0x40250788)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG10_MC_MAIN_REG 0x07004788
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG10_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG11_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x4025078C)                                                  */
/*       SKX (0x4025078C)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG11_MC_MAIN_REG 0x0700478C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG11_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG12_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x40250790)                                                  */
/*       SKX (0x40250790)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG12_MC_MAIN_REG 0x07004790
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG12_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG13_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x40250794)                                                  */
/*       SKX (0x40250794)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG13_MC_MAIN_REG 0x07004794
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG13_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG14_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x40250798)                                                  */
/*       SKX (0x40250798)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG14_MC_MAIN_REG 0x07004798
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG14_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG15_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x4025079C)                                                  */
/*       SKX (0x4025079C)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG15_MC_MAIN_REG 0x0700479C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG15_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG16_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x402507A0)                                                  */
/*       SKX (0x402507A0)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG16_MC_MAIN_REG 0x070047A0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG16_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG17_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x402507A4)                                                  */
/*       SKX (0x402507A4)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG17_MC_MAIN_REG 0x070047A4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG17_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG18_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x402507A8)                                                  */
/*       SKX (0x402507A8)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG18_MC_MAIN_REG 0x070047A8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG18_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG19_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x402507AC)                                                  */
/*       SKX (0x402507AC)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG19_MC_MAIN_REG 0x070047AC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG19_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG20_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x402507B0)                                                  */
/*       SKX (0x402507B0)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG20_MC_MAIN_REG 0x070047B0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG20_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG21_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x402507B4)                                                  */
/*       SKX (0x402507B4)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG21_MC_MAIN_REG 0x070047B4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG21_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG22_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x402507B8)                                                  */
/*       SKX (0x402507B8)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG22_MC_MAIN_REG 0x070047B8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG22_MC_MAIN_STRUCT;


/* INTERLEAVE_LIST_CFG23_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x402507BC)                                                  */
/*       SKX (0x402507BC)                                                     */
/* Register default value:              0x00000000                            */
#define INTERLEAVE_LIST_CFG23_MC_MAIN_REG 0x070047BC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 package0 : 4;
    /* package0 - Bits[3:0], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package1 : 4;
    /* package1 - Bits[7:4], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package2 : 4;
    /* package2 - Bits[11:8], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package3 : 4;
    /* package3 - Bits[15:12], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package4 : 4;
    /* package4 - Bits[19:16], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package5 : 4;
    /* package5 - Bits[23:20], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package6 : 4;
    /* package6 - Bits[27:24], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
    UINT32 package7 : 4;
    /* package7 - Bits[31:28], RW_LB, default = 3'b000 
       Interleave list target.  Encoding is as follows:
                   4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
                   4b'1xyz  -  target is a local memory controller which maps to 
       MC_ROUTE_TABLE index 3b'xyz 
                   Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is 
       actually {mod3[1:0],z} (i.e., xy is ignored) 
     */
  } Bits;
  UINT32 Data;
} INTERLEAVE_LIST_CFG23_MC_MAIN_STRUCT;


/* MC_ROUTE_TABLE_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x402507C0)                                                  */
/*       SKX (0x402507C0)                                                     */
/* Register default value:              0x00000000                            */
#define MC_ROUTE_TABLE_MC_MAIN_REG 0x070047C0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 12;
    /* rsvd_0 - Bits[11:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 channelid0 : 2;
    /* channelid0 - Bits[13:12], RW_LB, default = 2'b00 
       Physical Channel ID
     */
    UINT32 channelid1 : 2;
    /* channelid1 - Bits[15:14], RW_LB, default = 2'b00 
       Physical Channel ID
     */
    UINT32 channelid2 : 2;
    /* channelid2 - Bits[17:16], RW_LB, default = 2'b00 
       Physical Channel ID
     */
    UINT32 channelid3 : 2;
    /* channelid3 - Bits[19:18], RW_LB, default = 2'b00 
       Physical Channel ID
     */
    UINT32 channelid4 : 2;
    /* channelid4 - Bits[21:20], RW_LB, default = 2'b00 
       Physical Channel ID
     */
    UINT32 channelid5 : 2;
    /* channelid5 - Bits[23:22], RW_LB, default = 2'b00 
       Physical Channel ID
     */
    UINT32 rsvd_24 : 8;
    /* rsvd_24 - Bits[31:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MC_ROUTE_TABLE_MC_MAIN_STRUCT;


/* SCRUBMASK2_MC_MAIN_REG supported on:                                       */
/*       SKX_A0 (0x402507C4)                                                  */
/*       SKX (0x402507C4)                                                     */
/* Register default value:              0x00000000                            */
#define SCRUBMASK2_MC_MAIN_REG 0x070047C4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * This register contains fields to make channels/ranks from patrol scrub engine.
 */
typedef union {
  struct {
    UINT32 ch0_rank_dec : 8;
    /* ch0_rank_dec - Bits[7:0], RW_L, default = 8'b00000000 
       Rank to skip for channel 0. Each bit represents one rank and set to 1 to skip 
       the rank. This field is used when scrubmask.ch_mask is not set. 
     */
    UINT32 ch1_rank_dec : 8;
    /* ch1_rank_dec - Bits[15:8], RW_L, default = 8'b00000000 
       Rank to skip for channel 1. Each bit represents one rank and set to 1 to skip 
       the rank. This field is used when scrubmask.ch_mask is not set. 
     */
    UINT32 ch2_rank_dec : 8;
    /* ch2_rank_dec - Bits[23:16], RW_L, default = 8'b00000000 
       Rank to skip for channel 2. Each bit represents one rank and set to 1 to skip 
       the rank. This field is used when scrubmask.ch_mask is not set. 
     */
    UINT32 rsvd : 8;
    /* rsvd - Bits[31:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SCRUBMASK2_MC_MAIN_STRUCT;


/* MCNMCACHINGCFG_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x40250800)                                                  */
/*       SKX (0x40250800)                                                     */
/* Register default value:              0x00000000                            */
#define MCNMCACHINGCFG_MC_MAIN_REG 0x07004800
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * MC 2LM Configuration Register
 */
typedef union {
  struct {
    UINT32 mcnmcachingenb : 1;
    /* mcnmcachingenb - Bits[0:0], RW_L, default = 1'b0 
       Enables 2LM near memory caching of far memory if set. Locked by 2LM disable uCR. 
       This field is programmed on the per iMC basis, i.e. need to maintain consistency 
       with other populated channels in this iMC.  A related register - McNMCachingCfg2 
       - is per channel and is located in MC2LMCNTL block. 
     */
    UINT32 mcpmemenb : 1;
    /* mcpmemenb - Bits[1:1], RW_L, default = 1'b0 
       1LM or 2LM mode but with AG2 memory enabled if set. Locked by PMem disable uCR. 
       This field is programmed on the per iMC basis, i.e. need to maintain consistency 
       with other populated channels in this iMC. 
     */
    UINT32 mcnmcachingpmemwt : 1;
    /* mcnmcachingpmemwt - Bits[2:2], RW_L, default = 1'b0 
       For PMem transactions, write to both near and far memory if set. Locked by PMem 
       Write-Thru disable uCR. This field is programmed on the per iMC basis, i.e. need 
       to maintain consistency with other populated channels in this iMC. 
     */
    UINT32 rsvd_3 : 5;
    /* rsvd_3 - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mcmirrormode : 1;
    /* mcmirrormode - Bits[8:8], RW_L, default = 1'b0 
       Configured for mirroring - far memory is in the same channel as near memory if 
       set. Locked by mirroring disable uCR. This field is programmed on the per iMC 
       basis, i.e. need to maintain consistency with other populated channels in this 
       iMC. 
     */
    UINT32 rsvd_9 : 23;
    /* rsvd_9 - Bits[31:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCNMCACHINGCFG_MC_MAIN_STRUCT;


/* TADBASE_0_MC_MAIN_REG supported on:                                        */
/*       SKX_A0 (0x40250850)                                                  */
/*       SKX (0x40250850)                                                     */
/* Register default value:              0x00000000                            */
#define TADBASE_0_MC_MAIN_REG 0x07004850
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are total of 8 TAD ranges for DRAM memory.
 *                    This part of the TAD defines the system address Base of each 
 * range. 
 */
typedef union {
  struct {
    UINT32 base_offset : 3;
    /* base_offset - Bits[2:0], RW_LB, default = 3'b000 
       The position of the MC in the socket interleave list in the SAD rule that maps 
       to this TAD rule. 
                            If 1-way interleaved to one MC, base_offset is 0.
       		     If 2-way interleaved across two MCs, base_offset is either 0 or 1.
       		     4-way, 0 through 3.  8-way, 0 through 7.
     */
    UINT32 mirror_en : 1;
    /* mirror_en - Bits[3:3], RW_LB, default = 1'b0 
       
                     Mirroring enabled on this TAD
                 
     */
    UINT32 skt_granularity : 2;
    /* skt_granularity - Bits[5:4], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the skt_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11   1GB (based off PA[30] and up) {used for PMem only, though 
       the standard PMem mode will be 4KB) 
                 
     */
    UINT32 chn_granularity : 2;
    /* chn_granularity - Bits[7:6], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the chn_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11  reserved
                 
     */
    UINT32 en_failover : 1;
    /* en_failover - Bits[8:8], RW_LB, default = 1'b0 
       
                     Set to 1 to indicate mirror failover happened on this TAD. Patrol 
       address to the channel programmed in failed_ch for this TAD will be skipped. 
                 
     */
    UINT32 ign_ptrl_uc : 1;
    /* ign_ptrl_uc - Bits[9:9], RW_LB, default = 1'b0 
       
                     Downgrades patrol scrubbing uncorrectable errors to correactable 
       for this TAD range. Use for partial mirroring mode. 
                 
     */
    UINT32 failed_ch : 2;
    /* failed_ch - Bits[11:10], RW_LB, default = 2'b00 
       
                     Used when en_failover bit is set for this TAD. Indicates the 
       channel that has failed. 
                 
     */
    UINT32 base : 20;
    /* base - Bits[31:12], RW_LB, default = 20'b00000000000000000000 
       lowest address of the range in system address space, 64MB granularity, i.e. 
       TADRANGEBASE[45:26]. 
     */
  } Bits;
  UINT32 Data;
} TADBASE_0_MC_MAIN_STRUCT;


/* TADBASE_1_MC_MAIN_REG supported on:                                        */
/*       SKX_A0 (0x40250854)                                                  */
/*       SKX (0x40250854)                                                     */
/* Register default value:              0x00000000                            */
#define TADBASE_1_MC_MAIN_REG 0x07004854
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are total of 8 TAD ranges for DRAM memory.
 *                    This part of the TAD defines the system address Base of each 
 * range. 
 */
typedef union {
  struct {
    UINT32 base_offset : 3;
    /* base_offset - Bits[2:0], RW_LB, default = 3'b000 
       The position of the MC in the socket interleave list in the SAD rule that maps 
       to this TAD rule. 
                            If 1-way interleaved to one MC, base_offset is 0.
       		     If 2-way interleaved across two MCs, base_offset is either 0 or 1.
       		     4-way, 0 through 3.  8-way, 0 through 7.
     */
    UINT32 mirror_en : 1;
    /* mirror_en - Bits[3:3], RW_LB, default = 1'b0 
       
                     Mirroring enabled on this TAD
                 
     */
    UINT32 skt_granularity : 2;
    /* skt_granularity - Bits[5:4], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the skt_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11   1GB (based off PA[30] and up) {used for PMem only, though 
       the standard PMem mode will be 4KB) 
                 
     */
    UINT32 chn_granularity : 2;
    /* chn_granularity - Bits[7:6], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the chn_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11  reserved
                 
     */
    UINT32 en_failover : 1;
    /* en_failover - Bits[8:8], RW_LB, default = 1'b0 
       
                     Set to 1 to indicate mirror failover happened on this TAD. Patrol 
       address to the channel programmed in failed_ch for this TAD will be skipped. 
                 
     */
    UINT32 ign_ptrl_uc : 1;
    /* ign_ptrl_uc - Bits[9:9], RW_LB, default = 1'b0 
       
                     Downgrades patrol scrubbing uncorrectable errors to correactable 
       for this TAD range. Use for partial mirroring mode. 
                 
     */
    UINT32 failed_ch : 2;
    /* failed_ch - Bits[11:10], RW_LB, default = 2'b00 
       
                     Used when en_failover bit is set for this TAD. Indicates the 
       channel that has failed. 
                 
     */
    UINT32 base : 20;
    /* base - Bits[31:12], RW_LB, default = 20'b00000000000000000000 
       lowest address of the range in system address space, 64MB granularity, i.e. 
       TADRANGEBASE[45:26]. 
     */
  } Bits;
  UINT32 Data;
} TADBASE_1_MC_MAIN_STRUCT;


/* TADBASE_2_MC_MAIN_REG supported on:                                        */
/*       SKX_A0 (0x40250858)                                                  */
/*       SKX (0x40250858)                                                     */
/* Register default value:              0x00000000                            */
#define TADBASE_2_MC_MAIN_REG 0x07004858
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are total of 8 TAD ranges for DRAM memory.
 *                    This part of the TAD defines the system address Base of each 
 * range. 
 */
typedef union {
  struct {
    UINT32 base_offset : 3;
    /* base_offset - Bits[2:0], RW_LB, default = 3'b000 
       The position of the MC in the socket interleave list in the SAD rule that maps 
       to this TAD rule. 
                            If 1-way interleaved to one MC, base_offset is 0.
       		     If 2-way interleaved across two MCs, base_offset is either 0 or 1.
       		     4-way, 0 through 3.  8-way, 0 through 7.
     */
    UINT32 mirror_en : 1;
    /* mirror_en - Bits[3:3], RW_LB, default = 1'b0 
       
                     Mirroring enabled on this TAD
                 
     */
    UINT32 skt_granularity : 2;
    /* skt_granularity - Bits[5:4], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the skt_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11   1GB (based off PA[30] and up) {used for PMem only, though 
       the standard PMem mode will be 4KB) 
                 
     */
    UINT32 chn_granularity : 2;
    /* chn_granularity - Bits[7:6], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the chn_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11  reserved
                 
     */
    UINT32 en_failover : 1;
    /* en_failover - Bits[8:8], RW_LB, default = 1'b0 
       
                     Set to 1 to indicate mirror failover happened on this TAD. Patrol 
       address to the channel programmed in failed_ch for this TAD will be skipped. 
                 
     */
    UINT32 ign_ptrl_uc : 1;
    /* ign_ptrl_uc - Bits[9:9], RW_LB, default = 1'b0 
       
                     Downgrades patrol scrubbing uncorrectable errors to correactable 
       for this TAD range. Use for partial mirroring mode. 
                 
     */
    UINT32 failed_ch : 2;
    /* failed_ch - Bits[11:10], RW_LB, default = 2'b00 
       
                     Used when en_failover bit is set for this TAD. Indicates the 
       channel that has failed. 
                 
     */
    UINT32 base : 20;
    /* base - Bits[31:12], RW_LB, default = 20'b00000000000000000000 
       lowest address of the range in system address space, 64MB granularity, i.e. 
       TADRANGEBASE[45:26]. 
     */
  } Bits;
  UINT32 Data;
} TADBASE_2_MC_MAIN_STRUCT;


/* TADBASE_3_MC_MAIN_REG supported on:                                        */
/*       SKX_A0 (0x4025085C)                                                  */
/*       SKX (0x4025085C)                                                     */
/* Register default value:              0x00000000                            */
#define TADBASE_3_MC_MAIN_REG 0x0700485C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are total of 8 TAD ranges for DRAM memory.
 *                    This part of the TAD defines the system address Base of each 
 * range. 
 */
typedef union {
  struct {
    UINT32 base_offset : 3;
    /* base_offset - Bits[2:0], RW_LB, default = 3'b000 
       The position of the MC in the socket interleave list in the SAD rule that maps 
       to this TAD rule. 
                            If 1-way interleaved to one MC, base_offset is 0.
       		     If 2-way interleaved across two MCs, base_offset is either 0 or 1.
       		     4-way, 0 through 3.  8-way, 0 through 7.
     */
    UINT32 mirror_en : 1;
    /* mirror_en - Bits[3:3], RW_LB, default = 1'b0 
       
                     Mirroring enabled on this TAD
                 
     */
    UINT32 skt_granularity : 2;
    /* skt_granularity - Bits[5:4], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the skt_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11   1GB (based off PA[30] and up) {used for PMem only, though 
       the standard PMem mode will be 4KB) 
                 
     */
    UINT32 chn_granularity : 2;
    /* chn_granularity - Bits[7:6], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the chn_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11  reserved
                 
     */
    UINT32 en_failover : 1;
    /* en_failover - Bits[8:8], RW_LB, default = 1'b0 
       
                     Set to 1 to indicate mirror failover happened on this TAD. Patrol 
       address to the channel programmed in failed_ch for this TAD will be skipped. 
                 
     */
    UINT32 ign_ptrl_uc : 1;
    /* ign_ptrl_uc - Bits[9:9], RW_LB, default = 1'b0 
       
                     Downgrades patrol scrubbing uncorrectable errors to correactable 
       for this TAD range. Use for partial mirroring mode. 
                 
     */
    UINT32 failed_ch : 2;
    /* failed_ch - Bits[11:10], RW_LB, default = 2'b00 
       
                     Used when en_failover bit is set for this TAD. Indicates the 
       channel that has failed. 
                 
     */
    UINT32 base : 20;
    /* base - Bits[31:12], RW_LB, default = 20'b00000000000000000000 
       lowest address of the range in system address space, 64MB granularity, i.e. 
       TADRANGEBASE[45:26]. 
     */
  } Bits;
  UINT32 Data;
} TADBASE_3_MC_MAIN_STRUCT;


/* TADBASE_4_MC_MAIN_REG supported on:                                        */
/*       SKX_A0 (0x40250860)                                                  */
/*       SKX (0x40250860)                                                     */
/* Register default value:              0x00000000                            */
#define TADBASE_4_MC_MAIN_REG 0x07004860
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are total of 8 TAD ranges for DRAM memory.
 *                    This part of the TAD defines the system address Base of each 
 * range. 
 */
typedef union {
  struct {
    UINT32 base_offset : 3;
    /* base_offset - Bits[2:0], RW_LB, default = 3'b000 
       The position of the MC in the socket interleave list in the SAD rule that maps 
       to this TAD rule. 
                            If 1-way interleaved to one MC, base_offset is 0.
       		     If 2-way interleaved across two MCs, base_offset is either 0 or 1.
       		     4-way, 0 through 3.  8-way, 0 through 7.
     */
    UINT32 mirror_en : 1;
    /* mirror_en - Bits[3:3], RW_LB, default = 1'b0 
       
                     Mirroring enabled on this TAD
                 
     */
    UINT32 skt_granularity : 2;
    /* skt_granularity - Bits[5:4], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the skt_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11   1GB (based off PA[30] and up) {used for PMem only, though 
       the standard PMem mode will be 4KB) 
                 
     */
    UINT32 chn_granularity : 2;
    /* chn_granularity - Bits[7:6], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the chn_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11  reserved
                 
     */
    UINT32 en_failover : 1;
    /* en_failover - Bits[8:8], RW_LB, default = 1'b0 
       
                     Set to 1 to indicate mirror failover happened on this TAD. Patrol 
       address to the channel programmed in failed_ch for this TAD will be skipped. 
                 
     */
    UINT32 ign_ptrl_uc : 1;
    /* ign_ptrl_uc - Bits[9:9], RW_LB, default = 1'b0 
       
                     Downgrades patrol scrubbing uncorrectable errors to correactable 
       for this TAD range. Use for partial mirroring mode. 
                 
     */
    UINT32 failed_ch : 2;
    /* failed_ch - Bits[11:10], RW_LB, default = 2'b00 
       
                     Used when en_failover bit is set for this TAD. Indicates the 
       channel that has failed. 
                 
     */
    UINT32 base : 20;
    /* base - Bits[31:12], RW_LB, default = 20'b00000000000000000000 
       lowest address of the range in system address space, 64MB granularity, i.e. 
       TADRANGEBASE[45:26]. 
     */
  } Bits;
  UINT32 Data;
} TADBASE_4_MC_MAIN_STRUCT;


/* TADBASE_5_MC_MAIN_REG supported on:                                        */
/*       SKX_A0 (0x40250864)                                                  */
/*       SKX (0x40250864)                                                     */
/* Register default value:              0x00000000                            */
#define TADBASE_5_MC_MAIN_REG 0x07004864
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are total of 8 TAD ranges for DRAM memory.
 *                    This part of the TAD defines the system address Base of each 
 * range. 
 */
typedef union {
  struct {
    UINT32 base_offset : 3;
    /* base_offset - Bits[2:0], RW_LB, default = 3'b000 
       The position of the MC in the socket interleave list in the SAD rule that maps 
       to this TAD rule. 
                            If 1-way interleaved to one MC, base_offset is 0.
       		     If 2-way interleaved across two MCs, base_offset is either 0 or 1.
       		     4-way, 0 through 3.  8-way, 0 through 7.
     */
    UINT32 mirror_en : 1;
    /* mirror_en - Bits[3:3], RW_LB, default = 1'b0 
       
                     Mirroring enabled on this TAD
                 
     */
    UINT32 skt_granularity : 2;
    /* skt_granularity - Bits[5:4], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the skt_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11   1GB (based off PA[30] and up) {used for PMem only, though 
       the standard PMem mode will be 4KB) 
                 
     */
    UINT32 chn_granularity : 2;
    /* chn_granularity - Bits[7:6], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the chn_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11  reserved
                 
     */
    UINT32 en_failover : 1;
    /* en_failover - Bits[8:8], RW_LB, default = 1'b0 
       
                     Set to 1 to indicate mirror failover happened on this TAD. Patrol 
       address to the channel programmed in failed_ch for this TAD will be skipped. 
                 
     */
    UINT32 ign_ptrl_uc : 1;
    /* ign_ptrl_uc - Bits[9:9], RW_LB, default = 1'b0 
       
                     Downgrades patrol scrubbing uncorrectable errors to correactable 
       for this TAD range. Use for partial mirroring mode. 
                 
     */
    UINT32 failed_ch : 2;
    /* failed_ch - Bits[11:10], RW_LB, default = 2'b00 
       
                     Used when en_failover bit is set for this TAD. Indicates the 
       channel that has failed. 
                 
     */
    UINT32 base : 20;
    /* base - Bits[31:12], RW_LB, default = 20'b00000000000000000000 
       lowest address of the range in system address space, 64MB granularity, i.e. 
       TADRANGEBASE[45:26]. 
     */
  } Bits;
  UINT32 Data;
} TADBASE_5_MC_MAIN_STRUCT;


/* TADBASE_6_MC_MAIN_REG supported on:                                        */
/*       SKX_A0 (0x40250868)                                                  */
/*       SKX (0x40250868)                                                     */
/* Register default value:              0x00000000                            */
#define TADBASE_6_MC_MAIN_REG 0x07004868
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are total of 8 TAD ranges for DRAM memory.
 *                    This part of the TAD defines the system address Base of each 
 * range. 
 */
typedef union {
  struct {
    UINT32 base_offset : 3;
    /* base_offset - Bits[2:0], RW_LB, default = 3'b000 
       The position of the MC in the socket interleave list in the SAD rule that maps 
       to this TAD rule. 
                            If 1-way interleaved to one MC, base_offset is 0.
       		     If 2-way interleaved across two MCs, base_offset is either 0 or 1.
       		     4-way, 0 through 3.  8-way, 0 through 7.
     */
    UINT32 mirror_en : 1;
    /* mirror_en - Bits[3:3], RW_LB, default = 1'b0 
       
                     Mirroring enabled on this TAD
                 
     */
    UINT32 skt_granularity : 2;
    /* skt_granularity - Bits[5:4], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the skt_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11   1GB (based off PA[30] and up) {used for PMem only, though 
       the standard PMem mode will be 4KB) 
                 
     */
    UINT32 chn_granularity : 2;
    /* chn_granularity - Bits[7:6], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the chn_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11  reserved
                 
     */
    UINT32 en_failover : 1;
    /* en_failover - Bits[8:8], RW_LB, default = 1'b0 
       
                     Set to 1 to indicate mirror failover happened on this TAD. Patrol 
       address to the channel programmed in failed_ch for this TAD will be skipped. 
                 
     */
    UINT32 ign_ptrl_uc : 1;
    /* ign_ptrl_uc - Bits[9:9], RW_LB, default = 1'b0 
       
                     Downgrades patrol scrubbing uncorrectable errors to correactable 
       for this TAD range. Use for partial mirroring mode. 
                 
     */
    UINT32 failed_ch : 2;
    /* failed_ch - Bits[11:10], RW_LB, default = 2'b00 
       
                     Used when en_failover bit is set for this TAD. Indicates the 
       channel that has failed. 
                 
     */
    UINT32 base : 20;
    /* base - Bits[31:12], RW_LB, default = 20'b00000000000000000000 
       lowest address of the range in system address space, 64MB granularity, i.e. 
       TADRANGEBASE[45:26]. 
     */
  } Bits;
  UINT32 Data;
} TADBASE_6_MC_MAIN_STRUCT;


/* TADBASE_7_MC_MAIN_REG supported on:                                        */
/*       SKX_A0 (0x4025086C)                                                  */
/*       SKX (0x4025086C)                                                     */
/* Register default value:              0x00000000                            */
#define TADBASE_7_MC_MAIN_REG 0x0700486C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are total of 8 TAD ranges for DRAM memory.
 *                    This part of the TAD defines the system address Base of each 
 * range. 
 */
typedef union {
  struct {
    UINT32 base_offset : 3;
    /* base_offset - Bits[2:0], RW_LB, default = 3'b000 
       The position of the MC in the socket interleave list in the SAD rule that maps 
       to this TAD rule. 
                            If 1-way interleaved to one MC, base_offset is 0.
       		     If 2-way interleaved across two MCs, base_offset is either 0 or 1.
       		     4-way, 0 through 3.  8-way, 0 through 7.
     */
    UINT32 mirror_en : 1;
    /* mirror_en - Bits[3:3], RW_LB, default = 1'b0 
       
                     Mirroring enabled on this TAD
                 
     */
    UINT32 skt_granularity : 2;
    /* skt_granularity - Bits[5:4], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the skt_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11   1GB (based off PA[30] and up) {used for PMem only, though 
       the standard PMem mode will be 4KB) 
                 
     */
    UINT32 chn_granularity : 2;
    /* chn_granularity - Bits[7:6], RW_LB, default = 2'b00 
       
                     Specifies the granularity of the chn_way interleave
                     b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
                     b'01  256B (based off PA[8] and up)  (used for 1LM only)
                     b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and 
       Block/DDRT_CSR) 
                     b'11  reserved
                 
     */
    UINT32 en_failover : 1;
    /* en_failover - Bits[8:8], RW_LB, default = 1'b0 
       
                     Set to 1 to indicate mirror failover happened on this TAD. Patrol 
       address to the channel programmed in failed_ch for this TAD will be skipped. 
                 
     */
    UINT32 ign_ptrl_uc : 1;
    /* ign_ptrl_uc - Bits[9:9], RW_LB, default = 1'b0 
       
                     Downgrades patrol scrubbing uncorrectable errors to correactable 
       for this TAD range. Use for partial mirroring mode. 
                 
     */
    UINT32 failed_ch : 2;
    /* failed_ch - Bits[11:10], RW_LB, default = 2'b00 
       
                     Used when en_failover bit is set for this TAD. Indicates the 
       channel that has failed. 
                 
     */
    UINT32 base : 20;
    /* base - Bits[31:12], RW_LB, default = 20'b00000000000000000000 
       lowest address of the range in system address space, 64MB granularity, i.e. 
       TADRANGEBASE[45:26]. 
     */
  } Bits;
  UINT32 Data;
} TADBASE_7_MC_MAIN_STRUCT;


/* MCMTR_MC_MAIN_REG supported on:                                            */
/*       SKX_A0 (0x4025087C)                                                  */
/*       SKX (0x4025087C)                                                     */
/* Register default value:              0x00000000                            */
#define MCMTR_MC_MAIN_REG 0x0700487C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * generated by critter 19_0_0x07c
 */
typedef union {
  struct {
    UINT32 close_pg : 1;
    /* close_pg - Bits[0:0], RWS_LB, default = 1'b0 
       Use close page address mapping if set; otherwise, open page.
     */
    UINT32 ls_en : 1;
    /* ls_en - Bits[1:1], RWS_LBV, default = 1'b0 
        Not used in SKX.  Do not set.  Do not set for static Virtual Lockstep.
     */
    UINT32 ecc_en : 1;
    /* ecc_en - Bits[2:2], RWS_LBV, default = 1'b0 
       ECC enable.
     */
    UINT32 dir_en : 1;
    /* dir_en - Bits[3:3], RWS_LBV, default = 1'b0 
       Directory Enable. Read-Only (RO) with 0 value if not supported. 
               
     */
    UINT32 rsvd_4 : 4;
    /* rsvd_4 - Bits[7:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 normal : 1;
    /* normal - Bits[8:8], RW_LB, default = 1'b0 
       0: Training mode
       1: Normal Mode
     */
    UINT32 bank_xor_enable : 1;
    /* bank_xor_enable - Bits[9:9], RWS_LB, default = 1'b0 
       When set, this bit will enable bank XOR'ing. This is targeted at workloads that 
       bank thrashing caused by certain stride or page mappings. If one detects 
       unexpectedly poor page hit rates, one can attempt to flip this bit to see if it 
       helps. 
       [0]: Our base configuration. Bank selection is done using rank address bits 
       12:17:18 for open page mapping and bits 6:7:8 for close page mapping. 
       [1]: Bank XOR'ing enabled. Bank selection is done using rank address bits:
       (12^19):(17^20):(18^21) for open page mapping
       (6^19):(7^20):(8^21) for close page mapping
     */
    UINT32 trng_mode : 2;
    /* trng_mode - Bits[11:10], RW_LB, default = 2'b00 
       00: reserved
       01: Native CPGC Mode. (mcmtr.normal must be zero for this mode)
       10: reserved
       11: Normal Mode (mcmtr.normal is a don't care for this mode)
     */
    UINT32 imc_mode : 2;
    /* imc_mode - Bits[13:12], RWS_LB, default = 2'b00 
       Memory mode:
       00: Native DDR
       01: Reserved
       10: Reserved
       11: Reserved
     */
    UINT32 rsvd_14 : 4;
    /* rsvd_14 - Bits[17:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 chn_disable : 3;
    /* chn_disable - Bits[20:18], RWS_LB, default = 3'b000 
       Channel disable control. When set, the corresponding channel is disabled. 
                   bit 0 - Ch0
                   bit 1 - Ch1
                   bit 2 - Ch2
                   Note: Message Channel may not work if all channels are set to 
       disable in this field. 
     */
    UINT32 rsvd_21 : 1;
    /* rsvd_21 - Bits[21:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ch23cmd_ctl_delay : 1;
    /* ch23cmd_ctl_delay - Bits[22:22], RWS_LB, default = 1'b0  */
    UINT32 rsvd_23 : 1;
    /* rsvd_23 - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 adddc_mode : 1;
    /* adddc_mode - Bits[24:24], RW_LB, default = 1'b0 
       In ADDDC mode. Memory transactions will not arrive back-to-back.
     */
    UINT32 trng_target : 3;
    /* trng_target - Bits[27:25], RW_LB, default = 3'b000 
       Per channel based target. 
                   0 = CPGC transactions go to DRAM scheduler.
                   1 = CPGC transactions go to DDRT scheduler.  
               
     */
    UINT32 enable_slot_use : 1;
    /* enable_slot_use - Bits[28:28], RW_LB, default = 1'b0 
       When set 1, and when uclk is less than dclk, enable issuing of read CAS and DDRT 
       GNT only in 
       certain slot. Should be set when DDRT DIMM is populated.
     */
    UINT32 rsvd_29 : 3;
    /* rsvd_29 - Bits[31:29], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCMTR_MC_MAIN_STRUCT;


/* TADWAYNESS_0_MC_MAIN_REG supported on:                                     */
/*       SKX_A0 (0x40250880)                                                  */
/*       SKX (0x40250880)                                                     */
/* Register default value:              0x00000000                            */
#define TADWAYNESS_0_MC_MAIN_REG 0x07004880
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are total of 8 TAD ranges 
 *           Note for mirroring configuration:
 *           For 1-way interleave, channel 0-2 mirror pair: target list = 
 * <0,2,x,x>, TAD ways = "00" 
 *           For 1-way interleave, channel 1-3 mirror pair: target list = 
 * <1,3,x,x>, TAD ways = "00" 
 *           For 2-way interleave, 0-2 mirror pair and 1-3 mirror pair: target list 
 * = <0,1,2,3>, TAD ways = "01" 
 *           For 1-way interleave, lockstep + mirroring, target list = <0,2,x,x>, 
 * TAD ways = "00" 
 */
typedef union {
  struct {
    UINT32 tad_ch_tgt0 : 2;
    /* tad_ch_tgt0 - Bits[1:0], RW_LB, default = 2'b00 
       Obsolete register in SKX.  Should be removed from SKX.  target channel for 
       channel interleave 0 (used for 1/2/3/4-way TAD interleaving). 
     */
    UINT32 tad_ch_tgt1 : 2;
    /* tad_ch_tgt1 - Bits[3:2], RW_LB, default = 2'b00 
       Obsolete register in SKX.  Should be removed from SKX.  target channel for 
       channel interleave 1 (used for 2/3/4-way TAD interleaving). 
     */
    UINT32 tad_ch_tgt2 : 2;
    /* tad_ch_tgt2 - Bits[5:4], RW_LB, default = 2'b00 
       Obsolete register in SKX.  Should be removed from SKX.  target channel for 
       channel interleave 2 (used for 3/4-way TAD interleaving). 
     */
    UINT32 tad_ch_tgt3 : 2;
    /* tad_ch_tgt3 - Bits[7:6], RW_LB, default = 2'b00 
       Obsolete register in SKX.  Should be removed from SKX.  target channel for 
       channel interleave 3 (used for 4-way TAD interleaving). 
       This register is used in the IMC only for reverse address translation for 
       logging spare/patrol errors, converting a rank address back to a system address. 
     */
    UINT32 tad_ch_way : 2;
    /* tad_ch_way - Bits[9:8], RW_LB, default = 2'b00 
       channel interleave wayness
       00 - interleave across 1 channel or mirror pair
       01 - interleave across 2 channels or mirror pairs
       10 - interleave across 3 channels
       11 - interleave across 4 channels
       Note: This parameter effectively tells IMC how much to divide the system address 
       by when adjusting for the channel interleave. Since both channels in a pair 
       store every line of data, we want to divide by 1 when interleaving across one 
       pair and 2 when interleaving across two pairs. For M2M, it tells how may 
       channels to distribute the read requests across. When we interleaving across 1 
       pair, we want to distribute the reads to two channels, when interleaving across 
       2 pairs, we distribute the reads across 4 pairs. Writes always go to both 
       channels in the pair when the read target is either channel. 
     */
    UINT32 tad_skt_way : 2;
    /* tad_skt_way - Bits[11:10], RW_LB, default = 2'b00 
       socket interleave wayness
       00 = 1 way,
       01 = 2 way,
       10 = 4 way,
       11 = 8 way.
     */
    UINT32 tad_limit : 20;
    /* tad_limit - Bits[31:12], RW_LB, default = 20'b00000000000000000000 
       highest address of the range in system address space, 64MB granularity, i.e. 
       TADRANGLIMIT[45:26]. 
     */
  } Bits;
  UINT32 Data;
} TADWAYNESS_0_MC_MAIN_STRUCT;


/* TADWAYNESS_1_MC_MAIN_REG supported on:                                     */
/*       SKX_A0 (0x40250884)                                                  */
/*       SKX (0x40250884)                                                     */
/* Register default value:              0x00000000                            */
#define TADWAYNESS_1_MC_MAIN_REG 0x07004884
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are total of 8 TAD ranges 
 * Note for mirroring configuration:
 * For 1-way interleave, channel 0-2 mirror pair: target list = <0,2,x,x>, TAD ways 
 * = "00" 
 * For 1-way interleave, channel 1-3 mirror pair: target list = <1,3,x,x>, TAD ways 
 * = "00" 
 * For 2-way interleave, 0-2 mirror pair and 1-3 mirror pair: target list = 
 * <0,1,2,3>, TAD ways = "01" 
 * For 1-way interleave, lockstep + mirroring, target list = <0,2,x,x>, TAD ways = 
 * "00" 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 8;
    UINT32 tad_ch_way : 2;
    /* tad_ch_way - Bits[9:8], RW_LB, default = 2'b00 
       channel interleave wayness
       00 - interleave across 1 channel or mirror pair
       01 - interleave across 2 channels or mirror pairs
       10 - interleave across 3 channels
       11 - interleave across 4 channels
       Note: This parameter effectively tells IMC how much to divide the system address 
       by when adjusting for the channel interleave. Since both channels in a pair 
       store every line of data, we want to divide by 1 when interleaving across one 
       pair and 2 when interleaving across two pairs. For M2M, it tells how may 
       channels to distribute the read requests across. When we interleaving across 1 
       pair, we want to distribute the reads to two channels, when interleaving across 
       2 pairs, we distribute the reads across 4 pairs. Writes always go to both 
       channels in the pair when the read target is either channel. 
     */
    UINT32 tad_skt_way : 2;
    /* tad_skt_way - Bits[11:10], RW_LB, default = 2'b00 
       socket interleave wayness
       00 = 1 way,
       01 = 2 way,
       10 = 4 way,
       11 = 8 way.
     */
    UINT32 tad_limit : 20;
    /* tad_limit - Bits[31:12], RW_LB, default = 20'b00000000000000000000 
       highest address of the range in system address space, 64MB granularity, i.e. 
       TADRANGLIMIT[45:26]. 
     */
  } Bits;
  UINT32 Data;
} TADWAYNESS_1_MC_MAIN_STRUCT;


/* TADWAYNESS_2_MC_MAIN_REG supported on:                                     */
/*       SKX_A0 (0x40250888)                                                  */
/*       SKX (0x40250888)                                                     */
/* Register default value:              0x00000000                            */
#define TADWAYNESS_2_MC_MAIN_REG 0x07004888
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are total of 8 TAD ranges 
 * Note for mirroring configuration:
 * For 1-way interleave, channel 0-2 mirror pair: target list = <0,2,x,x>, TAD ways 
 * = "00" 
 * For 1-way interleave, channel 1-3 mirror pair: target list = <1,3,x,x>, TAD ways 
 * = "00" 
 * For 2-way interleave, 0-2 mirror pair and 1-3 mirror pair: target list = 
 * <0,1,2,3>, TAD ways = "01" 
 * For 1-way interleave, lockstep + mirroring, target list = <0,2,x,x>, TAD ways = 
 * "00" 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 8;
    UINT32 tad_ch_way : 2;
    /* tad_ch_way - Bits[9:8], RW_LB, default = 2'b00 
       channel interleave wayness
       00 - interleave across 1 channel or mirror pair
       01 - interleave across 2 channels or mirror pairs
       10 - interleave across 3 channels
       11 - interleave across 4 channels
       Note: This parameter effectively tells IMC how much to divide the system address 
       by when adjusting for the channel interleave. Since both channels in a pair 
       store every line of data, we want to divide by 1 when interleaving across one 
       pair and 2 when interleaving across two pairs. For M2M, it tells how may 
       channels to distribute the read requests across. When we interleaving across 1 
       pair, we want to distribute the reads to two channels, when interleaving across 
       2 pairs, we distribute the reads across 4 pairs. Writes always go to both 
       channels in the pair when the read target is either channel. 
     */
    UINT32 tad_skt_way : 2;
    /* tad_skt_way - Bits[11:10], RW_LB, default = 2'b00 
       socket interleave wayness
       00 = 1 way,
       01 = 2 way,
       10 = 4 way,
       11 = 8 way.
     */
    UINT32 tad_limit : 20;
    /* tad_limit - Bits[31:12], RW_LB, default = 20'b00000000000000000000 
       highest address of the range in system address space, 64MB granularity, i.e. 
       TADRANGLIMIT[45:26]. 
     */
  } Bits;
  UINT32 Data;
} TADWAYNESS_2_MC_MAIN_STRUCT;


/* TADWAYNESS_3_MC_MAIN_REG supported on:                                     */
/*       SKX_A0 (0x4025088C)                                                  */
/*       SKX (0x4025088C)                                                     */
/* Register default value:              0x00000000                            */
#define TADWAYNESS_3_MC_MAIN_REG 0x0700488C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are total of 8 TAD ranges 
 * Note for mirroring configuration:
 * For 1-way interleave, channel 0-2 mirror pair: target list = <0,2,x,x>, TAD ways 
 * = "00" 
 * For 1-way interleave, channel 1-3 mirror pair: target list = <1,3,x,x>, TAD ways 
 * = "00" 
 * For 2-way interleave, 0-2 mirror pair and 1-3 mirror pair: target list = 
 * <0,1,2,3>, TAD ways = "01" 
 * For 1-way interleave, lockstep + mirroring, target list = <0,2,x,x>, TAD ways = 
 * "00" 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 8;
    UINT32 tad_ch_way : 2;
    /* tad_ch_way - Bits[9:8], RW_LB, default = 2'b00 
       channel interleave wayness
       00 - interleave across 1 channel or mirror pair
       01 - interleave across 2 channels or mirror pairs
       10 - interleave across 3 channels
       11 - interleave across 4 channels
       Note: This parameter effectively tells IMC how much to divide the system address 
       by when adjusting for the channel interleave. Since both channels in a pair 
       store every line of data, we want to divide by 1 when interleaving across one 
       pair and 2 when interleaving across two pairs. For M2M, it tells how may 
       channels to distribute the read requests across. When we interleaving across 1 
       pair, we want to distribute the reads to two channels, when interleaving across 
       2 pairs, we distribute the reads across 4 pairs. Writes always go to both 
       channels in the pair when the read target is either channel. 
     */
    UINT32 tad_skt_way : 2;
    /* tad_skt_way - Bits[11:10], RW_LB, default = 2'b00 
       socket interleave wayness
       00 = 1 way,
       01 = 2 way,
       10 = 4 way,
       11 = 8 way.
     */
    UINT32 tad_limit : 20;
    /* tad_limit - Bits[31:12], RW_LB, default = 20'b00000000000000000000 
       highest address of the range in system address space, 64MB granularity, i.e. 
       TADRANGLIMIT[45:26]. 
     */
  } Bits;
  UINT32 Data;
} TADWAYNESS_3_MC_MAIN_STRUCT;


/* TADWAYNESS_4_MC_MAIN_REG supported on:                                     */
/*       SKX_A0 (0x40250890)                                                  */
/*       SKX (0x40250890)                                                     */
/* Register default value:              0x00000000                            */
#define TADWAYNESS_4_MC_MAIN_REG 0x07004890
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are total of 8 TAD ranges 
 * Note for mirroring configuration:
 * For 1-way interleave, channel 0-2 mirror pair: target list = <0,2,x,x>, TAD ways 
 * = "00" 
 * For 1-way interleave, channel 1-3 mirror pair: target list = <1,3,x,x>, TAD ways 
 * = "00" 
 * For 2-way interleave, 0-2 mirror pair and 1-3 mirror pair: target list = 
 * <0,1,2,3>, TAD ways = "01" 
 * For 1-way interleave, lockstep + mirroring, target list = <0,2,x,x>, TAD ways = 
 * "00" 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 8;
    UINT32 tad_ch_way : 2;
    /* tad_ch_way - Bits[9:8], RW_LB, default = 2'b00 
       channel interleave wayness
       00 - interleave across 1 channel or mirror pair
       01 - interleave across 2 channels or mirror pairs
       10 - interleave across 3 channels
       11 - interleave across 4 channels
       Note: This parameter effectively tells IMC how much to divide the system address 
       by when adjusting for the channel interleave. Since both channels in a pair 
       store every line of data, we want to divide by 1 when interleaving across one 
       pair and 2 when interleaving across two pairs. For M2M, it tells how may 
       channels to distribute the read requests across. When we interleaving across 1 
       pair, we want to distribute the reads to two channels, when interleaving across 
       2 pairs, we distribute the reads across 4 pairs. Writes always go to both 
       channels in the pair when the read target is either channel. 
     */
    UINT32 tad_skt_way : 2;
    /* tad_skt_way - Bits[11:10], RW_LB, default = 2'b00 
       socket interleave wayness
       00 = 1 way,
       01 = 2 way,
       10 = 4 way,
       11 = 8 way.
     */
    UINT32 tad_limit : 20;
    /* tad_limit - Bits[31:12], RW_LB, default = 20'b00000000000000000000 
       highest address of the range in system address space, 64MB granularity, i.e. 
       TADRANGLIMIT[45:26]. 
     */
  } Bits;
  UINT32 Data;
} TADWAYNESS_4_MC_MAIN_STRUCT;


/* TADWAYNESS_5_MC_MAIN_REG supported on:                                     */
/*       SKX_A0 (0x40250894)                                                  */
/*       SKX (0x40250894)                                                     */
/* Register default value:              0x00000000                            */
#define TADWAYNESS_5_MC_MAIN_REG 0x07004894
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are total of 8 TAD ranges 
 * Note for mirroring configuration:
 * For 1-way interleave, channel 0-2 mirror pair: target list = <0,2,x,x>, TAD ways 
 * = "00" 
 * For 1-way interleave, channel 1-3 mirror pair: target list = <1,3,x,x>, TAD ways 
 * = "00" 
 * For 2-way interleave, 0-2 mirror pair and 1-3 mirror pair: target list = 
 * <0,1,2,3>, TAD ways = "01" 
 * For 1-way interleave, lockstep + mirroring, target list = <0,2,x,x>, TAD ways = 
 * "00" 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 8;
    UINT32 tad_ch_way : 2;
    /* tad_ch_way - Bits[9:8], RW_LB, default = 2'b00 
       channel interleave wayness
       00 - interleave across 1 channel or mirror pair
       01 - interleave across 2 channels or mirror pairs
       10 - interleave across 3 channels
       11 - interleave across 4 channels
       Note: This parameter effectively tells IMC how much to divide the system address 
       by when adjusting for the channel interleave. Since both channels in a pair 
       store every line of data, we want to divide by 1 when interleaving across one 
       pair and 2 when interleaving across two pairs. For M2M, it tells how may 
       channels to distribute the read requests across. When we interleaving across 1 
       pair, we want to distribute the reads to two channels, when interleaving across 
       2 pairs, we distribute the reads across 4 pairs. Writes always go to both 
       channels in the pair when the read target is either channel. 
     */
    UINT32 tad_skt_way : 2;
    /* tad_skt_way - Bits[11:10], RW_LB, default = 2'b00 
       socket interleave wayness
       00 = 1 way,
       01 = 2 way,
       10 = 4 way,
       11 = 8 way.
     */
    UINT32 tad_limit : 20;
    /* tad_limit - Bits[31:12], RW_LB, default = 20'b00000000000000000000 
       highest address of the range in system address space, 64MB granularity, i.e. 
       TADRANGLIMIT[45:26]. 
     */
  } Bits;
  UINT32 Data;
} TADWAYNESS_5_MC_MAIN_STRUCT;


/* TADWAYNESS_6_MC_MAIN_REG supported on:                                     */
/*       SKX_A0 (0x40250898)                                                  */
/*       SKX (0x40250898)                                                     */
/* Register default value:              0x00000000                            */
#define TADWAYNESS_6_MC_MAIN_REG 0x07004898
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are total of 8 TAD ranges 
 * Note for mirroring configuration:
 * For 1-way interleave, channel 0-2 mirror pair: target list = <0,2,x,x>, TAD ways 
 * = "00" 
 * For 1-way interleave, channel 1-3 mirror pair: target list = <1,3,x,x>, TAD ways 
 * = "00" 
 * For 2-way interleave, 0-2 mirror pair and 1-3 mirror pair: target list = 
 * <0,1,2,3>, TAD ways = "01" 
 * For 1-way interleave, lockstep + mirroring, target list = <0,2,x,x>, TAD ways = 
 * "00" 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 8;
    UINT32 tad_ch_way : 2;
    /* tad_ch_way - Bits[9:8], RW_LB, default = 2'b00 
       channel interleave wayness
       00 - interleave across 1 channel or mirror pair
       01 - interleave across 2 channels or mirror pairs
       10 - interleave across 3 channels
       11 - interleave across 4 channels
       Note: This parameter effectively tells IMC how much to divide the system address 
       by when adjusting for the channel interleave. Since both channels in a pair 
       store every line of data, we want to divide by 1 when interleaving across one 
       pair and 2 when interleaving across two pairs. For M2M, it tells how may 
       channels to distribute the read requests across. When we interleaving across 1 
       pair, we want to distribute the reads to two channels, when interleaving across 
       2 pairs, we distribute the reads across 4 pairs. Writes always go to both 
       channels in the pair when the read target is either channel. 
     */
    UINT32 tad_skt_way : 2;
    /* tad_skt_way - Bits[11:10], RW_LB, default = 2'b00 
       socket interleave wayness
       00 = 1 way,
       01 = 2 way,
       10 = 4 way,
       11 = 8 way.
     */
    UINT32 tad_limit : 20;
    /* tad_limit - Bits[31:12], RW_LB, default = 20'b00000000000000000000 
       highest address of the range in system address space, 64MB granularity, i.e. 
       TADRANGLIMIT[45:26]. 
     */
  } Bits;
  UINT32 Data;
} TADWAYNESS_6_MC_MAIN_STRUCT;


/* TADWAYNESS_7_MC_MAIN_REG supported on:                                     */
/*       SKX_A0 (0x4025089C)                                                  */
/*       SKX (0x4025089C)                                                     */
/* Register default value:              0x00000000                            */
#define TADWAYNESS_7_MC_MAIN_REG 0x0700489C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * There are total of 8 TAD ranges 
 * Note for mirroring configuration:
 * For 1-way interleave, channel 0-2 mirror pair: target list = <0,2,x,x>, TAD ways 
 * = "00" 
 * For 1-way interleave, channel 1-3 mirror pair: target list = <1,3,x,x>, TAD ways 
 * = "00" 
 * For 2-way interleave, 0-2 mirror pair and 1-3 mirror pair: target list = 
 * <0,1,2,3>, TAD ways = "01" 
 * For 1-way interleave, lockstep + mirroring, target list = <0,2,x,x>, TAD ways = 
 * "00" 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 8;
    UINT32 tad_ch_way : 2;
    /* tad_ch_way - Bits[9:8], RW_LB, default = 2'b00 
       channel interleave wayness
       00 - interleave across 1 channel or mirror pair
       01 - interleave across 2 channels or mirror pairs
       10 - interleave across 3 channels
       11 - interleave across 4 channels
       Note: This parameter effectively tells IMC how much to divide the system address 
       by when adjusting for the channel interleave. Since both channels in a pair 
       store every line of data, we want to divide by 1 when interleaving across one 
       pair and 2 when interleaving across two pairs. For M2M, it tells how may 
       channels to distribute the read requests across. When we interleaving across 1 
       pair, we want to distribute the reads to two channels, when interleaving across 
       2 pairs, we distribute the reads across 4 pairs. Writes always go to both 
       channels in the pair when the read target is either channel. 
     */
    UINT32 tad_skt_way : 2;
    /* tad_skt_way - Bits[11:10], RW_LB, default = 2'b00 
       socket interleave wayness
       00 = 1 way,
       01 = 2 way,
       10 = 4 way,
       11 = 8 way.
     */
    UINT32 tad_limit : 20;
    /* tad_limit - Bits[31:12], RW_LB, default = 20'b00000000000000000000 
       highest address of the range in system address space, 64MB granularity, i.e. 
       TADRANGLIMIT[45:26]. 
     */
  } Bits;
  UINT32 Data;
} TADWAYNESS_7_MC_MAIN_STRUCT;




/* MC_INIT_STATE_G_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x402508B4)                                                  */
/*       SKX (0x402508B4)                                                     */
/* Register default value:              0x00000122                            */
#define MC_INIT_STATE_G_MC_MAIN_REG 0x070048B4
/* Struct format extracted from XML file SKX_A0\2.10.0.CFG.xml.
 * This register defines the high-level behavior in CPGC mode. It defines the DDR 
 * reset pin value, DCLK enable, refresh enable and bits indicating the MRC status 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    UINT32 ddr_reset : 1;
    /* ddr_reset - Bits[1:1], RW_L, default = 1'b1 
       DDR reset for all DIMMs from all channels within this socket. No IMC/DDRIO logic 
       is reset by asserting this register. 
       It is important to note that this bit is negative logic! i.e. writing 0 to 
       induce a reset and write 1 for not reset. 
     */
    UINT32 dclk_enable : 1;
    /* dclk_enable - Bits[2:2], RW_L, default = 1'b0 
       DCLK Enable (for all channels)
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 reset_io : 1;
    /* reset_io - Bits[5:5], RW_L, default = 1'b1 
       DDR IO reset
       In order to reset the IO this bit has to be set for 20 DCLKs and then cleared. 
       Setting this bit will reset the DDRIO receive FIFO registers only. 
       It is required in some of the training steps.
               
     */
    UINT32 rsvd_6 : 1;
    /* rsvd_6 - Bits[6:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mrc_done : 1;
    /* mrc_done - Bits[7:7], RW_L, default = 1'b0  */
    UINT32 safe_sr : 1;
    /* safe_sr - Bits[8:8], RWS_L, default = 1'b1 
       This bit indicates if it is safe to keep the MC in SR during MC-reset. If it is 
       clear when reset occurs, it means that the reset is without warning and the 
       DDR-reset should be asserted. If set when reset occurs, it indicates that DDR is 
       already in SR and it can keep it this way. This bit can also indicate MRC if 
       reset without warning has occured, and if it has, cold-reset flow should be 
       selected 
       Note to MRC BIOS: clear this bit at MRC entry.
     */
    UINT32 cs_oe_en : 4;
    /* cs_oe_en - Bits[12:9], RWS_L, default = 4'b0000  */
    UINT32 reset_vmse2to1 : 1;
    /* reset_vmse2to1 - Bits[13:13], RWS_L, default = 1'b0 
       Reset is used to set up Intel SMI 2 2:1 mode correctly
       in DDRIO. The register must be set and reset
       after the IMC mode register is configured to
       Intel SMI 2 2:1 mode.
     */
    UINT32 reset_io_vmse_rhs : 1;
    /* reset_io_vmse_rhs - Bits[14:14], RWS_L, default = 1'b0 
       Training Reset for DDRIO. This signal is unused on Romley and goes
       to Intel SMI 2 channel 1 on Brickland
     */
    UINT32 rsvd_15 : 17;
    /* rsvd_15 - Bits[31:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MC_INIT_STATE_G_MC_MAIN_A0_STRUCT;

/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * This register defines the high-level behavior in CPGC mode. It defines the DDR 
 * reset pin value, DCLK enable, refresh enable and bits indicating the MRC status 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    UINT32 ddr_reset : 1;
    /* ddr_reset - Bits[1:1], RW_L, default = 1'b1 
       DDR reset for all DIMMs from all channels within this socket. No IMC/DDRIO logic 
       is reset by asserting this register. 
       It is important to note that this bit is negative logic! i.e. writing 0 to 
       induce a reset and write 1 for not reset. 
     */
    UINT32 dclk_enable : 1;
    /* dclk_enable - Bits[2:2], RW_L, default = 1'b0 
       DCLK Enable (for all channels)
     */
    UINT32 rsvd_3 : 2;
    /* rsvd_3 - Bits[4:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 reset_io : 1;
    /* reset_io - Bits[5:5], RW_L, default = 1'b1 
       DDR IO reset
       In order to reset the IO this bit has to be set for 20 DCLKs and then cleared. 
       Setting this bit will reset the DDRIO receive FIFO registers only. 
       It is required in some of the training steps.
               
     */
    UINT32 rsvd_6 : 1;
    /* rsvd_6 - Bits[6:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mrc_done : 1;
    /* mrc_done - Bits[7:7], RW_L, default = 1'b0  */
    UINT32 safe_sr : 1;
    /* safe_sr - Bits[8:8], RWS_L, default = 1'b1 
       This bit indicates if it is safe to keep the MC in SR during MC-reset. If it is 
       clear when reset occurs, it means that the reset is without warning and the 
       DDR-reset should be asserted. If set when reset occurs, it indicates that DDR is 
       already in SR and it can keep it this way. This bit can also indicate MRC if 
       reset without warning has occured, and if it has, cold-reset flow should be 
       selected 
       Note to MRC BIOS: clear this bit at MRC entry.
     */
    UINT32 cs_oe_en : 4;
    /* cs_oe_en - Bits[12:9], RWS_L, default = 4'b0000  */
    UINT32 reset_link2to1 : 1;
    /* reset_link2to1 - Bits[13:13], RWS_L, default = 1'b0 
       Reset is used to set up Intel SMI 2 2:1 mode correctly
       in DDRIO. The register must be set and reset
       after the IMC mode register is configured to
       Intel SMI 2 2:1 mode.
     */
    UINT32 reset_io_link_rhs : 1;
    /* reset_io_link_rhs - Bits[14:14], RWS_L, default = 1'b0 
       Training Reset for DDRIO. This signal is unused on Romley and goes
       to Intel SMI 2 channel 1 on Brickland
     */
    UINT32 rsvd_15 : 17;
    /* rsvd_15 - Bits[31:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MC_INIT_STATE_G_MC_MAIN_STRUCT;



/* RCOMP_TIMER_MC_MAIN_REG supported on:                                      */
/*       SKX_A0 (0x402508C0)                                                  */
/*       SKX (0x402508C0)                                                     */
/* Register default value:              0x00000C00                            */
#define RCOMP_TIMER_MC_MAIN_REG 0x070048C0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Defines the time from IO starting to run RCOMP evaluation until RCOMP results 
 * are defenetly ready. This counter is added in order to keep determinism of the 
 * process if operated in different modes 
 * The register also indicates that first RCOMP has been done - required by BIOS
 */
typedef union {
  struct {
    UINT32 count : 16;
    /* count - Bits[15:0], RW, default = 16'b0000110000000000 
       DCLK cycle count that MC needs to wait from the point it has triggered RCOMP 
       evaluation until it can trigger the load to registers 
     */
    UINT32 first_rcomp_done : 1;
    /* first_rcomp_done - Bits[16:16], RW_LV, default = 1'b0 
       This is a status bit that indicates the first RCOMP has been completed. It is 
       cleared on reset, and set by MC HW when the first RCOMP is completed. Bios 
       should wait until this bit is set before executing any DDR command 
     */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 no_mdll_fsm_override : 1;
    /* no_mdll_fsm_override - Bits[20:20], RW, default = 1'b0  */
    UINT32 ignore_mdll_locked_bit : 1;
    /* ignore_mdll_locked_bit - Bits[21:21], RW, default = 1'b0  */
    UINT32 rsvd_22 : 8;
    /* rsvd_22 - Bits[29:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rcomp : 1;
    /* rcomp - Bits[30:30], RW_LB, default = 1'b0 
       RCOMP start via message channel control for bios.
       RCOMP start only triggered when the register bit output is changing from 0 -> 1
       MC will not be responsible for clearing this bit. MC already provides feedback 
       to bias 
       when Rcomp is done via first_rcomp_done bit field.
     */
    UINT32 rcomp_in_progress : 1;
    /* rcomp_in_progress - Bits[31:31], RW_V, default = 1'b0  */
  } Bits;
  UINT32 Data;
} RCOMP_TIMER_MC_MAIN_STRUCT;


/* IMC_FUSE_DOWNLOAD_SHADOW_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x402508C8)                                                  */
/*       SKX (0x402508C8)                                                     */
/* Register default value:              0x00009000                            */
#define IMC_FUSE_DOWNLOAD_SHADOW_MC_MAIN_REG 0x070048C8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * generated by critter 19_0_0x0c8
 */
typedef union {
  struct {
    UINT32 fuse_shadow_chn_disable_mc0 : 3;
    /* fuse_shadow_chn_disable_mc0 - Bits[2:0], RO_V, default = 3'b000 
       Fused channel disable control. When set, the corresponding channel is disabled. 
       Fuse download may change the default value after reset de-assertion. Setting to 
       all 1 may disable msg channel. 
     */
    UINT32 fuse_shadow_disable_ddr4_caparity : 1;
    /* fuse_shadow_disable_ddr4_caparity - Bits[3:3], RO_V, default = 1'b0 
       Force ddr4 command address parity to be zero. This requires DDR4 DRAMs to be 
       initialized to disable parity checking. 
     */
    UINT32 fuse_shadow_disable_2_dpc : 1;
    /* fuse_shadow_disable_2_dpc - Bits[4:4], RO_V, default = 1'b0 
       Fused 2 DPC disable control. When set, CS signals for DIMM slot 1 (i.e. slot 0 
       is not disabled) are disabled. Note: some CS may have multiplexed with address 
       signal to support extended addressing. The CS signal disabling is only 
       applicable to CS not the being multiplexed with address. Fuse download may 
       change the default value after reset de-assertion. 
     */
    UINT32 fuse_shadow_disable_patrol_scrub : 1;
    /* fuse_shadow_disable_patrol_scrub - Bits[5:5], RO_V, default = 1'b0 
       Fused patrol scrub disable control. When set, rank patrol scrub is disabled. 
       Fuse download may change the default value after reset de-assertion. 
     */
    UINT32 fuse_shadow_disable_3ds : 1;
    /* fuse_shadow_disable_3ds - Bits[6:6], RO_V, default = 1'b0 
       Fused 3DS (3D stacked die) disable control. When set, the C0, C1 and C2 signals 
       will forced to zero. Fuse download may change the default value after reset 
       de-assertion. 
     */
    UINT32 fuse_shadow_disable_16gbit : 1;
    /* fuse_shadow_disable_16gbit - Bits[7:7], RO_V, default = 1'b0 
       Fused 16Gb or higher disable control. When set, the address decode to the 
       corresponding 16Gb or higher mapping is disabled. Note: LR-DIMM's logical device 
       density is also limited to 16Gb when this fuse is set. Fuse download may change 
       the default value after reset de-assertion. 
     */
    UINT32 fuse_shadow_rfu_0 : 1;
    /* fuse_shadow_rfu_0 - Bits[8:8], RO_V, default = 1'b0 
       Reserved for future use.
     */
    UINT32 fuse_shadow_dis_asyncsr_adr : 1;
    /* fuse_shadow_dis_asyncsr_adr - Bits[9:9], RO_V, default = 1'b0 
       Fused ADR disable control. When set, memory ignores ADR event. Fuse download may 
       change the default value after reset de-assertion. 
     */
    UINT32 fuse_shadow_disable_ecc : 1;
    /* fuse_shadow_disable_ecc - Bits[10:10], RO_V, default = 1'b0 
       Fused ECC disable control. When set, ECC is disabled. Fuse download may change 
       the default value after reset de-assertion. 
     */
    UINT32 fuse_shadow_disable_dir : 1;
    /* fuse_shadow_disable_dir - Bits[11:11], RO_V, default = 1'b0 
       Fused DIR disable control. When set, directory is disabled. Fuse download may 
       change the default value after reset de-assertion. 
     */
    UINT32 fuse_shadow_mc_mca_recovery : 1;
    /* fuse_shadow_mc_mca_recovery - Bits[12:12], RO_V, default = 1'b1 
       Fuse for mc_mca_recovery. Blown to 0 for EP, HEDT, ... etc, i.e. Means recovery 
       from uncorrectable Patrol scrub errors is not supported. In addition, iMC 
       hardware logs uncorrectable PS errors in the MCA bank with MCi_STATUS.PCC when 
       set. When the fuse is blown to 1 in in EX only, this means that when poisoning 
       is enabled, recovery from uncorrectable patrol scrub errors is supported. MC 
       hardware will log uncorrectable Patrol scrub errors in the MCA bank with a 
       recoverable error signature. Please refer to MCA HAS for further details. 
     */
    UINT32 fuse_shadow_disable_rdimm : 1;
    /* fuse_shadow_disable_rdimm - Bits[13:13], RO_V, default = 1'b0 
       Fused RDIMM disable control. When set, RDIMM support is disabled by forcing the 
       upper 5 bits of the 13b T_STAB register to be zeros, i.e. the T_STAB can only 
       have max of 255 DCLK delay after clock-stopped power down mode which is in 
       sufficient for normal RDIMM clock stablization; hence, users will not be able to 
       support self-refresh with clock off mode (S3, pkg C6) if the RDIMM disable fuse 
       is blown to one. 
       Fuse download may change the default value after reset de-assertion.
     */
    UINT32 fuse_shadow_disable_udimm : 1;
    /* fuse_shadow_disable_udimm - Bits[14:14], RO_V, default = 1'b0 
       Fused UDIMM disable control. When set, UDIMM support is disabled by disabling 
       address bit swizzling. Fuse download may change the default value after reset 
       de-assertion. 
       Note: Since LRDIMM also have UDIMM address swizzling, this UDIMM disable fuse 
       must not be blown to 1 for JKT SKU that may support LRDIMM. 
     */
    UINT32 fuse_shadow_is_ex : 1;
    /* fuse_shadow_is_ex - Bits[15:15], RO_V, default = 1'b1 
       EX fuse: 1=EX config, 0=EP config
     */
    UINT32 fuse_shadow_disable_sparing : 1;
    /* fuse_shadow_disable_sparing - Bits[16:16], RO_V, default = 1'b0 
       Fused sparing disable control. When set, all sparing modes are disabled. Fuse 
       download may change the default value after reset de-assertion. 
     */
    UINT32 fuse_shadow_disable_adddc : 1;
    /* fuse_shadow_disable_adddc - Bits[17:17], RO_V, default = 1'b0 
       Fused ADDDC disable control. When set, all ADDDC regions are disabled. Fuse 
       download may change the default value after reset de-assertion. 
     */
    UINT32 fuse_shadow_rfu_2 : 2;
    /* fuse_shadow_rfu_2 - Bits[19:18], RO_V, default = 2'b00 
       Reserved for future use.
     */
    UINT32 fuse_shadow_disable_sddc_x4 : 1;
    /* fuse_shadow_disable_sddc_x4 - Bits[20:20], RO_V, default = 1'b0 
       Single device data correction fuse download. When set, will disable 4-bit device 
       SDDC. 
     */
    UINT32 fuse_shadow_disable_sddc_x8 : 1;
    /* fuse_shadow_disable_sddc_x8 - Bits[21:21], RO_V, default = 1'b0 
       Single device data correction fuse download. When set, will disable 8-bit device 
       SDDC. 
     */
    UINT32 fuse_shadow_disable_sddc_x4_plus1 : 1;
    /* fuse_shadow_disable_sddc_x4_plus1 - Bits[22:22], RO_V, default = 1'b0 
       Single device data correction fuse download. When set, will disable SDDC plus 
       one for x4 SDDC mode. 
     */
    UINT32 fuse_shadow_disable_sddc_x8_plus1 : 1;
    /* fuse_shadow_disable_sddc_x8_plus1 - Bits[23:23], RO_V, default = 1'b0 
       Single device data correction fuse download. When set, will disable SDDC plus 
       one for x8 SDDC mode. 
     */
    UINT32 fuse_shadow_chn_disable_mc1 : 3;
    /* fuse_shadow_chn_disable_mc1 - Bits[26:24], RO_V, default = 2'b00 
       Reserved for future use.
     */
    UINT32 fuse_shadow_disable_2lm : 1;
    /* fuse_shadow_disable_2lm - Bits[27:27], RO_V, default = 1'b0 
       Disable two-level memory
     */
    UINT32 fuse_shadow_disable_ddrt : 1;
    /* fuse_shadow_disable_ddrt - Bits[28:28], RO_V, default = 1'b0 
       Disable the use of DDRT devices, once the fuse is blown to one, iMC will not 
       issue any DDRT commands or responding DDRT bus request. Internally, any request 
       targeting DDRT port is treated as programming error. System may hang. 
     */
    UINT32 fuse_shadow_disable_cr_pmem : 1;
    /* fuse_shadow_disable_cr_pmem - Bits[29:29], RO_V, default = 1'b0 
       Disable use of Persistent Memory with Crystal Ridge.
     */
    UINT32 fuse_shadow_disable_cr_pmem_wt : 1;
    /* fuse_shadow_disable_cr_pmem_wt - Bits[30:30], RO_V, default = 1'b0 
       Disable use of Persistent Memory Write Through with Crystal Ridge.
     */
    UINT32 fuse_shadow_disable_mcmirrormode : 1;
    /* fuse_shadow_disable_mcmirrormode - Bits[31:31], RO_V, default = 1'b0 
       Disable use of mirroring.
     */
  } Bits;
  UINT32 Data;
} IMC_FUSE_DOWNLOAD_SHADOW_MC_MAIN_STRUCT;




/* MCBGFTUNE_MC_MAIN_REG supported on:                                        */
/*       SKX_A0 (0x402508D0)                                                  */
/*       SKX (0x402508D0)                                                     */
/* Register default value:              0x01000000                            */
#define MCBGFTUNE_MC_MAIN_REG 0x070048D0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Usage model:  BIOS or ITP or device driver programs HABGFTUNE and MCBGFTUNE 
 * registers.  The values are Memory Frequency dependent.  This feature must be 
 * disabled by programming URatio field to zero if Memory frequency is going to 
 * change.  The values are calculated to minimize delay through bgf while meeting 
 * setup time requirements.  (design team has a program which can do those 
 * calculations).  It is programmed for the sweet-spot URatio for a particular 
 * system.  The parameters in the tuning register override the default values (from 
 * PMA) if the URATIO matches and are sampled on the assertion edge of BgfRun.  
 * Both HABGFTUNE and MCBGFTUNE must be programmed correctly and consistently to 
 * avoid possible malfunction. 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 19;
    UINT32 mccbgfd_en_3ch : 1;
    /* mccbgfd_en_3ch - Bits[19:19], RW_LB, default = 1'b0 
       Enable bubble generation when 3 channels are populated
     */
    UINT32 mccbgfd_en_2d : 1;
    /* mccbgfd_en_2d - Bits[20:20], RWS_LB, default = 1'b0 
       Disable bubble generation when U is less than 2D instead of U is less than 1.5D. 
       Only valid when mccbgfd_en_3ch is set to 1. 
     */
    UINT32 mccbgfd_en_over : 1;
    /* mccbgfd_en_over - Bits[21:21], RW_LB, default = 1'b0 
       Enable override for bubble generation. When this bit is set, bubble is always 
       inserted. The rate at which bubble is inserted depends on the value programmed 
       in mccbgfd_delta. Only valid when mccbgfd_en_3ch is set to 1. This bit take 
       precedence over mccbgfd_en_2d. 
     */
    UINT32 mccbgfd_u2d_dis : 1;
    /* mccbgfd_u2d_dis - Bits[22:22], RW_LB, default = 1'b0 
       Override to disable bubble generation for data. Only valid when mccbgfd_en_3ch 
       is set to 1. 
     */
    UINT32 rsvd_23 : 1;
    /* rsvd_23 - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mccbgfd_delta : 8;
    /* mccbgfd_delta - Bits[31:24], RW_LB, default = 8'b1 
       Delta above UCLK ratio (UCLK frequency * 3 / 100) to control bubble insertion. 
       Bubble inserted at a rate = mccbgfd_delta / (mccbgfd_delta + UCLK ratio). Only 
       valid when mccbgfd_en_3ch and mccbgfd_en_over are set to 1. 
     */
  } Bits;
  UINT32 Data;
} MCBGFTUNE_MC_MAIN_STRUCT;






/* MCMAIN_CHKN_BITS_MC_MAIN_REG supported on:                                 */
/*       SKX_A0 (0x402508E0)                                                  */
/*       SKX (0x402508E0)                                                     */
/* Register default value:              0x00000200                            */
#define MCMAIN_CHKN_BITS_MC_MAIN_REG 0x070048E0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Chicken bit register in MCMAIN.
 */
typedef union {
  struct {
    UINT32 frc_sngl_spr : 1;
    /* frc_sngl_spr - Bits[0:0], RW_LB, default = 1'b0 
       Force sparing to issue one transaction at a time
     */
    UINT32 rsvd_chkn_b1 : 1;
    /* rsvd_chkn_b1 - Bits[1:1], RW_LB, default = 1'b0 
       Disable signalling of SMI from patrol scrub engine.
       Patrol scrub is able to signal SMI when it stops on error or reaches end of 
       address range. See SCRUBCTL for details. 
     */
    UINT32 dis_spr_err_log : 1;
    /* dis_spr_err_log - Bits[2:2], RW_LB, default = 1'b0 
       Disable spare error logging
     */
    UINT32 frc_spr_strt : 1;
    /* frc_spr_strt - Bits[3:3], RW_LB, default = 1'b0 
       Force spare start
     */
    UINT32 frc_spr_end : 1;
    /* frc_spr_end - Bits[4:4], RW_LB, default = 1'b0 
       Force spare end
     */
    UINT32 dis_spr_rir_updt : 1;
    /* dis_spr_rir_updt - Bits[5:5], RW_LB, default = 1'b0 
       Disable spare RIR update
     */
    UINT32 dis_ptrl_rty : 1;
    /* dis_ptrl_rty - Bits[6:6], RW_LB, default = 1'b0 
       Disable patrol retry
     */
    UINT32 dis_ptrl_err_log : 1;
    /* dis_ptrl_err_log - Bits[7:7], RW_LB, default = 1'b0 
       Disable patrol error logging
     */
    UINT32 frc_sngl_ptrl : 1;
    /* frc_sngl_ptrl - Bits[8:8], RW_LB, default = 1'b0 
       Enable extention of valid to completion BGF
     */
    UINT32 dis_mxb_tsod : 1;
    /* dis_mxb_tsod - Bits[9:9], RW_LB, default = 1'b1 
       Reserved Unused
     */
    UINT32 frc_sngl_mtst : 1;
    /* frc_sngl_mtst - Bits[10:10], RW_LB, default = 1'b0 
       Force mem test to issue one transaction at a time
     */
    UINT32 dis_rcomp : 1;
    /* dis_rcomp - Bits[11:11], RW_LB, default = 1'b0 
       Disable rcomp
     */
    UINT32 frc_rcomp_cmp_ack : 1;
    /* frc_rcomp_cmp_ack - Bits[12:12], RW_LB, default = 1'b0 
       Force rcomp completion ack
     */
    UINT32 dis_lcl_ck_gate_mcmain : 1;
    /* dis_lcl_ck_gate_mcmain - Bits[13:13], RW_LB, default = 1'b0 
       Disable local clock gating - mcmains
     */
    UINT32 increase_rcomp : 1;
    /* increase_rcomp - Bits[14:14], RW_LB, default = 1'b0 
       Increase RCOMP quiet time
     */
    UINT32 dis_msg_ch_ck_gate_mc : 1;
    /* dis_msg_ch_ck_gate_mc - Bits[15:15], RW_LB, default = 1'b0 
       Disable IMC message channel clock gate when set.
     */
    UINT32 dis_msg_ch_ck_gate_ddrio : 1;
    /* dis_msg_ch_ck_gate_ddrio - Bits[16:16], RW_LB, default = 1'b0 
       Disable DDRIO message channel clock gate when set.
     */
    UINT32 dis_dbg_bgf_push : 1;
    /* dis_dbg_bgf_push - Bits[17:17], RW_LB, default = 1'b0 
       Disable Debug BGF Push when set
     */
    UINT32 defeature_12 : 1;
    /* defeature_12 - Bits[18:18], RW_LB, default = 1'b0 
       Reserved Unused
     */
    UINT32 bgftune_lock : 1;
    /* bgftune_lock - Bits[19:19], RWS_L, default = 1'b0 
       Lock bit for MCBGFTUNE register
     */
    UINT32 freq_chng_flow : 1;
    /* freq_chng_flow - Bits[20:20], RW_LB, default = 1'b0 
       Bug fix for HSD b3123628:
       When set, tells MC that this is a frequency_change flow. When the bit is set, 
       following changes take place 
       1. When PmRsBlock is asserted, we block message channel to M2M
       2. PkgC Empty and FullEmpty will ignore msgChEmpty when this bit is set
     */
    UINT32 dis_leak_cntr : 1;
    /* dis_leak_cntr - Bits[21:21], RW_LB, default = 1'b0 
       Disable leaky bucket counter in mc_dec
     */
    UINT32 dis_pma_blockack_hold : 1;
    /* dis_pma_blockack_hold - Bits[22:22], RW_LB, default = 1'b0 
       When set to 1, disables the "hold" logic on the BlockAck going to the MC PMA, 
       that keeps the BlockAck asserted once set, until the BlockReq de-asserts 
     */
    UINT32 sda_dbg : 2;
    /* sda_dbg - Bits[24:23], RW_LB, default = 2'b00 
       Enable send debug trigger to scalable memory buffers via SMbus SDA wire, per 
       SMbus master 
     */
    UINT32 frc_not_occ_0 : 1;
    /* frc_not_occ_0 - Bits[25:25], RW_LB, default = 1'b0 
       MC PMA interface override for channel 3 when not occupied. When set to 1, 
       MCActive will de-assert and InSRD will assert. 
     */
    UINT32 frc_not_occ_1 : 1;
    /* frc_not_occ_1 - Bits[26:26], RW_LB, default = 1'b0 
       MC PMA interface override for channel 3 when not occupied. When set to 1, 
       MCActive will de-assert and InSRD will assert. 
     */
    UINT32 frc_not_occ_2 : 1;
    /* frc_not_occ_2 - Bits[27:27], RW_LB, default = 1'b0 
       MC PMA interface override for channel 3 when not occupied. When set to 1, 
       MCActive will de-assert and InSRD will assert. 
     */
    UINT32 frc_not_occ_3 : 1;
    /* frc_not_occ_3 - Bits[28:28], RW_LB, default = 1'b0 
       MC PMA interface override for channel 3 when not occupied. When set to 1, 
       MCActive will de-assert and InSRD will assert. 
     */
    UINT32 dis_ptrl_psn : 1;
    /* dis_ptrl_psn - Bits[29:29], RW_LB, default = 1'b0 
       Disable patrol scrub poison line on finding uncorr error
     */
    UINT32 dis_asyncsr_habackpress : 1;
    /* dis_asyncsr_habackpress - Bits[30:30], RW_LB, default = 1'b0 
       When set to 1, the MC will not backpressure the M2M during an ADR sequence.
       When set to 0 and the MC receives the AsyncSR signal from the PMA, the MC will 
       immediately backpressure the M2M, stopping any new transactions from being sent 
       to the MC. 
     */
    UINT32 defeature_10 : 1;
    /* defeature_10 - Bits[31:31], RW_LB, default = 1'b0 
       Reserved Unused
     */
  } Bits;
  UINT32 Data;
} MCMAIN_CHKN_BITS_MC_MAIN_STRUCT;


/* MCMAIN_CHKN_BITS2_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x402508E4)                                                  */
/*       SKX (0x402508E4)                                                     */
/* Register default value:              0x00000000                            */
#define MCMAIN_CHKN_BITS2_MC_MAIN_REG 0x070048E4
/* Struct format extracted from XML file SKX_A0\2.10.0.CFG.xml.
 * Chicken bit register in MCMAIN.
 */
typedef union {
  struct {
    UINT32 dis_fix_ufilloverride : 1;
    /* dis_fix_ufilloverride - Bits[0:0], RW_LB, default = 1'b0 
       Disable the fix for SprUfillOverride and LogUnCorSprOnError that only check CAP 
       error flow on channel running sparing 
     */
    UINT32 dis_fix_errseen : 1;
    /* dis_fix_errseen - Bits[1:1], RW_LB, default = 1'b0 
       Disable the fix for verr_seen that only check CAP error flow on channel running 
       sparing 
     */
    UINT32 dis_pcommit_perf : 1;
    /* dis_pcommit_perf - Bits[2:2], RW_LB, default = 1'b0 
       
               Disable all Pcommit performance optimizations. If this bit is
               set then all incoming pcommits will be treated as broadcast 
               
     */
    UINT32 dis_pat_pkgc : 1;
    /* dis_pat_pkgc - Bits[3:3], RW_LB, default = 1'b0 
       When set 1, PkgCEmpty should check RT empty including patrol transaction
     */
    UINT32 adddc_slot_sel : 1;
    /* adddc_slot_sel - Bits[4:4], RW_LB, default = 1'b0 
       Selects the slot polarity for patrol request; make sure patrol request is in the 
       same slot as M2M request 
     */
    UINT32 evict_addr_par_inj_err : 2;
    /* evict_addr_par_inj_err - Bits[6:5], RWS_L, default = 2'b00 
       Controls whether to inject a parity error on a NM eviction in 2LM mode:
       0 - no injection
       1 - always inject errors
       2 - reserved
       3 - reserved
               
     */
    UINT32 rsvd : 25;
    /* rsvd - Bits[31:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCMAIN_CHKN_BITS2_MC_MAIN_A0_STRUCT;

/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Chicken bit register in MCMAIN.
 */
typedef union {
  struct {
    UINT32 dis_fix_ufilloverride : 1;
    /* dis_fix_ufilloverride - Bits[0:0], RW_LB, default = 1'b0 
       Disable the fix for SprUfillOverride and LogUnCorSprOnError that only check CAP 
       error flow on channel running sparing 
     */
    UINT32 dis_fix_errseen : 1;
    /* dis_fix_errseen - Bits[1:1], RW_LB, default = 1'b0 
       Disable the fix for verr_seen that only check CAP error flow on channel running 
       sparing 
     */
    UINT32 dis_pcommit_perf : 1;
    /* dis_pcommit_perf - Bits[2:2], RW_LB, default = 1'b0 
       
               Disable all Pcommit performance optimizations. If this bit is
               set then all incoming pcommits will be treated as broadcast 
               
     */
    UINT32 dis_pat_pkgc : 1;
    /* dis_pat_pkgc - Bits[3:3], RW_LB, default = 1'b0 
       When set 1, PkgCEmpty should check RT empty including patrol transaction
     */
    UINT32 adddc_slot_sel : 1;
    /* adddc_slot_sel - Bits[4:4], RW_LB, default = 1'b0 
       Selects the slot polarity for patrol request; make sure patrol request is in the 
       same slot as M2M request 
     */
    UINT32 evict_addr_par_inj_err : 2;
    /* evict_addr_par_inj_err - Bits[6:5], RWS_L, default = 2'b00 
       Controls whether to inject a parity error on a NM eviction in 2LM mode:
       0 - no injection
       1 - always inject errors
       2 - reserved
       3 - reserved
               
     */
    UINT32 defeature : 10;
    /* defeature - Bits[16:7], RW_LB, default = 10'b0 
       
                Bit 7: disable moving back to idle in TXN_DONE state when patrol is 
       disabled;  
                Bit 8: DDRT PC6 clock stop will not de-assert PMA Queue Full Empty if 
       error FSM comes on.  
                Bit 9: DDRT PC6 clock stop will not de-assert PMA Pkgc Empty if error 
       FSM comes on.  
                Bit 10: DDRT PC6 clock stop will not de-assert PMA Queue Full Empty if 
       DDRT RPQ is not empty  
                Bit 11: DDRT PC6 clock stop will not de-assert PMA Pkgc Empty if DDRT 
       RPQ is not empty  
                Bit 12: Disable fix for b307283
                Bit 13: Disable fix for b311285
                Bit 14: Disable fix for b311323
                Bit 16:15: Reserved
               
     */
    UINT32 rsvd : 15;
    /* rsvd - Bits[31:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCMAIN_CHKN_BITS2_MC_MAIN_STRUCT;







/* SPAREADDRESSLO_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x40250900)                                                  */
/*       SKX (0x40250900)                                                     */
/* Register default value:              0x00000000                            */
#define SPAREADDRESSLO_MC_MAIN_REG 0x07004900
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Always points to the lower address for the next sparing operation. This register 
 * will not be affected by the M2M access to the spare source rank during the M2M 
 * window. 
 * 
 */
typedef union {
  struct {
    UINT32 rankadd : 32;
    /* rankadd - Bits[31:0], RW_LV, default = 32'b00000000000000000000000000000000 
       Always points to the lower address for the next sparing operation. This register 
       will not be affected by the M2M access to the spare source rank during the M2M 
       window. 
       
     */
  } Bits;
  UINT32 Data;
} SPAREADDRESSLO_MC_MAIN_STRUCT;


/* SPARECTL_MC_MAIN_REG supported on:                                         */
/*       SKX_A0 (0x40250904)                                                  */
/*       SKX (0x40250904)                                                     */
/* Register default value:              0x00000000                            */
#define SPARECTL_MC_MAIN_REG 0x07004904
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * generated by critter 19_1_0x090
 */
typedef union {
  struct {
    UINT32 spare_enable : 1;
    /* spare_enable - Bits[0:0], RW_LBV, default = 1'b0 
       Spare enable when set to 1. Hardware clear after the sparing completion.
     */
    UINT32 rsvd_1 : 1;
    /* rsvd_1 - Bits[1:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 chn_sel : 2;
    /* chn_sel - Bits[3:2], RW_LB, default = 2'b00 
       Since there is only one spare-copy logic for all channels, this field selects 
       the channel or channel-pair for the spare-copy operation. 
       For independent channel operation:
       00 = channel 0 is selected for the spare-copy operation
       01 = channel 1 is selected for the spare-copy operation
       10 = channel 2 is selected for the spare-copy operation
       11 = channel 3 is selected for the spare-copy operation
       For lock-step channel operation:
       0x = channel 0 and channel 1 are selected for the spare-copy operation
       1x = channel 2 and channel 3 are selected for the spare-copy operation
     */
    UINT32 src_rank : 3;
    /* src_rank - Bits[6:4], RW_LB, default = 3'b000 
       Source logical rank that provides the data to be copied.
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dst_rank : 3;
    /* dst_rank - Bits[10:8], RW_LB, default = 3'b000 
       Destination logical rank used for the memory copy.
     */
    UINT32 rsvd_11 : 5;
    /* rsvd_11 - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 scratch_pad : 8;
    /* scratch_pad - Bits[23:16], RW, default = 8'b00000000 
       This field is available as a scratch pad for SSR operations
     */
    UINT32 hafifowm : 5;
    /* hafifowm - Bits[28:24], RW_LB, default = 5'b00000 
       minimum water mark for M2M writes to failed rank. Actual wm is max of WPQ credit 
       level and HaFifoWM. When wm is hit the M2M is backpressured and a sparing window 
       is started. 
       If DisWPQWM is clear, the spare window is started when the number of hits to the 
       failed DIMM exceed max(# of credits in WPQ not yet returned to the M2M, 
       HaFifoWM) 
       If DisWPQWM is set, the spare window starts when the number of hits to the 
       failed DIMM exceed HaFifoWM. 
     */
    UINT32 diswpqwm : 1;
    /* diswpqwm - Bits[29:29], RW_LB, default = 1'b0 
       Disable WPQ level based water mark, so that sparing wm is only based on 
       HaFifoWM. 
       If DisWPQWM is clear, the spare window is started when the number of hits to the 
       failed DIMM exceed max(# of credits in WPQ not yet returned to the M2M, 
       HaFifoWM) 
       If DisWPQWM is set, the spare window starts when the number of hits to the 
       failed DIMM exceed HaFifoWM. 
       In either case, if the number of hits to the failed DIMM do not hit the WM, the 
       spare window will still start after SPAREINTERVAL.NORMOPDUR timer expiration. 
     */
    UINT32 rsvd_30 : 2;
    /* rsvd_30 - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SPARECTL_MC_MAIN_STRUCT;


/* SCRUBADDRESSLO_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x4025090C)                                                  */
/*       SKX (0x4025090C)                                                     */
/* Register default value:              0x00000000                            */
#define SCRUBADDRESSLO_MC_MAIN_REG 0x0700490C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * This register contains part of the address of the last patrol scrub request 
 * issued. When running memtest, the failing address is logged in this register on 
 * memtest errors. Software can write the next address to be scrubbed into this 
 * register. The STARTSCRUB bit will then trigger the specified address to be 
 * scrubbed. Patrol scrubs must be disabled to reliably write this register. 
 */
typedef union {
  struct {
    UINT32 rankadd : 32;
    /* rankadd - Bits[31:0], RW_LBV, default = 32'b00000000000000000000000000000000 
       Contains the rank address or bits 37:6 of the system address of the last scrub 
       issued. Can be written to specify the next scrub address with STARTSCRUB. Base 
       system address in scrubaddress2lo/hi also need to be programmed in system 
       address mode for the programmed address to work properly. In system address 
       mode, scrubaddresshi.ptl_sa_mode must be cleared to 0 and then set back to 1 
       after STARTSCRUB is set for address written to take effect. RESTRICTIONS: Patrol 
       Scrubs must be disabled when writing to this field. Bit 0 of this register maps 
       to bit 6 of address. 
     */
  } Bits;
  UINT32 Data;
} SCRUBADDRESSLO_MC_MAIN_STRUCT;


/* SCRUBADDRESSHI_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x40250910)                                                  */
/*       SKX (0x40250910)                                                     */
/* Register default value:              0x80000800                            */
#define SCRUBADDRESSHI_MC_MAIN_REG 0x07004910
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * This register pair contains part of the address of the last patrol scrub request 
 * issued. Software can write the next address into this register. Scrubbing must 
 * be disabled to reliably read and write this register. The STARTSCRUB bit will 
 * then trigger the specified address to be scrubbed. 
 */
typedef union {
  struct {
    UINT32 rankaddhi : 9;
    /* rankaddhi - Bits[8:0], RW_LBV, default = 9'b000000000 
       Contains bits 46:38 of the system address of the last scrub issued. Can be 
       written to specify the next scrub address with STARTSCRUB. Base system address 
       in scrubaddress2lo/hi also need to be programmed in system address mode for the 
       programmed address to work properly. scrubaddresshi.ptl_sa_mode must be cleared 
       to 0 and then set back to 1 after STARTSCRUB is set for address written to take 
       effect. RESTRICTIONS: Patrol Scrubs must be disabled when writing to this field. 
       Only used system address patrol mode. 
     */
    UINT32 rsvd_9 : 2;
    /* rsvd_9 - Bits[10:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mirr_pri : 1;
    /* mirr_pri - Bits[11:11], RW_LBV, default = 1'b1 
       Contains the primary indication when mirroring is enabled. Can be written to 
       specify the next scrub address. RESTRICTION: Patrol Scrubs must be disabled when 
       writing to this field. Only used for system address patrol mode. 
     */
    UINT32 rank : 4;
    /* rank - Bits[15:12], RW_LBV, default = 4'b0000 
       Contains the physical rank ID of the last scrub issued. Can be written to 
       specify the next scrub address with STARTSCRUB. RESTRICTION: Patrol Scrubs must 
       be disabled when writing to this field. Only used for legacy (non system 
       address) patrol mode. 
     */
    UINT32 chnl : 2;
    /* chnl - Bits[17:16], RW_LBV, default = 2'b00 
       Can be written to specify the next scrub address with STARTSCRUB. This register 
       is updated with channel address of the last scrub address issued. RESTRICTIONS: 
       Patrol Scrubs must be disabled when writing to this field. Only used for legacy 
       (non system address) patrol mode. 
     */
    UINT32 rsvd_18 : 2;
    /* rsvd_18 - Bits[19:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 tad_rule : 3;
    /* tad_rule - Bits[22:20], RW_LBV, default = 3'b000 
       Contains the TAD rule of the last scrub issued. Can be written to specify the 
       next scrub address with STARTSCRUB. scrubaddresshi.ptl_sa_mode must be cleared 
       to 0 and then set back to 1 after STARTSCRUB is set for address written to take 
       effect. RESTRICTION: Patrol Scrubs must be disabled when writing to this field. 
       Only used system address patrol mode. 
     */
    UINT32 rsvd_23 : 1;
    /* rsvd_23 - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 minimum_tad_rule : 3;
    /* minimum_tad_rule - Bits[26:24], RW_LB, default = 3'b000 
       
                   First TAD rule used for patrol address generation. Set to 0 to begin 
       generating system addresses for patrol at the lowest address mapped to the MC. 
               
     */
    UINT32 rsvd_27 : 1;
    /* rsvd_27 - Bits[27:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 maximum_tad_rule : 3;
    /* maximum_tad_rule - Bits[30:28], RW_LB, default = 3'b000 
       
                   Last TAD rule used for patrol address generation. Set to the maximum 
       valid TAD rule number used on the MC to generate system addresses for patrol up 
       to the maximum address mapped to the MC. 
               
     */
    UINT32 ptl_sa_mode : 1;
    /* ptl_sa_mode - Bits[31:31], RW_LBV, default = 1'b1 
       Patrol runs in system address generation mode if patrol is enabled.  If this 
       mode bit is not set, patrol runs in legacy mode if patrol is enabled. 
     */
  } Bits;
  UINT32 Data;
} SCRUBADDRESSHI_MC_MAIN_STRUCT;


/* SCRUBCTL_MC_MAIN_REG supported on:                                         */
/*       SKX_A0 (0x40250914)                                                  */
/*       SKX (0x40250914)                                                     */
/* Register default value:              0x00000000                            */
#define SCRUBCTL_MC_MAIN_REG 0x07004914
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * This register contains the Scrub control parameters and status.
 */
typedef union {
  struct {
    UINT32 scrubinterval : 24;
    /* scrubinterval - Bits[23:0], RW_LB, default = 24'b000000000000000000000000 
       Reserved Unused. Scrub interval is now defined in PCU.
     */
    UINT32 startscrub : 1;
    /* startscrub - Bits[24:24], RW_LBV, default = 1'b0 
       When Set, the Patrol scrub engine will start from the address in the scrub 
       address registers. Once the scrub is issued this bit is reset. 
     */
    UINT32 issueonce : 1;
    /* issueonce - Bits[25:25], RW_LB, default = 1'b0 
       When Set, the patrol scrub engine will issue the address in the scrub address 
       registers only once and stop.  Software is responsible to turn off periodic 
       patrol before issuing patrol once.  The patrol interval in PMA should be set to 
       0 in issue once mode.  No cross product of patrol once with PkgC is allowed. 
     */
    UINT32 scrubissued : 1;
    /* scrubissued - Bits[26:26], RW_LBV, default = 1'b0 
       When Set, the scrub address registers contain the last scrub address issued
     */
    UINT32 ptl_stopped : 1;
    /* ptl_stopped - Bits[27:27], RW_LBV, default = 1'b0 
       When stop_on_err is set, patrol will stop on error and set this bit.
       Patrol will resume at the next address when this bit or stop_on_err is cleared 
       by BIOS and patrol scrub is still enabled by scrub_en. 
     */
    UINT32 stop_on_err : 1;
    /* stop_on_err - Bits[28:28], RW_LB, default = 1'b0 
       Stop patrol scrub on poison or uncorrectable. On poison, patrol will log error 
       then stop. On uncorr, patrol will convert to poison (if enabled) or stop if 
       mcmain_chkn_bits.dis_ptrl_psn = 1. If mcmain_chkn_bits.dis_ptrl_psn = 0, uncorr 
       error will not stop immediately. But since patrol convert uncorr to poison (when 
       enabled), next when this poison line is scrubbed, patrol will be stopped. 
       This mode is meant to be used as part of memory migration flow. SMI is signalled 
       by default. 
     */
    UINT32 ptl_cmpl : 1;
    /* ptl_cmpl - Bits[29:29], RW_LBV, default = 1'b0 
       When stop_on_cmpl is enabled, patrol will stop at the end of the address range 
       and set this bit. 
       Patrol will resume from beginning of address range when this bit or stop_on_cmpl 
       is cleared by BIOS and patrol scrub is still enabled by scrub_en. 
     */
    UINT32 stop_on_cmpl : 1;
    /* stop_on_cmpl - Bits[30:30], RW_LB, default = 1'b0 
       Stop patrol scrub at end of memory range. This mode is meant to be used as part 
       of memory migration flow.  
                   SMI is signalled by default.
     */
    UINT32 scrub_en : 1;
    /* scrub_en - Bits[31:31], RW_L, default = 1'b0 
       Scrub Enable when set.  
     */
  } Bits;
  UINT32 Data;
} SCRUBCTL_MC_MAIN_STRUCT;


/* SPAREINTERVAL_MC_MAIN_REG supported on:                                    */
/*       SKX_A0 (0x4025091C)                                                  */
/*       SKX (0x4025091C)                                                     */
/* Register default value:              0x03200C80                            */
#define SPAREINTERVAL_MC_MAIN_REG 0x0700491C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Defines the interval between normal and sparing operations. Interval is defined 
 * in dclk. 
 */
typedef union {
  struct {
    UINT32 normopdur : 16;
    /* normopdur - Bits[15:0], RW_LB, default = 16'b0000110010000000 
       Normal operation duration. System requests will be serviced during this 
       interval. 
     */
    UINT32 numspare : 13;
    /* numspare - Bits[28:16], RW_LB, default = 13'b0001100100000 
       Sparing operation duration. System requests will be blocked during this interval 
       and only sparing copy operations will be serviced. 
     */
    UINT32 rsvd : 3;
    /* rsvd - Bits[31:29], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SPAREINTERVAL_MC_MAIN_STRUCT;


/* RASENABLES_MC_MAIN_REG supported on:                                       */
/*       SKX_A0 (0x40250920)                                                  */
/*       SKX (0x40250920)                                                     */
/* Register default value:              0x00000090                            */
#define RASENABLES_MC_MAIN_REG 0x07004920
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * RAS Enables Register
 */
typedef union {
  struct {
    UINT32 mirroren : 1;
    /* mirroren - Bits[0:0], RW_LB, default = 1'b0 
       Mirror mode enable. The channel mapping must be set up before this bit will have 
       an effect on IMC operation. This changes the error policy. 
     */
    UINT32 rsvd_1 : 3;
    /* rsvd_1 - Bits[3:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ch0_mirror : 2;
    /* ch0_mirror - Bits[5:4], RW_LB, default = 2'b01 
       The secondary channel number when the primary channel is channel 0 for 
       mirroring. This is used by patrol logic. 
     */
    UINT32 ch1_mirror : 2;
    /* ch1_mirror - Bits[7:6], RW_LB, default = 2'b10 
       The secondary channel number when the primary channel is channel 1 for 
       mirroring. This is used by patrol logic. 
     */
    UINT32 ch2_mirror : 2;
    /* ch2_mirror - Bits[9:8], RW_LB, default = 2'b00 
       The secondary channel number when the primary channel is channel 2 for 
       mirroring. This is used by patrol logic. 
     */
    UINT32 rsvd_10 : 22;
    /* rsvd_10 - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} RASENABLES_MC_MAIN_STRUCT;


/* SMISPARECTL_MC_MAIN_REG supported on:                                      */
/*       SKX_A0 (0x40250924)                                                  */
/*       SKX (0x40250924)                                                     */
/* Register default value:              0x00000000                            */
#define SMISPARECTL_MC_MAIN_REG 0x07004924
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * System Management Interrupt and Spare control register.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 15;
    /* rsvd_0 - Bits[14:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intrpt_sel_smi : 1;
    /* intrpt_sel_smi - Bits[15:15], RW_LB, default = 1'b0 
       SMI enable. Set to enable SMi signaling. Clear to disable SMI signaling.
     */
    UINT32 intrpt_sel_cmci : 1;
    /* intrpt_sel_cmci - Bits[16:16], RW_LB, default = 1'b0 
       (CMCI used as a proxy for NMI signaling). Set to enable NMI signaling. Clear to 
       disable NMI signaling. If both NMI and 
       SMI enable bits are set then only SMI is sent.
     */
    UINT32 intrpt_sel_pin : 1;
    /* intrpt_sel_pin - Bits[17:17], RW_LB, default = 1'b0 
       Enable pin signaling. When set the interrupt is signaled via the err[0] pin to 
       get the attention of a BMC. 
     */
    UINT32 rsvd_18 : 14;
    /* rsvd_18 - Bits[31:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SMISPARECTL_MC_MAIN_STRUCT;


/* LEAKY_BUCKET_CFG_MC_MAIN_REG supported on:                                 */
/*       SKX_A0 (0x40250928)                                                  */
/*       SKX (0x40250928)                                                     */
/* Register default value:              0x00000000                            */
#define LEAKY_BUCKET_CFG_MC_MAIN_REG 0x07004928
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * generated by critter 19_1_0x0b8
 */
typedef union {
  struct {
    UINT32 leaky_bkt_cfg_lo : 6;
    /* leaky_bkt_cfg_lo - Bits[5:0], RW_LB, default = 6'b000000 
       This is the lower order bit select mask of the two hot encoding threshold. The 
       value of this field specify the bit position of the mask: 
       00h: reserved
       01h: LEAKY_BUCKET_CNTR_LO bit 1, i.e. bit 12 of the full 53b counter
       ...
       1Fh: LEAKY_BUCKET_CNTR_LO bit 31, i.e. bit 42 of the full 53b counter
       20h: LEAKY_BUCKET_CNTR_HI bit 0, i.e. bit 43 of the full 53b counter
       ...
       29h: LEAKY_BUCKET_CNTR_HI bit 9, i.e. bit 52 of the full 53b counter
       2Ah - 3F: reserved
       When both counter bits selected by the LEAKY_BKT_CFG_HI and LEAKY_BKT_CFG_LO are 
       set, the 53b leaky bucket counter will be reset and the logic will generate a 
       LEAK pulse to decrement the correctable error counter by 1. 
       MRC BIOS must program this register to any non-zero value before switching to 
       NORMAL mode. 
     */
    UINT32 leaky_bkt_cfg_hi : 6;
    /* leaky_bkt_cfg_hi - Bits[11:6], RW_LB, default = 6'b000000 
       This is the higher order bit select mask of the two hot encoding threshold. The 
       value of this field specify the bit position of the mask: 
       00h: reserved
       01h: LEAKY_BUCKET_CNTR_LO bit 1, i.e. bit 12 of the full 53b counter
       ...
       1Fh: LEAKY_BUCKET_CNTR_LO bit 31, i.e. bit 42 of the full 53b counter
       20h: LEAKY_BUCKET_CNTR_HI bit 0, i.e. bit 43 of the full 53b counter
       ...
       29h: LEAKY_BUCKET_CNTR_HI bit 9, i.e. bit 52 of the full 53b counter
       2Ah - 3F: reserved
       When both counter bits selected by the LEAKY_BKT_CFG_HI and LEAKY_BKT_CFG_LO are 
       set, the 53b leaky bucket counter will be reset and the logic will generate a 
       LEAK pulse to decrement the correctable error counter by 1. 
       MRC BIOS must program this register to any non-zero value before switching to 
       NORMAL mode. 
     */
    UINT32 rsvd : 20;
    /* rsvd - Bits[31:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LEAKY_BUCKET_CFG_MC_MAIN_STRUCT;


/* LEAKY_BUCKET_CNTR_LO_MC_MAIN_REG supported on:                             */
/*       SKX_A0 (0x40250930)                                                  */
/*       SKX (0x40250930)                                                     */
/* Register default value:              0x00000000                            */
#define LEAKY_BUCKET_CNTR_LO_MC_MAIN_REG 0x07004930
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * generated by critter 19_1_0x0c0
 */
typedef union {
  struct {
    UINT32 leaky_bkt_cntr_lo : 32;
    /* leaky_bkt_cntr_lo - Bits[31:0], RW_V, default = 32'b00000000000000000000000000000000 
       This is the lower half of the leaky bucket counter. The full counter is actually 
       a 53b "DCLK" counter. There is a least significant 11b of the 53b counter is not 
       captured in CSR. The carry "strobe" from the not-shown least significant 11b 
       counter will trigger this 42b counter pair to count. The 42b counter-pair is 
       compared with the two-hot encoding threshold specified by the 
       LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO pair. When the counter bits 
       specified by the LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO are both set, the 
       53b counter is reset and the leaky bucket logic will generate a LEAK strobe last 
       for 1 DCLK.   
     */
  } Bits;
  UINT32 Data;
} LEAKY_BUCKET_CNTR_LO_MC_MAIN_STRUCT;


/* LEAKY_BUCKET_CNTR_HI_MC_MAIN_REG supported on:                             */
/*       SKX_A0 (0x40250934)                                                  */
/*       SKX (0x40250934)                                                     */
/* Register default value:              0x00000000                            */
#define LEAKY_BUCKET_CNTR_HI_MC_MAIN_REG 0x07004934
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * generated by critter 19_1_0x0c4
 */
typedef union {
  struct {
    UINT32 leaky_bkt_cntr_hi : 10;
    /* leaky_bkt_cntr_hi - Bits[9:0], RW_V, default = 10'b0000000000 
       This is the upper half of the leaky bucket counter. The full counter is actually 
       a 53b "DCLK" counter. There is a least significant 11b of the 53b counter is not 
       captured in CSR. The carry "strobe" from the not-shown least significant 11b 
       counter will trigger this 42b counter pair to count. The 42b counter-pair is 
       compared with the two-hot encoding threshold specified by the 
       LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO pair. When the counter bits 
       specified by the LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO are both set, the 
       53b counter is reset and the leaky bucket logic will generate a LEAK strobe last 
       for 1 DCLK.   
     */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LEAKY_BUCKET_CNTR_HI_MC_MAIN_STRUCT;


/* MAXMTR_MC_MAIN_REG supported on:                                           */
/*       SKX_A0 (0x40250944)                                                  */
/*       SKX (0x40250944)                                                     */
/* Register default value:              0x00000000                            */
#define MAXMTR_MC_MAIN_REG 0x07004944
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * generated by critter 19_1_0x0d4
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 6;
    /* rsvd_0 - Bits[5:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 maxnumrow : 3;
    /* maxnumrow - Bits[8:6], RW, default = 3'b000 
       Max number of rows.
       000: 2^12 rows
       001: 2^13 rows
       010: 2^14 rows
       011: 2^15 rows
       100: 2^16 rows
       101: 2^17 rows
       110: 2^18 rows
       Others: reserved
     */
    UINT32 maxnumcol : 2;
    /* maxnumcol - Bits[10:9], RW, default = 2'b00 
       Max number of columns.
       00: 2^10 columns
       01: 2^11 columns
       10: 2^12 columns
       11: 2^13 columns (Reserved)
     */
    UINT32 rsvd_11 : 21;
    /* rsvd_11 - Bits[31:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MAXMTR_MC_MAIN_STRUCT;


/* SCRUBADDRESS2LO_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250950)                                                  */
/*       SKX (0x40250950)                                                     */
/* Register default value:              0x00000000                            */
#define SCRUBADDRESS2LO_MC_MAIN_REG 0x07004950
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * This register contains part of the address of the last patrol scrub request 
 * issued. When running memtest, the failing address is logged in this register on 
 * memtest errors. Software can write the next address to be scrubbed into this 
 * register. The STARTSCRUB bit will then trigger the specified address to be 
 * scrubbed. Patrol scrubs must be disabled to reliably write this register. 
 */
typedef union {
  struct {
    UINT32 baseadd : 32;
    /* baseadd - Bits[31:0], RW_LBV, default = 32'b00000000000000000000000000000000 
       Contains bits 37:6 of the base system address of the last scrub issued. This is 
       the base of the current system address. Can be written to specify the next scrub 
       address with STARTSCRUB. System address in scrubaddresslo/hi also need to be 
       programmed in system address mode for the programmed address to take effect. 
       scrubaddresshi.ptl_sa_mode must be cleared to 0 and then set back to 1 after 
       STARTSCRUB is set for address written to take effect. RESTRICTIONS: Patrol 
       Scrubs must be disabled when writing to this field. Only used system address 
       patrol mode. 
     */
  } Bits;
  UINT32 Data;
} SCRUBADDRESS2LO_MC_MAIN_STRUCT;


/* SCRUBADDRESS2HI_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250954)                                                  */
/*       SKX (0x40250954)                                                     */
/* Register default value:              0x00000000                            */
#define SCRUBADDRESS2HI_MC_MAIN_REG 0x07004954
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * This register pair contains part of the address of the last patrol scrub request 
 * issued. Software can write the next address into this register. Scrubbing must 
 * be disabled to reliably read and write this register. The STARTSCRUB bit will 
 * then trigger the specified address to be scrubbed. 
 */
typedef union {
  struct {
    UINT32 baseaddhi : 9;
    /* baseaddhi - Bits[8:0], RW_LBV, default = 9'b000000000 
       Contains bits 46:38 of the base system address of the last scrub issued. This is 
       the base of the current system address. Can be written to specify the next scrub 
       address with STARTSCRUB. System address in scrubaddresslo/hi also need to be 
       programmed in system address mode for the programmed address to work properly. 
       scrubaddresshi.ptl_sa_mode must be cleared to 0 and then set back to 1 after 
       STARTSCRUB is set for address written to take effect. RESTRICTIONS: Patrol 
       Scrubs must be disabled when writing to this field. Only used system address 
       patrol mode. 
     */
    UINT32 rsvd : 23;
    /* rsvd - Bits[31:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SCRUBADDRESS2HI_MC_MAIN_STRUCT;


/* EMCALTCTL_MC_MAIN_REG supported on:                                        */
/*       SKX_A0 (0x1025095C)                                                  */
/*       SKX (0x1025095C)                                                     */
/* Register default value:              0x00                                  */
#define EMCALTCTL_MC_MAIN_REG 0x0700195C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * eMCA lite control register.
 */
typedef union {
  struct {
    UINT8 emcalt_sel_smi : 1;
    /* emcalt_sel_smi - Bits[0:0], RW_LB, default = 1'b0 
       SMI enable. Set to enable SMI signaling for each correctable error. Clear to 
       disable SMI signaling and signal CMCI when correctable error threshold is 
       reached. 
     */
    UINT8 rsvd : 7;
    /* rsvd - Bits[7:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} EMCALTCTL_MC_MAIN_STRUCT;


/* LBITMAP_MC_MAIN_REG supported on:                                          */
/*       SKX_A0 (0x40250960)                                                  */
/*       SKX (0x40250960)                                                     */
/* Register default value:              0x00000008                            */
#define LBITMAP_MC_MAIN_REG 0x07004960
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * This register defines a position of the bitmap in the global error status. 
 */
typedef union {
  struct {
    UINT32 bit_select : 5;
    /* bit_select - Bits[4:0], RW, default = 5'b01000 
       selects which bit to set in the one-hot payload of the Global Error Message that 
       iMC sends to UBOX.  
     */
    UINT32 rsvd : 27;
    /* rsvd - Bits[31:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} LBITMAP_MC_MAIN_STRUCT;






/* SCRUBMASK_MC_MAIN_REG supported on:                                        */
/*       SKX_A0 (0x4025096C)                                                  */
/*       SKX (0x4025096C)                                                     */
/* Register default value:              0x00000000                            */
#define SCRUBMASK_MC_MAIN_REG 0x0700496C
/* Struct format extracted from XML file SKX_A0\2.10.0.CFG.xml.
 * This register contains fields to make channels/ranks from patrol scrub engine.
 */
typedef union {
  struct {
    UINT32 ch_mask : 4;
    /* ch_mask - Bits[3:0], RW_L, default = 4'b0000 
       Patrol scrub channel mask, one bit per channel. Setting this bit will skip 
       patrol scrub on that channel according to the all_ranks and chx_rank fields. 
       lock bit is the scrub_en in scrubctl register.
     */
    UINT32 all_ranks : 4;
    /* all_ranks - Bits[7:4], RW_L, default = 4'b0000 
       Setting this bit will skip all ranks on the channel when the channel mask is 
       set. Else it will skip the rank specified on chx_rank. 
     */
    UINT32 ch0_rank : 3;
    /* ch0_rank - Bits[10:8], RW_L, default = 3'b000 
       Rank to skip for channel 0 when all_ranks is set to 0.
     */
    UINT32 ch1_rank : 3;
    /* ch1_rank - Bits[13:11], RW_L, default = 3'b000 
       Rank to skip for channel 1 when all_ranks is set to 0.
     */
    UINT32 ch2_rank : 3;
    /* ch2_rank - Bits[16:14], RW_L, default = 3'b000 
       Rank to skip for channel 2 when all_ranks is set to 0.
     */
    UINT32 ch3_rank : 3;
    /* ch3_rank - Bits[19:17], RW_L, default = 3'b000 
       Rank to skip for channel 3 when all_ranks is set to 0.
     */
    UINT32 link_fail : 4;
    /* link_fail - Bits[23:20], RW_L, default = 4'h0  */
    UINT32 no_stop_on_ecc : 1;
    /* no_stop_on_ecc - Bits[24:24], RW_L, default = 1'b0 
       When set to 1, patrol fsm will not stop if ECC error flow is on.
     */
    UINT32 rsvd : 7;
    /* rsvd - Bits[31:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SCRUBMASK_MC_MAIN_A0_STRUCT;

/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * This register contains fields to make channels/ranks from patrol scrub engine.
 */
typedef union {
  struct {
    UINT32 ch_mask : 4;
    /* ch_mask - Bits[3:0], RW_L, default = 4'b0000 
       Patrol scrub channel mask, one bit per channel. Setting this bit will skip 
       patrol scrub on that channel according to the all_ranks and chx_rank fields. 
       lock bit is the scrub_en in scrubctl register.
     */
    UINT32 all_ranks : 4;
    /* all_ranks - Bits[7:4], RW_L, default = 4'b0000 
       Setting this bit will skip all ranks on the channel when the channel mask is 
       set. Else it will skip the rank specified on chx_rank. 
     */
    UINT32 ch0_rank : 3;
    /* ch0_rank - Bits[10:8], RW_L, default = 3'b000 
       Rank to skip for channel 0 when all_ranks is set to 0.
     */
    UINT32 ch1_rank : 3;
    /* ch1_rank - Bits[13:11], RW_L, default = 3'b000 
       Rank to skip for channel 1 when all_ranks is set to 0.
     */
    UINT32 ch2_rank : 3;
    /* ch2_rank - Bits[16:14], RW_L, default = 3'b000 
       Rank to skip for channel 2 when all_ranks is set to 0.
     */
    UINT32 ch3_rank : 3;
    /* ch3_rank - Bits[19:17], RW_L, default = 3'b000 
       Rank to skip for channel 3 when all_ranks is set to 0.
     */
    UINT32 link_fail : 4;
    /* link_fail - Bits[23:20], RW_L, default = 4'h0  */
    UINT32 no_stop_on_ecc : 1;
    /* no_stop_on_ecc - Bits[24:24], RW_L, default = 1'b0 
       When set to 1, patrol fsm will not stop if ECC error flow is on.
     */
    UINT32 no_stop_on_mmretry : 1;
    /* no_stop_on_mmretry - Bits[25:25], RW_L, default = 1'b0 
       When set to 1, patrol fsm will not stop if M2Mem goes into retry.
     */
    UINT32 rsvd : 6;
    /* rsvd - Bits[31:26], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SCRUBMASK_MC_MAIN_STRUCT;



/* SPARING_CONTROL_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250970)                                                  */
/*       SKX (0x40250970)                                                     */
/* Register default value on SKX_A0:    0x00100000                            */
/* Register default value on SKX:       0x00000000                            */
#define SPARING_CONTROL_MC_MAIN_REG 0x07004970
/* Struct format extracted from XML file SKX_A0\2.10.0.CFG.xml.
 *  This register controls the sparing copy operation for ADDDC, rank sparing, and 
 * SDDC.   
 */
typedef union {
  struct {
    UINT32 spare_enable : 1;
    /* spare_enable - Bits[0:0], RW_LBV, default = 1'b0 
       Spare enable when set to 1. Hardware clears this bit after the sparing 
       completion. 
     */
    UINT32 reverse : 1;
    /* reverse - Bits[1:1], RW_LB, default = 1'b0 
       
                         Setting this bit will cause sparing engine to be run in 
       reverse (move from virtual lockstep back to independent) when sparing has been 
       started via the spare_enable bit. 
                         Expected usage models are upgrading a region failure from bank 
       to rank and post-silicon testing  
                     
     */
    UINT32 rank_sparing : 1;
    /* rank_sparing - Bits[2:2], RW_LB, default = 1'b0 
       
                         This bit causes the sparing copy to be rank sparing when 
       sparing copy has been started via the spare_enable bit. 
       This bit is mutually exclusive with the adddc_sparing and sddc_sparing bits.
                         This register is locked by the DISABLE_RANK_SPARING bit from 
       IMC_FUSE_DOWNLOAD register. 
                     
     */
    UINT32 adddc_sparing : 1;
    /* adddc_sparing - Bits[3:3], RW_LB, default = 1'b0 
       
                         This bit causes the sparing copy to be ADDDC sparing when 
       sparing copy has been started via the spare_enable bit. 
                         This bit is mutually exclusive with the rank_sparing and 
       sddc_sparing bits. 
                         This register is locked by the DISABLE_ADDDC_SPARING bit from 
       IMC_FUSE_DOWNLOAD register. 
                     
     */
    UINT32 sddc_sparing : 1;
    /* sddc_sparing - Bits[4:4], RW_LB, default = 1'b0 
       
                         This bit causes the sparing copy to transition ECC to the SDDC 
       state when sparing copy has been started via the spare_enable bit. 
                         This bit is mutually exclusive with the adddc_sparing and 
       rank_sparing bits. 
                         This register is locked by the DISABLE_SDDC bit from 
       IMC_FUSE_DOWNLOAD register. 
                     
     */
    UINT32 channel_select : 2;
    /* channel_select - Bits[6:5], RW_LB, default = 2'b00 
       
                         Since there is only one sparing copy engine for all channels, 
       this field selects the channel for the sparing copy operation. 
                         00 = channel 0 is selected for the sparing copy operation
                         01 = channel 1 is selected for the sparing copy operation
                         10 = channel 2 is selected for the sparing copy operation;  
       reserved on EX 
                         11 = reserved
                     
     */
    UINT32 region_size : 2;
    /* region_size - Bits[8:7], RW_LB, default = 2'b00 
       
                             This field selects the granularity for the sparing copy 
       operation: 
                             00=Bank
                             01=Rank
                             1X=Reserved
                         
     */
    UINT32 virtual_lockstep_en : 1;
    /* virtual_lockstep_en - Bits[9:9], RW_LB, default = 2'b00 
       
                             When set, this iMC is being used in static Virtual 
       Lockstep mode. 
                             ADDDC sparing flow may not be initiated when this bit is 
       set, though rank sparing or sddc sparing may still be used. 
                             This bit should be set and locked before memory 
       initialization. 
                         
     */
    UINT32 rsvd_10 : 2;
    /* rsvd_10 - Bits[11:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 minimum_tad_rule : 3;
    /* minimum_tad_rule - Bits[14:12], RW_LB, default = 3'b000 
       
                             First TAD rule used for spare address generation.
       		      Set to 0 to begin generating system addresses for sparing
       		      at the lowest address mapped to the MC.
                         
     */
    UINT32 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 maximum_tad_rule : 3;
    /* maximum_tad_rule - Bits[18:16], RW_LB, default = 3'b000 
       
                             Last TAD rule used for spare address generation.
       		      Set to the maximum valid TAD rule number used on the MC
       		      to generate system addresses for sparing up to the maximum
       		      address mapped to the MC.
                         
     */
    UINT32 mirr_pri : 1;
    /* mirr_pri - Bits[19:19], RW_LB, default = 1'b1 
       The primary indication when mirroring is enabled. When set to 1, only addresses 
       in mirror primary channel and non-mirrored region are spare copied. When set to 
       0, only addresses in mirror secondary channel are spare copied. 
     */
    UINT32 skip_non_mirr : 1;
    /* skip_non_mirr - Bits[20:20], RW_LB, default = 1'b0 
       When set to 1, addresses in non-mirrored TAD are not spare copied. This bit is 
       intended to be used when non-mirrored addresses are already spare copied with 
       primary channel. 
     */
    UINT32 rsvd_21 : 11;
    /* rsvd_21 - Bits[31:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SPARING_CONTROL_MC_MAIN_A0_STRUCT;

/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  This register controls the sparing copy operation for ADDDC, rank sparing, and 
 * SDDC.   
 */
typedef union {
  struct {
    UINT32 spare_enable : 1;
    /* spare_enable - Bits[0:0], RW_LBV, default = 1'b0 
       Spare enable when set to 1. Hardware clears this bit after the sparing 
       completion. 
     */
    UINT32 reverse : 1;
    /* reverse - Bits[1:1], RW_LB, default = 1'b0 
       
                         Setting this bit will cause sparing engine to be run in 
       reverse (move from virtual lockstep back to independent) when sparing has been 
       started via the spare_enable bit. 
                         Expected usage models are upgrading a region failure from bank 
       to rank and post-silicon testing  
                     
     */
    UINT32 rank_sparing : 1;
    /* rank_sparing - Bits[2:2], RW_LB, default = 1'b0 
       
                         This bit causes the sparing copy to be rank sparing when 
       sparing copy has been started via the spare_enable bit. 
       This bit is mutually exclusive with the adddc_sparing and sddc_sparing bits.
                         This register is locked by the DISABLE_RANK_SPARING bit from 
       IMC_FUSE_DOWNLOAD register. 
                     
     */
    UINT32 adddc_sparing : 1;
    /* adddc_sparing - Bits[3:3], RW_LB, default = 1'b0 
       
                         This bit causes the sparing copy to be ADDDC sparing when 
       sparing copy has been started via the spare_enable bit. 
                         This bit is mutually exclusive with the rank_sparing and 
       sddc_sparing bits. 
                         This register is locked by the DISABLE_ADDDC_SPARING bit from 
       IMC_FUSE_DOWNLOAD register. 
                     
     */
    UINT32 sddc_sparing : 1;
    /* sddc_sparing - Bits[4:4], RW_LB, default = 1'b0 
       
                         This bit causes the sparing copy to transition ECC to the SDDC 
       state when sparing copy has been started via the spare_enable bit. 
                         This bit is mutually exclusive with the adddc_sparing and 
       rank_sparing bits. 
                         This register is locked by the DISABLE_SDDC bit from 
       IMC_FUSE_DOWNLOAD register. 
                     
     */
    UINT32 channel_select : 2;
    /* channel_select - Bits[6:5], RW_LB, default = 2'b00 
       
                         Since there is only one sparing copy engine for all channels, 
       this field selects the channel for the sparing copy operation. 
                         00 = channel 0 is selected for the sparing copy operation
                         01 = channel 1 is selected for the sparing copy operation
                         10 = channel 2 is selected for the sparing copy operation
                         11 = reserved
                     
     */
    UINT32 region_size : 2;
    /* region_size - Bits[8:7], RW_LB, default = 2'b00 
       
                             This field selects the granularity for the sparing copy 
       operation: 
                             00=Bank
                             01=Rank
                             1X=Reserved
                         
     */
    UINT32 virtual_lockstep_en : 3;
    /* virtual_lockstep_en - Bits[11:9], RW_LB, default = 2'b00 
       
                             When set, this iMC is being used in static Virtual 
       Lockstep mode. 
                             ADDDC sparing flow may not be initiated when this bit is 
       set, though rank sparing or sddc sparing may still be used. 
                             This bit should be set and locked before memory 
       initialization. each channel gets its own enable bit 
                         
     */
    UINT32 minimum_tad_rule : 3;
    /* minimum_tad_rule - Bits[14:12], RW_LB, default = 3'b000 
       First TAD rule used for spare address generation. Set to 0 to begin generating 
       system addresses for sparing at the lowest address mapped to the MC. When 
       mirr_adddc_en = 1 and partial_mirr_en = 1, this represent the first TAD rule 
       with mirror_en = 1. 
     */
    UINT32 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 maximum_tad_rule : 3;
    /* maximum_tad_rule - Bits[18:16], RW_LB, default = 3'b000 
       Last TAD rule used for spare address generation. Set to the maximum valid TAD 
       rule number used on the MC to generate system addresses for sparing up to the 
       maximum address mapped to the MC. When mirr_adddc_en = 1 and partial_mirr_en = 
       1, this represent the last TAD rule with mirror_en = 1. 
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mirr_adddc_en : 1;
    /* mirr_adddc_en - Bits[20:20], RW_LB, default = 1'b0 
       Enabling special spare copy mode for ADDDC and mirroring enable. In this mode, 
       system addresses will be gone through 3 times, with first pass for non-mirror 
       addresses, second pass for mirror primary addresses, and third pass for mirror 
       secondary addresses. For this function to work, amap.mirr_adddc_en needs to be 
       set to 1 in the channel spare copy is done. 
     */
    UINT32 partial_mirr_en : 1;
    /* partial_mirr_en - Bits[21:21], RW_LB, default = 1'b0 
       Only used when mirr_adddc_en = 1. When set to 1, indicates partial mirroring is 
       enabled and system addresses will be generated 3 times. If set to 0, only full 
       mirroring is enabled and first pass system address will be skipped. 
     */
    UINT32 rsvd_22 : 2;
    /* rsvd_22 - Bits[23:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 minimum_tad_rule_nonmirr : 3;
    /* minimum_tad_rule_nonmirr - Bits[26:24], RW_LB, default = 3'b000 
       First TAD rule for non-mirror region used for spare address generation. Set to 
       minimum valid TAD rule number with mirror_en = 0 to begin generating system 
       addresses for sparing at the lowest non-mirror address mapped to the MC. This 
       field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. 
     */
    UINT32 rsvd_27 : 1;
    /* rsvd_27 - Bits[27:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 maximum_tad_rule_nonmirr : 3;
    /* maximum_tad_rule_nonmirr - Bits[30:28], RW_LB, default = 3'b000 
       Last TAD rule for non-mirror region used for spare address generation. Set to 
       the maximum valid TAD rule number with mirror_en = 0 used on the MC to generate 
       system addresses for sparing up to the maximum non-mirror address mapped to the 
       MC. This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. 
     */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SPARING_CONTROL_MC_MAIN_STRUCT;



/* SPARING_CONTROL_SOURCE_MC_MAIN_REG supported on:                           */
/*       SKX_A0 (0x40250974)                                                  */
/*       SKX (0x40250974)                                                     */
/* Register default value:              0x00000000                            */
#define SPARING_CONTROL_SOURCE_MC_MAIN_REG 0x07004974
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  This register controls the source for the sparing copy operation for ADDDC, 
 * rank sparing, and SDDC.   
 */
typedef union {
  struct {
    UINT32 source_cs : 3;
    /* source_cs - Bits[2:0], RW_LB, default = 3'b000 
       
                                The value in this field is encoded (Chip Selects are 
       normally 1-hot), corresponding to CS0-CS7.   
                                For rank sparing this field specifies the source rank 
       (Chip Select, CS0-CS7) for the sparing copy.   
                                For ADDDC and +1(SDDC), this field specifies the failed 
       rank for the sparing copy.   
                             
     */
    UINT32 rsvd_3 : 1;
    /* rsvd_3 - Bits[3:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 source_c : 3;
    /* source_c - Bits[6:4], RW_LB, default = 3'b000 
       
                                 For ADDDC used at the bank granularity 
       (region_size=bank), this field specifies the subrank (C0-C2) to match for the 
       sparing copy. 
                             
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 source_ba : 2;
    /* source_ba - Bits[9:8], RW_LB, default = 3'b000 
       
                                 For ADDDC used at the bank granularity 
       (region_size=bank), this field specifies the bank address (BA0-BA1) to match for 
       the sparing copy. 
                             
     */
    UINT32 source_bg : 2;
    /* source_bg - Bits[11:10], RW_LB, default = 3'b000 
       
                                 For ADDDC used at the bank granularity 
       (region_size=bank), this field specifies the bank group (BG0-BG1) to match for 
       the sparing copy. 
                             
     */
    UINT32 reserved : 4;
    /* reserved - Bits[15:12], RW_LB, default = 3'b000 
        Reserved for future use.  
     */
    UINT32 buddy_cs_en : 1;
    /* buddy_cs_en - Bits[16:16], RW_LB, default = 1'b0 
       
                                The enable bit for buddy_cs field. This enable bit is 
       only set for SDDC sparing in x8 mode, or SDDC sparing after ADDDC is enabled. 
                             
     */
    UINT32 buddy_cs : 3;
    /* buddy_cs - Bits[19:17], RW_LB, default = 3'b000 
       
                                The value in this field is encoded (Chip Selects are 
       normally 1-hot), corresponding to CS0-CS7.   
                                This field is only used for SDDC sparing in x8 mode, or 
       SDDC sparing after ADDDC is enabled. 
                                This field specifies the primary rank (Chip Select, 
       CS0-CS7) of an ADDDC transaction whose buddy is in the rank represented by 
       source_cs. 
                                This field is used only if buddy_cs_en bit is set to 1.
                             
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SPARING_CONTROL_SOURCE_MC_MAIN_STRUCT;


/* SPARING_CONTROL_DESTINATION_MC_MAIN_REG supported on:                      */
/*       SKX_A0 (0x40250978)                                                  */
/*       SKX (0x40250978)                                                     */
/* Register default value:              0x00000000                            */
#define SPARING_CONTROL_DESTINATION_MC_MAIN_REG 0x07004978
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  This register controls the destination for the sparing copy operation for 
 * ADDDC, rank sparing, and SDDC.   
 */
typedef union {
  struct {
    UINT32 destination_cs : 3;
    /* destination_cs - Bits[2:0], RW_LB, default = 3'b000 
       
                                 The value in this field is encoded (Chip Selects are 
       normally 1-hot), corresponding to CS0-CS7.   
                                 For rank sparing this field specifies the destination 
       rank (Chip Select, CS0-CS7) for the sparing copy.   
                                 For ADDDC and +1(SDDC) sparing  this field must be 
       equal to the source_cs.   
                            
     */
    UINT32 rsvd_3 : 1;
    /* rsvd_3 - Bits[3:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 destination_c : 3;
    /* destination_c - Bits[6:4], RW_LB, default = 3'b000 
       
                                 This field is unused for rank sparing, ADDDC, and SDDC 
       sparing. 
                            
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 destination_ba : 2;
    /* destination_ba - Bits[9:8], RW_LB, default = 3'b000 
       
                                 This field is unused for rank sparing, ADDDC, and SDDC 
       sparing. 
                            
     */
    UINT32 destination_bg : 2;
    /* destination_bg - Bits[11:10], RW_LB, default = 3'b000 
       
                                 This field is unused for rank sparing, ADDDC, and SDDC 
       sparing. 
                             
     */
    UINT32 reserved : 4;
    /* reserved - Bits[15:12], RW_LB, default = 3'b000 
        Reserved for future use.  
     */
    UINT32 rsvd_16 : 16;
    /* rsvd_16 - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SPARING_CONTROL_DESTINATION_MC_MAIN_STRUCT;


/* SPARING_PATROL_STATUS_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x4025097C)                                                  */
/*       SKX (0x4025097C)                                                     */
/* Register default value:              0x00000000                            */
#define SPARING_PATROL_STATUS_MC_MAIN_REG 0x0700497C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  This register logs the status of patrol scrub and the sparing copy operation 
 * for ADDDC, rank sparing, and SDDC.   
 *                         Formerly ssrstatus.
 *           
 */
typedef union {
  struct {
    UINT32 copy_in_progress : 1;
    /* copy_in_progress - Bits[0:0], RW_LBV, default = 1'b0 
       
                         This bit indicates that the sparing copy operation is in 
       progress.  
                         This bit is set by hardware once the sparing copy has started. 
       It is cleared by hardware once the copy operation is complete or fails. 
                     
     */
    UINT32 copy_complete : 1;
    /* copy_complete - Bits[1:1], RW_LBV, default = 1'b0 
       
                         Sparing copy operation complete. Set by hardware once 
       operation is complete.  
                         This bit is cleared by hardware when a new operation is 
       enabled. 
                     
     */
    UINT32 patrol_complete : 1;
    /* patrol_complete - Bits[2:2], RW1C, default = 1'b0 
       
                         All memory has been scrubbed. Hardware sets this bit each time 
       the patrol engine steps through all memory locations. If software wants to 
       monitor 0 to 1 transition after the bit has been set, the software will need to 
       clear the bit by writing a one to clear this bit in order to distinguish the 
       next patrol scrub completion. Clearing the bit will not affect the patrol scrub 
       operation. 
                     
     */
    UINT32 rsvd : 29;
    /* rsvd - Bits[31:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SPARING_PATROL_STATUS_MC_MAIN_STRUCT;


/* IMC0_POISON_SOURCE_N0_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x40250980)                                                  */
/*       SKX (0x40250980)                                                     */
/* Register default value:              0x00000000                            */
#define IMC0_POISON_SOURCE_N0_MC_MAIN_REG 0x07004980
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Poison source logging for channel 0
 */
typedef union {
  struct {
    UINT32 address : 32;
    /* address - Bits[31:0], RWS_LB, default = 40'b0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       System address for poison source
     */
  } Bits;
  UINT32 Data;
} IMC0_POISON_SOURCE_N0_MC_MAIN_STRUCT;


/* IMC0_POISON_SOURCE_N1_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x40250984)                                                  */
/*       SKX (0x40250984)                                                     */
/* Register default value:              0x00000000                            */
#define IMC0_POISON_SOURCE_N1_MC_MAIN_REG 0x07004984
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Poison source logging for channel 0
 */
typedef union {
  struct {
    UINT32 address : 8;
    /* address - Bits[7:0], RWS_LB, default = 40'b0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       System address for poison source
     */
    UINT32 patrol_err : 1;
    /* patrol_err - Bits[8:8], RWS_LB, default = 1'b0 
       This bit will be 1 when poison is due patrol uncorectable error.
     */
    UINT32 spare_err : 1;
    /* spare_err - Bits[9:9], RWS_LB, default = 1'b0 
       This bit will be 1 when poison is due spare copy uncorectable error.
     */
    UINT32 wdb_parity_err : 1;
    /* wdb_parity_err - Bits[10:10], RWS_LB, default = 1'b0 
       This bit will be 1 when poison is due WDB parity error.
     */
    UINT32 vdb_parity_err : 1;
    /* vdb_parity_err - Bits[11:11], RWS_LB, default = 1'b0 
       This bit will be 1 when poison is due DDRT VDB parity error.
     */
    UINT32 rsvd : 17;
    /* rsvd - Bits[28:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 en : 1;
    /* en - Bits[29:29], RWS_LB, default = 1'b0 
       Set this bit to 1 to enable logging in this register.
     */
    UINT32 overflow : 1;
    /* overflow - Bits[30:30], RWS_LB, default = 1'b0 
       When set to 1, indicates new poison source is detected when information logged 
       in this register is still valid. 
     */
    UINT32 valid : 1;
    /* valid - Bits[31:31], RWS_LB, default = 1'b0 
       When set to 1, a poison source is logged in this register and no new error 
       source can be logged. Software clears this bit to 0 to re-enable logging. 
     */
  } Bits;
  UINT32 Data;
} IMC0_POISON_SOURCE_N1_MC_MAIN_STRUCT;


/* IMC1_POISON_SOURCE_N0_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x40250988)                                                  */
/*       SKX (0x40250988)                                                     */
/* Register default value:              0x00000000                            */
#define IMC1_POISON_SOURCE_N0_MC_MAIN_REG 0x07004988
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Poison source logging for channel 1
 */
typedef union {
  struct {
    UINT32 address : 32;
    /* address - Bits[31:0], RWS_LB, default = 40'b0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       System address for poison source
     */
  } Bits;
  UINT32 Data;
} IMC1_POISON_SOURCE_N0_MC_MAIN_STRUCT;


/* IMC1_POISON_SOURCE_N1_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x4025098C)                                                  */
/*       SKX (0x4025098C)                                                     */
/* Register default value:              0x00000000                            */
#define IMC1_POISON_SOURCE_N1_MC_MAIN_REG 0x0700498C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Poison source logging for channel 1
 */
typedef union {
  struct {
    UINT32 address : 8;
    /* address - Bits[7:0], RWS_LB, default = 40'b0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       System address for poison source
     */
    UINT32 patrol_err : 1;
    /* patrol_err - Bits[8:8], RWS_LB, default = 1'b0 
       This bit will be 1 when poison is due patrol uncorectable error.
     */
    UINT32 spare_err : 1;
    /* spare_err - Bits[9:9], RWS_LB, default = 1'b0 
       This bit will be 1 when poison is due spare copy uncorectable error.
     */
    UINT32 wdb_parity_err : 1;
    /* wdb_parity_err - Bits[10:10], RWS_LB, default = 1'b0 
       This bit will be 1 when poison is due WDB parity error.
     */
    UINT32 vdb_parity_err : 1;
    /* vdb_parity_err - Bits[11:11], RWS_LB, default = 1'b0 
       This bit will be 1 when poison is due DDRT VDB parity error.
     */
    UINT32 rsvd : 17;
    /* rsvd - Bits[28:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 en : 1;
    /* en - Bits[29:29], RWS_LB, default = 1'b0 
       Set this bit to 1 to enable logging in this register.
     */
    UINT32 overflow : 1;
    /* overflow - Bits[30:30], RWS_LB, default = 1'b0 
       When set to 1, indicates new poison source is detected when information logged 
       in this register is still valid. 
     */
    UINT32 valid : 1;
    /* valid - Bits[31:31], RWS_LB, default = 1'b0 
       When set to 1, a poison source is logged in this register and no new error 
       source can be logged. Software clears this bit to 0 to re-enable logging. 
     */
  } Bits;
  UINT32 Data;
} IMC1_POISON_SOURCE_N1_MC_MAIN_STRUCT;


/* IMC2_POISON_SOURCE_N0_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x40250990)                                                  */
/*       SKX (0x40250990)                                                     */
/* Register default value:              0x00000000                            */
#define IMC2_POISON_SOURCE_N0_MC_MAIN_REG 0x07004990
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Poison source logging for channel 0
 */
typedef union {
  struct {
    UINT32 address : 32;
    /* address - Bits[31:0], RWS_LB, default = 40'b0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       System address for poison source
     */
  } Bits;
  UINT32 Data;
} IMC2_POISON_SOURCE_N0_MC_MAIN_STRUCT;


/* IMC2_POISON_SOURCE_N1_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x40250994)                                                  */
/*       SKX (0x40250994)                                                     */
/* Register default value:              0x00000000                            */
#define IMC2_POISON_SOURCE_N1_MC_MAIN_REG 0x07004994
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Poison source logging for channel 0
 */
typedef union {
  struct {
    UINT32 address : 8;
    /* address - Bits[7:0], RWS_LB, default = 40'b0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       System address for poison source
     */
    UINT32 patrol_err : 1;
    /* patrol_err - Bits[8:8], RWS_LB, default = 1'b0 
       This bit will be 1 when poison is due patrol uncorectable error.
     */
    UINT32 spare_err : 1;
    /* spare_err - Bits[9:9], RWS_LB, default = 1'b0 
       This bit will be 1 when poison is due spare copy uncorectable error.
     */
    UINT32 wdb_parity_err : 1;
    /* wdb_parity_err - Bits[10:10], RWS_LB, default = 1'b0 
       This bit will be 1 when poison is due WDB parity error.
     */
    UINT32 vdb_parity_err : 1;
    /* vdb_parity_err - Bits[11:11], RWS_LB, default = 1'b0 
       This bit will be 1 when poison is due DDRT VDB parity error.
     */
    UINT32 rsvd : 17;
    /* rsvd - Bits[28:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 en : 1;
    /* en - Bits[29:29], RWS_LB, default = 1'b0 
       Set this bit to 1 to enable logging in this register.
     */
    UINT32 overflow : 1;
    /* overflow - Bits[30:30], RWS_LB, default = 1'b0 
       When set to 1, indicates new poison source is detected when information logged 
       in this register is still valid. 
     */
    UINT32 valid : 1;
    /* valid - Bits[31:31], RWS_LB, default = 1'b0 
       When set to 1, a poison source is logged in this register and no new error 
       source can be logged. Software clears this bit to 0 to re-enable logging. 
     */
  } Bits;
  UINT32 Data;
} IMC2_POISON_SOURCE_N1_MC_MAIN_STRUCT;


/* SPARE_FSM_STATE_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250998)                                                  */
/*       SKX (0x40250998)                                                     */
/* Register default value:              0x0F0F1F1F                            */
#define SPARE_FSM_STATE_MC_MAIN_REG 0x07004998
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  This register contains current and previous state of spare FSMs.  
 */
typedef union {
  struct {
    UINT32 spr_current_state : 5;
    /* spr_current_state - Bits[4:0], RO_V, default = 5'b11111 
       Current encoded state of spare copy FSM
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 spr_previous_state : 5;
    /* spr_previous_state - Bits[12:8], RO_V, default = 5'b11111 
       Previous encoded state of spare copy FSM
     */
    UINT32 rsvd_13 : 3;
    /* rsvd_13 - Bits[15:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ssa_current_state : 4;
    /* ssa_current_state - Bits[19:16], RO_V, default = 4'b1111 
       Current encoded state of system address FSM for spare copy
     */
    UINT32 rsvd_20 : 4;
    /* rsvd_20 - Bits[23:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 ssa_previous_state : 4;
    /* ssa_previous_state - Bits[27:24], RO_V, default = 4'b1111 
       Previous encoded state of system address FSM for spare copy
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SPARE_FSM_STATE_MC_MAIN_STRUCT;


/* PATROL_FSM_STATE_MC_MAIN_REG supported on:                                 */
/*       SKX_A0 (0x4025099C)                                                  */
/*       SKX (0x4025099C)                                                     */
/* Register default value:              0x0F0F1F1F                            */
#define PATROL_FSM_STATE_MC_MAIN_REG 0x0700499C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  This register contains current and previous state of patrol FSMs.  
 */
typedef union {
  struct {
    UINT32 pat_current_state : 5;
    /* pat_current_state - Bits[4:0], RO_V, default = 5'b11111 
       Current encoded state of patrol scrub FSM
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 pat_previous_state : 5;
    /* pat_previous_state - Bits[12:8], RO_V, default = 5'b11111 
       Previous encoded state of patrol scrub FSM
     */
    UINT32 rsvd_13 : 3;
    /* rsvd_13 - Bits[15:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 psa_current_state : 4;
    /* psa_current_state - Bits[19:16], RO_V, default = 4'b1111 
       Current encoded state of system address FSM for patrol scrub
     */
    UINT32 rsvd_20 : 4;
    /* rsvd_20 - Bits[23:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 psa_previous_state : 4;
    /* psa_previous_state - Bits[27:24], RO_V, default = 4'b1111 
       Previous encoded state of system address FSM for patrol scrub
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} PATROL_FSM_STATE_MC_MAIN_STRUCT;


/* SPARING_2LM_ADDR0LO_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x402509A0)                                                  */
/*       SKX (0x402509A0)                                                     */
/* Register default value:              0x00000000                            */
#define SPARING_2LM_ADDR0LO_MC_MAIN_REG 0x070049A0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  This register controls the sparing address for ADDDC when fast div-3 is used. 
 * ADDR0 is the system address that belongs to current socket and channel, and maps 
 * to near memory rank address 0.  
 */
typedef union {
  struct {
    UINT32 curr_addr : 32;
    /* curr_addr - Bits[31:0], RW_LBV, default = 32'b00000000000000000000000000000000 
       Bits 37:6 of sparing address 0. Software should program the starting address and 
       hardware will update when spare address changes. 
     */
  } Bits;
  UINT32 Data;
} SPARING_2LM_ADDR0LO_MC_MAIN_STRUCT;


/* SPARING_2LM_ADDR0HI_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x402509A4)                                                  */
/*       SKX (0x402509A4)                                                     */
/* Register default value:              0x00000000                            */
#define SPARING_2LM_ADDR0HI_MC_MAIN_REG 0x070049A4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  This register controls the sparing address for ADDDC when fast div-3 is used. 
 * ADDR0 is the system address that belongs to current socket and channel, and maps 
 * to near memory rank address 0.  
 */
typedef union {
  struct {
    UINT32 curr_addr : 8;
    /* curr_addr - Bits[7:0], RW_LBV, default = 8'b00000000 
       Bits 45:38 of sparing address 0. Software should program the starting address 
       and hardware will update when spare address changes. 
     */
    UINT32 rsvd : 24;
    /* rsvd - Bits[31:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SPARING_2LM_ADDR0HI_MC_MAIN_STRUCT;


/* SPARING_2LM_ADDR1LO_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x402509A8)                                                  */
/*       SKX (0x402509A8)                                                     */
/* Register default value:              0x00000000                            */
#define SPARING_2LM_ADDR1LO_MC_MAIN_REG 0x070049A8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  This register controls the sparing address for ADDDC when fast div-3 is used. 
 * ADDR1 is the system address that belongs to current socket and channel, and maps 
 * to near memory rank address 1.  
 */
typedef union {
  struct {
    UINT32 curr_addr : 32;
    /* curr_addr - Bits[31:0], RW_LBV, default = 32'b00000000000000000000000000000000 
       Bits 37:6 of sparing address 1. Software should program the starting address and 
       hardware will update when spare address changes. 
     */
  } Bits;
  UINT32 Data;
} SPARING_2LM_ADDR1LO_MC_MAIN_STRUCT;


/* SPARING_2LM_ADDR1HI_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x402509AC)                                                  */
/*       SKX (0x402509AC)                                                     */
/* Register default value:              0x00000000                            */
#define SPARING_2LM_ADDR1HI_MC_MAIN_REG 0x070049AC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  This register controls the sparing address for ADDDC when fast div-3 is used. 
 * ADDR1 is the system address that belongs to current socket and channel, and maps 
 * to near memory rank address 1.  
 */
typedef union {
  struct {
    UINT32 curr_addr : 8;
    /* curr_addr - Bits[7:0], RW_LBV, default = 8'b00000000 
       Bits 45:38 of sparing address 1. Software should program the starting address 
       and hardware will update when spare address changes. 
     */
    UINT32 rsvd : 24;
    /* rsvd - Bits[31:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SPARING_2LM_ADDR1HI_MC_MAIN_STRUCT;


/* SPARING_2LM_ADDR2LO_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x402509B0)                                                  */
/*       SKX (0x402509B0)                                                     */
/* Register default value:              0x00000000                            */
#define SPARING_2LM_ADDR2LO_MC_MAIN_REG 0x070049B0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  This register controls the sparing address for ADDDC when fast div-3 is used. 
 * ADDR2 is the system address that belongs to current socket and channel, and maps 
 * to near memory rank address 2.  
 */
typedef union {
  struct {
    UINT32 curr_addr : 32;
    /* curr_addr - Bits[31:0], RW_LBV, default = 32'b00000000000000000000000000000000 
       Bits 37:6 of sparing address 2. Software should program the starting address and 
       hardware will update when spare address changes. 
     */
  } Bits;
  UINT32 Data;
} SPARING_2LM_ADDR2LO_MC_MAIN_STRUCT;


/* SPARING_2LM_ADDR2HI_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x402509B4)                                                  */
/*       SKX (0x402509B4)                                                     */
/* Register default value:              0x00000000                            */
#define SPARING_2LM_ADDR2HI_MC_MAIN_REG 0x070049B4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  This register controls the sparing address for ADDDC when fast div-3 is used. 
 * ADDR2 is the system address that belongs to current socket and channel, and maps 
 * to near memory rank address 2.  
 */
typedef union {
  struct {
    UINT32 curr_addr : 8;
    /* curr_addr - Bits[7:0], RW_LBV, default = 8'b00000000 
       Bits 45:38 of sparing address 2. Software should program the starting address 
       and hardware will update when spare address changes. 
     */
    UINT32 rsvd : 24;
    /* rsvd - Bits[31:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SPARING_2LM_ADDR2HI_MC_MAIN_STRUCT;


/* SPARING_2LM_CONTROL_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x402509B8)                                                  */
/*       SKX (0x402509B8)                                                     */
/* Register default value:              0x00000000                            */
#define SPARING_2LM_CONTROL_MC_MAIN_REG 0x070049B8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  This register contains the size of near memory for ADDDC sparing when fast 
 * div-3 is used.   
 */
typedef union {
  struct {
    UINT32 nm_size : 20;
    /* nm_size - Bits[19:0], RW_LB, default = 20'b00000000000000000000 
       Bits 45:26 to represent near memory size. Minimum size is 64 MB. NM size must be 
       power of 2. 
     */
    UINT32 rsvd : 11;
    /* rsvd - Bits[30:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 enable : 1;
    /* enable - Bits[31:31], RW_LB, default = 1'b0 
       Set to 1 to enable system address generation use addresses from these 6 
       sparing_2lm_control registers. This bit should only be set to 1 when fast div-3 
       is used and ADDDC spare copy enabled. 
     */
  } Bits;
  UINT32 Data;
} SPARING_2LM_CONTROL_MC_MAIN_STRUCT;






















/* MCGLBRSPCNTL_MC_MAIN_REG supported on:                                     */
/*       SKX_A0 (0x40250A80)                                                  */
/*       SKX (0x40250A80)                                                     */
/* Register default value:              0x00701C07                            */
#define MCGLBRSPCNTL_MC_MAIN_REG 0x07004A80
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * All register fields are locked by EPMCCTRL_DFX_LCK_CNTL.RSPLCK.
 */
typedef union {
  struct {
    UINT32 glbrsp0starttrigsel : 3;
    /* glbrsp0starttrigsel - Bits[2:0], RWS_L, default = 3'b111 
       This selects which trigger will be driven out.
       000: MBP_OUT[0]
       001: MBP_OUT[1]
       010: ASC[0] output
       011: ASC[1] output
       100: CTS trigger out
       101: Do it forever
       110: Always 1
       111: Never assert output
     */
    UINT32 glbrsp0stopsel : 3;
    /* glbrsp0stopsel - Bits[5:3], RWS_L, default = 3'b000 
       This selects the vent thatwill cause th output to be deasserted.
       000: MBP[0]
       001: MBP[1]
       010: ASC[0]
       011: ASC[1]
       100: CTS Trigger out
       101: Stop 1 cycle after start
       110: Do it forever
       111: Stop when start is false
     */
    UINT32 glbrsp0respdis : 1;
    /* glbrsp0respdis - Bits[6:6], RWS_L, default = 3'b000 
       Disable Global response logic 0.  This will abort any pending response.
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 glbrsp1starttrigsel : 3;
    /* glbrsp1starttrigsel - Bits[10:8], RWS_L, default = 3'b111 
       This selects which trigger will be driven out.
       000: MBP_OUT[0]
       001: MBP_OUT[1]
       010: ASC[0] output
       011: ASC[1] output
       100: CTS trigger out
       101: Do it forever
       110: Always 1
       111: Never assert output
     */
    UINT32 glbrsp1stopsel : 3;
    /* glbrsp1stopsel - Bits[13:11], RWS_L, default = 3'b000 
       This selects the vent thatwill cause th output to be deasserted.
       000: MBP[0]
       001: MBP[1]
       010: ASC[0]
       011: ASC[1]
       100: CTS Trigger out
       101: Stop 1 cycle after start
       110: Do it forever
       111: Stop when start is false
     */
    UINT32 glbrsp1respdis : 1;
    /* glbrsp1respdis - Bits[14:14], RWS_L, default = 3'b000 
       Disable Global response logic 1.  This will abort any pending response.
     */
    UINT32 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 glbrsp2starttrigsel : 3;
    /* glbrsp2starttrigsel - Bits[18:16], RWS_L, default = 3'b111 
       This selects which trigger will be driven out.
       000: MBP_OUT[0]
       001: MBP_OUT[1]
       010: ASC[0] output
       011: ASC[1] output
       100: CTS trigger out
       101: Reserved
       110: Always 1
       111: Never assert output
     */
    UINT32 glbrsp2stopsel : 3;
    /* glbrsp2stopsel - Bits[21:19], RWS_L, default = 3'b000 
       This selects the vent thatwill cause th output to be deasserted.
       000: MBP[0]
       001: MBP[1]
       010: ASC[0]
       011: ASC[1]
       100: CTS Trigger out
       101: Stop 1 cycle after start
       110: Do it forever
       111: Stop when start is false
     */
    UINT32 glbrsp2respdis : 1;
    /* glbrsp2respdis - Bits[22:22], RWS_L, default = 3'b000 
       Disable Global response logic 2.  This will abort any pending response.
     */
    UINT32 rsvd_23 : 9;
    /* rsvd_23 - Bits[31:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MCGLBRSPCNTL_MC_MAIN_STRUCT;






/* MCASC0LDVALLO_MC_MAIN_REG supported on:                                    */
/*       SKX_A0 (0x40250A8C)                                                  */
/*       SKX (0x40250A8C)                                                     */
/* Register default value:              0x00000000                            */
#define MCASC0LDVALLO_MC_MAIN_REG 0x07004A8C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * This register is contolled by lock bit ASCLCK in EPMCMAIN_DFX_LCK_CNTL register. 
 * The register may be readable with the lock bit set but no writes will take 
 * effect unless the lock bit is set to 0. 
 */
typedef union {
  struct {
    UINT32 ldlowval : 32;
    /* ldlowval - Bits[31:0], RWS_L, default = 32'b00000000000000000000000000000000 
       This value will be loaded into the counter when the ouput state transitions to 
       0. 
     */
  } Bits;
  UINT32 Data;
} MCASC0LDVALLO_MC_MAIN_STRUCT;


/* MCASC0LDVALHI_MC_MAIN_REG supported on:                                    */
/*       SKX_A0 (0x40250A90)                                                  */
/*       SKX (0x40250A90)                                                     */
/* Register default value:              0x00000000                            */
#define MCASC0LDVALHI_MC_MAIN_REG 0x07004A90
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * This register is contolled by lock bit ASCLCK in EPMCMAIN_DFX_LCK_CNTL register. 
 * The register may be readable with the lock bit set but no writes will take 
 * effect unless the lock bit is set to 0. 
 */
typedef union {
  struct {
    UINT32 ldhival : 32;
    /* ldhival - Bits[31:0], RWS_L, default = 32'b00000000000000000000000000000000 
       This value will be loaded into the counter when the ouput state transitions to 
       1. 
     */
  } Bits;
  UINT32 Data;
} MCASC0LDVALHI_MC_MAIN_STRUCT;






/* MCASCCONTROL_MC_MAIN_REG supported on:                                     */
/*       SKX_A0 (0x20250A9C)                                                  */
/*       SKX (0x20250A9C)                                                     */
/* Register default value:              0x0000                                */
#define MCASCCONTROL_MC_MAIN_REG 0x07002A9C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * This register is contolled by lock bit ASCLCK in EPMCMAIN_DFX_LCK_CNTL register. 
 * The register may be readable with the lock bit set but no writes will take 
 * effect unless the lock bit is set to 0. 
 */
typedef union {
  struct {
    UINT16 asc0state : 1;
    /* asc0state - Bits[0:0], RWS_LV, default = 1'b0 
       The output state of ASC0.
     */
    UINT16 asc0en : 1;
    /* asc0en - Bits[1:1], RWS_L, default = 1'b0 
       The enable bit for ASC0.
     */
    UINT16 asc0mode : 2;
    /* asc0mode - Bits[3:2], RWS_L, default = 2'b00 
       Control for ASC0. Provides ability to OR or AND ASC0 with ASC1.
       00: ASC0's output is asc0_state.
       01: ASC0's output is asc0_state AND asc1_state.
       10: ASC0's output is asc0_state OR asc1_state.
       11: Reserved.
     */
    UINT16 asc1state : 1;
    /* asc1state - Bits[4:4], RWS_LV, default = 1'b0 
       The output state of ASC1.
     */
    UINT16 asc1en : 1;
    /* asc1en - Bits[5:5], RWS_L, default = 1'b0 
       The enable bit for ASC1.
     */
    UINT16 asc1mode : 1;
    /* asc1mode - Bits[6:6], RWS_L, default = 1'b0 
       Specifies if ASC1 counter is an extension of ASC0 or not. if set, ASC1 does not 
       depend on MBPQUAL even if it is set. 
       0: ASC1 counter is independent.
       1: ASC1 is an extension of ASC0 counter. ASC counts when the falling edge of 
       ASC0 state is detected. 
     */
    UINT16 mbpqual : 1;
    /* mbpqual - Bits[7:7], RWS_L, default = 1'b0 
       When set, the enable bits for ASC0 and ASC1 must be qualified by the assertion 
       of the MBP selected by MBPSel for these counters to operate. 
     */
    UINT16 mbpsel : 1;
    /* mbpsel - Bits[8:8], RWS_L, default = 1'b0 
       When MBPQUAL is set, ASC0 and ASC1 only operate when their respective enable 
       bits are asserted and the MBP selected by this bit field is asserted. 
       0: MBP[0]
       1: MBP[1]
       
     */
    UINT16 asc0clronstop : 1;
    /* asc0clronstop - Bits[9:9], RWS_L, default = 1'b0 
       ASC0 output will clear on stop when set
     */
    UINT16 asc1clronstop : 1;
    /* asc1clronstop - Bits[10:10], RWS_L, default = 1'b0 
       ASC1 output will clear on stop when set
     */
    UINT16 rsvd : 5;
    /* rsvd - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} MCASCCONTROL_MC_MAIN_STRUCT;




/* CPGC_GLOBALCTRL_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250B00)                                                  */
/*       SKX (0x40250B00)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_GLOBALCTRL_MC_MAIN_REG 0x07004B00
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Global Control -
 * This register is used to control SEQ0/SEQ1 CPGC CH# Logic
 */
typedef union {
  struct {
    UINT32 start_test : 1;
    /* start_test - Bits[0:0], RW_LBV, default = 1'b0 
       Setting to 1 will immediately initiate a transition to Loopback.Pattern on all 
       channels that have their global_control bit set. 
       This field is cleared when all channels transition to Loopback.Marker from 
       loopback.Pattern for channels that have their global_control bit set. 
       If channels are not expected to transition to Loopback.Marker at the same time 
       (because of programming or other differences) 
       then start_test bit will not clear by itself.
       To start the test again, BIOS will need to clear this bit field followed by 
       setting it to 1 again. 
     */
    UINT32 stop_test : 1;
    /* stop_test - Bits[1:1], RW_LBV, default = 1'b0 
       Setting Global_Stop_Test to 1 will force a transition to Loopback.Marker on all 
       channels that have their Global_Control bit set. 
       Global_Stop_Test will immediately clear to 0 after forcing a transition to 
       Loopback.Marker on all channels that have their Global_Control bit set. 
     */
    UINT32 clear_errs : 1;
    /* clear_errs - Bits[2:2], RW_LBV, default = 1'b0 
       Setting Global_Clear_Errors to 1 will immediately clear all error status 
       registers (the same effect as asserting assert the Local_Clear_Errors) 
       on any channels that have their Global Control bit is set.
       Global_Clear_Errors will immediately be reset to 0 after all Channels_Err Status 
       Registers are cleared that have their Global Control bit Set 
     */
    UINT32 rsvd_3 : 1;
    /* rsvd_3 - Bits[3:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 stop_test_on_any_err : 1;
    /* stop_test_on_any_err - Bits[4:4], RW_LB, default = 1'b0 
       Setting Global_Stop_Test_On_Any_Error to 1 will immediately force a transition 
       to Loopback.Marker after any error on any channels 
       (indicated by a no zero value in Channel_Error_Status) that also have their 
       Global Control bit set. 
     */
    UINT32 use_bl4_col_addr : 1;
    /* use_bl4_col_addr - Bits[5:5], RW_LB, default = 1'b0 
       Currently Address bits [2:0] of the Column Addr are hard tied to zero, Setting 
       this bit will 
       enable bit control over Addres bit [2] as well thus enabling BL4 mode full 
       addressing. 
     */
    UINT32 cpgc_credits : 6;
    /* cpgc_credits - Bits[11:6], RW_LB, default = 6'b000000 
       Programmable credits for CPGC Multi Credit Scheme -
       6'd-zero: Use hardcoded defaults of 6'd16 (link 2:1) and 6'd32 (link 1:1)
       6'd-nonzero: Programmable credits for CPGC Multi-credit scheme
     */
    UINT32 rsvd_12 : 1;
    /* rsvd_12 - Bits[12:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 cpgc_crdt_wait : 1;
    /* cpgc_crdt_wait - Bits[13:13], RW_LB, default = 1'b0 
       When enabled, CPGC sequencer will wait for all credits to be returned before 
       moving to the next sub-sequence. 
       Usage of this de-feature bit is
       - limited to WAIT states between two sub-sequences.
       - limited to when CPGC is using multi-credit scheme.
     */
    UINT32 multiwr_singlerd_mode : 1;
    /* multiwr_singlerd_mode - Bits[14:14], RW_LB, default = 1'b0  */
    UINT32 ddrt_addr_mode : 3;
    /* ddrt_addr_mode - Bits[17:15], RW_LB, default = 3'b0 
       
               3b per channel vector that should be set for DDRT. 
               If this bit is set then 
               - Sequencer uses BL4 addressing mode for adddresses to DDRT scheduler 
               
     */
    UINT32 rsvd_18 : 14;
    /* rsvd_18 - Bits[31:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_GLOBALCTRL_MC_MAIN_STRUCT;


/* CPGC_GLOBALERR_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x40250B04)                                                  */
/*       SKX (0x40250B04)                                                     */
/* Register default value:              0x000F0000                            */
#define CPGC_GLOBALERR_MC_MAIN_REG 0x07004B04
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Global Err -
 * This register is used to globally monitor all CPGC CH# Logic.
 */
typedef union {
  struct {
    UINT32 channel_err_status_0 : 1;
    /* channel_err_status_0 - Bits[0:0], RO_V, default = 1'b0 
       Channel_Error_Status_0 corresponds to Channel 0. When set this indicated Channel 
       0 has at least one Data (Data_Error_Status) or ECC 
       (Ecc_Error_Status) error status bit set.
       Channel_Error_Status_0 will be cleared when setting Local_Clear_Errors or 
       (Global_Control and Global_Clear_Errors) . 
     */
    UINT32 channel_err_status_1 : 1;
    /* channel_err_status_1 - Bits[1:1], RO_V, default = 1'b0 
       Channel_Error_Status_1 corresponds to Channel 1. When set this indicated Channel 
       1 has at least one Data (Data_Error_Status) or ECC 
       (Ecc_Error_Status) error status bit set.
       Channel_Error_Status_1 will be cleared when setting Local_Clear_Errors or 
       (Global_Control and Global_Clear_Errors) . 
     */
    UINT32 channel_err_status_2 : 1;
    /* channel_err_status_2 - Bits[2:2], RO_V, default = 1'b0 
       Channel_Error_Status_2 corresponds to Channel 2. When set this indicated Channel 
       2 has at least one Data (Data_Error_Status) or ECC 
       (Ecc_Error_Status) error status bit set.
       Channel_Error_Status_2 will be cleared when setting Local_Clear_Errors or 
       (Global_Control and Global_Clear_Errors) . 
     */
    UINT32 channel_err_status_3 : 1;
    /* channel_err_status_3 - Bits[3:3], RO_V, default = 1'b0 
       Channel_Error_Status_3 corresponds to Channel 3. When set this indicated Channel 
       3 has at least one Data (Data_Error_Status) or ECC 
       (Ecc_Error_Status) error status bit set.
       Channel_Error_Status_3 will be cleared when setting Local_Clear_Errors or 
       (Global_Control and Global_Clear_Errors) . 
     */
    UINT32 rsvd_4 : 12;
    /* rsvd_4 - Bits[15:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 channel_test_done_status_0 : 1;
    /* channel_test_done_status_0 - Bits[16:16], RO_V, default = 1'b1 
       Channel_Test_Done_Status_0 corresponds to Channel 0 and is set in 
       Loopback.Marker and cleared in Loopback.Pattern 
     */
    UINT32 channel_test_done_status_1 : 1;
    /* channel_test_done_status_1 - Bits[17:17], RO_V, default = 1'b1 
       Channel_Test_Done_Status_1 corresponds to Channel 1 and is set in 
       Loopback.Marker and cleared in Loopback.Pattern 
     */
    UINT32 channel_test_done_status_2 : 1;
    /* channel_test_done_status_2 - Bits[18:18], RO_V, default = 1'b1 
       Channel_Test_Done_Status_2 corresponds to Channel 2 and is set in 
       Loopback.Marker and cleared in Loopback.Pattern 
     */
    UINT32 channel_test_done_status_3 : 1;
    /* channel_test_done_status_3 - Bits[19:19], RO_V, default = 1'b1 
       Channel_Test_Done_Status_3 corresponds to Channel 3 and is set in 
       Loopback.Marker and cleared in Loopback.Pattern 
     */
    UINT32 rsvd_20 : 12;
    /* rsvd_20 - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_GLOBALERR_MC_MAIN_STRUCT;


/* CPGC_SEQCTL0_MC_MAIN_REG supported on:                                     */
/*       SKX_A0 (0x40250B08)                                                  */
/*       SKX (0x40250B08)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQCTL0_MC_MAIN_REG 0x07004B08
/* Struct format extracted from XML file SKX_A0\2.10.0.CFG.xml.
 * CPGC Channel-0 Sequence Control -
 * SEQ_CTL0 defines a variety of controls available for configuring a Sequence for 
 * CH-0. 
 */
typedef union {
  struct {
    UINT32 local_start_test : 1;
    /* local_start_test - Bits[0:0], RW_LBV, default = 1'b0 
       Setting Local_Start_Test or (Global_Control and Global_Start_Test) to 1 will 
       immediately initiate a transition to Loopback.Pattern 
       from Loopback.Marker.
       Local_Start_Test must be cleared when a test transitions from Loopback.Pattern 
       to Loopback.Marker. 
     */
    UINT32 local_stop_test : 1;
    /* local_stop_test - Bits[1:1], RW_LBV, default = 1'b0 
       If Local_Stop_Test or (Global_Control and Global_Stop_Test) is set to 1 will 
       force a transition on this Channel # to Loopback.Marker 
       from Loopback.Pattern.
       Local_Start_Test must be cleared when a test transitions from Loopback.Pattern 
       to Loopback.Marker. 
     */
    UINT32 local_clear_errs : 1;
    /* local_clear_errs - Bits[2:2], RW_LBV, default = 1'b0 
       Setting Local_Clear_Errors or (Global_Control and Global_Clear_Errors) to 1 will 
       immediately clear all local channel errors status registers 
       (CPGC#_CH#_ERR_* registers).
       Local_Clear_Errors will immediately clear to 0 after clearing all error status 
       registers 
     */
    UINT32 stop_base_seq_on_wrap_trigger : 1;
    /* stop_base_seq_on_wrap_trigger - Bits[3:3], RW_LB, default = 1'b0 
       If Stop_Base_Seq_On_Wrap_Trigger is set then any Base Address Wrap Trigger that 
       occurs will immediately force a test to stop 
       (i.e. creates a transition from Loopback.Pattern to Loopback.Marker).
       Stop_On_Wrap_Trigger at the sequence level only makes sense when the 
       Address_Update_Rate_Mode is set to 0x1 where the four Address Update Rate 
       fields (Rank, Bank, Row, and Column) are updated by based on the Loopcount (the 
       # of loops through from the start of the test). 
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the former 
       causes the subsequence to end and the latter causes the sequence to end.
     */
    UINT32 address_update_rate_mode : 1;
    /* address_update_rate_mode - Bits[4:4], RW_LB, default = 1'b0 
       Address_Update_Rate_Mode dictates whether the address increment is based on # of 
       cachelines written and read or by Loopcount (# of sequences performed). 
       Address_Update_Rate_Mode = 0 means that the four Address Update Rate fields 
       (Rank, Bank, Row, and Column) are updated based on the # of read and 
       write cacheline transactions.
       Address_Update_Rate_Mode = 1 means that the four Address Update Rate fields 
       (Rank, Bank, Row, and Column) are updated by based on the Loopcount 
       (# of sequences perfromed).
     */
    UINT32 enable_dummy_reads : 1;
    /* enable_dummy_reads - Bits[5:5], RW_LB, default = 1'b0 
       If set then the Dummy Read state machine is Enabled during this sequence 
       creating ACT and PRE in the same Rank that is being targeted. 
       See CPGC_CH#_SEQ#_DUMMYREAD_*
     */
    UINT32 enable_constant_write_strobe : 1;
    /* enable_constant_write_strobe - Bits[6:6], RW_LB, default = 1'b0 
       This bit is UNUSED in design. Refer to be4536804 for details.
       Setting Enable_Constant_Write_Strobe will cause the Tx write Strobe to be driven 
       out constantly while a test is in progress 
       (while in Loopback.Pattern).
       This is most often used to help train the correct setting for per Rank write 
       leveling using the following steps. 
     */
    UINT32 global_control : 1;
    /* global_control - Bits[7:7], RW_LB, default = 1'b0 
       Enables the CPGC_GLOBAL_CTRL register to control this CPGC#_CH# engine in 
       multiple ways 
       (i.e. Global_Start_Test, Global_Stop_Test, Global_Clear_Errors, 
       Global_Clear_Errors_On_Start_Test, and Global_Stop_Test_on_Any_Error). 
     */
    UINT32 initialization_mode : 2;
    /* initialization_mode - Bits[9:8], RW_LBV, default = 2'b00 
       A change to Initialization Mode occurs immediately and does not require a 
       Physical Layer Reset to be asserted. 
       00 - Idle on MC Reset
       01 - CPGC Testing Once the Initialization_Mode is set to 01 then the channel 
       enters immediately 
       into the Loopback.Marker state and the ability to start a test becomes enabled.
       10 - MRS Mode.
       11 - RSVD.
     */
    UINT32 loopcount : 5;
    /* loopcount - Bits[14:10], RW_LB, default = 5'b00000 
       2^(Loopcount-1) determines how many iterations of the complete Sequence loop 
       takes place before a test stops, where a 
       Sequence loop is defined by the completion of all SubSequences indicated by the 
       SubSequence Start pointer to 
       SubSequence End pointer.
       Loopcount = 0 means the test is infinite.
       Loopcount = 1 means the test will end after one loop through the sub sequences.
       Loopcount = 2 means the test will end after two Loops through the sub sequences.
       Loopcount = 3 means the test will end after four Loops through the sub 
       sequences. 
     */
    UINT32 subseq_start_pointer : 4;
    /* subseq_start_pointer - Bits[18:15], RW_LB, default = 4'b0000 
       Initial SubSequence pointer when beginning a Sequence. Subseq_Start_Pointer 
       values of 0 9 are valid 
     */
    UINT32 subseq_end_pointer : 4;
    /* subseq_end_pointer - Bits[22:19], RW_LB, default = 4'b0000 
       Subsequence pointer when completed the Loopcount is incremented by 1 and the 
       Current_Subseq_Pointer is reset to the Subseq_Start_Pointer. 
       Subseq_End_Pointer values of 0 9 are valid
       The Subseq_End_Pointer must always be set to equal or greater than the 
       Subseq_Start_Pointer. 
     */
    UINT32 start_test_delay : 8;
    /* start_test_delay - Bits[30:23], RW_LB, default = 8'b00000000 
       Delay period (in DClks) between the setting of Local_Start_Test or 
       (Global_Control and Global_Start_Test) and the actual entry 
       to Loopback.Pattern where the first SubSequence is executed immediately.
     */
    UINT32 vmse_wrtrn_enb : 1;
    /* vmse_wrtrn_enb - Bits[31:31], RW_LB, default = 1'b0 
       This bit enables CPGC mode wherein more then 1 CPGC WR credits are available at 
       a time. 
       1'b0: Default CPGC Wr credit of 1
       1'b1: 32 (link 2:1) or 16 (link 1:1) Wr-credits per scheduler to enable LINK 
       Write and Write leveling training steps 
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQCTL0_MC_MAIN_A0_STRUCT;

/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sequence Control -
 * SEQ_CTL0 defines a variety of controls available for configuring a Sequence for 
 * CH-0. 
 */
typedef union {
  struct {
    UINT32 local_start_test : 1;
    /* local_start_test - Bits[0:0], RW_LBV, default = 1'b0 
       Setting Local_Start_Test or (Global_Control and Global_Start_Test) to 1 will 
       immediately initiate a transition to Loopback.Pattern 
       from Loopback.Marker.
       Local_Start_Test must be cleared when a test transitions from Loopback.Pattern 
       to Loopback.Marker. 
     */
    UINT32 local_stop_test : 1;
    /* local_stop_test - Bits[1:1], RW_LBV, default = 1'b0 
       If Local_Stop_Test or (Global_Control and Global_Stop_Test) is set to 1 will 
       force a transition on this Channel # to Loopback.Marker 
       from Loopback.Pattern.
       Local_Start_Test must be cleared when a test transitions from Loopback.Pattern 
       to Loopback.Marker. 
     */
    UINT32 local_clear_errs : 1;
    /* local_clear_errs - Bits[2:2], RW_LBV, default = 1'b0 
       Setting Local_Clear_Errors or (Global_Control and Global_Clear_Errors) to 1 will 
       immediately clear all local channel errors status registers 
       (CPGC#_CH#_ERR_* registers).
       Local_Clear_Errors will immediately clear to 0 after clearing all error status 
       registers 
     */
    UINT32 stop_base_seq_on_wrap_trigger : 1;
    /* stop_base_seq_on_wrap_trigger - Bits[3:3], RW_LB, default = 1'b0 
       If Stop_Base_Seq_On_Wrap_Trigger is set then any Base Address Wrap Trigger that 
       occurs will immediately force a test to stop 
       (i.e. creates a transition from Loopback.Pattern to Loopback.Marker).
       Stop_On_Wrap_Trigger at the sequence level only makes sense when the 
       Address_Update_Rate_Mode is set to 0x1 where the four Address Update Rate 
       fields (Rank, Bank, Row, and Column) are updated by based on the Loopcount (the 
       # of loops through from the start of the test). 
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the former 
       causes the subsequence to end and the latter causes the sequence to end.
     */
    UINT32 address_update_rate_mode : 1;
    /* address_update_rate_mode - Bits[4:4], RW_LB, default = 1'b0 
       Address_Update_Rate_Mode dictates whether the address increment is based on # of 
       cachelines written and read or by Loopcount (# of sequences performed). 
       Address_Update_Rate_Mode = 0 means that the four Address Update Rate fields 
       (Rank, Bank, Row, and Column) are updated based on the # of read and 
       write cacheline transactions.
       Address_Update_Rate_Mode = 1 means that the four Address Update Rate fields 
       (Rank, Bank, Row, and Column) are updated by based on the Loopcount 
       (# of sequences perfromed).
     */
    UINT32 enable_dummy_reads : 1;
    /* enable_dummy_reads - Bits[5:5], RW_LB, default = 1'b0 
       If set then the Dummy Read state machine is Enabled during this sequence 
       creating ACT and PRE in the same Rank that is being targeted. 
       See CPGC_CH#_SEQ#_DUMMYREAD_*
     */
    UINT32 rsvd_6 : 1;
    UINT32 global_control : 1;
    /* global_control - Bits[7:7], RW_LB, default = 1'b0 
       Enables the CPGC_GLOBAL_CTRL register to control this CPGC#_CH# engine in 
       multiple ways 
       (i.e. Global_Start_Test, Global_Stop_Test, Global_Clear_Errors, 
       Global_Clear_Errors_On_Start_Test, and Global_Stop_Test_on_Any_Error). 
     */
    UINT32 initialization_mode : 2;
    /* initialization_mode - Bits[9:8], RW_LBV, default = 2'b00 
       A change to Initialization Mode occurs immediately and does not require a 
       Physical Layer Reset to be asserted. 
       00 - Idle on MC Reset
       01 - CPGC Testing Once the Initialization_Mode is set to 01 then the channel 
       enters immediately 
       into the Loopback.Marker state and the ability to start a test becomes enabled.
       10 - MRS Mode.
       11 - RSVD.
     */
    UINT32 loopcount : 5;
    /* loopcount - Bits[14:10], RW_LB, default = 5'b00000 
       2^(Loopcount-1) determines how many iterations of the complete Sequence loop 
       takes place before a test stops, where a 
       Sequence loop is defined by the completion of all SubSequences indicated by the 
       SubSequence Start pointer to 
       SubSequence End pointer.
       Loopcount = 0 means the test is infinite.
       Loopcount = 1 means the test will end after one loop through the sub sequences.
       Loopcount = 2 means the test will end after two Loops through the sub sequences.
       Loopcount = 3 means the test will end after four Loops through the sub 
       sequences. 
     */
    UINT32 subseq_start_pointer : 4;
    /* subseq_start_pointer - Bits[18:15], RW_LB, default = 4'b0000 
       Initial SubSequence pointer when beginning a Sequence. Subseq_Start_Pointer 
       values of 0 9 are valid 
     */
    UINT32 subseq_end_pointer : 4;
    /* subseq_end_pointer - Bits[22:19], RW_LB, default = 4'b0000 
       Subsequence pointer when completed the Loopcount is incremented by 1 and the 
       Current_Subseq_Pointer is reset to the Subseq_Start_Pointer. 
       Subseq_End_Pointer values of 0 9 are valid
       The Subseq_End_Pointer must always be set to equal or greater than the 
       Subseq_Start_Pointer. 
     */
    UINT32 start_test_delay : 8;
    /* start_test_delay - Bits[30:23], RW_LB, default = 8'b00000000 
       Delay period (in DClks) between the setting of Local_Start_Test or 
       (Global_Control and Global_Start_Test) and the actual entry 
       to Loopback.Pattern where the first SubSequence is executed immediately.
     */
    UINT32 link_wrtrn_enb : 1;
    /* link_wrtrn_enb - Bits[31:31], RW_LB, default = 1'b0 
       This bit enables CPGC mode wherein more then 1 CPGC WR credits are available at 
       a time. 
       1'b0: Default CPGC Wr credit of 1
       1'b1: 32 (link 2:1) or 16 (link 1:1) Wr-credits per scheduler to enable LINK 
       Write and Write leveling training steps 
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQCTL0_MC_MAIN_STRUCT;



/* CPGC_SEQCTL1_MC_MAIN_REG supported on:                                     */
/*       SKX_A0 (0x40250B0C)                                                  */
/*       SKX (0x40250B0C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQCTL1_MC_MAIN_REG 0x07004B0C
/* Struct format extracted from XML file SKX_A0\2.10.0.CFG.xml.
 * CPGC Channel-1 Sequence Control -
 * SEQ_CTL1 defines a variety of controls available for configuring a Sequence for 
 * CH-1. 
 */
typedef union {
  struct {
    UINT32 local_start_test : 1;
    /* local_start_test - Bits[0:0], RW_LBV, default = 1'b0 
       Setting Local_Start_Test or (Global_Control and Global_Start_Test) to 1 will 
       immediately initiate a transition to Loopback.Pattern 
       from Loopback.Marker.
       Local_Start_Test must be cleared when a test transitions from Loopback.Pattern 
       to Loopback.Marker. 
     */
    UINT32 local_stop_test : 1;
    /* local_stop_test - Bits[1:1], RW_LBV, default = 1'b0 
       If Local_Stop_Test or (Global_Control and Global_Stop_Test) is set to 1 will 
       force a transition on this Channel # to Loopback.Marker 
       from Loopback.Pattern.
       Local_Start_Test must be cleared when a test transitions from Loopback.Pattern 
       to Loopback.Marker. 
     */
    UINT32 local_clear_errs : 1;
    /* local_clear_errs - Bits[2:2], RW_LBV, default = 1'b0 
       Setting Local_Clear_Errors or (Global_Control and Global_Clear_Errors) to 1 will 
       immediately clear all local channel errors status registers 
       (CPGC#_CH#_ERR_* registers).
       Local_Clear_Errors will immediately clear to 0 after clearing all error status 
       registers 
     */
    UINT32 stop_base_seq_on_wrap_trigger : 1;
    /* stop_base_seq_on_wrap_trigger - Bits[3:3], RW_LB, default = 1'b0 
       If Stop_Base_Seq_On_Wrap_Trigger is set then any Base Address Wrap Trigger that 
       occurs will immediately force a test to stop 
       (i.e. creates a transition from Loopback.Pattern to Loopback.Marker).
       Stop_On_Wrap_Trigger at the sequence level only makes sense when the 
       Address_Update_Rate_Mode is set to 0x1 where the four Address Update Rate 
       fields (Rank, Bank, Row, and Column) are updated by based on the Loopcount (the 
       # of loops through from the start of the test). 
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the former 
       causes the subsequence to end and the latter causes the sequence to end.
     */
    UINT32 address_update_rate_mode : 1;
    /* address_update_rate_mode - Bits[4:4], RW_LB, default = 1'b0 
       Address_Update_Rate_Mode dictates whether the address increment is based on # of 
       cachelines written and read or by Loopcount (# of sequences performed). 
       Address_Update_Rate_Mode = 0 means that the four Address Update Rate fields 
       (Rank, Bank, Row, and Column) are updated based on the # of read and 
       write cacheline transactions.
       Address_Update_Rate_Mode = 1 means that the four Address Update Rate fields 
       (Rank, Bank, Row, and Column) are updated by based on the Loopcount 
       (# of sequences perfromed).
     */
    UINT32 enable_dummy_reads : 1;
    /* enable_dummy_reads - Bits[5:5], RW_LB, default = 1'b0 
       If set then the Dummy Read state machine is Enabled during this sequence 
       creating ACT and PRE in the same Rank that is being targeted. 
       See CPGC_CH#_SEQ#_DUMMYREAD_*
     */
    UINT32 enable_constant_write_strobe : 1;
    /* enable_constant_write_strobe - Bits[6:6], RW_LB, default = 1'b0 
       This bit is UNUSED in design. Refer to be4536804 for details.
       Setting Enable_Constant_Write_Strobe will cause the Tx write Strobe to be driven 
       out constantly while a test is in progress 
       (while in Loopback.Pattern).
       This is most often used to help train the correct setting for per Rank write 
       leveling using the following steps. 
     */
    UINT32 global_control : 1;
    /* global_control - Bits[7:7], RW_LB, default = 1'b0 
       Enables the CPGC_GLOBAL_CTRL register to control this CPGC#_CH# engine in 
       multiple ways 
       (i.e. Global_Start_Test, Global_Stop_Test, Global_Clear_Errors, 
       Global_Clear_Errors_On_Start_Test, and Global_Stop_Test_on_Any_Error). 
     */
    UINT32 initialization_mode : 2;
    /* initialization_mode - Bits[9:8], RW_LBV, default = 2'b00 
       A change to Initialization Mode occurs immediately and does not require a 
       Physical Layer Reset to be asserted. 
       00 - Idle on MC Reset
       01 - CPGC Testing Once the Initialization_Mode is set to 01 then the channel 
       enters immediately 
       into the Loopback.Marker state and the ability to start a test becomes enabled.
       10 - MRS Mode.
       11 - Normal Operation. This is the normal protocol mode for the Link. (i.e. CPGC 
       is disabled). 
       If currently in one of the other modes, an exit will occur as soon as possible.
     */
    UINT32 loopcount : 5;
    /* loopcount - Bits[14:10], RW_LB, default = 5'b00000 
       2^(Loopcount-1) determines how many iterations of the complete Sequence loop 
       takes place before a test stops, where a 
       Sequence loop is defined by the completion of all SubSequences indicated by the 
       SubSequence Start pointer to 
       SubSequence End pointer.
       Loopcount = 0 means the test is infinite.
       Loopcount = 1 means the test will end after one loop through the sub sequences.
       Loopcount = 2 means the test will end after two Loops through the sub sequences.
       Loopcount = 3 means the test will end after four Loops through the sub 
       sequences. 
     */
    UINT32 subseq_start_pointer : 4;
    /* subseq_start_pointer - Bits[18:15], RW_LB, default = 4'b0000 
       Initial SubSequence pointer when beginning a Sequence. Subseq_Start_Pointer 
       values of 0 9 are valid 
     */
    UINT32 subseq_end_pointer : 4;
    /* subseq_end_pointer - Bits[22:19], RW_LB, default = 4'b0000 
       Subsequence pointer when completed the Loopcount is incremented by 1 and the 
       Current_Subseq_Pointer is reset to the Subseq_Start_Pointer. 
       Subseq_End_Pointer values of 0 9 are valid
       The Subseq_End_Pointer must always be set to equal or greater than the 
       Subseq_Start_Pointer. 
     */
    UINT32 start_test_delay : 8;
    /* start_test_delay - Bits[30:23], RW_LB, default = 8'b00000000 
       Delay period (in DClks) between the setting of Local_Start_Test or 
       (Global_Control and Global_Start_Test) and the actual entry 
       to Loopback.Pattern where the first SubSequence is executed immediately.
     */
    UINT32 vmse_wrtrn_enb : 1;
    /* vmse_wrtrn_enb - Bits[31:31], RW_LB, default = 1'b0 
       This bit enables CPGC mode wherein more then 1 CPGC WR credits are available at 
       a time. 
       1'b0: Default CPGC Wr credit of 1
       1'b1: 32 (link 2:1) or 16 (link 1:1) Wr-credits per scheduler to enable LINK 
       Write and Write leveling training steps 
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQCTL1_MC_MAIN_A0_STRUCT;

/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sequence Control -
 * SEQ_CTL1 defines a variety of controls available for configuring a Sequence for 
 * CH-1. 
 */
typedef union {
  struct {
    UINT32 local_start_test : 1;
    /* local_start_test - Bits[0:0], RW_LBV, default = 1'b0 
       Setting Local_Start_Test or (Global_Control and Global_Start_Test) to 1 will 
       immediately initiate a transition to Loopback.Pattern 
       from Loopback.Marker.
       Local_Start_Test must be cleared when a test transitions from Loopback.Pattern 
       to Loopback.Marker. 
     */
    UINT32 local_stop_test : 1;
    /* local_stop_test - Bits[1:1], RW_LBV, default = 1'b0 
       If Local_Stop_Test or (Global_Control and Global_Stop_Test) is set to 1 will 
       force a transition on this Channel # to Loopback.Marker 
       from Loopback.Pattern.
       Local_Start_Test must be cleared when a test transitions from Loopback.Pattern 
       to Loopback.Marker. 
     */
    UINT32 local_clear_errs : 1;
    /* local_clear_errs - Bits[2:2], RW_LBV, default = 1'b0 
       Setting Local_Clear_Errors or (Global_Control and Global_Clear_Errors) to 1 will 
       immediately clear all local channel errors status registers 
       (CPGC#_CH#_ERR_* registers).
       Local_Clear_Errors will immediately clear to 0 after clearing all error status 
       registers 
     */
    UINT32 stop_base_seq_on_wrap_trigger : 1;
    /* stop_base_seq_on_wrap_trigger - Bits[3:3], RW_LB, default = 1'b0 
       If Stop_Base_Seq_On_Wrap_Trigger is set then any Base Address Wrap Trigger that 
       occurs will immediately force a test to stop 
       (i.e. creates a transition from Loopback.Pattern to Loopback.Marker).
       Stop_On_Wrap_Trigger at the sequence level only makes sense when the 
       Address_Update_Rate_Mode is set to 0x1 where the four Address Update Rate 
       fields (Rank, Bank, Row, and Column) are updated by based on the Loopcount (the 
       # of loops through from the start of the test). 
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the former 
       causes the subsequence to end and the latter causes the sequence to end.
     */
    UINT32 address_update_rate_mode : 1;
    /* address_update_rate_mode - Bits[4:4], RW_LB, default = 1'b0 
       Address_Update_Rate_Mode dictates whether the address increment is based on # of 
       cachelines written and read or by Loopcount (# of sequences performed). 
       Address_Update_Rate_Mode = 0 means that the four Address Update Rate fields 
       (Rank, Bank, Row, and Column) are updated based on the # of read and 
       write cacheline transactions.
       Address_Update_Rate_Mode = 1 means that the four Address Update Rate fields 
       (Rank, Bank, Row, and Column) are updated by based on the Loopcount 
       (# of sequences perfromed).
     */
    UINT32 enable_dummy_reads : 1;
    /* enable_dummy_reads - Bits[5:5], RW_LB, default = 1'b0 
       If set then the Dummy Read state machine is Enabled during this sequence 
       creating ACT and PRE in the same Rank that is being targeted. 
       See CPGC_CH#_SEQ#_DUMMYREAD_*
     */
    UINT32 rsvd_6 : 1;
    UINT32 global_control : 1;
    /* global_control - Bits[7:7], RW_LB, default = 1'b0 
       Enables the CPGC_GLOBAL_CTRL register to control this CPGC#_CH# engine in 
       multiple ways 
       (i.e. Global_Start_Test, Global_Stop_Test, Global_Clear_Errors, 
       Global_Clear_Errors_On_Start_Test, and Global_Stop_Test_on_Any_Error). 
     */
    UINT32 initialization_mode : 2;
    /* initialization_mode - Bits[9:8], RW_LBV, default = 2'b00 
       A change to Initialization Mode occurs immediately and does not require a 
       Physical Layer Reset to be asserted. 
       00 - Idle on MC Reset
       01 - CPGC Testing Once the Initialization_Mode is set to 01 then the channel 
       enters immediately 
       into the Loopback.Marker state and the ability to start a test becomes enabled.
       10 - MRS Mode.
       11 - Normal Operation. This is the normal protocol mode for the Link. (i.e. CPGC 
       is disabled). 
       If currently in one of the other modes, an exit will occur as soon as possible.
     */
    UINT32 loopcount : 5;
    /* loopcount - Bits[14:10], RW_LB, default = 5'b00000 
       2^(Loopcount-1) determines how many iterations of the complete Sequence loop 
       takes place before a test stops, where a 
       Sequence loop is defined by the completion of all SubSequences indicated by the 
       SubSequence Start pointer to 
       SubSequence End pointer.
       Loopcount = 0 means the test is infinite.
       Loopcount = 1 means the test will end after one loop through the sub sequences.
       Loopcount = 2 means the test will end after two Loops through the sub sequences.
       Loopcount = 3 means the test will end after four Loops through the sub 
       sequences. 
     */
    UINT32 subseq_start_pointer : 4;
    /* subseq_start_pointer - Bits[18:15], RW_LB, default = 4'b0000 
       Initial SubSequence pointer when beginning a Sequence. Subseq_Start_Pointer 
       values of 0 9 are valid 
     */
    UINT32 subseq_end_pointer : 4;
    /* subseq_end_pointer - Bits[22:19], RW_LB, default = 4'b0000 
       Subsequence pointer when completed the Loopcount is incremented by 1 and the 
       Current_Subseq_Pointer is reset to the Subseq_Start_Pointer. 
       Subseq_End_Pointer values of 0 9 are valid
       The Subseq_End_Pointer must always be set to equal or greater than the 
       Subseq_Start_Pointer. 
     */
    UINT32 start_test_delay : 8;
    /* start_test_delay - Bits[30:23], RW_LB, default = 8'b00000000 
       Delay period (in DClks) between the setting of Local_Start_Test or 
       (Global_Control and Global_Start_Test) and the actual entry 
       to Loopback.Pattern where the first SubSequence is executed immediately.
     */
    UINT32 link_wrtrn_enb : 1;
    /* link_wrtrn_enb - Bits[31:31], RW_LB, default = 1'b0 
       This bit enables CPGC mode wherein more then 1 CPGC WR credits are available at 
       a time. 
       1'b0: Default CPGC Wr credit of 1
       1'b1: 32 (link 2:1) or 16 (link 1:1) Wr-credits per scheduler to enable LINK 
       Write and Write leveling training steps 
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQCTL1_MC_MAIN_STRUCT;



/* CPGC_SEQCTL2_MC_MAIN_REG supported on:                                     */
/*       SKX_A0 (0x40250B10)                                                  */
/*       SKX (0x40250B10)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQCTL2_MC_MAIN_REG 0x07004B10
/* Struct format extracted from XML file SKX_A0\2.10.0.CFG.xml.
 * CPGC Channel-2 Sequence Control -
 * SEQ_CTL2 defines a variety of controls available for configuring a Sequence for 
 * CH-2. 
 */
typedef union {
  struct {
    UINT32 local_start_test : 1;
    /* local_start_test - Bits[0:0], RW_LBV, default = 1'b0 
       Setting Local_Start_Test or (Global_Control and Global_Start_Test) to 1 will 
       immediately initiate a transition to Loopback.Pattern 
       from Loopback.Marker.
       Local_Start_Test must be cleared when a test transitions from Loopback.Pattern 
       to Loopback.Marker. 
     */
    UINT32 local_stop_test : 1;
    /* local_stop_test - Bits[1:1], RW_LBV, default = 1'b0 
       If Local_Stop_Test or (Global_Control and Global_Stop_Test) is set to 1 will 
       force a transition on this Channel # to Loopback.Marker 
       from Loopback.Pattern.
       Local_Start_Test must be cleared when a test transitions from Loopback.Pattern 
       to Loopback.Marker. 
     */
    UINT32 local_clear_errs : 1;
    /* local_clear_errs - Bits[2:2], RW_LBV, default = 1'b0 
       Setting Local_Clear_Errors or (Global_Control and Global_Clear_Errors) to 1 will 
       immediately clear all local channel errors status registers 
       (CPGC#_CH#_ERR_* registers).
       Local_Clear_Errors will immediately clear to 0 after clearing all error status 
       registers 
     */
    UINT32 stop_base_seq_on_wrap_trigger : 1;
    /* stop_base_seq_on_wrap_trigger - Bits[3:3], RW_LB, default = 1'b0 
       If Stop_Base_Seq_On_Wrap_Trigger is set then any Base Address Wrap Trigger that 
       occurs will immediately force a test to stop 
       (i.e. creates a transition from Loopback.Pattern to Loopback.Marker).
       Stop_On_Wrap_Trigger at the sequence level only makes sense when the 
       Address_Update_Rate_Mode is set to 0x1 where the four Address Update Rate 
       fields (Rank, Bank, Row, and Column) are updated by based on the Loopcount (the 
       # of loops through from the start of the test). 
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the former 
       causes the subsequence to end and the latter causes the sequence to end.
     */
    UINT32 address_update_rate_mode : 1;
    /* address_update_rate_mode - Bits[4:4], RW_LB, default = 1'b0 
       Address_Update_Rate_Mode dictates whether the address increment is based on # of 
       cachelines written and read or by Loopcount (# of sequences performed). 
       Address_Update_Rate_Mode = 0 means that the four Address Update Rate fields 
       (Rank, Bank, Row, and Column) are updated based on the # of read and 
       write cacheline transactions.
       Address_Update_Rate_Mode = 1 means that the four Address Update Rate fields 
       (Rank, Bank, Row, and Column) are updated by based on the Loopcount 
       (# of sequences perfromed).
     */
    UINT32 enable_dummy_reads : 1;
    /* enable_dummy_reads - Bits[5:5], RW_LB, default = 1'b0 
       If set then the Dummy Read state machine is Enabled during this sequence 
       creating ACT and PRE in the same Rank that is being targeted. 
       See CPGC_CH#_SEQ#_DUMMYREAD_*
     */
    UINT32 enable_constant_write_strobe : 1;
    /* enable_constant_write_strobe - Bits[6:6], RW_LB, default = 1'b0 
       This bit is UNUSED in design. Refer to be4536804 for details.
       Setting Enable_Constant_Write_Strobe will cause the Tx write Strobe to be driven 
       out constantly while a test is in progress 
       (while in Loopback.Pattern).
       This is most often used to help train the correct setting for per Rank write 
       leveling using the following steps. 
     */
    UINT32 global_control : 1;
    /* global_control - Bits[7:7], RW_LB, default = 1'b0 
       Enables the CPGC_GLOBAL_CTRL register to control this CPGC#_CH# engine in 
       multiple ways 
       (i.e. Global_Start_Test, Global_Stop_Test, Global_Clear_Errors, 
       Global_Clear_Errors_On_Start_Test, and Global_Stop_Test_on_Any_Error). 
     */
    UINT32 initialization_mode : 2;
    /* initialization_mode - Bits[9:8], RW_LBV, default = 2'b00 
       A change to Initialization Mode occurs immediately and does not require a 
       Physical Layer Reset to be asserted. 
       00 - Idle on MC Reset
       01 - CPGC Testing Once the Initialization_Mode is set to 01 then the channel 
       enters immediately 
       into the Loopback.Marker state and the ability to start a test becomes enabled.
       10 - MRS Mode.
       11 - Normal Operation. This is the normal protocol mode for the Link. (i.e. CPGC 
       is disabled). 
       If currently in one of the other modes, an exit will occur as soon as possible.
     */
    UINT32 loopcount : 5;
    /* loopcount - Bits[14:10], RW_LB, default = 5'b00000 
       2^(Loopcount-1) determines how many iterations of the complete Sequence loop 
       takes place before a test stops, where a 
       Sequence loop is defined by the completion of all SubSequences indicated by the 
       SubSequence Start pointer to 
       SubSequence End pointer.
       Loopcount = 0 means the test is infinite.
       Loopcount = 1 means the test will end after one loop through the sub sequences.
       Loopcount = 2 means the test will end after two Loops through the sub sequences.
       Loopcount = 3 means the test will end after four Loops through the sub 
       sequences. 
     */
    UINT32 subseq_start_pointer : 4;
    /* subseq_start_pointer - Bits[18:15], RW_LB, default = 4'b0000 
       Initial SubSequence pointer when beginning a Sequence. Subseq_Start_Pointer 
       values of 0 9 are valid 
     */
    UINT32 subseq_end_pointer : 4;
    /* subseq_end_pointer - Bits[22:19], RW_LB, default = 4'b0000 
       Subsequence pointer when completed the Loopcount is incremented by 1 and the 
       Current_Subseq_Pointer is reset to the Subseq_Start_Pointer. 
       Subseq_End_Pointer values of 0 9 are valid
       The Subseq_End_Pointer must always be set to equal or greater than the 
       Subseq_Start_Pointer. 
     */
    UINT32 start_test_delay : 8;
    /* start_test_delay - Bits[30:23], RW_LB, default = 8'b00000000 
       Delay period (in DClks) between the setting of Local_Start_Test or 
       (Global_Control and Global_Start_Test) and the actual entry 
       to Loopback.Pattern where the first SubSequence is executed immediately.
     */
    UINT32 vmse_wrtrn_enb : 1;
    /* vmse_wrtrn_enb - Bits[31:31], RW_LB, default = 1'b0 
       This bit enables CPGC mode wherein more then 1 CPGC WR credits are available at 
       a time. 
       1'b0: Default CPGC Wr credit of 1
       1'b1: 32 (link 1:1) or 16 (link 2:1) Wr-credits per scheduler to enable LINK 
       Write and Write leveling training steps 
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQCTL2_MC_MAIN_A0_STRUCT;

/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sequence Control -
 * SEQ_CTL2 defines a variety of controls available for configuring a Sequence for 
 * CH-2. 
 */
typedef union {
  struct {
    UINT32 local_start_test : 1;
    /* local_start_test - Bits[0:0], RW_LBV, default = 1'b0 
       Setting Local_Start_Test or (Global_Control and Global_Start_Test) to 1 will 
       immediately initiate a transition to Loopback.Pattern 
       from Loopback.Marker.
       Local_Start_Test must be cleared when a test transitions from Loopback.Pattern 
       to Loopback.Marker. 
     */
    UINT32 local_stop_test : 1;
    /* local_stop_test - Bits[1:1], RW_LBV, default = 1'b0 
       If Local_Stop_Test or (Global_Control and Global_Stop_Test) is set to 1 will 
       force a transition on this Channel # to Loopback.Marker 
       from Loopback.Pattern.
       Local_Start_Test must be cleared when a test transitions from Loopback.Pattern 
       to Loopback.Marker. 
     */
    UINT32 local_clear_errs : 1;
    /* local_clear_errs - Bits[2:2], RW_LBV, default = 1'b0 
       Setting Local_Clear_Errors or (Global_Control and Global_Clear_Errors) to 1 will 
       immediately clear all local channel errors status registers 
       (CPGC#_CH#_ERR_* registers).
       Local_Clear_Errors will immediately clear to 0 after clearing all error status 
       registers 
     */
    UINT32 stop_base_seq_on_wrap_trigger : 1;
    /* stop_base_seq_on_wrap_trigger - Bits[3:3], RW_LB, default = 1'b0 
       If Stop_Base_Seq_On_Wrap_Trigger is set then any Base Address Wrap Trigger that 
       occurs will immediately force a test to stop 
       (i.e. creates a transition from Loopback.Pattern to Loopback.Marker).
       Stop_On_Wrap_Trigger at the sequence level only makes sense when the 
       Address_Update_Rate_Mode is set to 0x1 where the four Address Update Rate 
       fields (Rank, Bank, Row, and Column) are updated by based on the Loopcount (the 
       # of loops through from the start of the test). 
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the former 
       causes the subsequence to end and the latter causes the sequence to end.
     */
    UINT32 address_update_rate_mode : 1;
    /* address_update_rate_mode - Bits[4:4], RW_LB, default = 1'b0 
       Address_Update_Rate_Mode dictates whether the address increment is based on # of 
       cachelines written and read or by Loopcount (# of sequences performed). 
       Address_Update_Rate_Mode = 0 means that the four Address Update Rate fields 
       (Rank, Bank, Row, and Column) are updated based on the # of read and 
       write cacheline transactions.
       Address_Update_Rate_Mode = 1 means that the four Address Update Rate fields 
       (Rank, Bank, Row, and Column) are updated by based on the Loopcount 
       (# of sequences perfromed).
     */
    UINT32 enable_dummy_reads : 1;
    /* enable_dummy_reads - Bits[5:5], RW_LB, default = 1'b0 
       If set then the Dummy Read state machine is Enabled during this sequence 
       creating ACT and PRE in the same Rank that is being targeted. 
       See CPGC_CH#_SEQ#_DUMMYREAD_*
     */
    UINT32 enable_constant_write_strobe : 1;
    /* enable_constant_write_strobe - Bits[6:6], RW_LB, default = 1'b0 
       This bit is UNUSED in design. Refer to be4536804 for details.
       Setting Enable_Constant_Write_Strobe will cause the Tx write Strobe to be driven 
       out constantly while a test is in progress 
       (while in Loopback.Pattern).
       This is most often used to help train the correct setting for per Rank write 
       leveling using the following steps. 
     */
    UINT32 global_control : 1;
    /* global_control - Bits[7:7], RW_LB, default = 1'b0 
       Enables the CPGC_GLOBAL_CTRL register to control this CPGC#_CH# engine in 
       multiple ways 
       (i.e. Global_Start_Test, Global_Stop_Test, Global_Clear_Errors, 
       Global_Clear_Errors_On_Start_Test, and Global_Stop_Test_on_Any_Error). 
     */
    UINT32 initialization_mode : 2;
    /* initialization_mode - Bits[9:8], RW_LBV, default = 2'b00 
       A change to Initialization Mode occurs immediately and does not require a 
       Physical Layer Reset to be asserted. 
       00 - Idle on MC Reset
       01 - CPGC Testing Once the Initialization_Mode is set to 01 then the channel 
       enters immediately 
       into the Loopback.Marker state and the ability to start a test becomes enabled.
       10 - MRS Mode.
       11 - Normal Operation. This is the normal protocol mode for the Link. (i.e. CPGC 
       is disabled). 
       If currently in one of the other modes, an exit will occur as soon as possible.
     */
    UINT32 loopcount : 5;
    /* loopcount - Bits[14:10], RW_LB, default = 5'b00000 
       2^(Loopcount-1) determines how many iterations of the complete Sequence loop 
       takes place before a test stops, where a 
       Sequence loop is defined by the completion of all SubSequences indicated by the 
       SubSequence Start pointer to 
       SubSequence End pointer.
       Loopcount = 0 means the test is infinite.
       Loopcount = 1 means the test will end after one loop through the sub sequences.
       Loopcount = 2 means the test will end after two Loops through the sub sequences.
       Loopcount = 3 means the test will end after four Loops through the sub 
       sequences. 
     */
    UINT32 subseq_start_pointer : 4;
    /* subseq_start_pointer - Bits[18:15], RW_LB, default = 4'b0000 
       Initial SubSequence pointer when beginning a Sequence. Subseq_Start_Pointer 
       values of 0 9 are valid 
     */
    UINT32 subseq_end_pointer : 4;
    /* subseq_end_pointer - Bits[22:19], RW_LB, default = 4'b0000 
       Subsequence pointer when completed the Loopcount is incremented by 1 and the 
       Current_Subseq_Pointer is reset to the Subseq_Start_Pointer. 
       Subseq_End_Pointer values of 0 9 are valid
       The Subseq_End_Pointer must always be set to equal or greater than the 
       Subseq_Start_Pointer. 
     */
    UINT32 start_test_delay : 8;
    /* start_test_delay - Bits[30:23], RW_LB, default = 8'b00000000 
       Delay period (in DClks) between the setting of Local_Start_Test or 
       (Global_Control and Global_Start_Test) and the actual entry 
       to Loopback.Pattern where the first SubSequence is executed immediately.
     */
    UINT32 link_wrtrn_enb : 1;
    /* link_wrtrn_enb - Bits[31:31], RW_LB, default = 1'b0 
       This bit enables CPGC mode wherein more then 1 CPGC WR credits are available at 
       a time. 
       1'b0: Default CPGC Wr credit of 1
       1'b1: 32 (link 1:1) or 16 (link 2:1) Wr-credits per scheduler to enable LINK 
       Write and Write leveling training steps 
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQCTL2_MC_MAIN_STRUCT;



/* CPGC_SEQCTL3_MC_MAIN_REG supported on:                                     */
/*       SKX_A0 (0x40250B14)                                                  */
/*       SKX (0x40250B14)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQCTL3_MC_MAIN_REG 0x07004B14
/* Struct format extracted from XML file SKX_A0\2.10.0.CFG.xml.
 * CPGC Channel-3 Sequence Control -
 * SEQ_CTL3 defines a variety of controls available for configuring a Sequence for 
 * CH-3. 
 */
typedef union {
  struct {
    UINT32 local_start_test : 1;
    /* local_start_test - Bits[0:0], RW_LBV, default = 1'b0 
       Setting Local_Start_Test or (Global_Control and Global_Start_Test) to 1 will 
       immediately initiate a transition to Loopback.Pattern 
       from Loopback.Marker.
       Local_Start_Test must be cleared when a test transitions from Loopback.Pattern 
       to Loopback.Marker. 
     */
    UINT32 local_stop_test : 1;
    /* local_stop_test - Bits[1:1], RW_LBV, default = 1'b0 
       If Local_Stop_Test or (Global_Control and Global_Stop_Test) is set to 1 will 
       force a transition on this Channel # to Loopback.Marker 
       from Loopback.Pattern.
       Local_Start_Test must be cleared when a test transitions from Loopback.Pattern 
       to Loopback.Marker. 
     */
    UINT32 local_clear_errs : 1;
    /* local_clear_errs - Bits[2:2], RW_LBV, default = 1'b0 
       Setting Local_Clear_Errors or (Global_Control and Global_Clear_Errors) to 1 will 
       immediately clear all local channel errors status registers 
       (CPGC#_CH#_ERR_* registers).
       Local_Clear_Errors will immediately clear to 0 after clearing all error status 
       registers 
     */
    UINT32 stop_base_seq_on_wrap_trigger : 1;
    /* stop_base_seq_on_wrap_trigger - Bits[3:3], RW_LB, default = 1'b0 
       If Stop_Base_Seq_On_Wrap_Trigger is set then any Base Address Wrap Trigger that 
       occurs will immediately force a test to stop 
       (i.e. creates a transition from Loopback.Pattern to Loopback.Marker).
       Stop_On_Wrap_Trigger at the sequence level only makes sense when the 
       Address_Update_Rate_Mode is set to 0x1 where the four Address Update Rate 
       fields (Rank, Bank, Row, and Column) are updated by based on the Loopcount (the 
       # of loops through from the start of the test). 
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the former 
       causes the subsequence to end and the latter causes the sequence to end.
     */
    UINT32 address_update_rate_mode : 1;
    /* address_update_rate_mode - Bits[4:4], RW_LB, default = 1'b0 
       Address_Update_Rate_Mode dictates whether the address increment is based on # of 
       cachelines written and read or by Loopcount (# of sequences performed). 
       Address_Update_Rate_Mode = 0 means that the four Address Update Rate fields 
       (Rank, Bank, Row, and Column) are updated based on the # of read and 
       write cacheline transactions.
       Address_Update_Rate_Mode = 1 means that the four Address Update Rate fields 
       (Rank, Bank, Row, and Column) are updated by based on the Loopcount 
       (# of sequences perfromed).
     */
    UINT32 enable_dummy_reads : 1;
    /* enable_dummy_reads - Bits[5:5], RW_LB, default = 1'b0 
       If set then the Dummy Read state machine is Enabled during this sequence 
       creating ACT and PRE in the same Rank that is being targeted. 
       See CPGC_CH#_SEQ#_DUMMYREAD_*
     */
    UINT32 rsvd_6 : 1;
    UINT32 global_control : 1;
    /* global_control - Bits[7:7], RW_LB, default = 1'b0 
       Enables the CPGC_GLOBAL_CTRL register to control this CPGC#_CH# engine in 
       multiple ways 
       (i.e. Global_Start_Test, Global_Stop_Test, Global_Clear_Errors, 
       Global_Clear_Errors_On_Start_Test, and Global_Stop_Test_on_Any_Error). 
     */
    UINT32 initialization_mode : 2;
    /* initialization_mode - Bits[9:8], RW_LBV, default = 2'b00 
       A change to Initialization Mode occurs immediately and does not require a 
       Physical Layer Reset to be asserted. 
       00 - Idle on MC Reset
       01 - CPGC Testing Once the Initialization_Mode is set to 01 then the channel 
       enters immediately 
       into the Loopback.Marker state and the ability to start a test becomes enabled.
       10 - MRS Mode.
       11 - Normal Operation. This is the normal protocol mode for the Link. (i.e. CPGC 
       is disabled). 
       If currently in one of the other modes, an exit will occur as soon as possible.
     */
    UINT32 loopcount : 5;
    /* loopcount - Bits[14:10], RW_LB, default = 5'b00000 
       2^(Loopcount-1) determines how many iterations of the complete Sequence loop 
       takes place before a test stops, where a 
       Sequence loop is defined by the completion of all SubSequences indicated by the 
       SubSequence Start pointer to 
       SubSequence End pointer.
       Loopcount = 0 means the test is infinite.
       Loopcount = 1 means the test will end after one loop through the sub sequences.
       Loopcount = 2 means the test will end after two Loops through the sub sequences.
       Loopcount = 3 means the test will end after four Loops through the sub 
       sequences. 
     */
    UINT32 subseq_start_pointer : 4;
    /* subseq_start_pointer - Bits[18:15], RW_LB, default = 4'b0000 
       Initial SubSequence pointer when beginning a Sequence. Subseq_Start_Pointer 
       values of 0 9 are valid 
     */
    UINT32 subseq_end_pointer : 4;
    /* subseq_end_pointer - Bits[22:19], RW_LB, default = 4'b0000 
       Subsequence pointer when completed the Loopcount is incremented by 1 and the 
       Current_Subseq_Pointer is reset to the Subseq_Start_Pointer. 
       Subseq_End_Pointer values of 0 9 are valid
       The Subseq_End_Pointer must always be set to equal or greater than the 
       Subseq_Start_Pointer. 
     */
    UINT32 start_test_delay : 8;
    /* start_test_delay - Bits[30:23], RW_LB, default = 8'b00000000 
       Delay period (in DClks) between the setting of Local_Start_Test or 
       (Global_Control and Global_Start_Test) and the actual entry 
       to Loopback.Pattern where the first SubSequence is executed immediately.
     */
    UINT32 vmse_wrtrn_enb : 1;
    /* vmse_wrtrn_enb - Bits[31:31], RW_LB, default = 1'b0 
       This bit enables CPGC mode wherein more then 1 CPGC WR credits are available at 
       a time. 
       1'b0: Default CPGC Wr credit of 1
       1'b1: 32 (link 1:1) or 16 (link 2:1) Wr-credits per scheduler to enable LINK 
       Write and Write leveling training steps 
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQCTL3_MC_MAIN_A0_STRUCT;

/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sequence Control -
 * SEQ_CTL3 defines a variety of controls available for configuring a Sequence for 
 * CH-3. 
 */
typedef union {
  struct {
    UINT32 local_start_test : 1;
    /* local_start_test - Bits[0:0], RW_LBV, default = 1'b0 
       Setting Local_Start_Test or (Global_Control and Global_Start_Test) to 1 will 
       immediately initiate a transition to Loopback.Pattern 
       from Loopback.Marker.
       Local_Start_Test must be cleared when a test transitions from Loopback.Pattern 
       to Loopback.Marker. 
     */
    UINT32 local_stop_test : 1;
    /* local_stop_test - Bits[1:1], RW_LBV, default = 1'b0 
       If Local_Stop_Test or (Global_Control and Global_Stop_Test) is set to 1 will 
       force a transition on this Channel # to Loopback.Marker 
       from Loopback.Pattern.
       Local_Start_Test must be cleared when a test transitions from Loopback.Pattern 
       to Loopback.Marker. 
     */
    UINT32 local_clear_errs : 1;
    /* local_clear_errs - Bits[2:2], RW_LBV, default = 1'b0 
       Setting Local_Clear_Errors or (Global_Control and Global_Clear_Errors) to 1 will 
       immediately clear all local channel errors status registers 
       (CPGC#_CH#_ERR_* registers).
       Local_Clear_Errors will immediately clear to 0 after clearing all error status 
       registers 
     */
    UINT32 stop_base_seq_on_wrap_trigger : 1;
    /* stop_base_seq_on_wrap_trigger - Bits[3:3], RW_LB, default = 1'b0 
       If Stop_Base_Seq_On_Wrap_Trigger is set then any Base Address Wrap Trigger that 
       occurs will immediately force a test to stop 
       (i.e. creates a transition from Loopback.Pattern to Loopback.Marker).
       Stop_On_Wrap_Trigger at the sequence level only makes sense when the 
       Address_Update_Rate_Mode is set to 0x1 where the four Address Update Rate 
       fields (Rank, Bank, Row, and Column) are updated by based on the Loopcount (the 
       # of loops through from the start of the test). 
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the former 
       causes the subsequence to end and the latter causes the sequence to end.
     */
    UINT32 address_update_rate_mode : 1;
    /* address_update_rate_mode - Bits[4:4], RW_LB, default = 1'b0 
       Address_Update_Rate_Mode dictates whether the address increment is based on # of 
       cachelines written and read or by Loopcount (# of sequences performed). 
       Address_Update_Rate_Mode = 0 means that the four Address Update Rate fields 
       (Rank, Bank, Row, and Column) are updated based on the # of read and 
       write cacheline transactions.
       Address_Update_Rate_Mode = 1 means that the four Address Update Rate fields 
       (Rank, Bank, Row, and Column) are updated by based on the Loopcount 
       (# of sequences perfromed).
     */
    UINT32 enable_dummy_reads : 1;
    /* enable_dummy_reads - Bits[5:5], RW_LB, default = 1'b0 
       If set then the Dummy Read state machine is Enabled during this sequence 
       creating ACT and PRE in the same Rank that is being targeted. 
       See CPGC_CH#_SEQ#_DUMMYREAD_*
     */
    UINT32 rsvd_6 : 1;
    UINT32 global_control : 1;
    /* global_control - Bits[7:7], RW_LB, default = 1'b0 
       Enables the CPGC_GLOBAL_CTRL register to control this CPGC#_CH# engine in 
       multiple ways 
       (i.e. Global_Start_Test, Global_Stop_Test, Global_Clear_Errors, 
       Global_Clear_Errors_On_Start_Test, and Global_Stop_Test_on_Any_Error). 
     */
    UINT32 initialization_mode : 2;
    /* initialization_mode - Bits[9:8], RW_LBV, default = 2'b00 
       A change to Initialization Mode occurs immediately and does not require a 
       Physical Layer Reset to be asserted. 
       00 - Idle on MC Reset
       01 - CPGC Testing Once the Initialization_Mode is set to 01 then the channel 
       enters immediately 
       into the Loopback.Marker state and the ability to start a test becomes enabled.
       10 - MRS Mode.
       11 - Normal Operation. This is the normal protocol mode for the Link. (i.e. CPGC 
       is disabled). 
       If currently in one of the other modes, an exit will occur as soon as possible.
     */
    UINT32 loopcount : 5;
    /* loopcount - Bits[14:10], RW_LB, default = 5'b00000 
       2^(Loopcount-1) determines how many iterations of the complete Sequence loop 
       takes place before a test stops, where a 
       Sequence loop is defined by the completion of all SubSequences indicated by the 
       SubSequence Start pointer to 
       SubSequence End pointer.
       Loopcount = 0 means the test is infinite.
       Loopcount = 1 means the test will end after one loop through the sub sequences.
       Loopcount = 2 means the test will end after two Loops through the sub sequences.
       Loopcount = 3 means the test will end after four Loops through the sub 
       sequences. 
     */
    UINT32 subseq_start_pointer : 4;
    /* subseq_start_pointer - Bits[18:15], RW_LB, default = 4'b0000 
       Initial SubSequence pointer when beginning a Sequence. Subseq_Start_Pointer 
       values of 0 9 are valid 
     */
    UINT32 subseq_end_pointer : 4;
    /* subseq_end_pointer - Bits[22:19], RW_LB, default = 4'b0000 
       Subsequence pointer when completed the Loopcount is incremented by 1 and the 
       Current_Subseq_Pointer is reset to the Subseq_Start_Pointer. 
       Subseq_End_Pointer values of 0 9 are valid
       The Subseq_End_Pointer must always be set to equal or greater than the 
       Subseq_Start_Pointer. 
     */
    UINT32 start_test_delay : 8;
    /* start_test_delay - Bits[30:23], RW_LB, default = 8'b00000000 
       Delay period (in DClks) between the setting of Local_Start_Test or 
       (Global_Control and Global_Start_Test) and the actual entry 
       to Loopback.Pattern where the first SubSequence is executed immediately.
     */
    UINT32 link_wrtrn_enb : 1;
    /* link_wrtrn_enb - Bits[31:31], RW_LB, default = 1'b0 
       This bit enables CPGC mode wherein more then 1 CPGC WR credits are available at 
       a time. 
       1'b0: Default CPGC Wr credit of 1
       1'b1: 32 (link 1:1) or 16 (link 2:1) Wr-credits per scheduler to enable LINK 
       Write and Write leveling training steps 
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQCTL3_MC_MAIN_STRUCT;



/* CPGC_SEQ_LPCNT_STS0_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x40250B18)                                                  */
/*       SKX (0x40250B18)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_LPCNT_STS0_MC_MAIN_REG 0x07004B18
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Loopcount Status -
 * CPGC#_CH#_SEQ_LOOPCOUNT_STATUS (Specific Channel Loopcount Status)
 */
typedef union {
  struct {
    UINT32 current_loopcount : 32;
    /* current_loopcount - Bits[31:0], RO_V, default = 32'b00000000000000000000000000000000 
       Current_Loopcount indicates how many times the full Sequence has been executed 
       completely. 
       Current_Loopcount is used to -
       1) Drive the Base Address Increment Logic (CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL) when 
       CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode is set to 1. 
       2) Help determine what the failing pattern is in conjunction with the control 
       signal to Stop_On_Nth_Error and the status provided by the 
       Physical Layer Address logged for the Nth Error (CPGC#_CH#_ERROR_ADDR).
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_LPCNT_STS0_MC_MAIN_STRUCT;


/* CPGC_SEQ_LPCNT_STS1_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x40250B1C)                                                  */
/*       SKX (0x40250B1C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_LPCNT_STS1_MC_MAIN_REG 0x07004B1C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Loopcount Status -
 * CPGC#_CH#_SEQ_LOOPCOUNT_STATUS (Specific Channel Loopcount Status)
 */
typedef union {
  struct {
    UINT32 current_loopcount : 32;
    /* current_loopcount - Bits[31:0], RO_V, default = 32'b00000000000000000000000000000000 
       Current_Loopcount indicates how many times the full Sequence has been executed 
       completely. 
       Current_Loopcount is used to -
       1) Drive the Base Address Increment Logic (CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL) when 
       CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode is set to 1. 
       2) Help determine what the failing pattern is in conjunction with the control 
       signal to Stop_On_Nth_Error and the status provided by the 
       Physical Layer Address logged for the Nth Error (CPGC#_CH#_ERROR_ADDR).
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_LPCNT_STS1_MC_MAIN_STRUCT;


/* CPGC_SEQ_LPCNT_STS2_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x40250B20)                                                  */
/*       SKX (0x40250B20)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_LPCNT_STS2_MC_MAIN_REG 0x07004B20
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Loopcount Status -
 * CPGC#_CH#_SEQ_LOOPCOUNT_STATUS (Specific Channel Loopcount Status)
 */
typedef union {
  struct {
    UINT32 current_loopcount : 32;
    /* current_loopcount - Bits[31:0], RO_V, default = 32'b00000000000000000000000000000000 
       Current_Loopcount indicates how many times the full Sequence has been executed 
       completely. 
       Current_Loopcount is used to -
       1) Drive the Base Address Increment Logic (CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL) when 
       CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode is set to 1. 
       2) Help determine what the failing pattern is in conjunction with the control 
       signal to Stop_On_Nth_Error and the status provided by the 
       Physical Layer Address logged for the Nth Error (CPGC#_CH#_ERROR_ADDR).
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_LPCNT_STS2_MC_MAIN_STRUCT;


/* CPGC_SEQ_LPCNT_STS3_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x40250B24)                                                  */
/*       SKX (0x40250B24)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_LPCNT_STS3_MC_MAIN_REG 0x07004B24
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Loopcount Status -
 * CPGC#_CH#_SEQ_LOOPCOUNT_STATUS (Specific Channel Loopcount Status)
 */
typedef union {
  struct {
    UINT32 current_loopcount : 32;
    /* current_loopcount - Bits[31:0], RO_V, default = 32'b00000000000000000000000000000000 
       Current_Loopcount indicates how many times the full Sequence has been executed 
       completely. 
       Current_Loopcount is used to -
       1) Drive the Base Address Increment Logic (CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL) when 
       CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode is set to 1. 
       2) Help determine what the failing pattern is in conjunction with the control 
       signal to Stop_On_Nth_Error and the status provided by the 
       Physical Layer Address logged for the Nth Error (CPGC#_CH#_ERROR_ADDR).
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_LPCNT_STS3_MC_MAIN_STRUCT;


/* CPGC_SEQ_SUBSEQ_PNTR_MC_MAIN_REG supported on:                             */
/*       SKX_A0 (0x40250B28)                                                  */
/*       SKX (0x40250B28)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_SUBSEQ_PNTR_MC_MAIN_REG 0x07004B28
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Current Sub-Sequence Pointer -
 * CPGC#_CH#_SEQ_SUBSEQ_PNTR (Current_Subsequence_Pointer)
 */
typedef union {
  struct {
    UINT32 currentpntr0 : 4;
    /* currentpntr0 - Bits[3:0], RO_V, default = 4'b0000 
       Indicates what the current Subsequence value is in the Sequence for ch-0.
     */
    UINT32 rsvd_4 : 2;
    /* rsvd_4 - Bits[5:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 currentpntr1 : 4;
    /* currentpntr1 - Bits[9:6], RO_V, default = 4'b0000 
       Indicates what the current Subsequence value is in the Sequence for ch-1.
     */
    UINT32 rsvd_10 : 2;
    /* rsvd_10 - Bits[11:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 currentpntr2 : 4;
    /* currentpntr2 - Bits[15:12], RO_V, default = 4'b0000 
       Indicates what the current Subsequence value is in the Sequence for ch-2.
     */
    UINT32 rsvd_16 : 2;
    /* rsvd_16 - Bits[17:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 currentpntr3 : 4;
    /* currentpntr3 - Bits[21:18], RO_V, default = 4'b0000 
       Indicates what the current Subsequence value is in the Sequence for ch-3.
     */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_SUBSEQ_PNTR_MC_MAIN_STRUCT;


/* CPGC_SEQ_CLSTS0_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250B2C)                                                  */
/*       SKX (0x40250B2C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_CLSTS0_MC_MAIN_REG 0x07004B2C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Cache-Line Status -
 * CPGC#_CH#_SEQ_CACHELINE_STATUS indicates the current Cacheline value is in the 
 * Subsequence 
 */
typedef union {
  struct {
    UINT32 current_cl : 32;
    /* current_cl - Bits[31:0], RO_V, default = 32'b00000000000000000000000000000000 
       Current_Cacheline indicates the number of cachelines executed within the current 
       subsequence (CPGC#_CH#_SEQ_SUBSEQ_PNTR). 
       Current_Cacheline is used to -
       1) Drive the Base Address Increment Logic (CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL) when 
       CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode 
       is set to 0.
       2) Help determine what the failing pattern is in conjunction with the control 
       signal to Stop_On_Nth_Error and the status provided 
       by the Physical Layer Address logged for the Nth Error (CPGC#_CH#_ERROR_ADDR).
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_CLSTS0_MC_MAIN_STRUCT;


/* CPGC_SEQ_CLSTS1_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250B30)                                                  */
/*       SKX (0x40250B30)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_CLSTS1_MC_MAIN_REG 0x07004B30
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Cache-Line Status -
 * CPGC#_CH#_SEQ_CACHELINE_STATUS indicates the current Cacheline value is in the 
 * Subsequence 
 */
typedef union {
  struct {
    UINT32 current_cl : 32;
    /* current_cl - Bits[31:0], RO_V, default = 32'b00000000000000000000000000000000 
       Current_Cacheline indicates the number of cachelines executed within the current 
       subsequence (CPGC#_CH#_SEQ_SUBSEQ_PNTR). 
       Current_Cacheline is used to -
       1) Drive the Base Address Increment Logic (CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL) when 
       CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode 
       is set to 0.
       2) Help determine what the failing pattern is in conjunction with the control 
       signal to Stop_On_Nth_Error and the status provided 
       by the Physical Layer Address logged for the Nth Error (CPGC#_CH#_ERROR_ADDR).
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_CLSTS1_MC_MAIN_STRUCT;


/* CPGC_SEQ_CLSTS2_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250B34)                                                  */
/*       SKX (0x40250B34)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_CLSTS2_MC_MAIN_REG 0x07004B34
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Cache-Line Status -
 * CPGC#_CH#_SEQ_CACHELINE_STATUS indicates the current Cacheline value is in the 
 * Subsequence 
 */
typedef union {
  struct {
    UINT32 current_cl : 32;
    /* current_cl - Bits[31:0], RO_V, default = 32'b00000000000000000000000000000000 
       Current_Cacheline indicates the number of cachelines executed within the current 
       subsequence (CPGC#_CH#_SEQ_SUBSEQ_PNTR). 
       Current_Cacheline is used to -
       1) Drive the Base Address Increment Logic (CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL) when 
       CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode 
       is set to 0.
       2) Help determine what the failing pattern is in conjunction with the control 
       signal to Stop_On_Nth_Error and the status provided 
       by the Physical Layer Address logged for the Nth Error (CPGC#_CH#_ERROR_ADDR).
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_CLSTS2_MC_MAIN_STRUCT;


/* CPGC_SEQ_CLSTS3_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250B38)                                                  */
/*       SKX (0x40250B38)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_CLSTS3_MC_MAIN_REG 0x07004B38
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Cache-Line Status -
 * CPGC#_CH#_SEQ_CACHELINE_STATUS indicates the current Cacheline value is in the 
 * Subsequence 
 */
typedef union {
  struct {
    UINT32 current_cl : 32;
    /* current_cl - Bits[31:0], RO_V, default = 32'b00000000000000000000000000000000 
       Current_Cacheline indicates the number of cachelines executed within the current 
       subsequence (CPGC#_CH#_SEQ_SUBSEQ_PNTR). 
       Current_Cacheline is used to -
       1) Drive the Base Address Increment Logic (CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL) when 
       CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode 
       is set to 0.
       2) Help determine what the failing pattern is in conjunction with the control 
       signal to Stop_On_Nth_Error and the status provided 
       by the Physical Layer Address logged for the Nth Error (CPGC#_CH#_ERROR_ADDR).
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_CLSTS3_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRSTART_LO0_MC_MAIN_REG supported on:                       */
/*       SKX_A0 (0x40250B3C)                                                  */
/*       SKX (0x40250B3C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRSTART_LO0_MC_MAIN_REG 0x07004B3C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence Starting Address -
 * CPGC#_CH#_SEQ_BASE_ADDR_START defines the starting base address of the sequence.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_addr : 18;
    /* column_addr - Bits[20:3], RW_LB, default = 18'h0 
       Starting Column Address. Normally the lowest three column bits are reserved 
       since all transfers are done on a cacheline basis (8 chunks 0-7), 
       but for implementations that address to a sub cacheline then these reserved bits 
       might be used as needed. 
       expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used 
       only for DDRT addresses.  
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_addr : 4;
    /* bank_addr - Bits[27:24], RW_LB, default = 4'b0000 
       Starting Bank Address
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRSTART_LO0_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRSTART_LO1_MC_MAIN_REG supported on:                       */
/*       SKX_A0 (0x40250B40)                                                  */
/*       SKX (0x40250B40)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRSTART_LO1_MC_MAIN_REG 0x07004B40
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence Starting Address -
 * CPGC#_CH#_SEQ_BASE_ADDR_START defines the starting base address of the sequence.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_addr : 18;
    /* column_addr - Bits[20:3], RW_LB, default = 18'h0 
       Starting Column Address. Normally the lowest three column bits are reserved 
       since all transfers are done on a cacheline basis (8 chunks 0-7), 
       but for implementations that address to a sub cacheline then these reserved bits 
       might be used as needed. 
       expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used 
       only for DDRT addresses.  
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_addr : 4;
    /* bank_addr - Bits[27:24], RW_LB, default = 4'b0000 
       Starting Bank Address
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRSTART_LO1_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRSTART_LO2_MC_MAIN_REG supported on:                       */
/*       SKX_A0 (0x40250B44)                                                  */
/*       SKX (0x40250B44)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRSTART_LO2_MC_MAIN_REG 0x07004B44
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence Starting Address -
 * CPGC#_CH#_SEQ_BASE_ADDR_START defines the starting base address of the sequence.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_addr : 18;
    /* column_addr - Bits[20:3], RW_LB, default = 18'h0 
       Starting Column Address. Normally the lowest three column bits are reserved 
       since all transfers are done on a cacheline basis (8 chunks 0-7), 
       but for implementations that address to a sub cacheline then these reserved bits 
       might be used as needed. 
       expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used 
       only for DDRT addresses.  
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_addr : 4;
    /* bank_addr - Bits[27:24], RW_LB, default = 4'b0000 
       Starting Bank Address
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRSTART_LO2_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRSTART_LO3_MC_MAIN_REG supported on:                       */
/*       SKX_A0 (0x40250B48)                                                  */
/*       SKX (0x40250B48)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRSTART_LO3_MC_MAIN_REG 0x07004B48
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence Starting Address -
 * CPGC#_CH#_SEQ_BASE_ADDR_START defines the starting base address of the sequence.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_addr : 18;
    /* column_addr - Bits[20:3], RW_LB, default = 18'h0 
       Starting Column Address. Normally the lowest three column bits are reserved 
       since all transfers are done on a cacheline basis (8 chunks 0-7), 
       but for implementations that address to a sub cacheline then these reserved bits 
       might be used as needed. 
       expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used 
       only for DDRT addresses.  
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_addr : 4;
    /* bank_addr - Bits[27:24], RW_LB, default = 4'b0000 
       Starting Bank Address
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRSTART_LO3_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRWRAP_LO0_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250B4C)                                                  */
/*       SKX (0x40250B4C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRWRAP_LO0_MC_MAIN_REG 0x07004B4C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence Wrap Address -
 * CPGC#_CH#_SEQ_BASE_ADDR_WRAP defines the wrap base address of the sequence.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_addr : 18;
    /* column_addr - Bits[20:3], RW_LB, default = 18'h0 
       If the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address = 
       CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address then any further request to modify 
       (increment or decrement) the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address 
       immediately causes a Wrap to occur with the following actions: 
       1. CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address must be set equal to the 
       CPGC#_CH#_SEQ_BASE_ADDR_Start.Column_Address: 
       2. If Column_Base_Wrap_Carry_Enable is set bit to 1 a carry increment from the 
       Column Address (order N) will propagate to the N+1 order 
       Address field(s).
       3. If Column_Base_Wrap_Trigger_Enable is set to 1 then an Address Wrap Trigger 
       has occurred which can be used in conjunction with Stop_On_Wrap_Trigger. 
       expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used 
       only for DDRT addresses.  
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_addr : 4;
    /* bank_addr - Bits[27:24], RW_LB, default = 4'b0000 
       Same as field [6:0] for Bank-Addr
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRWRAP_LO0_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRWRAP_LO1_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250B50)                                                  */
/*       SKX (0x40250B50)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRWRAP_LO1_MC_MAIN_REG 0x07004B50
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence Wrap Address -
 * CPGC#_CH#_SEQ_BASE_ADDR_WRAP defines the wrap base address of the sequence.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_addr : 18;
    /* column_addr - Bits[20:3], RW_LB, default = 18'h0 
       If the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address = 
       CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address then any further request to modify 
       (increment or decrement) the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address 
       immediately causes a Wrap to occur with the following actions: 
       1. CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address must be set equal to the 
       CPGC#_CH#_SEQ_BASE_ADDR_Start.Column_Address: 
       2. If Column_Base_Wrap_Carry_Enable is set bit to 1 a carry increment from the 
       Column Address (order N) will propagate to the N+1 order 
       Address field(s).
       3. If Column_Base_Wrap_Trigger_Enable is set to 1 then an Address Wrap Trigger 
       has occurred which can be used in conjunction with Stop_On_Wrap_Trigger. 
       expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used 
       only for DDRT addresses.  
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_addr : 4;
    /* bank_addr - Bits[27:24], RW_LB, default = 4'b0000 
       Same as field [6:0] for Bank-Addr
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRWRAP_LO1_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRWRAP_LO2_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250B54)                                                  */
/*       SKX (0x40250B54)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRWRAP_LO2_MC_MAIN_REG 0x07004B54
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence Wrap Address -
 * CPGC#_CH#_SEQ_BASE_ADDR_WRAP defines the wrap base address of the sequence.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_addr : 18;
    /* column_addr - Bits[20:3], RW_LB, default = 18'h0 
       If the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address = 
       CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address then any further request to modify 
       (increment or decrement) the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address 
       immediately causes a Wrap to occur with the following actions: 
       1. CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address must be set equal to the 
       CPGC#_CH#_SEQ_BASE_ADDR_Start.Column_Address: 
       2. If Column_Base_Wrap_Carry_Enable is set bit to 1 a carry increment from the 
       Column Address (order N) will propagate to the N+1 order 
       Address field(s).
       3. If Column_Base_Wrap_Trigger_Enable is set to 1 then an Address Wrap Trigger 
       has occurred which can be used in conjunction with Stop_On_Wrap_Trigger. 
       expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used 
       only for DDRT addresses.  
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_addr : 4;
    /* bank_addr - Bits[27:24], RW_LB, default = 4'b0000 
       Same as field [6:0] for Bank-Addr
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRWRAP_LO2_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRWRAP_LO3_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250B58)                                                  */
/*       SKX (0x40250B58)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRWRAP_LO3_MC_MAIN_REG 0x07004B58
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence Wrap Address -
 * CPGC#_CH#_SEQ_BASE_ADDR_WRAP defines the wrap base address of the sequence.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_addr : 18;
    /* column_addr - Bits[20:3], RW_LB, default = 18'h0 
       If the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address = 
       CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address then any further request to modify 
       (increment or decrement) the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address 
       immediately causes a Wrap to occur with the following actions: 
       1. CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address must be set equal to the 
       CPGC#_CH#_SEQ_BASE_ADDR_Start.Column_Address: 
       2. If Column_Base_Wrap_Carry_Enable is set bit to 1 a carry increment from the 
       Column Address (order N) will propagate to the N+1 order 
       Address field(s).
       3. If Column_Base_Wrap_Trigger_Enable is set to 1 then an Address Wrap Trigger 
       has occurred which can be used in conjunction with Stop_On_Wrap_Trigger. 
       expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used 
       only for DDRT addresses.  
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_addr : 4;
    /* bank_addr - Bits[27:24], RW_LB, default = 4'b0000 
       Same as field [6:0] for Bank-Addr
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRWRAP_LO3_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRCURR_LO0_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250B5C)                                                  */
/*       SKX (0x40250B5C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRCURR_LO0_MC_MAIN_REG 0x07004B5C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence Current Base Address -
 * CPGC#_CH#_SEQ_BASE_ADDR_CURRENT defines the current base address of the 
 * sequence. 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_addr : 18;
    /* column_addr - Bits[20:3], RO_V, default = 18'h0 
       Current Column Address. Normally the lowest three column bits are reserved since 
       all transfers are done on a cacheline basis (8 chunks 0-7), 
       but for implementations that address to a sub cacheline then these reserved bits 
       might be used as needed. 
       expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used 
       only for DDRT addresses.  
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_addr : 4;
    /* bank_addr - Bits[27:24], RO_V, default = 4'b0000 
       Current Bank Base Address
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRCURR_LO0_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRCURR_LO1_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250B60)                                                  */
/*       SKX (0x40250B60)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRCURR_LO1_MC_MAIN_REG 0x07004B60
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence Current Base Address -
 * CPGC#_CH#_SEQ_BASE_ADDR_CURRENT defines the current base address of the 
 * sequence. 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_addr : 18;
    /* column_addr - Bits[20:3], RO_V, default = 18'h0 
       Current Column Address. Normally the lowest three column bits are reserved since 
       all transfers are done on a cacheline basis (8 chunks 0-7), 
       but for implementations that address to a sub cacheline then these reserved bits 
       might be used as needed. 
       expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used 
       only for DDRT addresses.  
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_addr : 4;
    /* bank_addr - Bits[27:24], RO_V, default = 4'b0000 
       Current Bank Base Address
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRCURR_LO1_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRCURR_LO2_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250B64)                                                  */
/*       SKX (0x40250B64)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRCURR_LO2_MC_MAIN_REG 0x07004B64
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence Current Base Address -
 * CPGC#_CH#_SEQ_BASE_ADDR_CURRENT defines the current base address of the 
 * sequence. 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_addr : 18;
    /* column_addr - Bits[20:3], RO_V, default = 18'h0 
       Current Column Address. Normally the lowest three column bits are reserved since 
       all transfers are done on a cacheline basis (8 chunks 0-7), 
       but for implementations that address to a sub cacheline then these reserved bits 
       might be used as needed. 
       expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used 
       only for DDRT addresses.  
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_addr : 4;
    /* bank_addr - Bits[27:24], RO_V, default = 4'b0000 
       Current Bank Base Address
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRCURR_LO2_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRCURR_LO3_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250B68)                                                  */
/*       SKX (0x40250B68)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRCURR_LO3_MC_MAIN_REG 0x07004B68
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence Current Base Address -
 * CPGC#_CH#_SEQ_BASE_ADDR_CURRENT defines the current base address of the 
 * sequence. 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_addr : 18;
    /* column_addr - Bits[20:3], RO_V, default = 18'h0 
       Current Column Address. Normally the lowest three column bits are reserved since 
       all transfers are done on a cacheline basis (8 chunks 0-7), 
       but for implementations that address to a sub cacheline then these reserved bits 
       might be used as needed. 
       expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used 
       only for DDRT addresses.  
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_addr : 4;
    /* bank_addr - Bits[27:24], RO_V, default = 4'b0000 
       Current Bank Base Address
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRCURR_LO3_MC_MAIN_STRUCT;


/* CPGC_SEQ_BAOCIC0_MC_MAIN_REG supported on:                                 */
/*       SKX_A0 (0x40250B6C)                                                  */
/*       SKX (0x40250B6C)                                                     */
/* Register default value:              0xF00000E4                            */
#define CPGC_SEQ_BAOCIC0_MC_MAIN_REG 0x07004B6C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Subsequence Address Ordering, Carry Masking, and Invert Control -
 * CPGC#_CH#_SEQ_BASE_ADDR_ORDER_CARRY_INVERT_CTL defines a series of enables that 
 * related to propagating carry bits for each address field, logic for 
 *         inverting the current Base address, and how the various address fields 
 * will be ordered in the nested loop of LSB to MSB. 
 */
typedef union {
  struct {
    UINT32 column_addr_order : 2;
    /* column_addr_order - Bits[1:0], RW_LB, default = 2'b00 
       Determines the relative ordering of the Column address update logic in the 
       nested for loop in relation to the Rank, Bank, and Row 
       address update logic. Any address fields set to the same order that roll over 
       will cause a distinct carry of 1 to the next higher order 
       address field (multiple simultaneous carries will cause only one increment). All 
       fields can be arbitrarily placed in any order as long 
       as all address order fields are set in a continuous order starting from 0 and 
       may not skip over an order number. 
     */
    UINT32 row_addr_order : 2;
    /* row_addr_order - Bits[3:2], RW_LB, default = 2'b01 
       Same as Column_Addr_Order for Row
     */
    UINT32 bank_addr_order : 2;
    /* bank_addr_order - Bits[5:4], RW_LB, default = 2'b10 
       Same as Column_Addr_Order for Bank
     */
    UINT32 rank_addr_order : 2;
    /* rank_addr_order - Bits[7:6], RW_LB, default = 2'b11 
       Same as Column_Addr_Order for Rank
     */
    UINT32 rsvd_8 : 5;
    /* rsvd_8 - Bits[12:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 addr_inv_rate : 4;
    /* addr_inv_rate - Bits[16:13], RW_LB, default = 4'b0000 
       Address_Update_Rate_Mode dictates whether the Base address inversion logic is 
       based on # of cachelines written and read or by 
       Loopcount (# of sequences perfromed).
       Address_Update_Rate_Mode = 0 means that the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT is 
       inverted based on 2^(Base_Address_Invert_Rate) read and 
       write cacheline transactions.
       Address_Update_Rate_Mode = 1 means that the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT is 
       inverted based on 2^(Base_Address_Invert_Rate) Loops through 
       the Sequence.
     */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_ba_inven : 1;
    /* column_ba_inven - Bits[20:20], RW_LB, default = 1'b0 
       Setting Column_Base_Address_Invert_Enable bit = 1 will cause the 
       CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address to be inverted 
       every time 2^Base_Address_Invert_Rate cachelines are written or read or by 
       Loopcount (see Base_Address_Invert_Rate). 
       One must consider the address update rate when using this field.
       This feature is most often used for Memory array testing.
     */
    UINT32 row_ba_inven : 1;
    /* row_ba_inven - Bits[21:21], RW_LB, default = 1'b0 
       Same as Column_Ba_Inven for Row
     */
    UINT32 bank_ba_inven : 1;
    /* bank_ba_inven - Bits[22:22], RW_LB, default = 1'b0 
       Same as Column_Ba_Inven for Bank
     */
    UINT32 rank_ba_inven : 1;
    /* rank_ba_inven - Bits[23:23], RW_LB, default = 1'b0 
       Same as Column_Ba_Inven for Rank
     */
    UINT32 column_bw_trigen : 1;
    /* column_bw_trigen - Bits[24:24], RW_LB, default = 1'b0 
       If a Base Column Address Wrap occurs (see 
       CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address) and Column_Base_Wrap_Trigger_Enable 
       is set to 1 then an Address Wrap Trigger has occurred which can be used in 
       conjunction with Stop_On_Wrap_Trigger to stop a 
       Subsequence or Sequence.
     */
    UINT32 row_bw_trigen : 1;
    /* row_bw_trigen - Bits[25:25], RW_LB, default = 1'b0 
       Same as Column_Bw_Trigen for Row
     */
    UINT32 bank_bw_trigen : 1;
    /* bank_bw_trigen - Bits[26:26], RW_LB, default = 1'b0 
       Same as Column_Bw_Trigen for Bank
     */
    UINT32 rank_bw_trigen : 1;
    /* rank_bw_trigen - Bits[27:27], RW_LB, default = 1'b0 
       Same as Column_Bw_Trigen for Rank
     */
    UINT32 column_bw_cryen : 1;
    /* column_bw_cryen - Bits[28:28], RW_LB, default = 1'b1 
       If a Base Column Address Wrap occurs (see 
       CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address) and Column_Base_Wrap_Carry_Enable 
       is set to 1 then a carry increment from the Column Address (order N) will 
       propagate to the N+1 order Address field(s) . 
     */
    UINT32 row_bw_cryen : 1;
    /* row_bw_cryen - Bits[29:29], RW_LB, default = 1'b1 
       Same as Column_Bw_Cryen for Row
     */
    UINT32 bank_bw_cryen : 1;
    /* bank_bw_cryen - Bits[30:30], RW_LB, default = 1'b1 
       Same as Column_Bw_Cryen for Bank
     */
    UINT32 rank_bw_cryen : 1;
    /* rank_bw_cryen - Bits[31:31], RW_LB, default = 1'b1 
       Same as Column_Bw_Cryen for Rank
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BAOCIC0_MC_MAIN_STRUCT;


/* CPGC_SEQ_BAOCIC1_MC_MAIN_REG supported on:                                 */
/*       SKX_A0 (0x40250B70)                                                  */
/*       SKX (0x40250B70)                                                     */
/* Register default value:              0xF00000E4                            */
#define CPGC_SEQ_BAOCIC1_MC_MAIN_REG 0x07004B70
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Subsequence Address Ordering, Carry Masking, and Invert Control -
 * CPGC#_CH#_SEQ_BASE_ADDR_ORDER_CARRY_INVERT_CTL defines a series of enables that 
 * related to propagating carry bits for each address field, logic for 
 *         inverting the current Base address, and how the various address fields 
 * will be ordered in the nested loop of LSB to MSB. 
 */
typedef union {
  struct {
    UINT32 column_addr_order : 2;
    /* column_addr_order - Bits[1:0], RW_LB, default = 2'b00 
       Determines the relative ordering of the Column address update logic in the 
       nested for loop in relation to the Rank, Bank, and Row 
       address update logic. Any address fields set to the same order that roll over 
       will cause a distinct carry of 1 to the next higher order 
       address field (multiple simultaneous carries will cause only one increment). All 
       fields can be arbitrarily placed in any order as long 
       as all address order fields are set in a continuous order starting from 0 and 
       may not skip over an order number. 
     */
    UINT32 row_addr_order : 2;
    /* row_addr_order - Bits[3:2], RW_LB, default = 2'b01 
       Same as Column_Addr_Order for Row
     */
    UINT32 bank_addr_order : 2;
    /* bank_addr_order - Bits[5:4], RW_LB, default = 2'b10 
       Same as Column_Addr_Order for Bank
     */
    UINT32 rank_addr_order : 2;
    /* rank_addr_order - Bits[7:6], RW_LB, default = 2'b11 
       Same as Column_Addr_Order for Rank
     */
    UINT32 rsvd_8 : 5;
    /* rsvd_8 - Bits[12:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 addr_inv_rate : 4;
    /* addr_inv_rate - Bits[16:13], RW_LB, default = 4'b0000 
       Address_Update_Rate_Mode dictates whether the Base address inversion logic is 
       based on # of cachelines written and read or by 
       Loopcount (# of sequences perfromed).
       Address_Update_Rate_Mode = 0 means that the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT is 
       inverted based on 2^(Base_Address_Invert_Rate) read and 
       write cacheline transactions.
       Address_Update_Rate_Mode = 1 means that the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT is 
       inverted based on 2^(Base_Address_Invert_Rate) Loops through 
       the Sequence.
     */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_ba_inven : 1;
    /* column_ba_inven - Bits[20:20], RW_LB, default = 1'b0 
       Setting Column_Base_Address_Invert_Enable bit = 1 will cause the 
       CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address to be inverted 
       every time 2^Base_Address_Invert_Rate cachelines are written or read or by 
       Loopcount (see Base_Address_Invert_Rate). 
       One must consider the address update rate when using this field.
       This feature is most often used for Memory array testing.
     */
    UINT32 row_ba_inven : 1;
    /* row_ba_inven - Bits[21:21], RW_LB, default = 1'b0 
       Same as Column_Ba_Inven for Row
     */
    UINT32 bank_ba_inven : 1;
    /* bank_ba_inven - Bits[22:22], RW_LB, default = 1'b0 
       Same as Column_Ba_Inven for Bank
     */
    UINT32 rank_ba_inven : 1;
    /* rank_ba_inven - Bits[23:23], RW_LB, default = 1'b0 
       Same as Column_Ba_Inven for Rank
     */
    UINT32 column_bw_trigen : 1;
    /* column_bw_trigen - Bits[24:24], RW_LB, default = 1'b0 
       If a Base Column Address Wrap occurs (see 
       CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address) and Column_Base_Wrap_Trigger_Enable 
       is set to 1 then an Address Wrap Trigger has occurred which can be used in 
       conjunction with Stop_On_Wrap_Trigger to stop a 
       Subsequence or Sequence.
     */
    UINT32 row_bw_trigen : 1;
    /* row_bw_trigen - Bits[25:25], RW_LB, default = 1'b0 
       Same as Column_Bw_Trigen for Row
     */
    UINT32 bank_bw_trigen : 1;
    /* bank_bw_trigen - Bits[26:26], RW_LB, default = 1'b0 
       Same as Column_Bw_Trigen for Bank
     */
    UINT32 rank_bw_trigen : 1;
    /* rank_bw_trigen - Bits[27:27], RW_LB, default = 1'b0 
       Same as Column_Bw_Trigen for Rank
     */
    UINT32 column_bw_cryen : 1;
    /* column_bw_cryen - Bits[28:28], RW_LB, default = 1'b1 
       If a Base Column Address Wrap occurs (see 
       CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address) and Column_Base_Wrap_Carry_Enable 
       is set to 1 then a carry increment from the Column Address (order N) will 
       propagate to the N+1 order Address field(s) . 
     */
    UINT32 row_bw_cryen : 1;
    /* row_bw_cryen - Bits[29:29], RW_LB, default = 1'b1 
       Same as Column_Bw_Cryen for Row
     */
    UINT32 bank_bw_cryen : 1;
    /* bank_bw_cryen - Bits[30:30], RW_LB, default = 1'b1 
       Same as Column_Bw_Cryen for Bank
     */
    UINT32 rank_bw_cryen : 1;
    /* rank_bw_cryen - Bits[31:31], RW_LB, default = 1'b1 
       Same as Column_Bw_Cryen for Rank
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BAOCIC1_MC_MAIN_STRUCT;


/* CPGC_SEQ_BAOCIC2_MC_MAIN_REG supported on:                                 */
/*       SKX_A0 (0x40250B74)                                                  */
/*       SKX (0x40250B74)                                                     */
/* Register default value:              0xF00000E4                            */
#define CPGC_SEQ_BAOCIC2_MC_MAIN_REG 0x07004B74
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Subsequence Address Ordering, Carry Masking, and Invert Control -
 * CPGC#_CH#_SEQ_BASE_ADDR_ORDER_CARRY_INVERT_CTL defines a series of enables that 
 * related to propagating carry bits for each address field, logic for 
 *         inverting the current Base address, and how the various address fields 
 * will be ordered in the nested loop of LSB to MSB. 
 */
typedef union {
  struct {
    UINT32 column_addr_order : 2;
    /* column_addr_order - Bits[1:0], RW_LB, default = 2'b00 
       Determines the relative ordering of the Column address update logic in the 
       nested for loop in relation to the Rank, Bank, and Row 
       address update logic. Any address fields set to the same order that roll over 
       will cause a distinct carry of 1 to the next higher order 
       address field (multiple simultaneous carries will cause only one increment). All 
       fields can be arbitrarily placed in any order as long 
       as all address order fields are set in a continuous order starting from 0 and 
       may not skip over an order number. 
     */
    UINT32 row_addr_order : 2;
    /* row_addr_order - Bits[3:2], RW_LB, default = 2'b01 
       Same as Column_Addr_Order for Row
     */
    UINT32 bank_addr_order : 2;
    /* bank_addr_order - Bits[5:4], RW_LB, default = 2'b10 
       Same as Column_Addr_Order for Bank
     */
    UINT32 rank_addr_order : 2;
    /* rank_addr_order - Bits[7:6], RW_LB, default = 2'b11 
       Same as Column_Addr_Order for Rank
     */
    UINT32 rsvd_8 : 5;
    /* rsvd_8 - Bits[12:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 addr_inv_rate : 4;
    /* addr_inv_rate - Bits[16:13], RW_LB, default = 4'b0000 
       Address_Update_Rate_Mode dictates whether the Base address inversion logic is 
       based on # of cachelines written and read or by 
       Loopcount (# of sequences perfromed).
       Address_Update_Rate_Mode = 0 means that the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT is 
       inverted based on 2^(Base_Address_Invert_Rate) read and 
       write cacheline transactions.
       Address_Update_Rate_Mode = 1 means that the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT is 
       inverted based on 2^(Base_Address_Invert_Rate) Loops through 
       the Sequence.
     */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_ba_inven : 1;
    /* column_ba_inven - Bits[20:20], RW_LB, default = 1'b0 
       Setting Column_Base_Address_Invert_Enable bit = 1 will cause the 
       CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address to be inverted 
       every time 2^Base_Address_Invert_Rate cachelines are written or read or by 
       Loopcount (see Base_Address_Invert_Rate). 
       One must consider the address update rate when using this field.
       This feature is most often used for Memory array testing.
     */
    UINT32 row_ba_inven : 1;
    /* row_ba_inven - Bits[21:21], RW_LB, default = 1'b0 
       Same as Column_Ba_Inven for Row
     */
    UINT32 bank_ba_inven : 1;
    /* bank_ba_inven - Bits[22:22], RW_LB, default = 1'b0 
       Same as Column_Ba_Inven for Bank
     */
    UINT32 rank_ba_inven : 1;
    /* rank_ba_inven - Bits[23:23], RW_LB, default = 1'b0 
       Same as Column_Ba_Inven for Rank
     */
    UINT32 column_bw_trigen : 1;
    /* column_bw_trigen - Bits[24:24], RW_LB, default = 1'b0 
       If a Base Column Address Wrap occurs (see 
       CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address) and Column_Base_Wrap_Trigger_Enable 
       is set to 1 then an Address Wrap Trigger has occurred which can be used in 
       conjunction with Stop_On_Wrap_Trigger to stop a 
       Subsequence or Sequence.
     */
    UINT32 row_bw_trigen : 1;
    /* row_bw_trigen - Bits[25:25], RW_LB, default = 1'b0 
       Same as Column_Bw_Trigen for Row
     */
    UINT32 bank_bw_trigen : 1;
    /* bank_bw_trigen - Bits[26:26], RW_LB, default = 1'b0 
       Same as Column_Bw_Trigen for Bank
     */
    UINT32 rank_bw_trigen : 1;
    /* rank_bw_trigen - Bits[27:27], RW_LB, default = 1'b0 
       Same as Column_Bw_Trigen for Rank
     */
    UINT32 column_bw_cryen : 1;
    /* column_bw_cryen - Bits[28:28], RW_LB, default = 1'b1 
       If a Base Column Address Wrap occurs (see 
       CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address) and Column_Base_Wrap_Carry_Enable 
       is set to 1 then a carry increment from the Column Address (order N) will 
       propagate to the N+1 order Address field(s) . 
     */
    UINT32 row_bw_cryen : 1;
    /* row_bw_cryen - Bits[29:29], RW_LB, default = 1'b1 
       Same as Column_Bw_Cryen for Row
     */
    UINT32 bank_bw_cryen : 1;
    /* bank_bw_cryen - Bits[30:30], RW_LB, default = 1'b1 
       Same as Column_Bw_Cryen for Bank
     */
    UINT32 rank_bw_cryen : 1;
    /* rank_bw_cryen - Bits[31:31], RW_LB, default = 1'b1 
       Same as Column_Bw_Cryen for Rank
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BAOCIC2_MC_MAIN_STRUCT;


/* CPGC_SEQ_BAOCIC3_MC_MAIN_REG supported on:                                 */
/*       SKX_A0 (0x40250B78)                                                  */
/*       SKX (0x40250B78)                                                     */
/* Register default value:              0xF00000E4                            */
#define CPGC_SEQ_BAOCIC3_MC_MAIN_REG 0x07004B78
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Subsequence Address Ordering, Carry Masking, and Invert Control -
 * CPGC#_CH#_SEQ_BASE_ADDR_ORDER_CARRY_INVERT_CTL defines a series of enables that 
 * related to propagating carry bits for each address field, logic for 
 *         inverting the current Base address, and how the various address fields 
 * will be ordered in the nested loop of LSB to MSB. 
 */
typedef union {
  struct {
    UINT32 column_addr_order : 2;
    /* column_addr_order - Bits[1:0], RW_LB, default = 2'b00 
       Determines the relative ordering of the Column address update logic in the 
       nested for loop in relation to the Rank, Bank, and Row 
       address update logic. Any address fields set to the same order that roll over 
       will cause a distinct carry of 1 to the next higher order 
       address field (multiple simultaneous carries will cause only one increment). All 
       fields can be arbitrarily placed in any order as long 
       as all address order fields are set in a continuous order starting from 0 and 
       may not skip over an order number. 
     */
    UINT32 row_addr_order : 2;
    /* row_addr_order - Bits[3:2], RW_LB, default = 2'b01 
       Same as Column_Addr_Order for Row
     */
    UINT32 bank_addr_order : 2;
    /* bank_addr_order - Bits[5:4], RW_LB, default = 2'b10 
       Same as Column_Addr_Order for Bank
     */
    UINT32 rank_addr_order : 2;
    /* rank_addr_order - Bits[7:6], RW_LB, default = 2'b11 
       Same as Column_Addr_Order for Rank
     */
    UINT32 rsvd_8 : 5;
    /* rsvd_8 - Bits[12:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 addr_inv_rate : 4;
    /* addr_inv_rate - Bits[16:13], RW_LB, default = 4'b0000 
       Address_Update_Rate_Mode dictates whether the Base address inversion logic is 
       based on # of cachelines written and read or by 
       Loopcount (# of sequences perfromed).
       Address_Update_Rate_Mode = 0 means that the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT is 
       inverted based on 2^(Base_Address_Invert_Rate) read and 
       write cacheline transactions.
       Address_Update_Rate_Mode = 1 means that the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT is 
       inverted based on 2^(Base_Address_Invert_Rate) Loops through 
       the Sequence.
     */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_ba_inven : 1;
    /* column_ba_inven - Bits[20:20], RW_LB, default = 1'b0 
       Setting Column_Base_Address_Invert_Enable bit = 1 will cause the 
       CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address to be inverted 
       every time 2^Base_Address_Invert_Rate cachelines are written or read or by 
       Loopcount (see Base_Address_Invert_Rate). 
       One must consider the address update rate when using this field.
       This feature is most often used for Memory array testing.
     */
    UINT32 row_ba_inven : 1;
    /* row_ba_inven - Bits[21:21], RW_LB, default = 1'b0 
       Same as Column_Ba_Inven for Row
     */
    UINT32 bank_ba_inven : 1;
    /* bank_ba_inven - Bits[22:22], RW_LB, default = 1'b0 
       Same as Column_Ba_Inven for Bank
     */
    UINT32 rank_ba_inven : 1;
    /* rank_ba_inven - Bits[23:23], RW_LB, default = 1'b0 
       Same as Column_Ba_Inven for Rank
     */
    UINT32 column_bw_trigen : 1;
    /* column_bw_trigen - Bits[24:24], RW_LB, default = 1'b0 
       If a Base Column Address Wrap occurs (see 
       CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address) and Column_Base_Wrap_Trigger_Enable 
       is set to 1 then an Address Wrap Trigger has occurred which can be used in 
       conjunction with Stop_On_Wrap_Trigger to stop a 
       Subsequence or Sequence.
     */
    UINT32 row_bw_trigen : 1;
    /* row_bw_trigen - Bits[25:25], RW_LB, default = 1'b0 
       Same as Column_Bw_Trigen for Row
     */
    UINT32 bank_bw_trigen : 1;
    /* bank_bw_trigen - Bits[26:26], RW_LB, default = 1'b0 
       Same as Column_Bw_Trigen for Bank
     */
    UINT32 rank_bw_trigen : 1;
    /* rank_bw_trigen - Bits[27:27], RW_LB, default = 1'b0 
       Same as Column_Bw_Trigen for Rank
     */
    UINT32 column_bw_cryen : 1;
    /* column_bw_cryen - Bits[28:28], RW_LB, default = 1'b1 
       If a Base Column Address Wrap occurs (see 
       CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address) and Column_Base_Wrap_Carry_Enable 
       is set to 1 then a carry increment from the Column Address (order N) will 
       propagate to the N+1 order Address field(s) . 
     */
    UINT32 row_bw_cryen : 1;
    /* row_bw_cryen - Bits[29:29], RW_LB, default = 1'b1 
       Same as Column_Bw_Cryen for Row
     */
    UINT32 bank_bw_cryen : 1;
    /* bank_bw_cryen - Bits[30:30], RW_LB, default = 1'b1 
       Same as Column_Bw_Cryen for Bank
     */
    UINT32 rank_bw_cryen : 1;
    /* rank_bw_cryen - Bits[31:31], RW_LB, default = 1'b1 
       Same as Column_Bw_Cryen for Rank
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BAOCIC3_MC_MAIN_STRUCT;


/* CPGC_SEQ_BAINCCTL00_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x40250B7C)                                                  */
/*       SKX (0x40250B7C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BAINCCTL00_MC_MAIN_REG 0x07004B7C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Subsequence Base Address Increment Control -
 * Part0 - CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL defines how the Base address increment 
 * will behave during a sequence. 
 */
typedef union {
  struct {
    UINT32 column_ba_inc : 8;
    /* column_ba_inc - Bits[7:0], RW_LB, default = 8'b00000000 
       When dictated by Column Address Update Rate the current Column Address will be 
       modified by the Column Address Increment 
       (which is a 2's compliment field).
       A value of 0x0 means the Column Address Increment is effectively disabled since 
       no offset will be applied. 
       Disabling the Column Address Increment by setting Column Address Increment to 
       0x0 does not affect a carry from a lower order 
       field rolling over to a higher order field which will also result in an 
       increment to the higher order field of 1. 
     */
    UINT32 column_ba_updrate : 5;
    /* column_ba_updrate - Bits[12:8], RW_LB, default = 5'b00000 
       In linear mode (see Column_Address_Update_Rate_Scale setting), this field +1 
       defines how many times a specific Column address is repeated 
       before adding the Column_Base_Address_Increment.
       In exponential mode, 2^(value in this field) defines how many times a specific 
       Rank address is repeated before adding the 
       Column_Base_Address_Increment.
       CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode dictates whether the address 
       increment logic is driven by either the # of cachelines written and 
       read or by Loopcount (# of sequences performed).
     */
    UINT32 column_ba_updscale : 1;
    /* column_ba_updscale - Bits[13:13], RW_LB, default = 1'b0 
       1= Column Address Update Rate is a linear number, 0 = Column Address Update Rate 
       is an exponential number 
     */
    UINT32 row_ba_inc : 12;
    /* row_ba_inc - Bits[25:14], RW_LB, default = 12'b000000000000 
       Same as Column_Ba_Inc for Row
     */
    UINT32 row_ba_updrate : 5;
    /* row_ba_updrate - Bits[30:26], RW_LB, default = 5'b00000 
       Same as Column_Ba_Updrate for Row
     */
    UINT32 row_ba_updscale : 1;
    /* row_ba_updscale - Bits[31:31], RW_LB, default = 1'b0 
       Same as Column_Ba_Updscale for Row
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BAINCCTL00_MC_MAIN_STRUCT;


/* CPGC_SEQ_BAINCCTL10_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x40250B80)                                                  */
/*       SKX (0x40250B80)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BAINCCTL10_MC_MAIN_REG 0x07004B80
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Subsequence Base Address Increment Control -
 * Part1 - CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL defines how the Base address increment 
 * will behave during a sequence. 
 */
typedef union {
  struct {
    UINT32 bank_ba_inc : 4;
    /* bank_ba_inc - Bits[3:0], RW_LB, default = 4'b0000 
       Same as Column_Ba_Inc for Bank
     */
    UINT32 bank_ba_updrate : 5;
    /* bank_ba_updrate - Bits[8:4], RW_LB, default = 5'b00000 
       Same as Column_Ba_Updrate for Bank
     */
    UINT32 bank_ba_updscale : 1;
    /* bank_ba_updscale - Bits[9:9], RW_LB, default = 1'b0 
       Same as Column_Ba_Updscale for Bank
     */
    UINT32 rank_ba_inc : 3;
    /* rank_ba_inc - Bits[12:10], RW_LB, default = 3'b000 
       Same as Column_Ba_Inc for Rank
     */
    UINT32 rank_ba_updrate : 5;
    /* rank_ba_updrate - Bits[17:13], RW_LB, default = 5'b00000 
       Same as Column_Ba_Updrate for Rank
     */
    UINT32 rank_ba_updscale : 1;
    /* rank_ba_updscale - Bits[18:18], RW_LB, default = 1'b0 
       Same as Column_Ba_Updscale for Rank
     */
    UINT32 column_ba_inc_msb : 10;
    /* column_ba_inc_msb - Bits[28:19], RW_LB, default = 10'h0 
       MSB of CPGC_SEQ_BAINCCTL00. Bits 28:21 should be 0 for DDR4 and should be 
       programmed only for DDRT training  
     */
    UINT32 rsvd : 3;
    /* rsvd - Bits[31:29], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BAINCCTL10_MC_MAIN_STRUCT;


/* CPGC_SEQ_BAINCCTL01_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x40250B84)                                                  */
/*       SKX (0x40250B84)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BAINCCTL01_MC_MAIN_REG 0x07004B84
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Subsequence Base Address Increment Control -
 * Part0 - CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL defines how the Base address increment 
 * will behave during a sequence. 
 */
typedef union {
  struct {
    UINT32 column_ba_inc : 8;
    /* column_ba_inc - Bits[7:0], RW_LB, default = 8'b00000000 
       When dictated by Column Address Update Rate the current Column Address will be 
       modified by the Column Address Increment 
       (which is a 2's compliment field).
       A value of 0x0 means the Column Address Increment is effectively disabled since 
       no offset will be applied. 
       Disabling the Column Address Increment by setting Column Address Increment to 
       0x0 does not affect a carry from a lower order 
       field rolling over to a higher order field which will also result in an 
       increment to the higher order field of 1. 
     */
    UINT32 column_ba_updrate : 5;
    /* column_ba_updrate - Bits[12:8], RW_LB, default = 5'b00000 
       In linear mode (see Column_Address_Update_Rate_Scale setting), this field +1 
       defines how many times a specific Column address is repeated 
       before adding the Column_Base_Address_Increment.
       In exponential mode, 2^(value in this field) defines how many times a specific 
       Rank address is repeated before adding the 
       Column_Base_Address_Increment.
       CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode dictates whether the address 
       increment logic is driven by either the # of cachelines written and 
       read or by Loopcount (# of sequences performed).
     */
    UINT32 column_ba_updscale : 1;
    /* column_ba_updscale - Bits[13:13], RW_LB, default = 1'b0 
       1= Column Address Update Rate is a linear number, 0 = Column Address Update Rate 
       is an exponential number 
     */
    UINT32 row_ba_inc : 12;
    /* row_ba_inc - Bits[25:14], RW_LB, default = 12'b000000000000 
       Same as Column_Ba_Inc for Row
     */
    UINT32 row_ba_updrate : 5;
    /* row_ba_updrate - Bits[30:26], RW_LB, default = 5'b00000 
       Same as Column_Ba_Updrate for Row
     */
    UINT32 row_ba_updscale : 1;
    /* row_ba_updscale - Bits[31:31], RW_LB, default = 1'b0 
       Same as Column_Ba_Updscale for Row
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BAINCCTL01_MC_MAIN_STRUCT;


/* CPGC_SEQ_BAINCCTL11_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x40250B88)                                                  */
/*       SKX (0x40250B88)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BAINCCTL11_MC_MAIN_REG 0x07004B88
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Subsequence Base Address Increment Control -
 * Part1 - CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL defines how the Base address increment 
 * will behave during a sequence. 
 */
typedef union {
  struct {
    UINT32 bank_ba_inc : 4;
    /* bank_ba_inc - Bits[3:0], RW_LB, default = 4'b0000 
       Same as Column_Ba_Inc for Bank
     */
    UINT32 bank_ba_updrate : 5;
    /* bank_ba_updrate - Bits[8:4], RW_LB, default = 5'b00000 
       Same as Column_Ba_Updrate for Bank
     */
    UINT32 bank_ba_updscale : 1;
    /* bank_ba_updscale - Bits[9:9], RW_LB, default = 1'b0 
       Same as Column_Ba_Updscale for Bank
     */
    UINT32 rank_ba_inc : 3;
    /* rank_ba_inc - Bits[12:10], RW_LB, default = 3'b000 
       Same as Column_Ba_Inc for Rank
     */
    UINT32 rank_ba_updrate : 5;
    /* rank_ba_updrate - Bits[17:13], RW_LB, default = 5'b00000 
       Same as Column_Ba_Updrate for Rank
     */
    UINT32 rank_ba_updscale : 1;
    /* rank_ba_updscale - Bits[18:18], RW_LB, default = 1'b0 
       Same as Column_Ba_Updscale for Rank
     */
    UINT32 column_ba_inc_msb : 10;
    /* column_ba_inc_msb - Bits[28:19], RW_LB, default = 10'h0 
       MSB of CPGC_SEQ_BAINCCTL00. Bits 28:21 should be 0 for DDR4 and should be 
       programmed only for DDRT training  
     */
    UINT32 rsvd : 3;
    /* rsvd - Bits[31:29], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BAINCCTL11_MC_MAIN_STRUCT;


/* CPGC_SEQ_BAINCCTL02_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x40250B8C)                                                  */
/*       SKX (0x40250B8C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BAINCCTL02_MC_MAIN_REG 0x07004B8C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Subsequence Base Address Increment Control -
 * Part0 - CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL defines how the Base address increment 
 * will behave during a sequence. 
 */
typedef union {
  struct {
    UINT32 column_ba_inc : 8;
    /* column_ba_inc - Bits[7:0], RW_LB, default = 8'b00000000 
       When dictated by Column Address Update Rate the current Column Address will be 
       modified by the Column Address Increment 
       (which is a 2's compliment field).
       A value of 0x0 means the Column Address Increment is effectively disabled since 
       no offset will be applied. 
       Disabling the Column Address Increment by setting Column Address Increment to 
       0x0 does not affect a carry from a lower order 
       field rolling over to a higher order field which will also result in an 
       increment to the higher order field of 1. 
     */
    UINT32 column_ba_updrate : 5;
    /* column_ba_updrate - Bits[12:8], RW_LB, default = 5'b00000 
       In linear mode (see Column_Address_Update_Rate_Scale setting), this field +1 
       defines how many times a specific Column address is repeated 
       before adding the Column_Base_Address_Increment.
       In exponential mode, 2^(value in this field) defines how many times a specific 
       Rank address is repeated before adding the 
       Column_Base_Address_Increment.
       CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode dictates whether the address 
       increment logic is driven by either the # of cachelines written and 
       read or by Loopcount (# of sequences performed).
     */
    UINT32 column_ba_updscale : 1;
    /* column_ba_updscale - Bits[13:13], RW_LB, default = 1'b0 
       1= Column Address Update Rate is a linear number, 0 = Column Address Update Rate 
       is an exponential number 
     */
    UINT32 row_ba_inc : 12;
    /* row_ba_inc - Bits[25:14], RW_LB, default = 12'b000000000000 
       Same as Column_Ba_Inc for Row
     */
    UINT32 row_ba_updrate : 5;
    /* row_ba_updrate - Bits[30:26], RW_LB, default = 5'b00000 
       Same as Column_Ba_Updrate for Row
     */
    UINT32 row_ba_updscale : 1;
    /* row_ba_updscale - Bits[31:31], RW_LB, default = 1'b0 
       Same as Column_Ba_Updscale for Row
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BAINCCTL02_MC_MAIN_STRUCT;


/* CPGC_SEQ_BAINCCTL12_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x40250B90)                                                  */
/*       SKX (0x40250B90)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BAINCCTL12_MC_MAIN_REG 0x07004B90
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Subsequence Base Address Increment Control -
 * Part1 - CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL defines how the Base address increment 
 * will behave during a sequence. 
 */
typedef union {
  struct {
    UINT32 bank_ba_inc : 4;
    /* bank_ba_inc - Bits[3:0], RW_LB, default = 4'b0000 
       Same as Column_Ba_Inc for Bank
     */
    UINT32 bank_ba_updrate : 5;
    /* bank_ba_updrate - Bits[8:4], RW_LB, default = 5'b00000 
       Same as Column_Ba_Updrate for Bank
     */
    UINT32 bank_ba_updscale : 1;
    /* bank_ba_updscale - Bits[9:9], RW_LB, default = 1'b0 
       Same as Column_Ba_Updscale for Bank
     */
    UINT32 rank_ba_inc : 3;
    /* rank_ba_inc - Bits[12:10], RW_LB, default = 3'b000 
       Same as Column_Ba_Inc for Rank
     */
    UINT32 rank_ba_updrate : 5;
    /* rank_ba_updrate - Bits[17:13], RW_LB, default = 5'b00000 
       Same as Column_Ba_Updrate for Rank
     */
    UINT32 rank_ba_updscale : 1;
    /* rank_ba_updscale - Bits[18:18], RW_LB, default = 1'b0 
       Same as Column_Ba_Updscale for Rank
     */
    UINT32 column_ba_inc_msb : 10;
    /* column_ba_inc_msb - Bits[28:19], RW_LB, default = 10'h0 
       MSB of CPGC_SEQ_BAINCCTL00. Bits 28:21 should be 0 for DDR4 and should be 
       programmed only for DDRT training  
     */
    UINT32 rsvd : 3;
    /* rsvd - Bits[31:29], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BAINCCTL12_MC_MAIN_STRUCT;


/* CPGC_SEQ_BAINCCTL03_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x40250B94)                                                  */
/*       SKX (0x40250B94)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BAINCCTL03_MC_MAIN_REG 0x07004B94
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Subsequence Base Address Increment Control -
 * Part0 - CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL defines how the Base address increment 
 * will behave during a sequence. 
 */
typedef union {
  struct {
    UINT32 column_ba_inc : 8;
    /* column_ba_inc - Bits[7:0], RW_LB, default = 8'b00000000 
       When dictated by Column Address Update Rate the current Column Address will be 
       modified by the Column Address Increment 
       (which is a 2's compliment field).
       A value of 0x0 means the Column Address Increment is effectively disabled since 
       no offset will be applied. 
       Disabling the Column Address Increment by setting Column Address Increment to 
       0x0 does not affect a carry from a lower order 
       field rolling over to a higher order field which will also result in an 
       increment to the higher order field of 1. 
     */
    UINT32 column_ba_updrate : 5;
    /* column_ba_updrate - Bits[12:8], RW_LB, default = 5'b00000 
       In linear mode (see Column_Address_Update_Rate_Scale setting), this field +1 
       defines how many times a specific Column address is repeated 
       before adding the Column_Base_Address_Increment.
       In exponential mode, 2^(value in this field) defines how many times a specific 
       Rank address is repeated before adding the 
       Column_Base_Address_Increment.
       CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode dictates whether the address 
       increment logic is driven by either the # of cachelines written and 
       read or by Loopcount (# of sequences performed).
     */
    UINT32 column_ba_updscale : 1;
    /* column_ba_updscale - Bits[13:13], RW_LB, default = 1'b0 
       1= Column Address Update Rate is a linear number, 0 = Column Address Update Rate 
       is an exponential number 
     */
    UINT32 row_ba_inc : 12;
    /* row_ba_inc - Bits[25:14], RW_LB, default = 12'b000000000000 
       Same as Column_Ba_Inc for Row
     */
    UINT32 row_ba_updrate : 5;
    /* row_ba_updrate - Bits[30:26], RW_LB, default = 5'b00000 
       Same as Column_Ba_Updrate for Row
     */
    UINT32 row_ba_updscale : 1;
    /* row_ba_updscale - Bits[31:31], RW_LB, default = 1'b0 
       Same as Column_Ba_Updscale for Row
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BAINCCTL03_MC_MAIN_STRUCT;


/* CPGC_SEQ_BAINCCTL13_MC_MAIN_REG supported on:                              */
/*       SKX_A0 (0x40250B98)                                                  */
/*       SKX (0x40250B98)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BAINCCTL13_MC_MAIN_REG 0x07004B98
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Subsequence Base Address Increment Control -
 * Part1 - CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL defines how the Base address increment 
 * will behave during a sequence. 
 */
typedef union {
  struct {
    UINT32 bank_ba_inc : 4;
    /* bank_ba_inc - Bits[3:0], RW_LB, default = 4'b0000 
       Same as Column_Ba_Inc for Bank
     */
    UINT32 bank_ba_updrate : 5;
    /* bank_ba_updrate - Bits[8:4], RW_LB, default = 5'b00000 
       Same as Column_Ba_Updrate for Bank
     */
    UINT32 bank_ba_updscale : 1;
    /* bank_ba_updscale - Bits[9:9], RW_LB, default = 1'b0 
       Same as Column_Ba_Updscale for Bank
     */
    UINT32 rank_ba_inc : 3;
    /* rank_ba_inc - Bits[12:10], RW_LB, default = 3'b000 
       Same as Column_Ba_Inc for Rank
     */
    UINT32 rank_ba_updrate : 5;
    /* rank_ba_updrate - Bits[17:13], RW_LB, default = 5'b00000 
       Same as Column_Ba_Updrate for Rank
     */
    UINT32 rank_ba_updscale : 1;
    /* rank_ba_updscale - Bits[18:18], RW_LB, default = 1'b0 
       Same as Column_Ba_Updscale for Rank
     */
    UINT32 column_ba_inc_msb : 10;
    /* column_ba_inc_msb - Bits[28:19], RW_LB, default = 10'h0 
       MSB of CPGC_SEQ_BAINCCTL00. Bits 28:21 should be 0 for DDR4 and should be 
       programmed only for DDRT training  
     */
    UINT32 rsvd : 3;
    /* rsvd - Bits[31:29], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BAINCCTL13_MC_MAIN_STRUCT;


/* CPGC_SEQ_OFFADDRCUR0_MC_MAIN_REG supported on:                             */
/*       SKX_A0 (0x40250B9C)                                                  */
/*       SKX (0x40250B9C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_OFFADDRCUR0_MC_MAIN_REG 0x07004B9C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Subsequence Offset Address -
 * Only Row and Column bits are used in an Offset Sequence Type 
 * (CPGC#_CH#_SUBSEQ#_CTL.subsequence_type = (0x0100 or 0x0101)) and thus the 
 *         Rank and Bank address will always be equal to and Row and Column address 
 * will never be equal to their respective fields in 
 * CPGC_CH#_SEQ_BASE_ADDR_CURRENT. 
 */
typedef union {
  struct {
    UINT32 col_addr : 18;
    /* col_addr - Bits[17:0], RO_V, default = 10'b0000000000 
       Current Column Offset Address. Normally, the lowest three column bits are 
       reserved since all transfers are done on a 
       cacheline basis (8 chunks 0-7), but for implementations that address to a sub 
       cacheline then these reserved bits might be used as needed. 
       expanded to 10 bits (cpgcbl4 support+14bit column ddr3)
     */
    UINT32 rsvd : 14;
    /* rsvd - Bits[31:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_OFFADDRCUR0_MC_MAIN_STRUCT;


/* CPGC_SEQ_OFFADDRCUR1_MC_MAIN_REG supported on:                             */
/*       SKX_A0 (0x40250BA0)                                                  */
/*       SKX (0x40250BA0)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_OFFADDRCUR1_MC_MAIN_REG 0x07004BA0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Subsequence Offset Address -
 * Only Row and Column bits are used in an Offset Sequence Type 
 * (CPGC#_CH#_SUBSEQ#_CTL.subsequence_type = (0x0100 or 0x0101)) and thus the 
 *         Rank and Bank address will always be equal to and Row and Column address 
 * will never be equal to their respective fields in 
 * CPGC_CH#_SEQ_BASE_ADDR_CURRENT. 
 */
typedef union {
  struct {
    UINT32 col_addr : 18;
    /* col_addr - Bits[17:0], RO_V, default = 10'b0000000000 
       Current Column Offset Address. Normally, the lowest three column bits are 
       reserved since all transfers are done on a 
       cacheline basis (8 chunks 0-7), but for implementations that address to a sub 
       cacheline then these reserved bits might be used as needed. 
       expanded to 10 bits (cpgcbl4 support+14bit column ddr3)
     */
    UINT32 rsvd : 14;
    /* rsvd - Bits[31:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_OFFADDRCUR1_MC_MAIN_STRUCT;


/* CPGC_SEQ_OFFADDRCUR2_MC_MAIN_REG supported on:                             */
/*       SKX_A0 (0x40250BA4)                                                  */
/*       SKX (0x40250BA4)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_OFFADDRCUR2_MC_MAIN_REG 0x07004BA4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Subsequence Offset Address -
 * Only Row and Column bits are used in an Offset Sequence Type 
 * (CPGC#_CH#_SUBSEQ#_CTL.subsequence_type = (0x0100 or 0x0101)) and thus the 
 *         Rank and Bank address will always be equal to and Row and Column address 
 * will never be equal to their respective fields in 
 * CPGC_CH#_SEQ_BASE_ADDR_CURRENT. 
 */
typedef union {
  struct {
    UINT32 col_addr : 18;
    /* col_addr - Bits[17:0], RO_V, default = 10'b0000000000 
       Current Column Offset Address. Normally, the lowest three column bits are 
       reserved since all transfers are done on a 
       cacheline basis (8 chunks 0-7), but for implementations that address to a sub 
       cacheline then these reserved bits might be used as needed. 
       expanded to 10 bits (cpgcbl4 support+14bit column ddr3)
     */
    UINT32 rsvd : 14;
    /* rsvd - Bits[31:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_OFFADDRCUR2_MC_MAIN_STRUCT;


/* CPGC_SEQ_OFFADDRCUR3_MC_MAIN_REG supported on:                             */
/*       SKX_A0 (0x40250BA8)                                                  */
/*       SKX (0x40250BA8)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_OFFADDRCUR3_MC_MAIN_REG 0x07004BA8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Subsequence Offset Address -
 * Only Row and Column bits are used in an Offset Sequence Type 
 * (CPGC#_CH#_SUBSEQ#_CTL.subsequence_type = (0x0100 or 0x0101)) and thus the 
 *         Rank and Bank address will always be equal to and Row and Column address 
 * will never be equal to their respective fields in 
 * CPGC_CH#_SEQ_BASE_ADDR_CURRENT. 
 */
typedef union {
  struct {
    UINT32 col_addr : 18;
    /* col_addr - Bits[17:0], RO_V, default = 10'b0000000000 
       Current Column Offset Address. Normally, the lowest three column bits are 
       reserved since all transfers are done on a 
       cacheline basis (8 chunks 0-7), but for implementations that address to a sub 
       cacheline then these reserved bits might be used as needed. 
       expanded to 10 bits (cpgcbl4 support+14bit column ddr3)
     */
    UINT32 rsvd : 14;
    /* rsvd - Bits[31:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_OFFADDRCUR3_MC_MAIN_STRUCT;


/* CPGC_SEQ_RANKLG2PHYMAP0_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250BAC)                                                  */
/*       SKX (0x40250BAC)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_RANKLG2PHYMAP0_MC_MAIN_REG 0x07004BAC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Subsequence Logical to Physical Rank Lookup Table -
 * CPGC#_CH#_SEQ_RANK_LOGICAL_TO_PHYSICAL_MAPPING is used to program the Logical to 
 * Physical Rank Mapping. 
 * The internal hardware is always is in the world of the Logical Ranks starting 
 * from Logical_to_Physical_Rank0_Mapping and will 
 *         linearly increment through the Logical Ranks up to the maximum value 
 * (defined by CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Rank_Address) 
 * The user must define what Physical Ranks are associated with each Logical Rank, 
 * and that only valid physical ranks are programmed into this register. 
 */
typedef union {
  struct {
    UINT32 rank0_mapping : 3;
    /* rank0_mapping - Bits[2:0], RW_LB, default = 3'b000 
       Defines what Physical Rank Address (Memory controller Rank Mapping) is mapped to 
       this logical Rank Address-0 
       (Sequence Address logic doamin).
       It is possible to use more Logical_to_Physical_Rank#_Mapping fileds than actual 
       Physical Ranks which is useful for more complex 
       tests where non linear Physical Rank Sequences are needed.
     */
    UINT32 rsvd_3 : 1;
    /* rsvd_3 - Bits[3:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank1_mapping : 3;
    /* rank1_mapping - Bits[6:4], RW_LB, default = 3'b000 
       Rank Address-1 mapping
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank2_mapping : 3;
    /* rank2_mapping - Bits[10:8], RW_LB, default = 3'b000 
       Rank Address-2 mapping
     */
    UINT32 rsvd_11 : 1;
    /* rsvd_11 - Bits[11:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank3_mapping : 3;
    /* rank3_mapping - Bits[14:12], RW_LB, default = 3'b000 
       Rank Address-3 mapping
     */
    UINT32 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank4_mapping : 3;
    /* rank4_mapping - Bits[18:16], RW_LB, default = 3'b000 
       Rank Address-4 mapping
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank5_mapping : 3;
    /* rank5_mapping - Bits[22:20], RW_LB, default = 3'b000 
       Rank Address-5 mapping
     */
    UINT32 rsvd_23 : 1;
    /* rsvd_23 - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank6_mapping : 3;
    /* rank6_mapping - Bits[26:24], RW_LB, default = 3'b000 
       Rank Address-6 mapping
     */
    UINT32 rsvd_27 : 1;
    /* rsvd_27 - Bits[27:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank7_mapping : 3;
    /* rank7_mapping - Bits[30:28], RW_LB, default = 3'b000 
       Rank Address-7 mapping
     */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_RANKLG2PHYMAP0_MC_MAIN_STRUCT;


/* CPGC_SEQ_RANKLG2PHYMAP1_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250BB0)                                                  */
/*       SKX (0x40250BB0)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_RANKLG2PHYMAP1_MC_MAIN_REG 0x07004BB0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Subsequence Logical to Physical Rank Lookup Table -
 * CPGC#_CH#_SEQ_RANK_LOGICAL_TO_PHYSICAL_MAPPING is used to program the Logical to 
 * Physical Rank Mapping. 
 * The internal hardware is always is in the world of the Logical Ranks starting 
 * from Logical_to_Physical_Rank0_Mapping and will 
 *         linearly increment through the Logical Ranks up to the maximum value 
 * (defined by CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Rank_Address) 
 * The user must define what Physical Ranks are associated with each Logical Rank, 
 * and that only valid physical ranks are programmed into this register. 
 */
typedef union {
  struct {
    UINT32 rank0_mapping : 3;
    /* rank0_mapping - Bits[2:0], RW_LB, default = 3'b000 
       Defines what Physical Rank Address (Memory controller Rank Mapping) is mapped to 
       this logical Rank Address-0 
       (Sequence Address logic doamin).
       It is possible to use more Logical_to_Physical_Rank#_Mapping fileds than actual 
       Physical Ranks which is useful for more complex 
       tests where non linear Physical Rank Sequences are needed.
     */
    UINT32 rsvd_3 : 1;
    /* rsvd_3 - Bits[3:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank1_mapping : 3;
    /* rank1_mapping - Bits[6:4], RW_LB, default = 3'b000 
       Rank Address-1 mapping
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank2_mapping : 3;
    /* rank2_mapping - Bits[10:8], RW_LB, default = 3'b000 
       Rank Address-2 mapping
     */
    UINT32 rsvd_11 : 1;
    /* rsvd_11 - Bits[11:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank3_mapping : 3;
    /* rank3_mapping - Bits[14:12], RW_LB, default = 3'b000 
       Rank Address-3 mapping
     */
    UINT32 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank4_mapping : 3;
    /* rank4_mapping - Bits[18:16], RW_LB, default = 3'b000 
       Rank Address-4 mapping
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank5_mapping : 3;
    /* rank5_mapping - Bits[22:20], RW_LB, default = 3'b000 
       Rank Address-5 mapping
     */
    UINT32 rsvd_23 : 1;
    /* rsvd_23 - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank6_mapping : 3;
    /* rank6_mapping - Bits[26:24], RW_LB, default = 3'b000 
       Rank Address-6 mapping
     */
    UINT32 rsvd_27 : 1;
    /* rsvd_27 - Bits[27:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank7_mapping : 3;
    /* rank7_mapping - Bits[30:28], RW_LB, default = 3'b000 
       Rank Address-7 mapping
     */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_RANKLG2PHYMAP1_MC_MAIN_STRUCT;


/* CPGC_SEQ_RANKLG2PHYMAP2_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250BB4)                                                  */
/*       SKX (0x40250BB4)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_RANKLG2PHYMAP2_MC_MAIN_REG 0x07004BB4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Subsequence Logical to Physical Rank Lookup Table -
 * CPGC#_CH#_SEQ_RANK_LOGICAL_TO_PHYSICAL_MAPPING is used to program the Logical to 
 * Physical Rank Mapping. 
 * The internal hardware is always is in the world of the Logical Ranks starting 
 * from Logical_to_Physical_Rank0_Mapping and will 
 *         linearly increment through the Logical Ranks up to the maximum value 
 * (defined by CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Rank_Address) 
 * The user must define what Physical Ranks are associated with each Logical Rank, 
 * and that only valid physical ranks are programmed into this register. 
 */
typedef union {
  struct {
    UINT32 rank0_mapping : 3;
    /* rank0_mapping - Bits[2:0], RW_LB, default = 3'b000 
       Defines what Physical Rank Address (Memory controller Rank Mapping) is mapped to 
       this logical Rank Address-0 
       (Sequence Address logic doamin).
       It is possible to use more Logical_to_Physical_Rank#_Mapping fileds than actual 
       Physical Ranks which is useful for more complex 
       tests where non linear Physical Rank Sequences are needed.
     */
    UINT32 rsvd_3 : 1;
    /* rsvd_3 - Bits[3:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank1_mapping : 3;
    /* rank1_mapping - Bits[6:4], RW_LB, default = 3'b000 
       Rank Address-1 mapping
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank2_mapping : 3;
    /* rank2_mapping - Bits[10:8], RW_LB, default = 3'b000 
       Rank Address-2 mapping
     */
    UINT32 rsvd_11 : 1;
    /* rsvd_11 - Bits[11:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank3_mapping : 3;
    /* rank3_mapping - Bits[14:12], RW_LB, default = 3'b000 
       Rank Address-3 mapping
     */
    UINT32 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank4_mapping : 3;
    /* rank4_mapping - Bits[18:16], RW_LB, default = 3'b000 
       Rank Address-4 mapping
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank5_mapping : 3;
    /* rank5_mapping - Bits[22:20], RW_LB, default = 3'b000 
       Rank Address-5 mapping
     */
    UINT32 rsvd_23 : 1;
    /* rsvd_23 - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank6_mapping : 3;
    /* rank6_mapping - Bits[26:24], RW_LB, default = 3'b000 
       Rank Address-6 mapping
     */
    UINT32 rsvd_27 : 1;
    /* rsvd_27 - Bits[27:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank7_mapping : 3;
    /* rank7_mapping - Bits[30:28], RW_LB, default = 3'b000 
       Rank Address-7 mapping
     */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_RANKLG2PHYMAP2_MC_MAIN_STRUCT;


/* CPGC_SEQ_RANKLG2PHYMAP3_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250BB8)                                                  */
/*       SKX (0x40250BB8)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_RANKLG2PHYMAP3_MC_MAIN_REG 0x07004BB8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Subsequence Logical to Physical Rank Lookup Table -
 * CPGC#_CH#_SEQ_RANK_LOGICAL_TO_PHYSICAL_MAPPING is used to program the Logical to 
 * Physical Rank Mapping. 
 * The internal hardware is always is in the world of the Logical Ranks starting 
 * from Logical_to_Physical_Rank0_Mapping and will 
 *         linearly increment through the Logical Ranks up to the maximum value 
 * (defined by CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Rank_Address) 
 * The user must define what Physical Ranks are associated with each Logical Rank, 
 * and that only valid physical ranks are programmed into this register. 
 */
typedef union {
  struct {
    UINT32 rank0_mapping : 3;
    /* rank0_mapping - Bits[2:0], RW_LB, default = 3'b000 
       Defines what Physical Rank Address (Memory controller Rank Mapping) is mapped to 
       this logical Rank Address-0 
       (Sequence Address logic doamin).
       It is possible to use more Logical_to_Physical_Rank#_Mapping fileds than actual 
       Physical Ranks which is useful for more complex 
       tests where non linear Physical Rank Sequences are needed.
     */
    UINT32 rsvd_3 : 1;
    /* rsvd_3 - Bits[3:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank1_mapping : 3;
    /* rank1_mapping - Bits[6:4], RW_LB, default = 3'b000 
       Rank Address-1 mapping
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank2_mapping : 3;
    /* rank2_mapping - Bits[10:8], RW_LB, default = 3'b000 
       Rank Address-2 mapping
     */
    UINT32 rsvd_11 : 1;
    /* rsvd_11 - Bits[11:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank3_mapping : 3;
    /* rank3_mapping - Bits[14:12], RW_LB, default = 3'b000 
       Rank Address-3 mapping
     */
    UINT32 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank4_mapping : 3;
    /* rank4_mapping - Bits[18:16], RW_LB, default = 3'b000 
       Rank Address-4 mapping
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank5_mapping : 3;
    /* rank5_mapping - Bits[22:20], RW_LB, default = 3'b000 
       Rank Address-5 mapping
     */
    UINT32 rsvd_23 : 1;
    /* rsvd_23 - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank6_mapping : 3;
    /* rank6_mapping - Bits[26:24], RW_LB, default = 3'b000 
       Rank Address-6 mapping
     */
    UINT32 rsvd_27 : 1;
    /* rsvd_27 - Bits[27:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank7_mapping : 3;
    /* rank7_mapping - Bits[30:28], RW_LB, default = 3'b000 
       Rank Address-7 mapping
     */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_RANKLG2PHYMAP3_MC_MAIN_STRUCT;


/* CPGC_SEQ_RASL0_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x40250BBC)                                                  */
/*       SKX (0x40250BBC)                                                     */
/* Register default value:              0x0A418820                            */
#define CPGC_SEQ_RASL0_MC_MAIN_REG 0x07004BBC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Subsequence Logical to Physical Row Address Swizzling Lower -
 * This register is used to swizzle the Lower Logial to Physical Row Bits.
 * The Lower bits swizzling is desired when testing of DIMM arrays is the goal and 
 * when the DRAM DUT internally swizles the logical to 
 *         physical row bits within the DRAM.
 * By remapping the lower bits to undo the swizzling within the DRAM adjacent row 
 * DIMM array testing can take place which is a major goal in DIMM array testing. 
 */
typedef union {
  struct {
    UINT32 log2phy_row0_swzl : 5;
    /* log2phy_row0_swzl - Bits[4:0], RW_LB, default = 5'b00000 
       Defines how a particular logical Row Bit is remapped to a Physical Row Address. 
       The bits are essentially swizzled with each other. 
       Remapping the lower Row bits allows one to more effectively test adjacent rows 
       in a DRAM when the Row swizzling is used within the DRAM. 
       Remapping any two or more row bits to the same value is not allowed and the 
       behavior is undefined. 
       Remapping is a 2 step process with a write required to both 
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER and CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER 
       Example using Logical Row Bit X:
       If a swizzle between X and Y is desired then
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle must be 
       set to Y 
       And
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle must be 
       set to X 
       Note:
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle can be 
       only be set to equal itself or the largest 
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle value
     */
    UINT32 log2phy_row1_swzl : 5;
    /* log2phy_row1_swzl - Bits[9:5], RW_LB, default = 5'b00001 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 log2phy_row2_swzl : 5;
    /* log2phy_row2_swzl - Bits[14:10], RW_LB, default = 5'b00010 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 log2phy_row3_swzl : 5;
    /* log2phy_row3_swzl - Bits[19:15], RW_LB, default = 5'b00011 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 log2phy_row4_swzl : 5;
    /* log2phy_row4_swzl - Bits[24:20], RW_LB, default = 5'b00100 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 log2phy_row5_swzl : 5;
    /* log2phy_row5_swzl - Bits[29:25], RW_LB, default = 5'b00101 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 rsvd : 2;
    /* rsvd - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_RASL0_MC_MAIN_STRUCT;


/* CPGC_SEQ_RASL1_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x40250BC0)                                                  */
/*       SKX (0x40250BC0)                                                     */
/* Register default value:              0x0A418820                            */
#define CPGC_SEQ_RASL1_MC_MAIN_REG 0x07004BC0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Subsequence Logical to Physical Row Address Swizzling Lower -
 * This register is used to swizzle the Lower Logial to Physical Row Bits.
 * The Lower bits swizzling is desired when testing of DIMM arrays is the goal and 
 * when the DRAM DUT internally swizles the logical to 
 *         physical row bits within the DRAM.
 * By remapping the lower bits to undo the swizzling within the DRAM adjacent row 
 * DIMM array testing can take place which is a major goal in DIMM array testing. 
 */
typedef union {
  struct {
    UINT32 log2phy_row0_swzl : 5;
    /* log2phy_row0_swzl - Bits[4:0], RW_LB, default = 5'b00000 
       Defines how a particular logical Row Bit is remapped to a Physical Row Address. 
       The bits are essentially swizzled with each other. 
       Remapping the lower Row bits allows one to more effectively test adjacent rows 
       in a DRAM when the Row swizzling is used within the DRAM. 
       Remapping any two or more row bits to the same value is not allowed and the 
       behavior is undefined. 
       Remapping is a 2 step process with a write required to both 
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER and CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER 
       Example using Logical Row Bit X:
       If a swizzle between X and Y is desired then
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle must be 
       set to Y 
       And
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle must be 
       set to X 
       Note:
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle can be 
       only be set to equal itself or the largest 
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle value
     */
    UINT32 log2phy_row1_swzl : 5;
    /* log2phy_row1_swzl - Bits[9:5], RW_LB, default = 5'b00001 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 log2phy_row2_swzl : 5;
    /* log2phy_row2_swzl - Bits[14:10], RW_LB, default = 5'b00010 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 log2phy_row3_swzl : 5;
    /* log2phy_row3_swzl - Bits[19:15], RW_LB, default = 5'b00011 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 log2phy_row4_swzl : 5;
    /* log2phy_row4_swzl - Bits[24:20], RW_LB, default = 5'b00100 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 log2phy_row5_swzl : 5;
    /* log2phy_row5_swzl - Bits[29:25], RW_LB, default = 5'b00101 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 rsvd : 2;
    /* rsvd - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_RASL1_MC_MAIN_STRUCT;


/* CPGC_SEQ_RASL2_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x40250BC4)                                                  */
/*       SKX (0x40250BC4)                                                     */
/* Register default value:              0x0A418820                            */
#define CPGC_SEQ_RASL2_MC_MAIN_REG 0x07004BC4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Subsequence Logical to Physical Row Address Swizzling Lower -
 * This register is used to swizzle the Lower Logial to Physical Row Bits.
 * The Lower bits swizzling is desired when testing of DIMM arrays is the goal and 
 * when the DRAM DUT internally swizles the logical to 
 *         physical row bits within the DRAM.
 * By remapping the lower bits to undo the swizzling within the DRAM adjacent row 
 * DIMM array testing can take place which is a major goal in DIMM array testing. 
 */
typedef union {
  struct {
    UINT32 log2phy_row0_swzl : 5;
    /* log2phy_row0_swzl - Bits[4:0], RW_LB, default = 5'b00000 
       Defines how a particular logical Row Bit is remapped to a Physical Row Address. 
       The bits are essentially swizzled with each other. 
       Remapping the lower Row bits allows one to more effectively test adjacent rows 
       in a DRAM when the Row swizzling is used within the DRAM. 
       Remapping any two or more row bits to the same value is not allowed and the 
       behavior is undefined. 
       Remapping is a 2 step process with a write required to both 
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER and CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER 
       Example using Logical Row Bit X:
       If a swizzle between X and Y is desired then
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle must be 
       set to Y 
       And
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle must be 
       set to X 
       Note:
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle can be 
       only be set to equal itself or the largest 
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle value
     */
    UINT32 log2phy_row1_swzl : 5;
    /* log2phy_row1_swzl - Bits[9:5], RW_LB, default = 5'b00001 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 log2phy_row2_swzl : 5;
    /* log2phy_row2_swzl - Bits[14:10], RW_LB, default = 5'b00010 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 log2phy_row3_swzl : 5;
    /* log2phy_row3_swzl - Bits[19:15], RW_LB, default = 5'b00011 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 log2phy_row4_swzl : 5;
    /* log2phy_row4_swzl - Bits[24:20], RW_LB, default = 5'b00100 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 log2phy_row5_swzl : 5;
    /* log2phy_row5_swzl - Bits[29:25], RW_LB, default = 5'b00101 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 rsvd : 2;
    /* rsvd - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_RASL2_MC_MAIN_STRUCT;


/* CPGC_SEQ_RASL3_MC_MAIN_REG supported on:                                   */
/*       SKX_A0 (0x40250BC8)                                                  */
/*       SKX (0x40250BC8)                                                     */
/* Register default value:              0x0A418820                            */
#define CPGC_SEQ_RASL3_MC_MAIN_REG 0x07004BC8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Subsequence Logical to Physical Row Address Swizzling Lower -
 * This register is used to swizzle the Lower Logial to Physical Row Bits.
 * The Lower bits swizzling is desired when testing of DIMM arrays is the goal and 
 * when the DRAM DUT internally swizles the logical to 
 *         physical row bits within the DRAM.
 * By remapping the lower bits to undo the swizzling within the DRAM adjacent row 
 * DIMM array testing can take place which is a major goal in DIMM array testing. 
 */
typedef union {
  struct {
    UINT32 log2phy_row0_swzl : 5;
    /* log2phy_row0_swzl - Bits[4:0], RW_LB, default = 5'b00000 
       Defines how a particular logical Row Bit is remapped to a Physical Row Address. 
       The bits are essentially swizzled with each other. 
       Remapping the lower Row bits allows one to more effectively test adjacent rows 
       in a DRAM when the Row swizzling is used within the DRAM. 
       Remapping any two or more row bits to the same value is not allowed and the 
       behavior is undefined. 
       Remapping is a 2 step process with a write required to both 
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER and CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER 
       Example using Logical Row Bit X:
       If a swizzle between X and Y is desired then
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle must be 
       set to Y 
       And
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle must be 
       set to X 
       Note:
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle can be 
       only be set to equal itself or the largest 
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle value
     */
    UINT32 log2phy_row1_swzl : 5;
    /* log2phy_row1_swzl - Bits[9:5], RW_LB, default = 5'b00001 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 log2phy_row2_swzl : 5;
    /* log2phy_row2_swzl - Bits[14:10], RW_LB, default = 5'b00010 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 log2phy_row3_swzl : 5;
    /* log2phy_row3_swzl - Bits[19:15], RW_LB, default = 5'b00011 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 log2phy_row4_swzl : 5;
    /* log2phy_row4_swzl - Bits[24:20], RW_LB, default = 5'b00100 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 log2phy_row5_swzl : 5;
    /* log2phy_row5_swzl - Bits[29:25], RW_LB, default = 5'b00101 
       Refer to Log2phy_Row1_Swzl for details
     */
    UINT32 rsvd : 2;
    /* rsvd - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_RASL3_MC_MAIN_STRUCT;


/* CPGC_SEQ_RASU00_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250BCC)                                                  */
/*       SKX (0x40250BCC)                                                     */
/* Register default value:              0x16A4A0E6                            */
#define CPGC_SEQ_RASU00_MC_MAIN_REG 0x07004BCC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Subsequence Logical to Physical Row Address Swizzling Upper -
 * Part-0: This register is used to swizzle the Upper Logial to Physical Row Bits.
 */
typedef union {
  struct {
    UINT32 log2phy_row6_swzl : 5;
    /* log2phy_row6_swzl - Bits[4:0], RW_LB, default = 5'b00110 
       Defines how a particular logical Row Bit is remapped to a Physical Row Address. 
       The bits are essentially swizzled with each other. 
       Example using Logical Row Bit X:
       If a Logical_to_Physical_RowX_Swizzle = Y then this implies that
       Physical Row bit Y = X
       Physical Row bit X = Y
       Remapping Row bits allows one to more effectively test adjacent rows in a DRAM 
       when the Row swizzling is used within the DRAM. 
       Remapping any two or more row bits to the same value is not allowed and the 
       behavior is undefined. 
     */
    UINT32 log2phy_row7_swzl : 5;
    /* log2phy_row7_swzl - Bits[9:5], RW_LB, default = 5'b00111 
       Refer to Log2phy_Row6_Swzl for details
     */
    UINT32 log2phy_row8_swzl : 5;
    /* log2phy_row8_swzl - Bits[14:10], RW_LB, default = 5'b01000 
       Refer to Log2phy_Row6_Swzl for details
     */
    UINT32 log2phy_row9_swzl : 5;
    /* log2phy_row9_swzl - Bits[19:15], RW_LB, default = 5'b01001 
       Refer to Log2phy_Row6_Swzl for details
     */
    UINT32 log2phy_row10_swzl : 5;
    /* log2phy_row10_swzl - Bits[24:20], RW_LB, default = 5'b01010 
       Refer to Log2phy_Row6_Swzl for details
     */
    UINT32 log2phy_row11_swzl : 5;
    /* log2phy_row11_swzl - Bits[29:25], RW_LB, default = 5'b01011 
       Defines how a particular logical Row Bit is remapped to a Physical Row Address. 
       The bits are essentially swizzled with each other. 
       Remapping the lower Row bits allows one to more effectively test adjacent rows 
       in a DRAM when the Row swizzling is used within the DRAM. 
       Remapping any two or more row bits to the same value is not allowed and the 
       behavior is undefined. 
       Remapping is a 2 step process with a write required to both 
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER and CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER 
       Example using Logical Row Bit X:
       If a swizzle between X and Y is desired then
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle must be 
       set to Y 
       And
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle must be 
       set to X 
       Note:
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle can be 
       only be set to equal itself or the largest 
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle value
     */
    UINT32 rsvd : 2;
    /* rsvd - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_RASU00_MC_MAIN_STRUCT;


/* CPGC_SEQ_RASU10_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250BD0)                                                  */
/*       SKX (0x40250BD0)                                                     */
/* Register default value:              0x2307B9AC                            */
#define CPGC_SEQ_RASU10_MC_MAIN_REG 0x07004BD0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Subsequence Logical to Physical Row Address Swizzling Upper -
 * Part-1: This register is used to swizzle the Upper Logial to Physical Row Bits.
 */
typedef union {
  struct {
    UINT32 log2phy_row12_swzl : 5;
    /* log2phy_row12_swzl - Bits[4:0], RW_LB, default = 5'b01100 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row13_swzl : 5;
    /* log2phy_row13_swzl - Bits[9:5], RW_LB, default = 5'b01101 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row14_swzl : 5;
    /* log2phy_row14_swzl - Bits[14:10], RW_LB, default = 5'b01110 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row15_swzl : 5;
    /* log2phy_row15_swzl - Bits[19:15], RW_LB, default = 5'b01111 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row16_swzl : 5;
    /* log2phy_row16_swzl - Bits[24:20], RW_LB, default = 5'b10000 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row17_swzl : 5;
    /* log2phy_row17_swzl - Bits[29:25], RW_LB, default = 5'b10001 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 rsvd : 2;
    /* rsvd - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_RASU10_MC_MAIN_STRUCT;


/* CPGC_SEQ_RASU01_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250BD4)                                                  */
/*       SKX (0x40250BD4)                                                     */
/* Register default value:              0x16A4A0E6                            */
#define CPGC_SEQ_RASU01_MC_MAIN_REG 0x07004BD4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Part-0: This register is used to swizzle the Upper Logial to Physical Row Bits.
 */
typedef union {
  struct {
    UINT32 log2phy_row6_swzl : 5;
    /* log2phy_row6_swzl - Bits[4:0], RW_LB, default = 5'b00110 
       Defines how a particular logical Row Bit is remapped to a Physical Row Address. 
       The bits are essentially swizzled with each other. 
       Example using Logical Row Bit X:
       If a Logical_to_Physical_RowX_Swizzle = Y then this implies that
       Physical Row bit Y = X
       Physical Row bit X = Y
       Remapping Row bits allows one to more effectively test adjacent rows in a DRAM 
       when the Row swizzling is used within the DRAM. 
       Remapping any two or more row bits to the same value is not allowed and the 
       behavior is undefined. 
     */
    UINT32 log2phy_row7_swzl : 5;
    /* log2phy_row7_swzl - Bits[9:5], RW_LB, default = 5'b00111 
       Refer to Log2phy_Row6_Swzl for details
     */
    UINT32 log2phy_row8_swzl : 5;
    /* log2phy_row8_swzl - Bits[14:10], RW_LB, default = 5'b01000 
       Refer to Log2phy_Row6_Swzl for details
     */
    UINT32 log2phy_row9_swzl : 5;
    /* log2phy_row9_swzl - Bits[19:15], RW_LB, default = 5'b01001 
       Refer to Log2phy_Row6_Swzl for details
     */
    UINT32 log2phy_row10_swzl : 5;
    /* log2phy_row10_swzl - Bits[24:20], RW_LB, default = 5'b01010 
       Refer to Log2phy_Row6_Swzl for details
     */
    UINT32 log2phy_row11_swzl : 5;
    /* log2phy_row11_swzl - Bits[29:25], RW_LB, default = 5'b01011 
       Defines how a particular logical Row Bit is remapped to a Physical Row Address. 
       The bits are essentially swizzled with each other. 
       Remapping the lower Row bits allows one to more effectively test adjacent rows 
       in a DRAM when the Row swizzling is used within the DRAM. 
       Remapping any two or more row bits to the same value is not allowed and the 
       behavior is undefined. 
       Remapping is a 2 step process with a write required to both 
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER and CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER 
       Example using Logical Row Bit X:
       If a swizzle between X and Y is desired then
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle must be 
       set to Y 
       And
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle must be 
       set to X 
       Note:
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle can be 
       only be set to equal itself or the largest 
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle value
     */
    UINT32 rsvd : 2;
    /* rsvd - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_RASU01_MC_MAIN_STRUCT;


/* CPGC_SEQ_RASU11_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250BD8)                                                  */
/*       SKX (0x40250BD8)                                                     */
/* Register default value:              0x2307B9AC                            */
#define CPGC_SEQ_RASU11_MC_MAIN_REG 0x07004BD8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Subsequence Logical to Physical Row Address Swizzling Upper -
 * Part-1: This register is used to swizzle the Upper Logial to Physical Row Bits.
 */
typedef union {
  struct {
    UINT32 log2phy_row12_swzl : 5;
    /* log2phy_row12_swzl - Bits[4:0], RW_LB, default = 5'b01100 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row13_swzl : 5;
    /* log2phy_row13_swzl - Bits[9:5], RW_LB, default = 5'b01101 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row14_swzl : 5;
    /* log2phy_row14_swzl - Bits[14:10], RW_LB, default = 5'b01110 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row15_swzl : 5;
    /* log2phy_row15_swzl - Bits[19:15], RW_LB, default = 5'b01111 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row16_swzl : 5;
    /* log2phy_row16_swzl - Bits[24:20], RW_LB, default = 5'b10000 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row17_swzl : 5;
    /* log2phy_row17_swzl - Bits[29:25], RW_LB, default = 5'b10001 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 rsvd : 2;
    /* rsvd - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_RASU11_MC_MAIN_STRUCT;


/* CPGC_SEQ_RASU02_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250BDC)                                                  */
/*       SKX (0x40250BDC)                                                     */
/* Register default value:              0x16A4A0E6                            */
#define CPGC_SEQ_RASU02_MC_MAIN_REG 0x07004BDC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Part-0: This register is used to swizzle the Upper Logial to Physical Row Bits.
 */
typedef union {
  struct {
    UINT32 log2phy_row6_swzl : 5;
    /* log2phy_row6_swzl - Bits[4:0], RW_LB, default = 5'b00110 
       Defines how a particular logical Row Bit is remapped to a Physical Row Address. 
       The bits are essentially swizzled with each other. 
       Example using Logical Row Bit X:
       If a Logical_to_Physical_RowX_Swizzle = Y then this implies that
       Physical Row bit Y = X
       Physical Row bit X = Y
       Remapping Row bits allows one to more effectively test adjacent rows in a DRAM 
       when the Row swizzling is used within the DRAM. 
       Remapping any two or more row bits to the same value is not allowed and the 
       behavior is undefined. 
     */
    UINT32 log2phy_row7_swzl : 5;
    /* log2phy_row7_swzl - Bits[9:5], RW_LB, default = 5'b00111 
       Refer to Log2phy_Row6_Swzl for details
     */
    UINT32 log2phy_row8_swzl : 5;
    /* log2phy_row8_swzl - Bits[14:10], RW_LB, default = 5'b01000 
       Refer to Log2phy_Row6_Swzl for details
     */
    UINT32 log2phy_row9_swzl : 5;
    /* log2phy_row9_swzl - Bits[19:15], RW_LB, default = 5'b01001 
       Refer to Log2phy_Row6_Swzl for details
     */
    UINT32 log2phy_row10_swzl : 5;
    /* log2phy_row10_swzl - Bits[24:20], RW_LB, default = 5'b01010 
       Refer to Log2phy_Row6_Swzl for details
     */
    UINT32 log2phy_row11_swzl : 5;
    /* log2phy_row11_swzl - Bits[29:25], RW_LB, default = 5'b01011 
       Defines how a particular logical Row Bit is remapped to a Physical Row Address. 
       The bits are essentially swizzled with each other. 
       Remapping the lower Row bits allows one to more effectively test adjacent rows 
       in a DRAM when the Row swizzling is used within the DRAM. 
       Remapping any two or more row bits to the same value is not allowed and the 
       behavior is undefined. 
       Remapping is a 2 step process with a write required to both 
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER and CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER 
       Example using Logical Row Bit X:
       If a swizzle between X and Y is desired then
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle must be 
       set to Y 
       And
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle must be 
       set to X 
       Note:
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle can be 
       only be set to equal itself or the largest 
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle value
     */
    UINT32 rsvd : 2;
    /* rsvd - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_RASU02_MC_MAIN_STRUCT;


/* CPGC_SEQ_RASU12_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250BE0)                                                  */
/*       SKX (0x40250BE0)                                                     */
/* Register default value:              0x2307B9AC                            */
#define CPGC_SEQ_RASU12_MC_MAIN_REG 0x07004BE0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Subsequence Logical to Physical Row Address Swizzling Upper -
 * Part-1: This register is used to swizzle the Upper Logial to Physical Row Bits.
 */
typedef union {
  struct {
    UINT32 log2phy_row12_swzl : 5;
    /* log2phy_row12_swzl - Bits[4:0], RW_LB, default = 5'b01100 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row13_swzl : 5;
    /* log2phy_row13_swzl - Bits[9:5], RW_LB, default = 5'b01101 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row14_swzl : 5;
    /* log2phy_row14_swzl - Bits[14:10], RW_LB, default = 5'b01110 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row15_swzl : 5;
    /* log2phy_row15_swzl - Bits[19:15], RW_LB, default = 5'b01111 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row16_swzl : 5;
    /* log2phy_row16_swzl - Bits[24:20], RW_LB, default = 5'b10000 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row17_swzl : 5;
    /* log2phy_row17_swzl - Bits[29:25], RW_LB, default = 5'b10001 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 rsvd : 2;
    /* rsvd - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_RASU12_MC_MAIN_STRUCT;


/* CPGC_SEQ_RASU03_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250BE4)                                                  */
/*       SKX (0x40250BE4)                                                     */
/* Register default value:              0x16A4A0E6                            */
#define CPGC_SEQ_RASU03_MC_MAIN_REG 0x07004BE4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Part-0: This register is used to swizzle the Upper Logial to Physical Row Bits.
 */
typedef union {
  struct {
    UINT32 log2phy_row6_swzl : 5;
    /* log2phy_row6_swzl - Bits[4:0], RW_LB, default = 5'b00110 
       Defines how a particular logical Row Bit is remapped to a Physical Row Address. 
       The bits are essentially swizzled with each other. 
       Example using Logical Row Bit X:
       If a Logical_to_Physical_RowX_Swizzle = Y then this implies that
       Physical Row bit Y = X
       Physical Row bit X = Y
       Remapping Row bits allows one to more effectively test adjacent rows in a DRAM 
       when the Row swizzling is used within the DRAM. 
       Remapping any two or more row bits to the same value is not allowed and the 
       behavior is undefined. 
     */
    UINT32 log2phy_row7_swzl : 5;
    /* log2phy_row7_swzl - Bits[9:5], RW_LB, default = 5'b00111 
       Refer to Log2phy_Row6_Swzl for details
     */
    UINT32 log2phy_row8_swzl : 5;
    /* log2phy_row8_swzl - Bits[14:10], RW_LB, default = 5'b01000 
       Refer to Log2phy_Row6_Swzl for details
     */
    UINT32 log2phy_row9_swzl : 5;
    /* log2phy_row9_swzl - Bits[19:15], RW_LB, default = 5'b01001 
       Refer to Log2phy_Row6_Swzl for details
     */
    UINT32 log2phy_row10_swzl : 5;
    /* log2phy_row10_swzl - Bits[24:20], RW_LB, default = 5'b01010 
       Refer to Log2phy_Row6_Swzl for details
     */
    UINT32 log2phy_row11_swzl : 5;
    /* log2phy_row11_swzl - Bits[29:25], RW_LB, default = 5'b01011 
       Defines how a particular logical Row Bit is remapped to a Physical Row Address. 
       The bits are essentially swizzled with each other. 
       Remapping the lower Row bits allows one to more effectively test adjacent rows 
       in a DRAM when the Row swizzling is used within the DRAM. 
       Remapping any two or more row bits to the same value is not allowed and the 
       behavior is undefined. 
       Remapping is a 2 step process with a write required to both 
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER and CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER 
       Example using Logical Row Bit X:
       If a swizzle between X and Y is desired then
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle must be 
       set to Y 
       And
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle must be 
       set to X 
       Note:
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle can be 
       only be set to equal itself or the largest 
       CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle value
     */
    UINT32 rsvd : 2;
    /* rsvd - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_RASU03_MC_MAIN_STRUCT;


/* CPGC_SEQ_RASU13_MC_MAIN_REG supported on:                                  */
/*       SKX_A0 (0x40250BE8)                                                  */
/*       SKX (0x40250BE8)                                                     */
/* Register default value:              0x2307B9AC                            */
#define CPGC_SEQ_RASU13_MC_MAIN_REG 0x07004BE8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Subsequence Logical to Physical Row Address Swizzling Upper -
 * Part-1: This register is used to swizzle the Upper Logial to Physical Row Bits.
 */
typedef union {
  struct {
    UINT32 log2phy_row12_swzl : 5;
    /* log2phy_row12_swzl - Bits[4:0], RW_LB, default = 5'b01100 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row13_swzl : 5;
    /* log2phy_row13_swzl - Bits[9:5], RW_LB, default = 5'b01101 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row14_swzl : 5;
    /* log2phy_row14_swzl - Bits[14:10], RW_LB, default = 5'b01110 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row15_swzl : 5;
    /* log2phy_row15_swzl - Bits[19:15], RW_LB, default = 5'b01111 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row16_swzl : 5;
    /* log2phy_row16_swzl - Bits[24:20], RW_LB, default = 5'b10000 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 log2phy_row17_swzl : 5;
    /* log2phy_row17_swzl - Bits[29:25], RW_LB, default = 5'b10001 
       Refer to Log2phy_Row11_Swzl for details
     */
    UINT32 rsvd : 2;
    /* rsvd - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_RASU13_MC_MAIN_STRUCT;


/* CPGC_SEQ_DMYRDADDR_LO_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x40250BEC)                                                  */
/*       SKX (0x40250BEC)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_DMYRDADDR_LO_MC_MAIN_REG 0x07004BEC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Defines what Banks and the Starting Row Address for the Dummy Reads to occur. 
 * (for chs 0 and 1) 
 * Dummy Reads are defined as a qualified read request which will generate the 
 * necessary Activates and Precharges but no Read will occur. 
 */
typedef union {
  struct {
    UINT32 bank_mask0 : 16;
    /* bank_mask0 - Bits[15:0], RW_LB, default = 16'b0000000000000000 
       A one hot Mask that defines which Banks will be used in generating the Dummy 
       Reads which create Activates and 
       pre-charges according to the functional behavior of the scheduler.
       A 1 means that a Bank will not be used to issue the Dummy Read to cause a 
       precharge and activate. 
       Bit 0 Bank 0
       Bit 1 Bank 1
       Bit 15 Bank 15
     */
    UINT32 bank_mask1 : 16;
    /* bank_mask1 - Bits[31:16], RW_LB, default = 16'b0000000000000000 
       Refer to Bank_Mask0 for details
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_DMYRDADDR_LO_MC_MAIN_STRUCT;


/* CPGC_SEQ_DMYRDSTS0_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x40250BF0)                                                  */
/*       SKX (0x40250BF0)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_DMYRDSTS0_MC_MAIN_REG 0x07004BF0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Susequence Dummy Activate Address Status -
 * Indicates the Dummy Read Current Row Address.
 * Dummy Reads are defined as a qualified read request which will generate the 
 * necessary Activates and Precharges but no Read will occur. 
 */
typedef union {
  struct {
    UINT32 row_curraddr : 18;
    /* row_curraddr - Bits[17:0], RW_V, default = 18'b000000000000000000 
       Dummy_Read_Row_Current_Address defines the current Row Address for the Dummy 
       Reads which is updated while a test is in progress. 
       The Dummy_Read_Row_Current_Address will be increment by 1 everytime a Dummy Read 
       is generated. 
       One may program Dummy_Read_Row_Current_Address to a desired starting value if a 
       certain initial condition is desired otherwise 
       the Dummy_Read_Row_Current_Address will resume from the current value as no 
       hardware mechanism exists to explicitly 
       clear or modify this register.
     */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_curraddr : 4;
    /* bank_curraddr - Bits[27:24], RW_V, default = 4'b0000 
       Refer to Row_Curraddr for details
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_DMYRDSTS0_MC_MAIN_STRUCT;


/* CPGC_SEQ_DMYRDSTS1_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x40250BF4)                                                  */
/*       SKX (0x40250BF4)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_DMYRDSTS1_MC_MAIN_REG 0x07004BF4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Susequence Dummy Activate Address Status -
 * Indicates the Dummy Read Current Row Address.
 * Dummy Reads are defined as a qualified read request which will generate the 
 * necessary Activates and Precharges but no Read will occur. 
 */
typedef union {
  struct {
    UINT32 row_curraddr : 18;
    /* row_curraddr - Bits[17:0], RW_V, default = 18'b000000000000000000 
       Dummy_Read_Row_Current_Address defines the current Row Address for the Dummy 
       Reads which is updated while a test is in progress. 
       The Dummy_Read_Row_Current_Address will be increment by 1 everytime a Dummy Read 
       is generated. 
       One may program Dummy_Read_Row_Current_Address to a desired starting value if a 
       certain initial condition is desired otherwise 
       the Dummy_Read_Row_Current_Address will resume from the current value as no 
       hardware mechanism exists to explicitly 
       clear or modify this register.
     */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_curraddr : 4;
    /* bank_curraddr - Bits[27:24], RW_V, default = 4'b0000 
       Refer to Row_Curraddr for details
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_DMYRDSTS1_MC_MAIN_STRUCT;


/* CPGC_SEQ_DMYRDSTS2_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x40250BF8)                                                  */
/*       SKX (0x40250BF8)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_DMYRDSTS2_MC_MAIN_REG 0x07004BF8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Susequence Dummy Activate Address Status -
 * Indicates the Dummy Read Current Row Address.
 * Dummy Reads are defined as a qualified read request which will generate the 
 * necessary Activates and Precharges but no Read will occur. 
 */
typedef union {
  struct {
    UINT32 row_curraddr : 18;
    /* row_curraddr - Bits[17:0], RW_V, default = 18'b000000000000000000 
       Dummy_Read_Row_Current_Address defines the current Row Address for the Dummy 
       Reads which is updated while a test is in progress. 
       The Dummy_Read_Row_Current_Address will be increment by 1 everytime a Dummy Read 
       is generated. 
       One may program Dummy_Read_Row_Current_Address to a desired starting value if a 
       certain initial condition is desired otherwise 
       the Dummy_Read_Row_Current_Address will resume from the current value as no 
       hardware mechanism exists to explicitly 
       clear or modify this register.
     */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_curraddr : 4;
    /* bank_curraddr - Bits[27:24], RW_V, default = 4'b0000 
       Refer to Row_Curraddr for details
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_DMYRDSTS2_MC_MAIN_STRUCT;


/* CPGC_SEQ_DMYRDSTS3_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x40250BFC)                                                  */
/*       SKX (0x40250BFC)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_DMYRDSTS3_MC_MAIN_REG 0x07004BFC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Susequence Dummy Activate Address Status -
 * Indicates the Dummy Read Current Row Address.
 * Dummy Reads are defined as a qualified read request which will generate the 
 * necessary Activates and Precharges but no Read will occur. 
 */
typedef union {
  struct {
    UINT32 row_curraddr : 18;
    /* row_curraddr - Bits[17:0], RW_V, default = 18'b000000000000000000 
       Dummy_Read_Row_Current_Address defines the current Row Address for the Dummy 
       Reads which is updated while a test is in progress. 
       The Dummy_Read_Row_Current_Address will be increment by 1 everytime a Dummy Read 
       is generated. 
       One may program Dummy_Read_Row_Current_Address to a desired starting value if a 
       certain initial condition is desired otherwise 
       the Dummy_Read_Row_Current_Address will resume from the current value as no 
       hardware mechanism exists to explicitly 
       clear or modify this register.
     */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_curraddr : 4;
    /* bank_curraddr - Bits[27:24], RW_V, default = 4'b0000 
       Refer to Row_Curraddr for details
     */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_DMYRDSTS3_MC_MAIN_STRUCT;


/* CPGC_SEQ_DMYRDCTL0_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x40250C00)                                                  */
/*       SKX (0x40250C00)                                                     */
/* Register default value:              0x01010100                            */
#define CPGC_SEQ_DMYRDCTL0_MC_MAIN_REG 0x07004C00
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Susequence Dummy Activate Control -
 * Defines how often a Dummy Reads will occur.
 * Dummy Reads are defined as a qualified read request which will generate the 
 * necessary Activates and Precharges but no Read will occur. 
 */
typedef union {
  struct {
    UINT32 l_dmyrd_select : 1;
    /* l_dmyrd_select - Bits[0:0], RW_LB, default = 1'b0 
       L_DummyRead_Select indicates whether Dummy Reads will be generated during the 
       first L Dclks after a test is started (entering Loopback.Pattern) 
       0x0 = Dummy Reads must be driven during the initial L counter Dclk delay with 
       minimum spacing as possible 
       0x1=Dummy Reads must be not be driven during the initial L counter Dclk delay
     */
    UINT32 sweep_freq : 1;
    /* sweep_freq - Bits[1:1], RW_LB, default = 1'b0 
       After L_Counter Dclk cycles of Dummy Reads (L_DummyRead_Select =1) or no Dummy 
       Reads (DummyRead_Select = 0) 
       are performed at the beginning of a test (entering Loopback.Pattern) then the 
       following dummy Read periodic pattern is 
       continuously repeated depending on the value of Sweep Frequency.
     */
    UINT32 rsvd : 6;
    /* rsvd - Bits[7:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 l_counter : 8;
    /* l_counter - Bits[15:8], RW_LB, default = 8'b00000001 
       After L_Counter Dclk cycles of Dummy Reads (L_DummyRead_Select =1) or no Dummy 
       Reads (DummyRead_Select = 0) are performed 
       at the beginning of a test (entering Loopback.Pattern) then the following dummy 
       Read periodic pattern is continuously 
       repeated depending on the value of Sweep Frequency.
       If Sweep_Frequency = 0 then a steady state frequency of Dummy Activiates driven 
       (see Sweep_Frequency for exact behavior) 
       If Sweep_Frequency = 1 then a frequency sweep of Dummy Activates is continuously 
       generated ranging from 2*(M) to 2*(N) driven 
       (see Sweep_Frequency for exact behavior)
     */
    UINT32 m_counter : 8;
    /* m_counter - Bits[23:16], RW_LB, default = 8'b00000001 
       Refer to L_Counter for details
     */
    UINT32 n_counter : 8;
    /* n_counter - Bits[31:24], RW_LB, default = 8'b00000001 
       Refer to L_Counter for details
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_DMYRDCTL0_MC_MAIN_STRUCT;


/* CPGC_SEQ_DMYRDCTL1_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x40250C04)                                                  */
/*       SKX (0x40250C04)                                                     */
/* Register default value:              0x01010100                            */
#define CPGC_SEQ_DMYRDCTL1_MC_MAIN_REG 0x07004C04
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Susequence Dummy Activate Control -
 * Defines how often a Dummy Reads will occur.
 * Dummy Reads are defined as a qualified read request which will generate the 
 * necessary Activates and Precharges but no Read will occur. 
 */
typedef union {
  struct {
    UINT32 l_dmyrd_select : 1;
    /* l_dmyrd_select - Bits[0:0], RW_LB, default = 1'b0 
       L_DummyRead_Select indicates whether Dummy Reads will be generated during the 
       first L Dclks after a test is started (entering Loopback.Pattern) 
       0x0 = Dummy Reads must be driven during the initial L counter Dclk delay with 
       minimum spacing as possible 
       0x1=Dummy Reads must be not be driven during the initial L counter Dclk delay
     */
    UINT32 sweep_freq : 1;
    /* sweep_freq - Bits[1:1], RW_LB, default = 1'b0 
       After L_Counter Dclk cycles of Dummy Reads (L_DummyRead_Select =1) or no Dummy 
       Reads (DummyRead_Select = 0) 
       are performed at the beginning of a test (entering Loopback.Pattern) then the 
       following dummy Read periodic pattern is 
       continuously repeated depending on the value of Sweep Frequency.
     */
    UINT32 rsvd : 6;
    /* rsvd - Bits[7:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 l_counter : 8;
    /* l_counter - Bits[15:8], RW_LB, default = 8'b00000001 
       After L_Counter Dclk cycles of Dummy Reads (L_DummyRead_Select =1) or no Dummy 
       Reads (DummyRead_Select = 0) are performed 
       at the beginning of a test (entering Loopback.Pattern) then the following dummy 
       Read periodic pattern is continuously 
       repeated depending on the value of Sweep Frequency.
       If Sweep_Frequency = 0 then a steady state frequency of Dummy Activiates driven 
       (see Sweep_Frequency for exact behavior) 
       If Sweep_Frequency = 1 then a frequency sweep of Dummy Activates is continuously 
       generated ranging from 2*(M) to 2*(N) driven 
       (see Sweep_Frequency for exact behavior)
     */
    UINT32 m_counter : 8;
    /* m_counter - Bits[23:16], RW_LB, default = 8'b00000001 
       Refer to L_Counter for details
     */
    UINT32 n_counter : 8;
    /* n_counter - Bits[31:24], RW_LB, default = 8'b00000001 
       Refer to L_Counter for details
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_DMYRDCTL1_MC_MAIN_STRUCT;


/* CPGC_SEQ_DMYRDCTL2_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x40250C08)                                                  */
/*       SKX (0x40250C08)                                                     */
/* Register default value:              0x01010100                            */
#define CPGC_SEQ_DMYRDCTL2_MC_MAIN_REG 0x07004C08
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Susequence Dummy Activate Control -
 * Defines how often a Dummy Reads will occur.
 * Dummy Reads are defined as a qualified read request which will generate the 
 * necessary Activates and Precharges but no Read will occur. 
 */
typedef union {
  struct {
    UINT32 l_dmyrd_select : 1;
    /* l_dmyrd_select - Bits[0:0], RW_LB, default = 1'b0 
       L_DummyRead_Select indicates whether Dummy Reads will be generated during the 
       first L Dclks after a test is started (entering Loopback.Pattern) 
       0x0 = Dummy Reads must be driven during the initial L counter Dclk delay with 
       minimum spacing as possible 
       0x1=Dummy Reads must be not be driven during the initial L counter Dclk delay
     */
    UINT32 sweep_freq : 1;
    /* sweep_freq - Bits[1:1], RW_LB, default = 1'b0 
       After L_Counter Dclk cycles of Dummy Reads (L_DummyRead_Select =1) or no Dummy 
       Reads (DummyRead_Select = 0) 
       are performed at the beginning of a test (entering Loopback.Pattern) then the 
       following dummy Read periodic pattern is 
       continuously repeated depending on the value of Sweep Frequency.
     */
    UINT32 rsvd : 6;
    /* rsvd - Bits[7:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 l_counter : 8;
    /* l_counter - Bits[15:8], RW_LB, default = 8'b00000001 
       After L_Counter Dclk cycles of Dummy Reads (L_DummyRead_Select =1) or no Dummy 
       Reads (DummyRead_Select = 0) are performed 
       at the beginning of a test (entering Loopback.Pattern) then the following dummy 
       Read periodic pattern is continuously 
       repeated depending on the value of Sweep Frequency.
       If Sweep_Frequency = 0 then a steady state frequency of Dummy Activiates driven 
       (see Sweep_Frequency for exact behavior) 
       If Sweep_Frequency = 1 then a frequency sweep of Dummy Activates is continuously 
       generated ranging from 2*(M) to 2*(N) driven 
       (see Sweep_Frequency for exact behavior)
     */
    UINT32 m_counter : 8;
    /* m_counter - Bits[23:16], RW_LB, default = 8'b00000001 
       Refer to L_Counter for details
     */
    UINT32 n_counter : 8;
    /* n_counter - Bits[31:24], RW_LB, default = 8'b00000001 
       Refer to L_Counter for details
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_DMYRDCTL2_MC_MAIN_STRUCT;


/* CPGC_SEQ_DMYRDCTL3_MC_MAIN_REG supported on:                               */
/*       SKX_A0 (0x40250C0C)                                                  */
/*       SKX (0x40250C0C)                                                     */
/* Register default value:              0x01010100                            */
#define CPGC_SEQ_DMYRDCTL3_MC_MAIN_REG 0x07004C0C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Susequence Dummy Activate Control -
 * Defines how often a Dummy Reads will occur.
 * Dummy Reads are defined as a qualified read request which will generate the 
 * necessary Activates and Precharges but no Read will occur. 
 */
typedef union {
  struct {
    UINT32 l_dmyrd_select : 1;
    /* l_dmyrd_select - Bits[0:0], RW_LB, default = 1'b0 
       L_DummyRead_Select indicates whether Dummy Reads will be generated during the 
       first L Dclks after a test is started (entering Loopback.Pattern) 
       0x0 = Dummy Reads must be driven during the initial L counter Dclk delay with 
       minimum spacing as possible 
       0x1=Dummy Reads must be not be driven during the initial L counter Dclk delay
     */
    UINT32 sweep_freq : 1;
    /* sweep_freq - Bits[1:1], RW_LB, default = 1'b0 
       After L_Counter Dclk cycles of Dummy Reads (L_DummyRead_Select =1) or no Dummy 
       Reads (DummyRead_Select = 0) 
       are performed at the beginning of a test (entering Loopback.Pattern) then the 
       following dummy Read periodic pattern is 
       continuously repeated depending on the value of Sweep Frequency.
     */
    UINT32 rsvd : 6;
    /* rsvd - Bits[7:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 l_counter : 8;
    /* l_counter - Bits[15:8], RW_LB, default = 8'b00000001 
       After L_Counter Dclk cycles of Dummy Reads (L_DummyRead_Select =1) or no Dummy 
       Reads (DummyRead_Select = 0) are performed 
       at the beginning of a test (entering Loopback.Pattern) then the following dummy 
       Read periodic pattern is continuously 
       repeated depending on the value of Sweep Frequency.
       If Sweep_Frequency = 0 then a steady state frequency of Dummy Activiates driven 
       (see Sweep_Frequency for exact behavior) 
       If Sweep_Frequency = 1 then a frequency sweep of Dummy Activates is continuously 
       generated ranging from 2*(M) to 2*(N) driven 
       (see Sweep_Frequency for exact behavior)
     */
    UINT32 m_counter : 8;
    /* m_counter - Bits[23:16], RW_LB, default = 8'b00000001 
       Refer to L_Counter for details
     */
    UINT32 n_counter : 8;
    /* n_counter - Bits[31:24], RW_LB, default = 8'b00000001 
       Refer to L_Counter for details
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_DMYRDCTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ0_CTL0_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250C10)                                                  */
/*       SKX (0x40250C10)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ0_CTL0_MC_MAIN_REG 0x07004C10
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-0 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
       The interpretation of Number_Of_Cachelines is based on 
       Number_Of_Cachelines_Scale 
       If Number_Of_Cachelines_Scale is set to 1 then Number_Of_Cachelines operates as 
       a linear counter with one notable exception: 
       Setting Number_Of_Cachelines_Scale to 1 and Number_of_Cachelines to 0 will 
       result in an infinite # of cachelines being transmitted. 
       If Number_Of_Cachelines_Scale is set to 0 then Number_Of_Cachelines operates as 
       an exponential counter with a value equal to (2^ Number_Of_Cachelines_Scale). 
       Only bits 0:4 are supported Number_Of_Cachelines_Scale is set to 0 (exponential 
       counter mode). 
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ0_CTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ0_OFFSETCTL0_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250C14)                                                  */
/*       SKX (0x40250C14)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ0_OFFSETCTL0_MC_MAIN_REG 0x07004C14
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-0 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 * 
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ0_OFFSETCTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ1_CTL0_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250C18)                                                  */
/*       SKX (0x40250C18)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ1_CTL0_MC_MAIN_REG 0x07004C18
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-1 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ1_CTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ1_OFFSETCTL0_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250C1C)                                                  */
/*       SKX (0x40250C1C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ1_OFFSETCTL0_MC_MAIN_REG 0x07004C1C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-1 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ1_OFFSETCTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ2_CTL0_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250C20)                                                  */
/*       SKX (0x40250C20)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ2_CTL0_MC_MAIN_REG 0x07004C20
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-2 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ2_CTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ2_OFFSETCTL0_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250C24)                                                  */
/*       SKX (0x40250C24)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ2_OFFSETCTL0_MC_MAIN_REG 0x07004C24
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-2 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ2_OFFSETCTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ3_CTL0_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250C28)                                                  */
/*       SKX (0x40250C28)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ3_CTL0_MC_MAIN_REG 0x07004C28
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-3 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ3_CTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ3_OFFSETCTL0_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250C2C)                                                  */
/*       SKX (0x40250C2C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ3_OFFSETCTL0_MC_MAIN_REG 0x07004C2C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-3 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ3_OFFSETCTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ4_CTL0_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250C30)                                                  */
/*       SKX (0x40250C30)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ4_CTL0_MC_MAIN_REG 0x07004C30
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-4 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ4_CTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ4_OFFSETCTL0_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250C34)                                                  */
/*       SKX (0x40250C34)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ4_OFFSETCTL0_MC_MAIN_REG 0x07004C34
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-4 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ4_OFFSETCTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ5_CTL0_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250C38)                                                  */
/*       SKX (0x40250C38)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ5_CTL0_MC_MAIN_REG 0x07004C38
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-5 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ5_CTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ5_OFFSETCTL0_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250C3C)                                                  */
/*       SKX (0x40250C3C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ5_OFFSETCTL0_MC_MAIN_REG 0x07004C3C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-5 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ5_OFFSETCTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ6_CTL0_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250C40)                                                  */
/*       SKX (0x40250C40)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ6_CTL0_MC_MAIN_REG 0x07004C40
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-6 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ6_CTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ6_OFFSETCTL0_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250C44)                                                  */
/*       SKX (0x40250C44)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ6_OFFSETCTL0_MC_MAIN_REG 0x07004C44
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-6 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ6_OFFSETCTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ7_CTL0_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250C48)                                                  */
/*       SKX (0x40250C48)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ7_CTL0_MC_MAIN_REG 0x07004C48
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-7 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ7_CTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ7_OFFSETCTL0_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250C4C)                                                  */
/*       SKX (0x40250C4C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ7_OFFSETCTL0_MC_MAIN_REG 0x07004C4C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-7 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ7_OFFSETCTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ8_CTL0_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250C50)                                                  */
/*       SKX (0x40250C50)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ8_CTL0_MC_MAIN_REG 0x07004C50
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-8 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ8_CTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ8_OFFSETCTL0_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250C54)                                                  */
/*       SKX (0x40250C54)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ8_OFFSETCTL0_MC_MAIN_REG 0x07004C54
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-8 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ8_OFFSETCTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ9_CTL0_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250C58)                                                  */
/*       SKX (0x40250C58)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ9_CTL0_MC_MAIN_REG 0x07004C58
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-9 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ9_CTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ9_OFFSETCTL0_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250C5C)                                                  */
/*       SKX (0x40250C5C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ9_OFFSETCTL0_MC_MAIN_REG 0x07004C5C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Sub-Sequence-9 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ9_OFFSETCTL0_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ0_CTL1_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250C60)                                                  */
/*       SKX (0x40250C60)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ0_CTL1_MC_MAIN_REG 0x07004C60
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-0 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ0_CTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ0_OFFSETCTL1_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250C64)                                                  */
/*       SKX (0x40250C64)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ0_OFFSETCTL1_MC_MAIN_REG 0x07004C64
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-0 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ0_OFFSETCTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ1_CTL1_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250C68)                                                  */
/*       SKX (0x40250C68)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ1_CTL1_MC_MAIN_REG 0x07004C68
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-1 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ1_CTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ1_OFFSETCTL1_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250C6C)                                                  */
/*       SKX (0x40250C6C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ1_OFFSETCTL1_MC_MAIN_REG 0x07004C6C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-1 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ1_OFFSETCTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ2_CTL1_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250C70)                                                  */
/*       SKX (0x40250C70)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ2_CTL1_MC_MAIN_REG 0x07004C70
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-2 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ2_CTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ2_OFFSETCTL1_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250C74)                                                  */
/*       SKX (0x40250C74)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ2_OFFSETCTL1_MC_MAIN_REG 0x07004C74
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-2 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ2_OFFSETCTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ3_CTL1_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250C78)                                                  */
/*       SKX (0x40250C78)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ3_CTL1_MC_MAIN_REG 0x07004C78
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-3 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ3_CTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ3_OFFSETCTL1_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250C7C)                                                  */
/*       SKX (0x40250C7C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ3_OFFSETCTL1_MC_MAIN_REG 0x07004C7C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-3 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ3_OFFSETCTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ4_CTL1_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250C80)                                                  */
/*       SKX (0x40250C80)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ4_CTL1_MC_MAIN_REG 0x07004C80
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-4 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ4_CTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ4_OFFSETCTL1_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250C84)                                                  */
/*       SKX (0x40250C84)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ4_OFFSETCTL1_MC_MAIN_REG 0x07004C84
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-4 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ4_OFFSETCTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ5_CTL1_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250C88)                                                  */
/*       SKX (0x40250C88)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ5_CTL1_MC_MAIN_REG 0x07004C88
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-5 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ5_CTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ5_OFFSETCTL1_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250C8C)                                                  */
/*       SKX (0x40250C8C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ5_OFFSETCTL1_MC_MAIN_REG 0x07004C8C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-5 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ5_OFFSETCTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ6_CTL1_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250C90)                                                  */
/*       SKX (0x40250C90)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ6_CTL1_MC_MAIN_REG 0x07004C90
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-6 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ6_CTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ6_OFFSETCTL1_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250C94)                                                  */
/*       SKX (0x40250C94)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ6_OFFSETCTL1_MC_MAIN_REG 0x07004C94
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-6 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ6_OFFSETCTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ7_CTL1_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250C98)                                                  */
/*       SKX (0x40250C98)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ7_CTL1_MC_MAIN_REG 0x07004C98
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-7 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ7_CTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ7_OFFSETCTL1_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250C9C)                                                  */
/*       SKX (0x40250C9C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ7_OFFSETCTL1_MC_MAIN_REG 0x07004C9C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-7 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ7_OFFSETCTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ8_CTL1_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250CA0)                                                  */
/*       SKX (0x40250CA0)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ8_CTL1_MC_MAIN_REG 0x07004CA0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-8 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ8_CTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ8_OFFSETCTL1_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250CA4)                                                  */
/*       SKX (0x40250CA4)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ8_OFFSETCTL1_MC_MAIN_REG 0x07004CA4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-8 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ8_OFFSETCTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ9_CTL1_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250CA8)                                                  */
/*       SKX (0x40250CA8)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ9_CTL1_MC_MAIN_REG 0x07004CA8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-9 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ9_CTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ9_OFFSETCTL1_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250CAC)                                                  */
/*       SKX (0x40250CAC)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ9_OFFSETCTL1_MC_MAIN_REG 0x07004CAC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Sub-Sequence-9 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ9_OFFSETCTL1_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ0_CTL2_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250CB0)                                                  */
/*       SKX (0x40250CB0)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ0_CTL2_MC_MAIN_REG 0x07004CB0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-0 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ0_CTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ0_OFFSETCTL2_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250CB4)                                                  */
/*       SKX (0x40250CB4)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ0_OFFSETCTL2_MC_MAIN_REG 0x07004CB4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-0 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ0_OFFSETCTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ1_CTL2_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250CB8)                                                  */
/*       SKX (0x40250CB8)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ1_CTL2_MC_MAIN_REG 0x07004CB8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-1 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ1_CTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ1_OFFSETCTL2_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250CBC)                                                  */
/*       SKX (0x40250CBC)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ1_OFFSETCTL2_MC_MAIN_REG 0x07004CBC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-1 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ1_OFFSETCTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ2_CTL2_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250CC0)                                                  */
/*       SKX (0x40250CC0)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ2_CTL2_MC_MAIN_REG 0x07004CC0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-2 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ2_CTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ2_OFFSETCTL2_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250CC4)                                                  */
/*       SKX (0x40250CC4)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ2_OFFSETCTL2_MC_MAIN_REG 0x07004CC4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-2 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ2_OFFSETCTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ3_CTL2_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250CC8)                                                  */
/*       SKX (0x40250CC8)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ3_CTL2_MC_MAIN_REG 0x07004CC8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-3 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ3_CTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ3_OFFSETCTL2_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250CCC)                                                  */
/*       SKX (0x40250CCC)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ3_OFFSETCTL2_MC_MAIN_REG 0x07004CCC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-3 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ3_OFFSETCTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ4_CTL2_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250CD0)                                                  */
/*       SKX (0x40250CD0)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ4_CTL2_MC_MAIN_REG 0x07004CD0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-4 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ4_CTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ4_OFFSETCTL2_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250CD4)                                                  */
/*       SKX (0x40250CD4)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ4_OFFSETCTL2_MC_MAIN_REG 0x07004CD4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-4 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ4_OFFSETCTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ5_CTL2_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250CD8)                                                  */
/*       SKX (0x40250CD8)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ5_CTL2_MC_MAIN_REG 0x07004CD8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-5 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ5_CTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ5_OFFSETCTL2_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250CDC)                                                  */
/*       SKX (0x40250CDC)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ5_OFFSETCTL2_MC_MAIN_REG 0x07004CDC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-5 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ5_OFFSETCTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ6_CTL2_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250CE0)                                                  */
/*       SKX (0x40250CE0)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ6_CTL2_MC_MAIN_REG 0x07004CE0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-6 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ6_CTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ6_OFFSETCTL2_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250CE4)                                                  */
/*       SKX (0x40250CE4)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ6_OFFSETCTL2_MC_MAIN_REG 0x07004CE4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-6 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ6_OFFSETCTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ7_CTL2_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250CE8)                                                  */
/*       SKX (0x40250CE8)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ7_CTL2_MC_MAIN_REG 0x07004CE8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-7 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ7_CTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ7_OFFSETCTL2_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250CEC)                                                  */
/*       SKX (0x40250CEC)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ7_OFFSETCTL2_MC_MAIN_REG 0x07004CEC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-7 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ7_OFFSETCTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ8_CTL2_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250CF0)                                                  */
/*       SKX (0x40250CF0)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ8_CTL2_MC_MAIN_REG 0x07004CF0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-8 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ8_CTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ8_OFFSETCTL2_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250CF4)                                                  */
/*       SKX (0x40250CF4)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ8_OFFSETCTL2_MC_MAIN_REG 0x07004CF4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-8 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ8_OFFSETCTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ9_CTL2_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250CF8)                                                  */
/*       SKX (0x40250CF8)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ9_CTL2_MC_MAIN_REG 0x07004CF8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-9 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ9_CTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ9_OFFSETCTL2_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250CFC)                                                  */
/*       SKX (0x40250CFC)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ9_OFFSETCTL2_MC_MAIN_REG 0x07004CFC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Sub-Sequence-9 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ9_OFFSETCTL2_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ0_CTL3_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250D00)                                                  */
/*       SKX (0x40250D00)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ0_CTL3_MC_MAIN_REG 0x07004D00
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-0 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ0_CTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ0_OFFSETCTL3_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250D04)                                                  */
/*       SKX (0x40250D04)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ0_OFFSETCTL3_MC_MAIN_REG 0x07004D04
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-0 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ0_OFFSETCTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ1_CTL3_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250D08)                                                  */
/*       SKX (0x40250D08)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ1_CTL3_MC_MAIN_REG 0x07004D08
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-1 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ1_CTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ1_OFFSETCTL3_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250D0C)                                                  */
/*       SKX (0x40250D0C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ1_OFFSETCTL3_MC_MAIN_REG 0x07004D0C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-1 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ1_OFFSETCTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ2_CTL3_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250D10)                                                  */
/*       SKX (0x40250D10)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ2_CTL3_MC_MAIN_REG 0x07004D10
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-2 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ2_CTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ2_OFFSETCTL3_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250D14)                                                  */
/*       SKX (0x40250D14)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ2_OFFSETCTL3_MC_MAIN_REG 0x07004D14
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-2 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ2_OFFSETCTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ3_CTL3_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250D18)                                                  */
/*       SKX (0x40250D18)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ3_CTL3_MC_MAIN_REG 0x07004D18
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-3 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ3_CTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ3_OFFSETCTL3_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250D1C)                                                  */
/*       SKX (0x40250D1C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ3_OFFSETCTL3_MC_MAIN_REG 0x07004D1C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-3 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ3_OFFSETCTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ4_CTL3_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250D20)                                                  */
/*       SKX (0x40250D20)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ4_CTL3_MC_MAIN_REG 0x07004D20
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-4 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ4_CTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ4_OFFSETCTL3_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250D24)                                                  */
/*       SKX (0x40250D24)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ4_OFFSETCTL3_MC_MAIN_REG 0x07004D24
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-4 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ4_OFFSETCTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ5_CTL3_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250D28)                                                  */
/*       SKX (0x40250D28)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ5_CTL3_MC_MAIN_REG 0x07004D28
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-5 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ5_CTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ5_OFFSETCTL3_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250D2C)                                                  */
/*       SKX (0x40250D2C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ5_OFFSETCTL3_MC_MAIN_REG 0x07004D2C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-5 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ5_OFFSETCTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ6_CTL3_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250D30)                                                  */
/*       SKX (0x40250D30)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ6_CTL3_MC_MAIN_REG 0x07004D30
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-6 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ6_CTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ6_OFFSETCTL3_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250D34)                                                  */
/*       SKX (0x40250D34)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ6_OFFSETCTL3_MC_MAIN_REG 0x07004D34
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-6 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ6_OFFSETCTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ7_CTL3_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250D38)                                                  */
/*       SKX (0x40250D38)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ7_CTL3_MC_MAIN_REG 0x07004D38
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-7 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ7_CTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ7_OFFSETCTL3_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250D3C)                                                  */
/*       SKX (0x40250D3C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ7_OFFSETCTL3_MC_MAIN_REG 0x07004D3C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-7 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ7_OFFSETCTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ8_CTL3_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250D40)                                                  */
/*       SKX (0x40250D40)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ8_CTL3_MC_MAIN_REG 0x07004D40
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-8 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ8_CTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ8_OFFSETCTL3_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250D44)                                                  */
/*       SKX (0x40250D44)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ8_OFFSETCTL3_MC_MAIN_REG 0x07004D44
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-8 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ8_OFFSETCTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ9_CTL3_MC_MAIN_REG supported on:                                */
/*       SKX_A0 (0x40250D48)                                                  */
/*       SKX (0x40250D48)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ9_CTL3_MC_MAIN_REG 0x07004D48
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-9 Control -
 * CPGC#_CH#_SUBSEQ#_CTL defines the controls for a particular subsequence.
 */
typedef union {
  struct {
    UINT32 num_cachelines : 7;
    /* num_cachelines - Bits[6:0], RW_LB, default = 7'b0000000 
       Number_ of_Cachelines defines how many cachelines must be transmitted before a 
       base subsequence or a particular offset direction 
       (row and/or column) is considered completed.
     */
    UINT32 num_cachelines_scale : 1;
    /* num_cachelines_scale - Bits[7:7], RW_LB, default = 1'b0 
       Number_of_Cachelines operates as a linear or exponential counter based on the 
       value of Number_Of_Cachelines_Scale 
     */
    UINT32 subseq_wait : 12;
    /* subseq_wait - Bits[19:8], RW_LB, default = 12'h0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 subseq_type : 4;
    /* subseq_type - Bits[23:20], RW_LB, default = 4'b0000 
       Defines what type of operation a particular Subsequence will be:
       0000: Base Read
       0001: Base Write
       0010: Base Read Write
       0011: Base Write Read
       0100: Offset Read
       0101: Offset Write
     */
    UINT32 subseq_wait_bit12 : 1;
    /* subseq_wait_bit12 - Bits[24:24], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 savecurr_ba_start : 1;
    /* savecurr_ba_start - Bits[25:25], RW_LB, default = 1'b0 
       Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the 
       following actions must occur: 
       1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must 
       be written into the corresponding 
       fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
       2) In the case where both Save_Current_Base_Address_To_Start = 1 and 
       Reset_Current_Base_Address_To_Start = 1 then only 
       Save_Current_Base_Address_To_Start = 1 will take effect and 
       Reset_Current_Base_Address_To_Start = 1 will be ignored. 
     */
    UINT32 rstcurr_ba_start : 1;
    /* rstcurr_ba_start - Bits[26:26], RW_LB, default = 1'b0 
       Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the 
       following actions must occur:Base 
       Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized 
       to the Base Starting Address 
       (CPGC#_CH#_SEQ_BASE_ADDR_START).
     */
    UINT32 dataecc_addrinv : 2;
    /* dataecc_addrinv - Bits[28:27], RW_LB, default = 2'b00 
       Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of 
       the Column and Row Base address fields. 
     */
    UINT32 subseq_wait_bit13 : 1;
    /* subseq_wait_bit13 - Bits[29:29], RW_LB, default = 1'b0 
       # of DCLK cycles between completion of the current sub-sequence and beginning 
       the next sub-sequence. 
       The wait period is considered to be part of this subsequence for
       considering any logical action. Subsequence wait is 14 bits wide and
       is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
     */
    UINT32 inv_dataecc : 1;
    /* inv_dataecc - Bits[30:30], RW_LB, default = 1'b0 
       Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the 
       given subsequence which is then applied 
       to the logical output of any Address_Invesion to determine the final polarity 
       for the current write or read. 
     */
    UINT32 stop_baseseq_wrptrig : 1;
    /* stop_baseseq_wrptrig - Bits[31:31], RW_LB, default = 1'b0 
       If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap 
       Trigger that occurs will immediately force 
       a transition to the next Subsequence after the Subsequence_Wait.
       Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and 
       CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
       former causes the subsequence to end and the latter causes the sequence to end.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ9_CTL3_MC_MAIN_STRUCT;


/* CPGC_SUBSEQ9_OFFSETCTL3_MC_MAIN_REG supported on:                          */
/*       SKX_A0 (0x40250D4C)                                                  */
/*       SKX (0x40250D4C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SUBSEQ9_OFFSETCTL3_MC_MAIN_REG 0x07004D4C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Sub-Sequence-9 Offset Control -
 * CPGC#_CH#_SUBSEQ#_OFFSET_CTL defines the controls for a particular subsequence 
 * in the case where the Subsequence_Type is set 
 * to an be an OFFSET (0x100 or 0x101).
 */
typedef union {
  struct {
    UINT32 offadd_updrate : 5;
    /* offadd_updrate - Bits[4:0], RW_LB, default = 5'b00000 
       Offset_Address_Update_Rate determines the rate that the Current Offset Address 
       is updated. 
     */
    UINT32 rsvd_5 : 3;
    /* rsvd_5 - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_rptrate : 5;
    /* base_subseq_rptrate - Bits[12:8], RW_LB, default = 5'b00000 
       When the Subsequence_Type is set to an offset operation then 
       Base_Subsequence_Repeat_Rate determines how often 
       the Base_Subsequence_Type operation occurs for 1 cacheline.
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 coloff_wrptrig_enb : 1;
    /* coloff_wrptrig_enb - Bits[15:15], RW_LB, default = 1'b0  */
    UINT32 rowoff_wrptrig_enb : 1;
    /* rowoff_wrptrig_enb - Bits[16:16], RW_LB, default = 1'b0  */
    UINT32 rsvd_17 : 3;
    /* rsvd_17 - Bits[19:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_subseq_type : 1;
    /* base_subseq_type - Bits[20:20], RW_LB, default = 1'b0 
       Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is 
       performed for one command based on other fields. 
       
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_order : 1;
    /* col_inc_order - Bits[24:24], RW_LB, default = 1'b0  */
    UINT32 rsvd_25 : 1;
    /* rsvd_25 - Bits[25:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 col_inc_enb : 1;
    /* col_inc_enb - Bits[26:26], RW_LB, default = 1'b0  */
    UINT32 row_inc_order : 1;
    /* row_inc_order - Bits[27:27], RW_LB, default = 1'b0  */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_inc_enb : 1;
    /* row_inc_enb - Bits[29:29], RW_LB, default = 1'b0  */
    UINT32 base_inv_dataecc : 1;
    /* base_inv_dataecc - Bits[30:30], RW_LB, default = 1'b0  */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SUBSEQ9_OFFSETCTL3_MC_MAIN_STRUCT;


/* CPGC_SEQ_LRRANKLG2PHYMAP0_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250D50)                                                  */
/*       SKX (0x40250D50)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_LRRANKLG2PHYMAP0_MC_MAIN_REG 0x07004D50
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC LRDIMM Rank Mapping: Channel-0 Subsequence Logical to Physical Rank Lookup 
 * Table - 
 * LRDIMM Rank Mapping
 */
typedef union {
  struct {
    UINT32 lr0_mapping : 3;
    /* lr0_mapping - Bits[2:0], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-0 mapping
     */
    UINT32 lr1_mapping : 3;
    /* lr1_mapping - Bits[5:3], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-1 mapping
     */
    UINT32 lr2_mapping : 3;
    /* lr2_mapping - Bits[8:6], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-2 mapping
     */
    UINT32 lr3_mapping : 3;
    /* lr3_mapping - Bits[11:9], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-3 mapping
     */
    UINT32 lr4_mapping : 3;
    /* lr4_mapping - Bits[14:12], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-4 mapping
     */
    UINT32 lr5_mapping : 3;
    /* lr5_mapping - Bits[17:15], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-5 mapping
     */
    UINT32 lr6_mapping : 3;
    /* lr6_mapping - Bits[20:18], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-6 mapping
     */
    UINT32 lr7_mapping : 3;
    /* lr7_mapping - Bits[23:21], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-7 mapping
     */
    UINT32 lrdimm_rank_mapping : 3;
    /* lrdimm_rank_mapping - Bits[26:24], RW_LB, default = 3'b000 
       lrdimm_rank_mapping is a 3-bit field that maps which type of LRDIMM/3ds devices 
       have been populated in the system. 
       3'b000: No subranks. ddr3 will use row_addr[15:0], ddr4 will use row_addr[17:0]
       3'b001: subranks appended after A[14]
       3'b010: subranks appended after A[15]
       3'b011: subranks appended after A[13]; for ddr4 only
       3'b100: subranks appended after A[16]; for ddr4 only
       3'b101: subranks appended after A[17]; for ddr4 only
       3'b110-3'b111: Reserved
       Note: Subrank information is obtained from lr*_mapping fields in this register.
     */
    UINT32 rsvd : 5;
    /* rsvd - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_LRRANKLG2PHYMAP0_MC_MAIN_STRUCT;


/* CPGC_SEQ_LRRANKLG2PHYMAP1_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250D54)                                                  */
/*       SKX (0x40250D54)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_LRRANKLG2PHYMAP1_MC_MAIN_REG 0x07004D54
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC LRDIMM Rank Mapping: Channel-1 Subsequence Logical to Physical Rank Lookup 
 * Table - 
 * LRDIMM Rank Mapping
 */
typedef union {
  struct {
    UINT32 lr0_mapping : 3;
    /* lr0_mapping - Bits[2:0], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-0 mapping
     */
    UINT32 lr1_mapping : 3;
    /* lr1_mapping - Bits[5:3], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-1 mapping
     */
    UINT32 lr2_mapping : 3;
    /* lr2_mapping - Bits[8:6], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-2 mapping
     */
    UINT32 lr3_mapping : 3;
    /* lr3_mapping - Bits[11:9], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-3 mapping
     */
    UINT32 lr4_mapping : 3;
    /* lr4_mapping - Bits[14:12], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-4 mapping
     */
    UINT32 lr5_mapping : 3;
    /* lr5_mapping - Bits[17:15], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-5 mapping
     */
    UINT32 lr6_mapping : 3;
    /* lr6_mapping - Bits[20:18], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-6 mapping
     */
    UINT32 lr7_mapping : 3;
    /* lr7_mapping - Bits[23:21], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-7 mapping
     */
    UINT32 lrdimm_rank_mapping : 3;
    /* lrdimm_rank_mapping - Bits[26:24], RW_LB, default = 3'b000 
       lrdimm_rank_mapping is a 3-bit field that maps which type of LRDIMM/3ds devices 
       have been populated in the system. 
       3'b000: No subranks. ddr3 will use row_addr[15:0], ddr4 will use row_addr[17:0]
       3'b001: subranks appended after A[14]
       3'b010: subranks appended after A[15]
       3'b011: subranks appended after A[13]; for ddr4 only
       3'b100: subranks appended after A[16]; for ddr4 only
       3'b101: subranks appended after A[17]; for ddr4 only
       3'b110-3'b111: Reserved
       Note: Subrank information is obtained from lr*_mapping fields in this register.
     */
    UINT32 rsvd : 5;
    /* rsvd - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_LRRANKLG2PHYMAP1_MC_MAIN_STRUCT;


/* CPGC_SEQ_LRRANKLG2PHYMAP2_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250D58)                                                  */
/*       SKX (0x40250D58)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_LRRANKLG2PHYMAP2_MC_MAIN_REG 0x07004D58
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC LRDIMM Rank Mapping: Channel-2 Subsequence Logical to Physical Rank Lookup 
 * Table - 
 * LRDIMM Rank Mapping
 */
typedef union {
  struct {
    UINT32 lr0_mapping : 3;
    /* lr0_mapping - Bits[2:0], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-0 mapping
     */
    UINT32 lr1_mapping : 3;
    /* lr1_mapping - Bits[5:3], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-1 mapping
     */
    UINT32 lr2_mapping : 3;
    /* lr2_mapping - Bits[8:6], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-2 mapping
     */
    UINT32 lr3_mapping : 3;
    /* lr3_mapping - Bits[11:9], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-3 mapping
     */
    UINT32 lr4_mapping : 3;
    /* lr4_mapping - Bits[14:12], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-4 mapping
     */
    UINT32 lr5_mapping : 3;
    /* lr5_mapping - Bits[17:15], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-5 mapping
     */
    UINT32 lr6_mapping : 3;
    /* lr6_mapping - Bits[20:18], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-6 mapping
     */
    UINT32 lr7_mapping : 3;
    /* lr7_mapping - Bits[23:21], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-7 mapping
     */
    UINT32 lrdimm_rank_mapping : 3;
    /* lrdimm_rank_mapping - Bits[26:24], RW_LB, default = 3'b000 
       lrdimm_rank_mapping is a 3-bit field that maps which type of LRDIMM/3ds devices 
       have been populated in the system. 
       3'b000: No subranks. ddr3 will use row_addr[15:0], ddr4 will use row_addr[17:0]
       3'b001: subranks appended after A[14]
       3'b010: subranks appended after A[15]
       3'b011: subranks appended after A[13]; for ddr4 only
       3'b100: subranks appended after A[16]; for ddr4 only
       3'b101: subranks appended after A[17]; for ddr4 only
       3'b110-3'b111: Reserved
       Note: Subrank information is obtained from lr*_mapping fields in this register.
     */
    UINT32 rsvd : 5;
    /* rsvd - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_LRRANKLG2PHYMAP2_MC_MAIN_STRUCT;


/* CPGC_SEQ_LRRANKLG2PHYMAP3_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250D5C)                                                  */
/*       SKX (0x40250D5C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_LRRANKLG2PHYMAP3_MC_MAIN_REG 0x07004D5C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC LRDIMM Rank Mapping: Channel-3 Subsequence Logical to Physical Rank Lookup 
 * Table - 
 * LRDIMM Rank Mapping
 */
typedef union {
  struct {
    UINT32 lr0_mapping : 3;
    /* lr0_mapping - Bits[2:0], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-0 mapping
     */
    UINT32 lr1_mapping : 3;
    /* lr1_mapping - Bits[5:3], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-1 mapping
     */
    UINT32 lr2_mapping : 3;
    /* lr2_mapping - Bits[8:6], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-2 mapping
     */
    UINT32 lr3_mapping : 3;
    /* lr3_mapping - Bits[11:9], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-3 mapping
     */
    UINT32 lr4_mapping : 3;
    /* lr4_mapping - Bits[14:12], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-4 mapping
     */
    UINT32 lr5_mapping : 3;
    /* lr5_mapping - Bits[17:15], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-5 mapping
     */
    UINT32 lr6_mapping : 3;
    /* lr6_mapping - Bits[20:18], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-6 mapping
     */
    UINT32 lr7_mapping : 3;
    /* lr7_mapping - Bits[23:21], RW_LB, default = 3'b000 
       ddr3_lrdim/ddr4 subrank-7 mapping
     */
    UINT32 lrdimm_rank_mapping : 3;
    /* lrdimm_rank_mapping - Bits[26:24], RW_LB, default = 3'b000 
       lrdimm_rank_mapping is a 3-bit field that maps which type of LRDIMM/3ds devices 
       have been populated in the system. 
       3'b000: No subranks. ddr3 will use row_addr[15:0], ddr4 will use row_addr[17:0]
       3'b001: subranks appended after A[14]
       3'b010: subranks appended after A[15]
       3'b011: subranks appended after A[13]; for ddr4 only
       3'b100: subranks appended after A[16]; for ddr4 only
       3'b101: subranks appended after A[17]; for ddr4 only
       3'b110-3'b111: Reserved
       Note: Subrank information is obtained from lr*_mapping fields in this register.
     */
    UINT32 rsvd : 5;
    /* rsvd - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_LRRANKLG2PHYMAP3_MC_MAIN_STRUCT;


/* CPGC_ERR_TRIGCTL_MC_MAIN_REG supported on:                                 */
/*       SKX_A0 (0x40250D60)                                                  */
/*       SKX (0x40250D60)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_ERR_TRIGCTL_MC_MAIN_REG 0x07004D60
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel Err Trigger Control -
 * Enables and controls how uBP Triggers behave in relation to specific CPGC 
 * events. 
 */
typedef union {
  struct {
    UINT32 trigger_in_global_start : 1;
    /* trigger_in_global_start - Bits[0:0], RW_LB, default = 1'b0 
       Setting Trigger_In_Global_Start enables a test to start based on a uBP trigger.
       This capability enables a test to start in a synchronous fashion with respect to 
       an external event. 
       This is required to allow synchronous CPGC operation with external test hardware 
       (HVM Tester, BERT, etc.). 
       When Trigger_In_Global_Start is set the uBP used to start a CPGC test will set 
       REUT#_GLOBAL_CTL.Global_Start_Test on a deterministic boundary. 
     */
    UINT32 trigger_out_global_start : 1;
    /* trigger_out_global_start - Bits[1:1], RW_LB, default = 1'b0 
       Setting Trigger_Out_Global_Start will generate a deterministic external uBP 
       trigger that is based on Global_Start_Test being set. 
       This capability enables a test to start in a synchronous fashion with respect to 
       an external event. 
       This is required to allow synchronous CPGC operation with external test hardware 
       (HVM Tester, BERT, etc.). 
       When Trigger_OUT_Global_Start is set a deterministic uBP trigger is generated 
       each time REUT#_GLOBAL_CTL.Global_Start_Test is set. 
     */
    UINT32 rsvd_2 : 5;
    /* rsvd_2 - Bits[6:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 trigger_out_on_err_0 : 1;
    /* trigger_out_on_err_0 - Bits[7:7], RW_LB, default = 1'b0 
       Setting Trigger_Out_On_Error_0 enables external equipment to be synced 
       deterministically to when any bit in Data_Error_Status or ECC_Error_Status on 
       channel 0 is set. 
       Once any bit in Data_Error_Status or ECC_Error_Status on channel 0 is set no 
       additional triggers will be generated. 
       This capability enables external test equipment to be synched to an error event 
       within CPGC on channel 0. 
       This is required to allow synchronous CPGC operation with external test hardware 
       (HVM Tester, BERT, etc.). 
       When Trigger_Out_On_Error_0 is set a deterministic uBP trigger is generated in 
       relation to when REUT_CH#_ERR_DATA_STATUS.REUT_CH#_ERR_CTL.Data_Error_Status or 
       REUT_CH#_ERR_ECC_CHUNK_RANK_BYTE_NTH_STATUS.ECC_Error_Status becomes non zero on 
       channel 0. 
     */
    UINT32 trigger_out_on_err_1 : 1;
    /* trigger_out_on_err_1 - Bits[8:8], RW_LB, default = 1'b0 
       Setting Trigger_Out_On_Error_1 enables external equipment to be synced 
       deterministically to when any bit in Data_Error_Status or ECC_Error_Status on 
       channel 1 is set. 
       Once any bit in Data_Error_Status or ECC_Error_Status on channel 1 is set no 
       additional triggers will be generated. 
       This capability enables external test equipment to be synched to an error event 
       within CPGC on channel 1. 
       This is required to allow synchronous CPGC operation with external test hardware 
       (HVM Tester, BERT, etc.). 
       When Trigger_Out_On_Error_1 is set a deterministic uBP trigger is generated in 
       relation to when REUT_CH#_ERR_DATA_STATUS.REUT_CH#_ERR_CTL.Data_Error_Status or 
       REUT_CH#_ERR_ECC_CHUNK_RANK_BYTE_NTH_STATUS.ECC_Error_Status becomes non zero on 
       channel 1. 
     */
    UINT32 trigger_out_on_err_2 : 1;
    /* trigger_out_on_err_2 - Bits[9:9], RW_LB, default = 1'b0 
       Setting Trigger_Out_On_Error_2 enables external equipment to be synced 
       deterministically to when any bit in Data_Error_Status or ECC_Error_Status on 
       channel 2 is set. 
       Once any bit in Data_Error_Status or ECC_Error_Status on channel 2 is set no 
       additional triggers will be generated. 
       This capability enables external test equipment to be synched to an error event 
       within CPGC on channel 2. 
       This is required to allow synchronous CPGC operation with external test hardware 
       (HVM Tester, BERT, etc.). 
       When Trigger_Out_On_Error_2 is set a deterministic uBP trigger is generated in 
       relation to when REUT_CH#_ERR_DATA_STATUS.REUT_CH#_ERR_CTL.Data_Error_Status or 
       REUT_CH#_ERR_ECC_CHUNK_RANK_BYTE_NTH_STATUS.ECC_Error_Status becomes non zero on 
       channel 2. 
     */
    UINT32 trigger_out_on_err_3 : 1;
    /* trigger_out_on_err_3 - Bits[10:10], RW_LB, default = 1'b0 
       Setting Trigger_Out_On_Error_3 enables external equipment to be synced 
       deterministically to when any bit in Data_Error_Status or ECC_Error_Status on 
       channel 3 is set. 
       Once any bit in Data_Error_Status or ECC_Error_Status on channel 3 is set no 
       additional triggers will be generated. 
       This capability enables external test equipment to be synched to an error event 
       within CPGC on channel 3. 
       This is required to allow synchronous CPGC operation with external test hardware 
       (HVM Tester, BERT, etc.). 
       When Trigger_Out_On_Error_3 is set a deterministic uBP trigger is generated in 
       relation to when REUT_CH#_ERR_DATA_STATUS.REUT_CH#_ERR_CTL.Data_Error_Status or 
       REUT_CH#_ERR_ECC_CHUNK_RANK_BYTE_NTH_STATUS.ECC_Error_Status becomes non zero on 
       channel 3. 
     */
    UINT32 rsvd_11 : 4;
    /* rsvd_11 - Bits[14:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 trigout_on_ch_testdone_sts_0 : 1;
    /* trigout_on_ch_testdone_sts_0 - Bits[15:15], RW_LB, default = 1'b0 
       Setting trigout_on_ch_testdone_sts_0 enables external equipment to be synced 
       deterministically to the exact moment when trigout_on_ch_testdone_sts_0 is set. 
       This capability enables external test equipment to be deterministically synched 
       to when Channel 0 CPGC test is completed. 
       This is required to allow synchronous CPGC operation with external test hardware 
       (HVM Tester, BERT, etc.). 
       When trigout_on_ch_testdone_sts_0 is set a deterministic externally viewable uBP 
       trigger is generated each time REUT#_GLOBAL_ERR.Channel_Test_Done_Status_0 is 
       set to 1. 
     */
    UINT32 trigout_on_ch_testdone_sts_1 : 1;
    /* trigout_on_ch_testdone_sts_1 - Bits[16:16], RW_LB, default = 1'b0 
       Setting trigout_on_ch_testdone_sts_1 enables external equipment to be synced 
       deterministically to the exact moment when trigout_on_ch_testdone_sts_1 is set. 
       This capability enables external test equipment to be deterministically synched 
       to when Channel 1 CPGC test is completed. 
       This is required to allow synchronous CPGC operation with external test hardware 
       (HVM Tester, BERT, etc.). 
       When trigout_on_ch_testdone_sts_1 is set a deterministic externally viewable uBP 
       trigger is generated each time REUT#_GLOBAL_ERR.Channel_Test_Done_Status_1 is 
       set to 1. 
     */
    UINT32 trigout_on_ch_testdone_sts_2 : 1;
    /* trigout_on_ch_testdone_sts_2 - Bits[17:17], RW_LB, default = 1'b0 
       Setting trigout_on_ch_testdone_sts_2 enables external equipment to be synced 
       deterministically to the exact moment when trigout_on_ch_testdone_sts_2 is set. 
       This capability enables external test equipment to be deterministically synched 
       to when Channel 2 CPGC test is completed. 
       This is required to allow synchronous CPGC operation with external test hardware 
       (HVM Tester, BERT, etc.). 
       When trigout_on_ch_testdone_sts_2 is set a deterministic externally viewable uBP 
       trigger is generated each time REUT#_GLOBAL_ERR.Channel_Test_Done_Status_2 is 
       set to 1. 
     */
    UINT32 trigout_on_ch_testdone_sts_3 : 1;
    /* trigout_on_ch_testdone_sts_3 - Bits[18:18], RW_LB, default = 1'b0 
       Setting trigout_on_ch_testdone_sts_3 enables external equipment to be synced 
       deterministically to the exact moment when trigout_on_ch_testdone_sts_3 is set. 
       This capability enables external test equipment to be deterministically synched 
       to when Channel 3 CPGC test is completed. 
       This is required to allow synchronous CPGC operation with external test hardware 
       (HVM Tester, BERT, etc.). 
       When trigout_on_ch_testdone_sts_3 is set a deterministic externally viewable uBP 
       trigger is generated each time REUT#_GLOBAL_ERR.Channel_Test_Done_Status_3 is 
       set to 1. 
     */
    UINT32 rsvd_19 : 13;
    /* rsvd_19 - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_ERR_TRIGCTL_MC_MAIN_STRUCT;


/* CPGC_SEQ_DMYRDADDR_HI_MC_MAIN_REG supported on:                            */
/*       SKX_A0 (0x40250D64)                                                  */
/*       SKX (0x40250D64)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_DMYRDADDR_HI_MC_MAIN_REG 0x07004D64
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * Defines what Banks and the Starting Row Address for the Dummy Reads to occur.  
 * (for chs 2 and 3) 
 * Dummy Reads are defined as a qualified read request which will generate the 
 * necessary Activates and Precharges but no Read will occur. 
 */
typedef union {
  struct {
    UINT32 bank_mask2 : 16;
    /* bank_mask2 - Bits[15:0], RW_LB, default = 16'b0000000000000000 
       Refer to Bank_Mask0 for details
     */
    UINT32 bank_mask3 : 16;
    /* bank_mask3 - Bits[31:16], RW_LB, default = 16'b0000000000000000 
       Refer to Bank_Mask0 for details
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_DMYRDADDR_HI_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRSTART_HI0_MC_MAIN_REG supported on:                       */
/*       SKX_A0 (0x40250D68)                                                  */
/*       SKX (0x40250D68)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRSTART_HI0_MC_MAIN_REG 0x07004D68
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC#_CH#_SEQ_BASE_ADDR_START defines the starting base address of the sequence.
 */
typedef union {
  struct {
    UINT32 row_addr : 18;
    /* row_addr - Bits[17:0], RW_LB, default = 18'b000000000000000000 
       Starting Row Address
     */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_addr : 3;
    /* rank_addr - Bits[26:24], RW_LB, default = 3'b000 
       Starting Logical Rank Address
     */
    UINT32 rsvd_27 : 5;
    /* rsvd_27 - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRSTART_HI0_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRSTART_HI1_MC_MAIN_REG supported on:                       */
/*       SKX_A0 (0x40250D6C)                                                  */
/*       SKX (0x40250D6C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRSTART_HI1_MC_MAIN_REG 0x07004D6C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC#_CH#_SEQ_BASE_ADDR_START defines the starting base address of the sequence.
 */
typedef union {
  struct {
    UINT32 row_addr : 18;
    /* row_addr - Bits[17:0], RW_LB, default = 18'b000000000000000000 
       Starting Row Address
     */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_addr : 3;
    /* rank_addr - Bits[26:24], RW_LB, default = 3'b000 
       Starting Logical Rank Address
     */
    UINT32 rsvd_27 : 5;
    /* rsvd_27 - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRSTART_HI1_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRSTART_HI2_MC_MAIN_REG supported on:                       */
/*       SKX_A0 (0x40250D70)                                                  */
/*       SKX (0x40250D70)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRSTART_HI2_MC_MAIN_REG 0x07004D70
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC#_CH#_SEQ_BASE_ADDR_START defines the starting base address of the sequence.
 */
typedef union {
  struct {
    UINT32 row_addr : 18;
    /* row_addr - Bits[17:0], RW_LB, default = 18'b000000000000000000 
       Starting Row Address
     */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_addr : 3;
    /* rank_addr - Bits[26:24], RW_LB, default = 3'b000 
       Starting Logical Rank Address
     */
    UINT32 rsvd_27 : 5;
    /* rsvd_27 - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRSTART_HI2_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRSTART_HI3_MC_MAIN_REG supported on:                       */
/*       SKX_A0 (0x40250D74)                                                  */
/*       SKX (0x40250D74)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRSTART_HI3_MC_MAIN_REG 0x07004D74
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC#_CH#_SEQ_BASE_ADDR_START defines the starting base address of the sequence.
 */
typedef union {
  struct {
    UINT32 row_addr : 18;
    /* row_addr - Bits[17:0], RW_LB, default = 18'b000000000000000000 
       Starting Row Address
     */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_addr : 3;
    /* rank_addr - Bits[26:24], RW_LB, default = 3'b000 
       Starting Logical Rank Address
     */
    UINT32 rsvd_27 : 5;
    /* rsvd_27 - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRSTART_HI3_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRWRAP_HI0_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250D78)                                                  */
/*       SKX (0x40250D78)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRWRAP_HI0_MC_MAIN_REG 0x07004D78
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC#_CH#_SEQ_BASE_ADDR_WRAP defines the wrap base address of the sequence.
 */
typedef union {
  struct {
    UINT32 row_addr : 18;
    /* row_addr - Bits[17:0], RW_LB, default = 18'b000000000000000000 
       Same as field [6:0] for Row-Addr
     */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_addr : 3;
    /* rank_addr - Bits[26:24], RW_LB, default = 3'b000 
       Same as field [6:0] for Rank-Addr
     */
    UINT32 rsvd_27 : 5;
    /* rsvd_27 - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRWRAP_HI0_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRWRAP_HI1_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250D7C)                                                  */
/*       SKX (0x40250D7C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRWRAP_HI1_MC_MAIN_REG 0x07004D7C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC#_CH#_SEQ_BASE_ADDR_WRAP defines the wrap base address of the sequence.
 */
typedef union {
  struct {
    UINT32 row_addr : 18;
    /* row_addr - Bits[17:0], RW_LB, default = 18'b000000000000000000 
       Same as field [6:0] for Row-Addr
     */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_addr : 3;
    /* rank_addr - Bits[26:24], RW_LB, default = 3'b000 
       Same as field [6:0] for Rank-Addr
     */
    UINT32 rsvd_27 : 5;
    /* rsvd_27 - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRWRAP_HI1_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRWRAP_HI2_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250D80)                                                  */
/*       SKX (0x40250D80)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRWRAP_HI2_MC_MAIN_REG 0x07004D80
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC#_CH#_SEQ_BASE_ADDR_WRAP defines the wrap base address of the sequence.
 */
typedef union {
  struct {
    UINT32 row_addr : 18;
    /* row_addr - Bits[17:0], RW_LB, default = 18'b000000000000000000 
       Same as field [6:0] for Row-Addr
     */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_addr : 3;
    /* rank_addr - Bits[26:24], RW_LB, default = 3'b000 
       Same as field [6:0] for Rank-Addr
     */
    UINT32 rsvd_27 : 5;
    /* rsvd_27 - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRWRAP_HI2_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRWRAP_HI3_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250D84)                                                  */
/*       SKX (0x40250D84)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRWRAP_HI3_MC_MAIN_REG 0x07004D84
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC#_CH#_SEQ_BASE_ADDR_WRAP defines the wrap base address of the sequence.
 */
typedef union {
  struct {
    UINT32 row_addr : 18;
    /* row_addr - Bits[17:0], RW_LB, default = 18'b000000000000000000 
       Same as field [6:0] for Row-Addr
     */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_addr : 3;
    /* rank_addr - Bits[26:24], RW_LB, default = 3'b000 
       Same as field [6:0] for Rank-Addr
     */
    UINT32 rsvd_27 : 5;
    /* rsvd_27 - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRWRAP_HI3_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRCURR_HI0_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250D88)                                                  */
/*       SKX (0x40250D88)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRCURR_HI0_MC_MAIN_REG 0x07004D88
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC#_CH#_SEQ_BASE_ADDR_CURRENT defines the current base address of the 
 * sequence. 
 */
typedef union {
  struct {
    UINT32 row_addr : 18;
    /* row_addr - Bits[17:0], RO_V, default = 18'b000000000000000000 
       Current Base Row Address
     */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_addr : 3;
    /* rank_addr - Bits[26:24], RO_V, default = 3'b000 
       Current Base Logical Rank Address
     */
    UINT32 rsvd_27 : 5;
    /* rsvd_27 - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRCURR_HI0_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRCURR_HI1_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250D8C)                                                  */
/*       SKX (0x40250D8C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRCURR_HI1_MC_MAIN_REG 0x07004D8C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC#_CH#_SEQ_BASE_ADDR_CURRENT defines the current base address of the 
 * sequence. 
 */
typedef union {
  struct {
    UINT32 row_addr : 18;
    /* row_addr - Bits[17:0], RO_V, default = 18'b000000000000000000 
       Current Base Row Address
     */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_addr : 3;
    /* rank_addr - Bits[26:24], RO_V, default = 3'b000 
       Current Base Logical Rank Address
     */
    UINT32 rsvd_27 : 5;
    /* rsvd_27 - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRCURR_HI1_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRCURR_HI2_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250D90)                                                  */
/*       SKX (0x40250D90)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRCURR_HI2_MC_MAIN_REG 0x07004D90
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC#_CH#_SEQ_BASE_ADDR_CURRENT defines the current base address of the 
 * sequence. 
 */
typedef union {
  struct {
    UINT32 row_addr : 18;
    /* row_addr - Bits[17:0], RO_V, default = 18'b000000000000000000 
       Current Base Row Address
     */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_addr : 3;
    /* rank_addr - Bits[26:24], RO_V, default = 3'b000 
       Current Base Logical Rank Address
     */
    UINT32 rsvd_27 : 5;
    /* rsvd_27 - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRCURR_HI2_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRCURR_HI3_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250D94)                                                  */
/*       SKX (0x40250D94)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRCURR_HI3_MC_MAIN_REG 0x07004D94
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC#_CH#_SEQ_BASE_ADDR_CURRENT defines the current base address of the 
 * sequence. 
 */
typedef union {
  struct {
    UINT32 row_addr : 18;
    /* row_addr - Bits[17:0], RO_V, default = 18'b000000000000000000 
       Current Base Row Address
     */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_addr : 3;
    /* rank_addr - Bits[26:24], RO_V, default = 3'b000 
       Current Base Logical Rank Address
     */
    UINT32 rsvd_27 : 5;
    /* rsvd_27 - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRCURR_HI3_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRSAVE_LO0_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250D98)                                                  */
/*       SKX (0x40250D98)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRSAVE_LO0_MC_MAIN_REG 0x07004D98
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_addr : 18;
    /* column_addr - Bits[20:3], RW_LBV, default = 10'h0 
       Bits 20:13 are used only for DDRT addresses.
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_addr : 4;
    /* bank_addr - Bits[27:24], RW_LBV, default = 4'h0  */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRSAVE_LO0_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRSAVE_LO1_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250D9C)                                                  */
/*       SKX (0x40250D9C)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRSAVE_LO1_MC_MAIN_REG 0x07004D9C
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_addr : 18;
    /* column_addr - Bits[20:3], RW_LBV, default = 10'h0 
       Bits 20:13 are used only for DDRT addresses. 
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_addr : 4;
    /* bank_addr - Bits[27:24], RW_LBV, default = 4'h0  */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRSAVE_LO1_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRSAVE_LO2_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250DA0)                                                  */
/*       SKX (0x40250DA0)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRSAVE_LO2_MC_MAIN_REG 0x07004DA0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_addr : 18;
    /* column_addr - Bits[20:3], RW_LBV, default = 10'h0 
       Bits 20:13 are used only for DDRT addresses. 
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_addr : 4;
    /* bank_addr - Bits[27:24], RW_LBV, default = 4'h0  */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRSAVE_LO2_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRSAVE_LO3_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250DA4)                                                  */
/*       SKX (0x40250DA4)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRSAVE_LO3_MC_MAIN_REG 0x07004DA4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 column_addr : 18;
    /* column_addr - Bits[20:3], RW_LBV, default = 10'h0 
       Bits 20:13 are used only for DDRT addresses. 
     */
    UINT32 rsvd_21 : 3;
    /* rsvd_21 - Bits[23:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 bank_addr : 4;
    /* bank_addr - Bits[27:24], RW_LBV, default = 4'h0  */
    UINT32 rsvd_28 : 4;
    /* rsvd_28 - Bits[31:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRSAVE_LO3_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRSAVE_HI0_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250DA8)                                                  */
/*       SKX (0x40250DA8)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRSAVE_HI0_MC_MAIN_REG 0x07004DA8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 row_addr : 18;
    /* row_addr - Bits[17:0], RW_LBV, default = 18'h0  */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_addr : 3;
    /* rank_addr - Bits[26:24], RW_LBV, default = 3'h0  */
    UINT32 rsvd_27 : 5;
    /* rsvd_27 - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRSAVE_HI0_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRSAVE_HI1_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250DAC)                                                  */
/*       SKX (0x40250DAC)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRSAVE_HI1_MC_MAIN_REG 0x07004DAC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 row_addr : 18;
    /* row_addr - Bits[17:0], RW_LBV, default = 18'h0  */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_addr : 3;
    /* rank_addr - Bits[26:24], RW_LBV, default = 3'h0  */
    UINT32 rsvd_27 : 5;
    /* rsvd_27 - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRSAVE_HI1_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRSAVE_HI2_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250DB0)                                                  */
/*       SKX (0x40250DB0)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRSAVE_HI2_MC_MAIN_REG 0x07004DB0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 row_addr : 18;
    /* row_addr - Bits[17:0], RW_LBV, default = 18'h0  */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_addr : 3;
    /* rank_addr - Bits[26:24], RW_LBV, default = 3'h0  */
    UINT32 rsvd_27 : 5;
    /* rsvd_27 - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRSAVE_HI2_MC_MAIN_STRUCT;


/* CPGC_SEQ_BASEADDRSAVE_HI3_MC_MAIN_REG supported on:                        */
/*       SKX_A0 (0x40250DB4)                                                  */
/*       SKX (0x40250DB4)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_BASEADDRSAVE_HI3_MC_MAIN_REG 0x07004DB4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 */
typedef union {
  struct {
    UINT32 row_addr : 18;
    /* row_addr - Bits[17:0], RW_LBV, default = 18'h0  */
    UINT32 rsvd_18 : 6;
    /* rsvd_18 - Bits[23:18], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rank_addr : 3;
    /* rank_addr - Bits[26:24], RW_LBV, default = 3'h0  */
    UINT32 rsvd_27 : 5;
    /* rsvd_27 - Bits[31:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_BASEADDRSAVE_HI3_MC_MAIN_STRUCT;


/* CPGC_SEQ_OFFADDRCUR0_ROW_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x40250DB8)                                                  */
/*       SKX (0x40250DB8)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_OFFADDRCUR0_ROW_MC_MAIN_REG 0x07004DB8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Subsequence Offset Address -
 * Only Row and Column bits are used in an Offset Sequence Type 
 * (CPGC#_CH#_SUBSEQ#_CTL.subsequence_type = (0x0100 or 0x0101)) and thus the 
 *         Rank and Bank address will always be equal to and Row and Column address 
 * will never be equal to their respective fields in 
 * CPGC_CH#_SEQ_BASE_ADDR_CURRENT. 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 12;
    /* rsvd_0 - Bits[11:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_addr : 18;
    /* row_addr - Bits[29:12], RO_V, default = 18'b000000000000000000 
       Current Row Offset Address
     */
    UINT32 rsvd_30 : 2;
    /* rsvd_30 - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_OFFADDRCUR0_ROW_MC_MAIN_STRUCT;


/* CPGC_SEQ_OFFADDRCUR1_ROW_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x40250DBC)                                                  */
/*       SKX (0x40250DBC)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_OFFADDRCUR1_ROW_MC_MAIN_REG 0x07004DBC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Subsequence Offset Address -
 * Only Row and Column bits are used in an Offset Sequence Type 
 * (CPGC#_CH#_SUBSEQ#_CTL.subsequence_type = (0x0100 or 0x0101)) and thus the 
 *         Rank and Bank address will always be equal to and Row and Column address 
 * will never be equal to their respective fields in 
 * CPGC_CH#_SEQ_BASE_ADDR_CURRENT. 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 12;
    /* rsvd_0 - Bits[11:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_addr : 18;
    /* row_addr - Bits[29:12], RO_V, default = 18'b000000000000000000 
       Current Row Offset Address
     */
    UINT32 rsvd_30 : 2;
    /* rsvd_30 - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_OFFADDRCUR1_ROW_MC_MAIN_STRUCT;


/* CPGC_SEQ_OFFADDRCUR2_ROW_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x40250DC0)                                                  */
/*       SKX (0x40250DC0)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_OFFADDRCUR2_ROW_MC_MAIN_REG 0x07004DC0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Subsequence Offset Address -
 * Only Row and Column bits are used in an Offset Sequence Type 
 * (CPGC#_CH#_SUBSEQ#_CTL.subsequence_type = (0x0100 or 0x0101)) and thus the 
 *         Rank and Bank address will always be equal to and Row and Column address 
 * will never be equal to their respective fields in 
 * CPGC_CH#_SEQ_BASE_ADDR_CURRENT. 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 12;
    /* rsvd_0 - Bits[11:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_addr : 18;
    /* row_addr - Bits[29:12], RO_V, default = 18'b000000000000000000 
       Current Row Offset Address
     */
    UINT32 rsvd_30 : 2;
    /* rsvd_30 - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_OFFADDRCUR2_ROW_MC_MAIN_STRUCT;


/* CPGC_SEQ_OFFADDRCUR3_ROW_MC_MAIN_REG supported on:                         */
/*       SKX_A0 (0x40250DC4)                                                  */
/*       SKX (0x40250DC4)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_OFFADDRCUR3_ROW_MC_MAIN_REG 0x07004DC4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-3 Subsequence Offset Address -
 * Only Row and Column bits are used in an Offset Sequence Type 
 * (CPGC#_CH#_SUBSEQ#_CTL.subsequence_type = (0x0100 or 0x0101)) and thus the 
 *         Rank and Bank address will always be equal to and Row and Column address 
 * will never be equal to their respective fields in 
 * CPGC_CH#_SEQ_BASE_ADDR_CURRENT. 
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 12;
    /* rsvd_0 - Bits[11:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 row_addr : 18;
    /* row_addr - Bits[29:12], RO_V, default = 18'b000000000000000000 
       Current Row Offset Address
     */
    UINT32 rsvd_30 : 2;
    /* rsvd_30 - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_OFFADDRCUR3_ROW_MC_MAIN_STRUCT;






/* CPGC_SEQ_X8VLRANKLG2PHYMAP0_MC_MAIN_REG supported on:                      */
/*       SKX_A0 (0x40250DD0)                                                  */
/*       SKX (0x40250DD0)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_X8VLRANKLG2PHYMAP0_MC_MAIN_REG 0x07004DD0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-0 Subsequence x8 Virtual Lock Mode Logical to Physical Rank Lookup 
 * Table for buddy rank. 
 */
typedef union {
  struct {
    UINT32 br0_mapping : 3;
    /* br0_mapping - Bits[2:0], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 0 mapping
     */
    UINT32 rsvd_3 : 1;
    /* rsvd_3 - Bits[3:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br1_mapping : 3;
    /* br1_mapping - Bits[6:4], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 1 mapping
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br2_mapping : 3;
    /* br2_mapping - Bits[10:8], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 2 mapping
     */
    UINT32 rsvd_11 : 1;
    /* rsvd_11 - Bits[11:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br3_mapping : 3;
    /* br3_mapping - Bits[14:12], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 3 mapping
     */
    UINT32 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br4_mapping : 3;
    /* br4_mapping - Bits[18:16], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 4 mapping
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br5_mapping : 3;
    /* br5_mapping - Bits[22:20], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 5 mapping
     */
    UINT32 rsvd_23 : 1;
    /* rsvd_23 - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br6_mapping : 3;
    /* br6_mapping - Bits[26:24], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 6 mapping
     */
    UINT32 rsvd_27 : 1;
    /* rsvd_27 - Bits[27:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br7_mapping : 3;
    /* br7_mapping - Bits[30:28], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 7 mapping
     */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_X8VLRANKLG2PHYMAP0_MC_MAIN_STRUCT;


/* CPGC_SEQ_X8VLRANKLG2PHYMAP1_MC_MAIN_REG supported on:                      */
/*       SKX_A0 (0x40250DD4)                                                  */
/*       SKX (0x40250DD4)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_X8VLRANKLG2PHYMAP1_MC_MAIN_REG 0x07004DD4
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-1 Subsequence x8 Virtual Lock Mode Logical to Physical Rank Lookup 
 * Table for buddy rank. 
 */
typedef union {
  struct {
    UINT32 br0_mapping : 3;
    /* br0_mapping - Bits[2:0], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 0 mapping
     */
    UINT32 rsvd_3 : 1;
    /* rsvd_3 - Bits[3:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br1_mapping : 3;
    /* br1_mapping - Bits[6:4], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 1 mapping
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br2_mapping : 3;
    /* br2_mapping - Bits[10:8], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 2 mapping
     */
    UINT32 rsvd_11 : 1;
    /* rsvd_11 - Bits[11:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br3_mapping : 3;
    /* br3_mapping - Bits[14:12], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 3 mapping
     */
    UINT32 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br4_mapping : 3;
    /* br4_mapping - Bits[18:16], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 4 mapping
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br5_mapping : 3;
    /* br5_mapping - Bits[22:20], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 5 mapping
     */
    UINT32 rsvd_23 : 1;
    /* rsvd_23 - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br6_mapping : 3;
    /* br6_mapping - Bits[26:24], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 6 mapping
     */
    UINT32 rsvd_27 : 1;
    /* rsvd_27 - Bits[27:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br7_mapping : 3;
    /* br7_mapping - Bits[30:28], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 7 mapping
     */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_X8VLRANKLG2PHYMAP1_MC_MAIN_STRUCT;


/* CPGC_SEQ_X8VLRANKLG2PHYMAP2_MC_MAIN_REG supported on:                      */
/*       SKX_A0 (0x40250DD8)                                                  */
/*       SKX (0x40250DD8)                                                     */
/* Register default value:              0x00000000                            */
#define CPGC_SEQ_X8VLRANKLG2PHYMAP2_MC_MAIN_REG 0x07004DD8
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * CPGC Channel-2 Subsequence x8 Virtual Lock Mode Logical to Physical Rank Lookup 
 * Table for buddy rank. 
 */
typedef union {
  struct {
    UINT32 br0_mapping : 3;
    /* br0_mapping - Bits[2:0], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 0 mapping
     */
    UINT32 rsvd_3 : 1;
    /* rsvd_3 - Bits[3:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br1_mapping : 3;
    /* br1_mapping - Bits[6:4], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 1 mapping
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br2_mapping : 3;
    /* br2_mapping - Bits[10:8], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 2 mapping
     */
    UINT32 rsvd_11 : 1;
    /* rsvd_11 - Bits[11:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br3_mapping : 3;
    /* br3_mapping - Bits[14:12], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 3 mapping
     */
    UINT32 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br4_mapping : 3;
    /* br4_mapping - Bits[18:16], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 4 mapping
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br5_mapping : 3;
    /* br5_mapping - Bits[22:20], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 5 mapping
     */
    UINT32 rsvd_23 : 1;
    /* rsvd_23 - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br6_mapping : 3;
    /* br6_mapping - Bits[26:24], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 6 mapping
     */
    UINT32 rsvd_27 : 1;
    /* rsvd_27 - Bits[27:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 br7_mapping : 3;
    /* br7_mapping - Bits[30:28], RW_LB, default = 3'b000 
       x8 virtual lockstep mode buddy rank 7 mapping
     */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPGC_SEQ_X8VLRANKLG2PHYMAP2_MC_MAIN_STRUCT;




/* MH_MAINCNTL_MC_MAIN_REG supported on:                                      */
/*       SKX_A0 (0x40250E04)                                                  */
/*       SKX (0x40250E04)                                                     */
/* Register default value:              0x0000E01F                            */
#define MH_MAINCNTL_MC_MAIN_REG 0x07004E04
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 * generated by critter 19_0_0x104
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 15;
    UINT32 mh_output_en : 1;
    /* mh_output_en - Bits[15:15], RW_LB, default = 1'b1 
       MEM_HOT output generation logic enable control.
       When 0, the MEM_HOT output generation logic is disabled, i.e. MEM_HOT[1:0]# 
       outputs are in de-asserted state, no assertion regardless of the memory 
       temperature. Sensing of externally asserted MEM_HOT[1:0]# is not affected by 
       this bit. IMC will always reset the MH1_DIMM_VAL and MH0_DIMM_VAL bits in the 
       next DCLK so there is no impact to the PCODE update to the MH_TEMP_STAT 
       registers. 
       When 1, the MEM_HOT output generation logic is enabled.
     */
    UINT32 mh_sense_en : 1;
    /* mh_sense_en - Bits[16:16], RW_LB, default = 1'b0 
       Externally asserted MEM_HOTsense control enable bit.
       When set, the MEM_HOT sense logic is enabled.
     */
    UINT32 mhot_smi_en : 1;
    /* mhot_smi_en - Bits[17:17], RW, default = 1'b0 
       this bit enables the MHOT_SMI_EXT_EN, i.e.
       Generate SMI when either MEMHOT[1:0]# is EXTERNALLY asserted.
     */
    UINT32 mhot_ext_smi_en : 1;
    /* mhot_ext_smi_en - Bits[18:18], RW, default = 1'b0 
       this bit enables the MHOT_SMI_EN, i.e.
       Generate SMI during INTERNAL MEMHOT# event assertion.
     */
    UINT32 smbus_01src_sel_0 : 1;
    /* smbus_01src_sel_0 - Bits[19:19], RW, default = 1'b0 
       When set to one selects SMBus source input 0 for channels 0/1. When zero
       selects SMBus source input 1A.
     */
    UINT32 smbus_23src_sel_1a : 1;
    /* smbus_23src_sel_1a - Bits[20:20], RW, default = 1'b0 
       When set to one selects SMBus source input 1A for channels 2/3. When zero
       selects SMBus source input 1B.
     */
    UINT32 rsvd : 11;
    /* rsvd - Bits[31:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MH_MAINCNTL_MC_MAIN_STRUCT;






















































/* SPARING_CONTROL_TAD_MC_MAIN_REG supported on:                              */
/*       SKX (0x402509BC)                                                     */
/* Register default value:              0x001F58D1                            */
#define SPARING_CONTROL_TAD_MC_MAIN_REG 0x070049BC
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  This register controls the sparing copy operation for ADDDC and when mirroring 
 * is enabled.   
 */
typedef union {
  struct {
    UINT32 nxt_tad_0 : 3;
    /* nxt_tad_0 - Bits[2:0], RW_LB, default = 3'b001 
       This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This 
       field contains the next TAD number from TAD 0 with the same mirror_en bit as TAD 
       0 in tadbase. 
     */
    UINT32 nxt_tad_1 : 3;
    /* nxt_tad_1 - Bits[5:3], RW_LB, default = 3'b010 
       This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This 
       field contains the next TAD number from TAD 1 with the same mirror_en bit as TAD 
       1 in tadbase. 
     */
    UINT32 nxt_tad_2 : 3;
    /* nxt_tad_2 - Bits[8:6], RW_LB, default = 3'b011 
       This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This 
       field contains the next TAD number from TAD 2 with the same mirror_en bit as TAD 
       2 in tadbase. 
     */
    UINT32 nxt_tad_3 : 3;
    /* nxt_tad_3 - Bits[11:9], RW_LB, default = 3'b100 
       This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This 
       field contains the next TAD number from TAD 3 with the same mirror_en bit as TAD 
       3 in tadbase. 
     */
    UINT32 nxt_tad_4 : 3;
    /* nxt_tad_4 - Bits[14:12], RW_LB, default = 3'b101 
       This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This 
       field contains the next TAD number from TAD 4 with the same mirror_en bit as TAD 
       4 in tadbase. 
     */
    UINT32 nxt_tad_5 : 3;
    /* nxt_tad_5 - Bits[17:15], RW_LB, default = 3'b110 
       This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This 
       field contains the next TAD number from TAD 5 with the same mirror_en bit as TAD 
       5 in tadbase. 
     */
    UINT32 nxt_tad_6 : 3;
    /* nxt_tad_6 - Bits[20:18], RW_LB, default = 3'b111 
       This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This 
       field contains the next TAD number from TAD 6 with the same mirror_en bit as TAD 
       6 in tadbase. 
     */
    UINT32 rsvd : 11;
    /* rsvd - Bits[31:21], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SPARING_CONTROL_TAD_MC_MAIN_STRUCT;


/* SPARING_CONTROL_THRESH_MC_MAIN_REG supported on:                           */
/*       SKX (0x402509C0)                                                     */
/* Register default value:              0x00010100                            */
#define SPARING_CONTROL_THRESH_MC_MAIN_REG 0x070049C0
/* Struct format extracted from XML file SKX\2.10.0.CFG.xml.
 *  This register controls the sparing copy operation.  
 */
typedef union {
  struct {
    UINT32 addr_skip : 16;
    /* addr_skip - Bits[15:0], RW_LB, default = 16'b100000000 
       Threshold to exit spare window when number of skipped addresses reaches this 
       value. The value shouldn't be programmed to 0 even if addr_skip_en = 0. 
     */
    UINT32 addr_skip_en : 1;
    /* addr_skip_en - Bits[16:16], RW_LB, default = 1'b1 
       Enable exiting spare window when number of skipped addresses reaches threshold 
       (addr_skip). 
     */
    UINT32 rsvd : 15;
    /* rsvd - Bits[31:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SPARING_CONTROL_THRESH_MC_MAIN_STRUCT;


#endif /* MC_MAIN_h */
