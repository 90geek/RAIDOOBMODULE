//
// This file contains 'Framework Code' and is licensed as such
// under the terms of your license agreement with Intel or your
// vendor.  This file may not be modified, except as allowed by
// additional terms of your license agreement.
//
// **************************************************************************
// *                                                                        *
// *      Intel Restricted Secret                                           *
// *                                                                        *
// *      Reference Code                                                    *
// *                                                                        *
// *      Copyright (c) 2007-2016, Intel Corporation.                       *
// *                                                                        *
// *      This software and associated documentation (if any) is furnished  *
// *      under a license and may only be used or copied in accordance      *
// *      with the terms of the license. Except as permitted by such        *
// *      license, no part of this software or documentation may be         *
// *      reproduced, stored in a retrieval system, or transmitted in any   *
// *      form or by any means without the express written consent of       *
// *      Intel Corporation.                                                *
// *                                                                        *
// *      This program has been developed by Intel Corporation.             *
// *      Licensee has Intel's permission to incorporate this source code   *
// *      into their product, royalty free.  This source code may NOT be    *
// *      redistributed to anyone without Intel's written permission.       *
// *                                                                        *
// *      Intel specifically disclaims all warranties, express or           *
// *      implied, and all liability, including consequential and other     *
// *      indirect damages, for the use of this code, including liability   *
// *      for infringement of any proprietary rights, and including the     *
// *      warranties of merchantability and fitness for a particular        *
// *      purpose.  Intel does not assume any responsibility for any        *
// *      errors which may appear in this code nor any responsibility to    *
// *      update it.                                                        *
// *                                                                        *
// **************************************************************************
// **************************************************************************
// *                                                                        *
// *  PURPOSE:                                                              *
// *                                                                        *
// *      This file contains Silicon register definitions.                  *
// *                                                                        *
// **************************************************************************
//
/* Date Stamp: 9/13/2016 */

#ifndef IIO_VTD_h
#define IIO_VTD_h

#include "DataTypes.h"

/* Device and Function specifications:                                        */
/* For all target CPUs:                                                       */
/* IIO_VTD_DEV 5                                                              */
/* IIO_VTD_FUN 0                                                              */

/* VID_IIO_VTD_REG supported on:                                              */
/*       SKX_A0 (0x20128000)                                                  */
/*       SKX (0x20128000)                                                     */
/* Register default value:              0x8086                                */
#define VID_IIO_VTD_REG 0x11002000
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x000
 */
typedef union {
  struct {
    UINT16 vendor_identification_number : 16;
    /* vendor_identification_number - Bits[15:0], RO, default = 16'b1000000010000110 
       The value is assigned by PCI-SIG to Intel.
     */
  } Bits;
  UINT16 Data;
} VID_IIO_VTD_STRUCT;


/* DID_IIO_VTD_REG supported on:                                              */
/*       SKX_A0 (0x20128002)                                                  */
/*       SKX (0x20128002)                                                     */
/* Register default value:              0x2034                                */
#define DID_IIO_VTD_REG 0x11002002
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x002
 */
typedef union {
  struct {
    UINT16 device_identification_number : 16;
    /* device_identification_number - Bits[15:0], RO, default = 16'b0010000000110100 
       //TODO_HSXA0_SYNC
       Device ID values vary from function to function. Bits 15:8 are equal to 0x0E for 
       Ivytown. The following list is a breakdown of the function groups.0x0E00 - 
       0x0E1F : PCI Express and DMI ports 
       0x0E20 - 0x0E3F : IO Features (CBDMA, APIC, VT, RAS, LT)
       0x0E40 - 0x0E5F : Performance Monitors
       0x0E60 - 0x0E7F : DFX
       0x0E80 - 0x0E9F : Quick Path Interface
       0x0EA0 - 0x0EBF : Home Agent/Memory Controller
       0x0EC0 - 0x0EDF : Power Management
       0x0EE0 - 0x0EFF : Cbo/Ring
       //TODO_HSXA0_SYNC
       //SKX:Oct 18 2012: Post HSX sync values should be as below
       Device ID values vary from function to function. Bits 15:8 are equal to 0x2F for 
       the processor. The following list is a breakdown of the function groups. 
       0x2F00 - 0x2F1F : PCI Express and DMI ports
       0x2F20 - 0x2F3F : IO Features (CBDMA, APIC, VT, RAS, Intel TXT)
       0x2F40 - 0x2F5F : Performance Monitors
       0x2F60 - 0x2F7F : DFX
       0x2F80 - 0x2F9F : Intel Quick Path Interface
       0x2FA0 - 0x2FBF : Home Agent/Memory Controller
       0x2FC0 - 0x2FDF : Power Management
       0x2FE0 - 0x2FFF : Cbo/Ring
       
     */
  } Bits;
  UINT16 Data;
} DID_IIO_VTD_STRUCT;


/* PCICMD_IIO_VTD_REG supported on:                                           */
/*       SKX_A0 (0x20128004)                                                  */
/*       SKX (0x20128004)                                                     */
/* Register default value:              0x0000                                */
#define PCICMD_IIO_VTD_REG 0x11002004
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x004
 */
typedef union {
  struct {
    UINT16 io_space_enable : 1;
    /* io_space_enable - Bits[0:0], RO, default = 1'b0 
       Hardwired to 0 since these devices don't decode any IO BARs
     */
    UINT16 memory_space_enable : 1;
    /* memory_space_enable - Bits[1:1], RO, default = 1'b0 
       Hardwired to 0 since these devices don't decode any memory BARs
     */
    UINT16 bus_master_enable : 1;
    /* bus_master_enable - Bits[2:2], RO, default = 1'b0 
       Hardwired to 0 since these devices don't generate any transactions
     */
    UINT16 special_cycle_enable : 1;
    /* special_cycle_enable - Bits[3:3], RO, default = 1'b0 
       Not applicable. Hardwired to 0.
     */
    UINT16 memory_write_and_invalidate_enable : 1;
    /* memory_write_and_invalidate_enable - Bits[4:4], RO, default = 1'b0 
       Not applicable to internal devices. Hardwired to 0.
     */
    UINT16 vga_palette_snoop_enable : 1;
    /* vga_palette_snoop_enable - Bits[5:5], RO, default = 1'b0 
       Not applicable to internal devices. Hardwired to 0.
     */
    UINT16 parity_error_response : 1;
    /* parity_error_response - Bits[6:6], RO, default = 1'b0 
       This bit has no impact on error reporting from these devices
     */
    UINT16 idsel_stepping_wait_cycle_control : 1;
    /* idsel_stepping_wait_cycle_control - Bits[7:7], RO, default = 1'b0 
       Not applicable to internal devices. Hardwired to 0.
     */
    UINT16 serr_enable : 1;
    /* serr_enable - Bits[8:8], RO, default = 1'b0 
       This bit has no impact on error reporting from these devices
     */
    UINT16 fast_back_to_back_enable : 1;
    /* fast_back_to_back_enable - Bits[9:9], RO, default = 1'b0 
       Not applicable to PCI Express and is hardwired to 0
     */
    UINT16 intx_disable : 1;
    /* intx_disable - Bits[10:10], RO, default = 1'b0 
       N/A for these devices
     */
    UINT16 rsvd : 5;
    /* rsvd - Bits[15:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PCICMD_IIO_VTD_STRUCT;


/* PCISTS_IIO_VTD_REG supported on:                                           */
/*       SKX_A0 (0x20128006)                                                  */
/*       SKX (0x20128006)                                                     */
/* Register default value:              0x0010                                */
#define PCISTS_IIO_VTD_REG 0x11002006
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x006
 */
typedef union {
  struct {
    UINT16 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 intx_status : 1;
    /* intx_status - Bits[3:3], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 capabilities_list : 1;
    /* capabilities_list - Bits[4:4], RO, default = 1'b1 
       This bit indicates the presence of a capabilities list structure
     */
    UINT16 pci66mhz_capable : 1;
    /* pci66mhz_capable - Bits[5:5], RO, default = 1'b0 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 rsvd_6 : 1;
    /* rsvd_6 - Bits[6:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT16 fast_back_to_back : 1;
    /* fast_back_to_back - Bits[7:7], RO, default = 1'b0 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 master_data_parity_error : 1;
    /* master_data_parity_error - Bits[8:8], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 devsel_timing : 2;
    /* devsel_timing - Bits[10:9], RO, default = 2'b00 
       Not applicable to PCI Express. Hardwired to 0.
     */
    UINT16 signaled_target_abort : 1;
    /* signaled_target_abort - Bits[11:11], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 received_target_abort : 1;
    /* received_target_abort - Bits[12:12], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 received_master_abort : 1;
    /* received_master_abort - Bits[13:13], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 signaled_system_error : 1;
    /* signaled_system_error - Bits[14:14], RO, default = 1'b0 
       Hardwired to 0
     */
    UINT16 detected_parity_error : 1;
    /* detected_parity_error - Bits[15:15], RO, default = 1'b0 
       This bit is set when the device receives a packet on the primary side with an 
       uncorrectable data error (including a packet with poison bit set) or an 
       uncorrectable address/control parity error. The setting of this bit is 
       regardless of the Parity Error Response bit (PERRE) in the PCICMD register. 
       R2PCIe will never set this bit. 
     */
  } Bits;
  UINT16 Data;
} PCISTS_IIO_VTD_STRUCT;


/* RID_IIO_VTD_REG supported on:                                              */
/*       SKX_A0 (0x10128008)                                                  */
/*       SKX (0x10128008)                                                     */
/* Register default value:              0x00                                  */
#define RID_IIO_VTD_REG 0x11001008
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Revision ID
 */
typedef union {
  struct {
    UINT8 revision_id : 8;
    /* revision_id - Bits[7:0], RO, default = 8'h0 
       
       	  Revision ID.
       	
     */
  } Bits;
  UINT8 Data;
} RID_IIO_VTD_STRUCT;


/* CCR_N0_IIO_VTD_REG supported on:                                           */
/*       SKX_A0 (0x10128009)                                                  */
/*       SKX (0x10128009)                                                     */
/* Register default value:              0x00                                  */
#define CCR_N0_IIO_VTD_REG 0x11001009
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Class Code Register
 */
typedef union {
  struct {
    UINT8 interface : 8;
    /* interface - Bits[7:0], RO, default = 8'h0 
       
       	  Base revision.
       	
     */
  } Bits;
  UINT8 Data;
} CCR_N0_IIO_VTD_STRUCT;


/* CCR_N1_IIO_VTD_REG supported on:                                           */
/*       SKX_A0 (0x2012800A)                                                  */
/*       SKX (0x2012800A)                                                     */
/* Register default value:              0x0880                                */
#define CCR_N1_IIO_VTD_REG 0x1100200A
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Class Code Register
 */
typedef union {
  struct {
    UINT16 sub_class : 8;
    /* sub_class - Bits[7:0], RO, default = 8'h80 
       
       	  Base revision.
       	
     */
    UINT16 base_class : 8;
    /* base_class - Bits[15:8], RO, default = 8'h8 
       
       	  Base revision.
       	
     */
  } Bits;
  UINT16 Data;
} CCR_N1_IIO_VTD_STRUCT;


/* CLSR_IIO_VTD_REG supported on:                                             */
/*       SKX_A0 (0x1012800C)                                                  */
/*       SKX (0x1012800C)                                                     */
/* Register default value:              0x00                                  */
#define CLSR_IIO_VTD_REG 0x1100100C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x00c
 */
typedef union {
  struct {
    UINT8 cacheline_size : 8;
    /* cacheline_size - Bits[7:0], RW, default = 8'b00000000 
       This register is set as RW for compatibility reasons only. Cacheline size for 
       processor is always 64B. 
     */
  } Bits;
  UINT8 Data;
} CLSR_IIO_VTD_STRUCT;


/* HDR_IIO_VTD_REG supported on:                                              */
/*       SKX_A0 (0x1012800E)                                                  */
/*       SKX (0x1012800E)                                                     */
/* Register default value:              0x80                                  */
#define HDR_IIO_VTD_REG 0x1100100E
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x00e
 */
typedef union {
  struct {
    UINT8 configuration_layout : 7;
    /* configuration_layout - Bits[6:0], RO, default = 7'b0000000 
       This field identifies the format of the configuration header layout. It is Type 
       0 for all these devices. The default is 00h, indicating a 'endpoint device'. 
     */
    UINT8 multi_function_device : 1;
    /* multi_function_device - Bits[7:7], RO, default = 1'b1 
       This bit defaults to 1b since all these devices are multi-function
     */
  } Bits;
  UINT8 Data;
} HDR_IIO_VTD_STRUCT;


/* SVID_IIO_VTD_REG supported on:                                             */
/*       SKX_A0 (0x2012802C)                                                  */
/*       SKX (0x2012802C)                                                     */
/* Register default value:              0x0000                                */
#define SVID_IIO_VTD_REG 0x1100202C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x02c
 */
typedef union {
  struct {
    UINT16 subsystem_vendor_identification_number : 16;
    /* subsystem_vendor_identification_number - Bits[15:0], RW_O, default = 16'b0000000000000000 
       The default value specifies Intel but can be set to any value once after reset.
     */
  } Bits;
  UINT16 Data;
} SVID_IIO_VTD_STRUCT;


/* SDID_IIO_VTD_REG supported on:                                             */
/*       SKX_A0 (0x2012802E)                                                  */
/*       SKX (0x2012802E)                                                     */
/* Register default value:              0x0000                                */
#define SDID_IIO_VTD_REG 0x1100202E
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x02e
 */
typedef union {
  struct {
    UINT16 subsystem_device_identification_number : 16;
    /* subsystem_device_identification_number - Bits[15:0], RW_O, default = 16'b0000000000000000 
       Assigned by the subsystem vendor to uniquely identify the subsystem
     */
  } Bits;
  UINT16 Data;
} SDID_IIO_VTD_STRUCT;


/* CAPPTR_IIO_VTD_REG supported on:                                           */
/*       SKX_A0 (0x10128034)                                                  */
/*       SKX (0x10128034)                                                     */
/* Register default value:              0x40                                  */
#define CAPPTR_IIO_VTD_REG 0x11001034
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x034
 */
typedef union {
  struct {
    UINT8 capability_pointer : 8;
    /* capability_pointer - Bits[7:0], RO, default = 8'b01000000 
       Points to the first capability structure for the device which is the PCIe 
       capability. 
     */
  } Bits;
  UINT8 Data;
} CAPPTR_IIO_VTD_STRUCT;


/* INTL_IIO_VTD_REG supported on:                                             */
/*       SKX_A0 (0x1012803C)                                                  */
/*       SKX (0x1012803C)                                                     */
/* Register default value:              0x00                                  */
#define INTL_IIO_VTD_REG 0x1100103C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x03c
 */
typedef union {
  struct {
    UINT8 interrupt_line : 8;
    /* interrupt_line - Bits[7:0], RO, default = 8'b00000000 
       N/A for these devices
     */
  } Bits;
  UINT8 Data;
} INTL_IIO_VTD_STRUCT;


/* INTPIN_IIO_VTD_REG supported on:                                           */
/*       SKX_A0 (0x1012803D)                                                  */
/*       SKX (0x1012803D)                                                     */
/* Register default value:              0x00                                  */
#define INTPIN_IIO_VTD_REG 0x1100103D
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x03d
 */
typedef union {
  struct {
    UINT8 interrupt_pin : 8;
    /* interrupt_pin - Bits[7:0], RO, default = 8'b00000000 
       N/A since these devices do not generate any interrupt on their own
     */
  } Bits;
  UINT8 Data;
} INTPIN_IIO_VTD_STRUCT;


/* PXPCAPID_IIO_VTD_REG supported on:                                         */
/*       SKX_A0 (0x10128040)                                                  */
/*       SKX (0x10128040)                                                     */
/* Register default value:              0x10                                  */
#define PXPCAPID_IIO_VTD_REG 0x11001040
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x040
 */
typedef union {
  struct {
    UINT8 capability_id : 8;
    /* capability_id - Bits[7:0], RO, default = 8'b00010000 
       Provides the PCI Express capability ID assigned by PCI-SIG.
     */
  } Bits;
  UINT8 Data;
} PXPCAPID_IIO_VTD_STRUCT;


/* PXPNXTPTR_IIO_VTD_REG supported on:                                        */
/*       SKX_A0 (0x10128041)                                                  */
/*       SKX (0x10128041)                                                     */
/* Register default value:              0x00                                  */
#define PXPNXTPTR_IIO_VTD_REG 0x11001041
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x041
 */
typedef union {
  struct {
    UINT8 next_ptr : 8;
    /* next_ptr - Bits[7:0], RO, default = 8'b00000000 
       This field is set to the PCI PM capability.
     */
  } Bits;
  UINT8 Data;
} PXPNXTPTR_IIO_VTD_STRUCT;


/* PXPCAP_IIO_VTD_REG supported on:                                           */
/*       SKX_A0 (0x20128042)                                                  */
/*       SKX (0x20128042)                                                     */
/* Register default value:              0x0092                                */
#define PXPCAP_IIO_VTD_REG 0x11002042
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x042
 */
typedef union {
  struct {
    UINT16 capability_version : 4;
    /* capability_version - Bits[3:0], RO, default = 4'b0010 
       This field identifies the version of the PCI Express capability structure. Set 
       to 2h for PCI Express and DMA devices for compliance with the extended base 
       registers. 
     */
    UINT16 device_port_type : 4;
    /* device_port_type - Bits[7:4], RO, default = 4'b1001 
       This field identifies the type of device. It is set to for the DMA to indicate 
       root complex integrated endpoint device. 
     */
    UINT16 slot_implemented_n_a : 1;
    /* slot_implemented_n_a - Bits[8:8], RO, default = 1'b0  */
    UINT16 interrupt_message_number_n_a : 5;
    /* interrupt_message_number_n_a - Bits[13:9], RO, default = 5'b00000  */
    UINT16 rsvd : 2;
    /* rsvd - Bits[15:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT16 Data;
} PXPCAP_IIO_VTD_STRUCT;


/* HDRTYPECTRL_IIO_VTD_REG supported on:                                      */
/*       SKX_A0 (0x10128080)                                                  */
/*       SKX (0x10128080)                                                     */
/* Register default value:              0x00                                  */
#define HDRTYPECTRL_IIO_VTD_REG 0x11001080
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x080
 */
typedef union {
  struct {
    UINT8 clr_hdrmfd : 3;
    /* clr_hdrmfd - Bits[2:0], RW, default = 3'b000 
       When set, function#0 with in the indicated device shows a value of 0 for bit 7 
       of the HDR register, indicating a single function device. BIOS sets this bit, 
       when only function#0 is visible within the device, either because SKU reasons or 
       BIOS has hidden all functions but function#0 within the device via the DEVHIDE 
       register. 
       Bit 0 is for Device#1
       Bit 1 is for Device#2
       Bit 3 is for Device#3
       Currently this is defined only for devices 1, 2 and 3 because in other devices 
       it is expected that at least 2 functions are visible to OS or the entire device 
       is hidden. 
     */
    UINT8 rsvd : 5;
    /* rsvd - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} HDRTYPECTRL_IIO_VTD_STRUCT;


/* MMCFG_BASE_N0_IIO_VTD_REG supported on:                                    */
/*       SKX_A0 (0x40128090)                                                  */
/*       SKX (0x40128090)                                                     */
/* Register default value:              0x7FFFFFC000000                       */
#define MMCFG_BASE_N0_IIO_VTD_REG 0x11004090
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x090
 */
typedef union {
  struct {
    UINT32 rsvd : 26;
    /* rsvd - Bits[25:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mmcfg_base_addr : 6;
    /* mmcfg_base_addr - Bits[31:26], RW_LB, default = 25'b1111111111111111111111111 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MMCFG_BASE_N0_IIO_VTD_STRUCT;


/* MMCFG_BASE_N1_IIO_VTD_REG supported on:                                    */
/*       SKX_A0 (0x40128094)                                                  */
/*       SKX (0x40128094)                                                     */
/* Register default value:              0x01FFFFFF                            */
#define MMCFG_BASE_N1_IIO_VTD_REG 0x11004094
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x090
 */
typedef union {
  struct {
    UINT32 mmcfg_base_addr : 19;
    /* mmcfg_base_addr - Bits[18:0], RW_LB, default = 25'b1111111111111111111111111 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MMCFG_BASE_N1_IIO_VTD_STRUCT;


/* MMCFG_LIMIT_N0_IIO_VTD_REG supported on:                                   */
/*       SKX_A0 (0x40128098)                                                  */
/*       SKX (0x40128098)                                                     */
/* Register default value:              0x00000000                            */
#define MMCFG_LIMIT_N0_IIO_VTD_REG 0x11004098
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x098
 */
typedef union {
  struct {
    UINT32 rsvd : 26;
    /* rsvd - Bits[25:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mmcfg_limit_addr : 6;
    /* mmcfg_limit_addr - Bits[31:26], RW_LB, default = 25'b0000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
  } Bits;
  UINT32 Data;
} MMCFG_LIMIT_N0_IIO_VTD_STRUCT;


/* MMCFG_LIMIT_N1_IIO_VTD_REG supported on:                                   */
/*       SKX_A0 (0x4012809C)                                                  */
/*       SKX (0x4012809C)                                                     */
/* Register default value:              0x00000000                            */
#define MMCFG_LIMIT_N1_IIO_VTD_REG 0x1100409C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x098
 */
typedef union {
  struct {
    UINT32 mmcfg_limit_addr : 19;
    /* mmcfg_limit_addr - Bits[18:0], RW_LB, default = 25'b0000000000000000000000000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MMCFG_LIMIT_N1_IIO_VTD_STRUCT;


/* TOMMIOL_OB_IIO_VTD_REG supported on:                                       */
/*       SKX_A0 (0x401280A4)                                                  */
/*       SKX (0x401280A4)                                                     */
/* Register default value:              0xFBF00000                            */
#define TOMMIOL_OB_IIO_VTD_REG 0x110040A4
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x0a4
 */
typedef union {
  struct {
    UINT32 rsvd : 20;
    /* rsvd - Bits[19:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 tommiol_ob : 12;
    /* tommiol_ob - Bits[31:20], RW_LB, default = 12'b111110111111 
       This field is used to prevent non-DMI links, along with CBDMA/APIC/NTB primary 
       BARs, from claiming outbound addresses 
       starting above this address and ending at 0xffff_ffff. Bits 19:0 are zero and 
       not writable, and are treated as 1's (like TOLM and TOHM). 
       Set this to 0xfff to disable TOMMIOL_OB. This is intended to be set consistently 
       with TOMMIOL, but the two can be different if needed. 
     */
  } Bits;
  UINT32 Data;
} TOMMIOL_OB_IIO_VTD_STRUCT;


/* TSEG_N0_IIO_VTD_REG supported on:                                          */
/*       SKX_A0 (0x401280A8)                                                  */
/*       SKX (0x401280A8)                                                     */
/* Register default value:              0xFE000000                            */
#define TSEG_N0_IIO_VTD_REG 0x110040A8
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x0a8
 */
typedef union {
  struct {
    UINT32 rsvd : 20;
    /* rsvd - Bits[19:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base : 12;
    /* base - Bits[31:20], RW_LB, default = 12'b111111100000 
       1
     */
  } Bits;
  UINT32 Data;
} TSEG_N0_IIO_VTD_STRUCT;


/* TSEG_N1_IIO_VTD_REG supported on:                                          */
/*       SKX_A0 (0x401280AC)                                                  */
/*       SKX (0x401280AC)                                                     */
/* Register default value:              0x00000000                            */
#define TSEG_N1_IIO_VTD_REG 0x110040AC
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x0a8
 */
typedef union {
  struct {
    UINT32 rsvd : 20;
    /* rsvd - Bits[19:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limit : 12;
    /* limit - Bits[31:20], RW_LB, default = 12'b000000000000 
       Indicates the limit address which is aligned to a 1MB boundary.
       Any access to falls within TSEG.BASE[31:20] &lt;= Addr[31:20] &lt;= 
       TSEG.LIMIT[31:20] is considered to target the Tseg region and IIO aborts it. 
       Note that address bits 19:0 are ignored and not compared. The result is that 
       BASE[19:0] is effectively 00000h and LIMIT is effectively FFFFFh. 
       Setting the TSEG.BASE greater than the limit, disable this region.
       Note that setting BASE[31:20] = LIMIT[31:0] opens a 1MB window due to address 
       bits [19:0] being ignored for this comparison. 
     */
  } Bits;
  UINT32 Data;
} TSEG_N1_IIO_VTD_STRUCT;


/* TOLM_IIO_VTD_REG supported on:                                             */
/*       SKX_A0 (0x401280D0)                                                  */
/*       SKX (0x401280D0)                                                     */
/* Register default value:              0x00000000                            */
#define TOLM_IIO_VTD_REG 0x110040D0
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x0d0
 */
typedef union {
  struct {
    UINT32 rsvd : 26;
    /* rsvd - Bits[25:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 addr : 6;
    /* addr - Bits[31:26], RW_LB, default = 6'b000000 
       1
     */
  } Bits;
  UINT32 Data;
} TOLM_IIO_VTD_STRUCT;


/* TOHM_0_IIO_VTD_REG supported on:                                           */
/*       SKX_A0 (0x401280D4)                                                  */
/*       SKX (0x401280D4)                                                     */
/* Register default value:              0x00000000                            */
#define TOHM_0_IIO_VTD_REG 0x110040D4
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x0d4
 */
typedef union {
  struct {
    UINT32 rsvd : 26;
    /* rsvd - Bits[25:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 addr : 6;
    /* addr - Bits[31:26], RW_LB, default = 6'b000000  */
  } Bits;
  UINT32 Data;
} TOHM_0_IIO_VTD_STRUCT;


/* TOHM_1_IIO_VTD_REG supported on:                                           */
/*       SKX_A0 (0x401280D8)                                                  */
/*       SKX (0x401280D8)                                                     */
/* Register default value:              0x00000000                            */
#define TOHM_1_IIO_VTD_REG 0x110040D8
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x0d8
 */
typedef union {
  struct {
    UINT32 addr : 32;
    /* addr - Bits[31:0], RW_LB, default = 32'b00000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} TOHM_1_IIO_VTD_STRUCT;


/* TOMMIOL_IIO_VTD_REG supported on:                                          */
/*       SKX_A0 (0x401280DC)                                                  */
/*       SKX (0x401280DC)                                                     */
/* Register default value:              0xFBF00000                            */
#define TOMMIOL_IIO_VTD_REG 0x110040DC
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x0dc
 */
typedef union {
  struct {
    UINT32 rsvd : 20;
    /* rsvd - Bits[19:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 tommiol : 12;
    /* tommiol - Bits[31:20], RW_LB, default = 12'b111110111111 
       This field is used to abort inbound MRd/MWr/atomic accesses starting above this 
       address and ending at 0xffff_ffff, 
       exclusive of the interrupt hole (0xfeex_xxxx). Bits 19:0 are zero and not 
       writable, and are treated as 1's (like TOLM and TOHM). 
       Set this to 0xfff to disable TOMMIOL.
     */
  } Bits;
  UINT32 Data;
} TOMMIOL_IIO_VTD_STRUCT;


/* NCMEM_BASE_0_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x401280E0)                                                  */
/*       SKX (0x401280E0)                                                     */
/* Register default value:              0xFC000000                            */
#define NCMEM_BASE_0_IIO_VTD_REG 0x110040E0
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x0e0
 */
typedef union {
  struct {
    UINT32 rsvd : 26;
    /* rsvd - Bits[25:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 addr : 6;
    /* addr - Bits[31:26], RW_LB, default = 6'b111111  */
  } Bits;
  UINT32 Data;
} NCMEM_BASE_0_IIO_VTD_STRUCT;


/* NCMEM_BASE_1_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x401280E4)                                                  */
/*       SKX (0x401280E4)                                                     */
/* Register default value:              0xFFFFFFFF                            */
#define NCMEM_BASE_1_IIO_VTD_REG 0x110040E4
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x0e4
 */
typedef union {
  struct {
    UINT32 addr : 32;
    /* addr - Bits[31:0], RW_LB, default = 32'b11111111111111111111111111111111  */
  } Bits;
  UINT32 Data;
} NCMEM_BASE_1_IIO_VTD_STRUCT;


/* NCMEM_LIMIT_0_IIO_VTD_REG supported on:                                    */
/*       SKX_A0 (0x401280E8)                                                  */
/*       SKX (0x401280E8)                                                     */
/* Register default value:              0x00000000                            */
#define NCMEM_LIMIT_0_IIO_VTD_REG 0x110040E8
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x0e8
 */
typedef union {
  struct {
    UINT32 rsvd : 26;
    /* rsvd - Bits[25:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 addr : 6;
    /* addr - Bits[31:26], RW_LB, default = 6'b000000  */
  } Bits;
  UINT32 Data;
} NCMEM_LIMIT_0_IIO_VTD_STRUCT;


/* NCMEM_LIMIT_1_IIO_VTD_REG supported on:                                    */
/*       SKX_A0 (0x401280EC)                                                  */
/*       SKX (0x401280EC)                                                     */
/* Register default value:              0x00000000                            */
#define NCMEM_LIMIT_1_IIO_VTD_REG 0x110040EC
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x0ec
 */
typedef union {
  struct {
    UINT32 addr : 32;
    /* addr - Bits[31:0], RW_LB, default = 32'b00000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} NCMEM_LIMIT_1_IIO_VTD_STRUCT;


/* MENCMEM_BASE_0_IIO_VTD_REG supported on:                                   */
/*       SKX_A0 (0x401280F0)                                                  */
/*       SKX (0x401280F0)                                                     */
/* Register default value:              0xFFF80000                            */
#define MENCMEM_BASE_0_IIO_VTD_REG 0x110040F0
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x0f0
 */
typedef union {
  struct {
    UINT32 rsvd : 19;
    /* rsvd - Bits[18:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 addr : 13;
    /* addr - Bits[31:19], RW_LB, default = 13'b1111111111111  */
  } Bits;
  UINT32 Data;
} MENCMEM_BASE_0_IIO_VTD_STRUCT;


/* MENCMEM_BASE_1_IIO_VTD_REG supported on:                                   */
/*       SKX_A0 (0x401280F4)                                                  */
/*       SKX (0x401280F4)                                                     */
/* Register default value:              0xFFFFFFFF                            */
#define MENCMEM_BASE_1_IIO_VTD_REG 0x110040F4
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x0f4
 */
typedef union {
  struct {
    UINT32 addr : 32;
    /* addr - Bits[31:0], RW_LB, default = 32'b11111111111111111111111111111111  */
  } Bits;
  UINT32 Data;
} MENCMEM_BASE_1_IIO_VTD_STRUCT;


/* MENCMEM_LIMIT_0_IIO_VTD_REG supported on:                                  */
/*       SKX_A0 (0x401280F8)                                                  */
/*       SKX (0x401280F8)                                                     */
/* Register default value:              0x00000000                            */
#define MENCMEM_LIMIT_0_IIO_VTD_REG 0x110040F8
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x0f8
 */
typedef union {
  struct {
    UINT32 rsvd : 19;
    /* rsvd - Bits[18:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 addr : 13;
    /* addr - Bits[31:19], RW_LB, default = 13'b0000000000000  */
  } Bits;
  UINT32 Data;
} MENCMEM_LIMIT_0_IIO_VTD_STRUCT;


/* MENCMEM_LIMIT_1_IIO_VTD_REG supported on:                                  */
/*       SKX_A0 (0x401280FC)                                                  */
/*       SKX (0x401280FC)                                                     */
/* Register default value:              0x00000000                            */
#define MENCMEM_LIMIT_1_IIO_VTD_REG 0x110040FC
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x0fc
 */
typedef union {
  struct {
    UINT32 addr : 32;
    /* addr - Bits[31:0], RW_LB, default = 32'b00000000000000000000000000000000  */
  } Bits;
  UINT32 Data;
} MENCMEM_LIMIT_1_IIO_VTD_STRUCT;


/* PXPEXTCAP_IIO_VTD_REG supported on:                                        */
/*       SKX_A0 (0x40128100)                                                  */
/*       SKX (0x40128100)                                                     */
/* Register default value:              0x00000000                            */
#define PXPEXTCAP_IIO_VTD_REG 0x11004100
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * This field implements the extended capability header required by 7.9.1 in the 
 * PCIe 3.0 spec. 
 */
typedef union {
  struct {
    UINT32 extended_capability_id : 16;
    /* extended_capability_id - Bits[15:0], RO, default = 16'b0000000000000000 
       Indicates there are no extended capability structures for this dev/fn.
     */
    UINT32 capability_version : 4;
    /* capability_version - Bits[19:16], RO, default = 4'b0000 
       Indicates there are no extended capability structures for this dev/fn.
     */
    UINT32 next_capability_offset : 12;
    /* next_capability_offset - Bits[31:20], RO, default = 12'b000000000000 
       Indicates there are no extended capability structures for this dev/fn.
     */
  } Bits;
  UINT32 Data;
} PXPEXTCAP_IIO_VTD_STRUCT;


/* CPUBUSNO_IIO_VTD_REG supported on:                                         */
/*       SKX_A0 (0x40128108)                                                  */
/*       SKX (0x40128108)                                                     */
/* Register default value:              0x00000000                            */
#define CPUBUSNO_IIO_VTD_REG 0x11004108
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x108
 */
typedef union {
  struct {
    UINT32 bus0 : 8;
    /* bus0 - Bits[7:0], RW_LB, default = 8'b00000000  */
    UINT32 bus1 : 8;
    /* bus1 - Bits[15:8], RW_LB, default = 8'b00000000 
       Is the internal bus# of rest of uncore. All devices are claimed by UBOX on 
       behalf of this component. Devices that do not exist within this component on 
       this bus number are master aborted by the UBOX. 
     */
    UINT32 valid : 1;
    /* valid - Bits[16:16], RW_LBV, default = 1'b0 
       1: IIO claims PCI config accesses from ring if:
       the bus# matches the value in bits 7:0 of this register and Dev# >= 16
       OR
       the bus# does not match either the value in bits 7:0 or 15:8 of this register
       0: IIO does not claim PCI config accesses from ring
     */
    UINT32 segment : 8;
    /* segment - Bits[24:17], RW_LB, default = 8'b00000000  */
    UINT32 rsvd : 7;
    /* rsvd - Bits[31:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CPUBUSNO_IIO_VTD_STRUCT;






/* CIPCTRL_IIO_VTD_REG supported on:                                          */
/*       SKX_A0 (0x40128140)                                                  */
/*       SKX (0x40128140)                                                     */
/* Register default value:              0x01808000                            */
#define CIPCTRL_IIO_VTD_REG 0x11004140
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x140
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 8;
    UINT32 diswrcomb : 1;
    /* diswrcomb - Bits[8:8], RW, default = 1'b0 
       Disables wr->wr, rd->rd, and rd->wr transfers. This bit is a don't-care if 
       rd_merge_enable==1. 
       Setting diswrcomb==1 and rd_merge_enable==0 disables all entry to entry 
       transfers in IRP (causing a Cbo request for every switch request). 
     */
    UINT32 rsvd_9 : 3;
    /* rsvd_9 - Bits[11:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dcaen : 1;
    /* dcaen - Bits[12:12], RW_LB, default = 1'b0 
       When clear, PrefetchHint will not be sent on the coherent interface.
       The CIPDCASAD table is programmed by BIOS and this bit is set when the table is 
       valid. 
     */
    UINT32 rsvd_13 : 2;
    /* rsvd_13 - Bits[14:13], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rd_merge_enable : 1;
    /* rd_merge_enable - Bits[15:15], RW, default = 1'b1 
       Enables all entry to entry transfer flows in IRP (those enabled by ~diswrcomb, 
       plus wr->rd). 
     */
    UINT32 rsvd_16 : 7;
    /* rsvd_16 - Bits[22:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 enable_bl_parity_err_checking : 1;
    /* enable_bl_parity_err_checking - Bits[23:23], RW_L, default = 1'b1 
       Enables Parity Error Checking in the IRP on the data received from the BL Ring.
       Default value is enabled. (SChoudha)
       Notes:
       Locked by DBGBUSLCK
     */
    UINT32 port1_is_legacy : 1;
    /* port1_is_legacy - Bits[24:24], RW_L, default = 1'b1 
       This bit indicates that port 1 of IRPRING (IIMTS) is the legacy stack. Thus, in 
       case of a s345 flow or 
       reset warn flow, we need to check only if the cache of this stack is flushed 
       before sending signal to IMI4. 
       We only need to check the legacy stack because of ME traffic. The other stacks 
       are going to be flushed 
       before this using the CIPCTRL/CIPSTATUS registers and the PCIE devices will be 
       quiesced before the s345/rst_warn 
       is received.
     */
    UINT32 rsvd_25 : 5;
    /* rsvd_25 - Bits[29:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 adr_snapshot_req : 1;
    /* adr_snapshot_req - Bits[30:30], RW, default = 1'b0 
       Whenever this bit is written to 1, this implies wr$ snapshot request was due to 
       ADR. This is a status indication and does not cause the snapshot to occur. 
     */
    UINT32 flushpendwr : 1;
    /* flushpendwr - Bits[31:31], RW, default = 1'b0 
       Whenever this bit is written to 1 (regardless what the current value of this bit 
       is), IRP block first clears bit 0 in CIPSTS register and takes a snapshot of the 
       currently pending write transactions to dram in Write Cache, wait for them to 
       complete fully (i.e. deallocate the corresponding Write Cache/RRB entry) and 
       then set bit 0 in CIPSTS register. 
     */
  } Bits;
  UINT32 Data;
} CIPCTRL_IIO_VTD_STRUCT;


/* CIPSTS_IIO_VTD_REG supported on:                                           */
/*       SKX_A0 (0x40128144)                                                  */
/*       SKX (0x40128144)                                                     */
/* Register default value:              0x00000006                            */
#define CIPSTS_IIO_VTD_REG 0x11004144
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x144
 */
typedef union {
  struct {
    UINT32 flush_pending_writes : 1;
    /* flush_pending_writes - Bits[0:0], RO_V, default = 1'b0 
       This bit gets cleared whenever bit 31 in CPICTRL is written to 1 by software and 
       gets set by h/w when the pending writes in the Write Cache (at the time bit 31 
       in CIPCTRL is written to 1 by software) complete i.e. the Write Cache/RRB entry 
       is deallocated for all those writes. 
     */
    UINT32 rrb_empty : 1;
    /* rrb_empty - Bits[1:1], RO_V, default = 1'b1 
       This indicates that there are no pending requests in the RRB.0 - Pending RRB 
       requests 
       1 - RRB Empty
       This is a live bit and hence can toggle clock by clock. This is provided mostly 
       as a debug visibility feature. 
     */
    UINT32 rrb_non_phold_arb_empty : 1;
    /* rrb_non_phold_arb_empty - Bits[2:2], RO_V, default = 1'b1 
       This indicates that there are no pending requests in the RRB with the exception 
       of ProcLock/Unlock* messages to the lock arbiter.0 - Pending RRB requests 
       1 - RRB Empty except for any pending Proclock* /Unlock
       This is a live bit and hence can toggle clock by clock. This is provided mostly 
       as a debug visibility feature. 
     */
    UINT32 rsvd : 29;
    /* rsvd - Bits[31:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CIPSTS_IIO_VTD_STRUCT;


/* CIPDCASAD_IIO_VTD_REG supported on:                                        */
/*       SKX_A0 (0x40128148)                                                  */
/*       SKX (0x40128148)                                                     */
/* Register default value:              0x00000000                            */
#define CIPDCASAD_IIO_VTD_REG 0x11004148
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x148
 */
typedef union {
  struct {
    UINT32 dcalt0 : 4;
    /* dcalt0 - Bits[3:0], RW_LB, default = 4'b0000 
       For a TPH/DCA request, specifies the target NodeID[3:0] when the inverted 
       Tag[2:0] is 0. NID[2]==1 disables PrefetchHint issue for ST that maps to this 
       entry. 
     */
    UINT32 dcalt1 : 4;
    /* dcalt1 - Bits[7:4], RW_LB, default = 4'b0000 
       For a TPH/DCA request, specifies the target NodeID[3:0] when the inverted 
       Tag[2:0] is 1. NID[2]==1 disables PrefetchHint issue for ST that maps to this 
       entry. 
     */
    UINT32 dcalt2 : 4;
    /* dcalt2 - Bits[11:8], RW_LB, default = 4'b0000 
       For a TPH/DCA request, specifies the target NodeID[3:0] when the inverted 
       Tag[2:0] is 2. NID[2]==1 disables PrefetchHint issue for ST that maps to this 
       entry. 
     */
    UINT32 dcalt3 : 4;
    /* dcalt3 - Bits[15:12], RW_LB, default = 4'b0000 
       For a TPH/DCA request, specifies the target NodeID[3:0] when the inverted 
       Tag[2:0] is 3. NID[2]==1 disables PrefetchHint issue for ST that maps to this 
       entry. 
     */
    UINT32 dcalt4 : 4;
    /* dcalt4 - Bits[19:16], RW_LB, default = 4'b0000 
       For a TPH/DCA request, specifies the target NodeID[3:0] when the inverted 
       Tag[2:0] is 4. NID[2]==1 disables PrefetchHint issue for ST that maps to this 
       entry. 
     */
    UINT32 dcalt5 : 4;
    /* dcalt5 - Bits[23:20], RW_LB, default = 4'b0000 
       For a TPH/DCA request, specifies the target NodeID[3:0] when the inverted 
       Tag[2:0] is 5. NID[2]==1 disables PrefetchHint issue for ST that maps to this 
       entry. 
     */
    UINT32 dcalt6 : 4;
    /* dcalt6 - Bits[27:24], RW_LB, default = 4'b0000 
       For a TPH/DCA request, specifies the target NodeID[3:0] when the inverted 
       Tag[2:0] is 6. NID[2]==1 disables PrefetchHint issue for ST that maps to this 
       entry. 
     */
    UINT32 dcalt7 : 4;
    /* dcalt7 - Bits[31:28], RW_LB, default = 4'b0000 
       For a TPH/DCA request, specifies the target NodeID[3:0] when the inverted 
       Tag[2:0] is 7. NID[2]==1 disables PrefetchHint issue for ST that maps to this 
       entry. 
     */
  } Bits;
  UINT32 Data;
} CIPDCASAD_IIO_VTD_STRUCT;


/* CIPINTRC_IIO_VTD_REG supported on:                                         */
/*       SKX_A0 (0x4012814C)                                                  */
/*       SKX (0x4012814C)                                                     */
/* Register default value:              0x00003F00                            */
#define CIPINTRC_IIO_VTD_REG 0x1100414C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x14c
 */
typedef union {
  struct {
    UINT32 cluster_check_sampling_mode : 1;
    /* cluster_check_sampling_mode - Bits[0:0], RW_L, default = 1'b0  */
    UINT32 logical : 1;
    /* logical - Bits[1:1], RW, default = 1'b0  */
    UINT32 rsvd_2 : 6;
    /* rsvd_2 - Bits[7:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 nmi_mask : 1;
    /* nmi_mask - Bits[8:8], RW, default = 1'b1  */
    UINT32 init_mask : 1;
    /* init_mask - Bits[9:9], RW, default = 1'b1  */
    UINT32 smi_mask : 1;
    /* smi_mask - Bits[10:10], RW, default = 1'b1  */
    UINT32 intr_mask : 1;
    /* intr_mask - Bits[11:11], RW, default = 1'b1  */
    UINT32 a20m_mask : 1;
    /* a20m_mask - Bits[12:12], RW, default = 1'b1  */
    UINT32 ferr_mask : 1;
    /* ferr_mask - Bits[13:13], RW_L, default = 1'b1  */
    UINT32 rsvd_14 : 2;
    /* rsvd_14 - Bits[15:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 nmi_msi_en : 1;
    /* nmi_msi_en - Bits[16:16], RW, default = 1'b0  */
    UINT32 init_msi_en : 1;
    /* init_msi_en - Bits[17:17], RW, default = 1'b0  */
    UINT32 smi_msi_en : 1;
    /* smi_msi_en - Bits[18:18], RW, default = 1'b0  */
    UINT32 rsvd_19 : 5;
    /* rsvd_19 - Bits[23:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 route_nmi2mca : 1;
    /* route_nmi2mca - Bits[24:24], RW, default = 1'b0  */
    UINT32 dis_intx_route2ich : 1;
    /* dis_intx_route2ich - Bits[25:25], RW, default = 1'b0  */
    UINT32 rsvd_26 : 6;
    /* rsvd_26 - Bits[31:26], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} CIPINTRC_IIO_VTD_STRUCT;


/* CIPINTRS_IIO_VTD_REG supported on:                                         */
/*       SKX_A0 (0x40128154)                                                  */
/*       SKX (0x40128154)                                                     */
/* Register default value:              0x00000000                            */
#define CIPINTRS_IIO_VTD_REG 0x11004154
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * This register is to be polled by BIOS to determine if internal pending system 
 * interrupts are drained out of IIO. General usage model is for software to 
 * quiesce the source (e.g. IOM global error logic) of a system event like SMI, 
 * then poll this register till this register indicates that the event is not 
 * pending inside IIO. One additional read is required from software, after the 
 * register first reads 0 for the associated event.It would be nice if this error 
 * status is combined into a global register with the internally generated event 
 * status bits. will look into that later. 
 */
typedef union {
  struct {
    UINT32 vlw_msgpend : 1;
    /* vlw_msgpend - Bits[0:0], RO_V, default = 1'b0 
       (either generated internally or externally)
     */
    UINT32 nmi_evt_pending : 1;
    /* nmi_evt_pending - Bits[1:1], RO_V, default = 1'b0  */
    UINT32 init_evt_pending : 1;
    /* init_evt_pending - Bits[2:2], RO_V, default = 1'b0  */
    UINT32 a20m_evt_pending : 1;
    /* a20m_evt_pending - Bits[3:3], RO_V, default = 1'b0  */
    UINT32 intr_evt_pending : 1;
    /* intr_evt_pending - Bits[4:4], RO_V, default = 1'b0  */
    UINT32 smi_ras_evt_pending : 1;
    /* smi_ras_evt_pending - Bits[5:5], RO_V, default = 1'b0  */
    UINT32 nmi_ras_evt_pending : 1;
    /* nmi_ras_evt_pending - Bits[6:6], RO_V, default = 1'b0  */
    UINT32 mca_ras_evt_pending : 1;
    /* mca_ras_evt_pending - Bits[7:7], RO_V, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[29:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 nmi : 1;
    /* nmi - Bits[30:30], RW1CS, default = 1'b0 
       This is set whenever IIO forwards a VLW from PCH that had the NMI bit assserted
     */
    UINT32 smi : 1;
    /* smi - Bits[31:31], RW1CS, default = 1'b0 
       This is set whenever IIO forwards a VLW from PCH that had the SMI bit assserted
     */
  } Bits;
  UINT32 Data;
} CIPINTRS_IIO_VTD_STRUCT;


/* VTBAR_IIO_VTD_REG supported on:                                            */
/*       SKX_A0 (0x40128180)                                                  */
/*       SKX (0x40128180)                                                     */
/* Register default value:              0x00000000                            */
#define VTBAR_IIO_VTD_REG 0x11004180
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x180
 */
typedef union {
  struct {
    UINT32 vtd_chipset_base_address_enable : 1;
    /* vtd_chipset_base_address_enable - Bits[0:0], RW_LB, default = 1'b0 
       Note that accesses to registers pointed to by VTBAR are accessible via message 
       channel or JTAG mini-port, irrespective of the setting of this enable bit i.e. 
       even if this bit is clear, read/write to VT-d registers are completed normally 
       (writes update registers and reads return the value of the register) for 
       accesses from message channel or JTAG mini-port. 
       This bit is RW-LB (i.e. lock is determined based on the 'trusted' bit in message 
       channel) when VTGENCTRL.lockvtd is clear, else it is RO. 
     */
    UINT32 rsvd : 12;
    /* rsvd - Bits[12:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 vtd_chipset_base_address : 19;
    /* vtd_chipset_base_address - Bits[31:13], RW_LB, default = 19'b0000000000000000000 
       Provides an aligned 8K base address for IIO registers relating to VT-d. All 
       inbound accesses to this region are completer aborted by the IIO. 
     */
  } Bits;
  UINT32 Data;
} VTBAR_IIO_VTD_STRUCT;


/* VTGENCTRL_IIO_VTD_REG supported on:                                        */
/*       SKX_A0 (0x40128184)                                                  */
/*       SKX (0x40128184)                                                     */
/* Register default value:              0x007000A8                            */
#define VTGENCTRL_IIO_VTD_REG 0x11004184
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x184
 */
typedef union {
  struct {
    UINT32 gpa_limit : 4;
    /* gpa_limit - Bits[3:0], RW_LB, default = 4'b1000 
       Represents the guest virtual addressing limit for the non-Isoch VT-d engine.
       0000: 2^40 (i.e. bits 39:0)
       0001: 2^41 (i.e. bits 40:0)
       ..
       0111: 2^47
       1000: 2^48
       Others: Reserved
       When VT-d translation is enabled, all incoming guest addresses from PCI Express, 
       associated with the non-isoch VT-d engine, that go beyond the limit specified in 
       this register will be aborted by IIO and a UR response returned. This register 
       is not used when translation is not enabled. Note that 'translated' and 
       'pass-through' addresses are in the 'host-addressing' domain and NOT 
       'guest-addressing' domain and hence GPA_LIMIT checking on those accesses are 
       bypassed and instead HPA_LIMIT checking applies. 
     */
    UINT32 hpa_limit : 4;
    /* hpa_limit - Bits[7:4], RW_LB, default = 4'b1010 
       Represents the host processor addressing limit
       0000: 2^36 (i.e. bits 35:0)
       0001: 2^37 (i.e. bits 36:0)
       ...
       1010: 2^46 (i.e. bits 45:0)
       When VT-d translation is enabled on a VT-d engine (isoch or non-isoch), all host 
       addresses (during page walks) that go beyond the limit specified in this 
       register will be aborted by IIO. Note that pass-through and 'translated' ATS 
       accesses carry the host-address directly in the access and are subject to this 
       check as well. 
     */
    UINT32 rsvd_8 : 7;
    /* rsvd_8 - Bits[14:8], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 lockvtd : 1;
    /* lockvtd - Bits[15:15], RW_O, default = 1'b0 
       When this bit is 0, VTBAR.vtd_chipset_base_address_enable is RW-LB, else it is 
       RO. 
     */
    UINT32 rsvd_16 : 7;
    UINT32 reset_pf_miss_ctr : 1;
    /* reset_pf_miss_ctr - Bits[23:23], RW_LBV, default = 1'b0 
       One-shot bit to reset the counter used by VTDGENCTRL2.tlb_p_np_pf_limit to track 
       prefetches that missed the TLB. 
       This is LT-locked, but wo-lb is not supported in crgen.
     */
    UINT32 rsvd_24 : 8;
    /* rsvd_24 - Bits[31:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} VTGENCTRL_IIO_VTD_STRUCT;


/* VTISOCHCTRL_IIO_VTD_REG supported on:                                      */
/*       SKX_A0 (0x40128188)                                                  */
/*       SKX (0x40128188)                                                     */
/* Register default value:              0x00000001                            */
#define VTISOCHCTRL_IIO_VTD_REG 0x11004188
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x188
 */
typedef union {
  struct {
    UINT32 azaliausenonisochvtd : 1;
    /* azaliausenonisochvtd - Bits[0:0], RW_LB, default = 1'b1 
       When set, causes Azalia traffic to use the Non-Isoch VTd engine
     */
    UINT32 rsvd_1 : 1;
    /* rsvd_1 - Bits[1:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 numisochl1entries : 3;
    /* numisochl1entries - Bits[4:2], RW_LB, default = 3'b000 
       000: 16 entries (when ISOCH is enabled only)
       001: 1 entry
       010: 2 entries
       011: 4 entries
       100: 8 entries
       101: 16 entries
       Others: Reserved
     */
    UINT32 nel3 : 3;
    /* nel3 - Bits[7:5], RW_LB, default = 3'b000 
       Number of Isoch L3 entries reserved for Azalia and non-Azalia VCp.
       USB VCp would use these reseved entries only when Isoch enginve is enabled and 
       USB VCP is set to take High priority switch path. 
       000: 16 entries when Isoch engine is enabled.
       001: 1 entry
       010: 2 entries
       011: 4 entries
       100: 8 entries
       101: 16 entries
       Others: Reserved
     */
    UINT32 azalia_on_vcp : 1;
    /* azalia_on_vcp - Bits[8:8], RW_LB, default = 1'b0 
       1: all VCp traffic uses the Azalia optimizations in VTd pagewalk request.
       0: non-Azalia VCp traffic uses VC0 channel for VTd pagewalk request.
       This bit should be set whenever Azalia traffic is sharing VCp with non-Azalia 
       rather than running on VC1 to avoid and non-Azalia to Azalia dependencies that 
       can crop up when Azalia traffic is also on VCp. 
       When this bit is cleared, VC0 can block non-Azalia VCp traffic. If Azalia 
       traffic is running on VCp, then VCp traffic can block Azalia. Therefore VC0 can 
       block Azalia traffic. 
       Azalia traffic will always use the optimizations regardless of the value of this 
       bit. This bit makes it is possible to allow non-Azalia VCp to also use the 
       Azalia optimizations. 
     */
    UINT32 rsvd_9 : 23;
    /* rsvd_9 - Bits[31:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} VTISOCHCTRL_IIO_VTD_STRUCT;


/* VTGENCTRL2_IIO_VTD_REG supported on:                                       */
/*       SKX_A0 (0x4012818C)                                                  */
/*       SKX (0x4012818C)                                                     */
/* Register default value:              0x001883A0                            */
#define VTGENCTRL2_IIO_VTD_REG 0x1100418C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x18c
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dontevictleafat01 : 1;
    /* dontevictleafat01 - Bits[1:1], RW_LB, default = 1'b0  */
    UINT32 evictnonleafat01 : 1;
    /* evictnonleafat01 - Bits[2:2], RW_LB, default = 1'b0  */
    UINT32 ignoreubitleafeviction : 1;
    /* ignoreubitleafeviction - Bits[3:3], RW_LB, default = 1'b0  */
    UINT32 rsvd_4 : 1;
    /* rsvd_4 - Bits[4:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rsvd_5 : 2;
    UINT32 lt : 4;
    /* lt - Bits[10:7], RW_LB, default = 4'b0111 
       Controls the rate at which the LRU buckets should degrade.
       If we are in "Cycles" mode (LRUCTRL = 0), then we will degrade LRU after 256 * N 
       requests where N is the value of this field. 
       If we are in "Request" mode (CRUCTRL = 1), then we will degrade LRU after 16 * N 
       cycles where N is the value of this field. 
       The default value of 0x7 (along with LRUCTRL=0) will give us a default behavior 
       of decreasing the LRU buckets every 112 requests. 
     */
    UINT32 lructrl : 1;
    /* lructrl - Bits[11:11], RW_LB, default = 1'b0 
       Controls what increments the LRU counter that is used to degrade the LRU bits in 
       the IOTLB, L1/L2, and L3 caches. 
       0: Count Cycles (same as TB)
       1: Count Requests
     */
    UINT32 tlb_free_entry_limit : 7;
    /* tlb_free_entry_limit - Bits[18:12], RW_LB, default = 7'b0001000 
       Retry prefetch request when number of entries available for allocation in the 
       IOTLB is less than the programmed value. Set this to 0 to disable it. 
     */
    UINT32 rsvd_19 : 1;
    UINT32 tlb_allow_b2b_victims : 1;
    /* tlb_allow_b2b_victims - Bits[20:20], RW_LB, default = 1'b1 
       
       Enable performance optimization where VTd TLB data and mask can be written in 
       the same cycle, which allows victims to be generated in back-to-back cycles. 
       If you set vtgenctrl2.tlb_allow_b2b_victims=0, you also need to set 
       vtddebugreg0.tlb_dis_ut_passthru_superpage=1. 
               
     */
    UINT32 en_lock_rsvd_ent : 1;
    /* en_lock_rsvd_ent - Bits[21:21], RW_LB, default = 1'b0 
       Chicken bit to enable a dedicated P F TLB entry for an agent under lock.
        Recommended BIOS setting: 1
        EDS visibility: No
               
     */
    UINT32 rsvd_22 : 10;
  } Bits;
  UINT32 Data;
} VTGENCTRL2_IIO_VTD_STRUCT;


/* VTGENCTRL3_IIO_VTD_REG supported on:                                       */
/*       SKX_A0 (0x40128190)                                                  */
/*       SKX (0x40128190)                                                     */
/* Register default value:              0x00000000                            */
#define VTGENCTRL3_IIO_VTD_REG 0x11004190
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x190
 */
typedef union {
  struct {
    UINT32 en_agt_rsvd_p_f_ent_tlb0 : 7;
    /* en_agt_rsvd_p_f_ent_tlb0 - Bits[6:0], RW_LB, default = 7'b0000000 
       
       Enable a reserved TLB entry for P F RFTs from the given agent.  FW may need to 
       enable this on a problematic port (card with an illegal P->P dependency). 
       Mapping:
       0 -> d2f0
       1 -> d2f1
       2 -> d2f2
       3 -> d2f3
       4 -> IOAPIC
       5 -> CBDMA
       6 -> ME (unused)
        Recommended BIOS setting: 0
        EDS visibility: No
               
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 en_agt_rsvd_p_f_ent_tlb1 : 9;
    /* en_agt_rsvd_p_f_ent_tlb1 - Bits[16:8], RW_LB, default = 9'b000000000 
       
       Enable a reserved TLB entry for P F RFTs from the given agent.  FW may need to 
       enable this on a problematic port (card with an illegal P->P dependency). 
       Mapping:
       0 -> d3f0
       1 -> d3f1
       2 -> d3f2
       3 -> d3f3
       4 -> d1f0
       5 -> d1f1
       6 -> d0f0 VC0
       7 -> d0f0 VC1
       8 -> d0f0 VCp
        Recommended BIOS setting: 0x100
        EDS visibility: No
               
     */
    UINT32 rsvd_17 : 15;
    /* rsvd_17 - Bits[31:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} VTGENCTRL3_IIO_VTD_STRUCT;


/* IOTLBPARTITION_IIO_VTD_REG supported on:                                   */
/*       SKX_A0 (0x40128194)                                                  */
/*       SKX (0x40128194)                                                     */
/* Register default value:              0x00000000                            */
#define IOTLBPARTITION_IIO_VTD_REG 0x11004194
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x194
 */
typedef union {
  struct {
    UINT32 iotlb_parten : 1;
    /* iotlb_parten - Bits[0:0], RW_LB, default = 1'b0 
       0: Disabled
       1: Enabled
     */
    UINT32 rsvd_1 : 8;
    /* rsvd_1 - Bits[8:1], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rangesel_intr : 2;
    /* rangesel_intr - Bits[10:9], RW, default = 2'b00  */
    UINT32 rangesel_cb : 2;
    /* rangesel_cb - Bits[12:11], RW, default = 2'b00  */
    UINT32 rangesel_me : 2;
    /* rangesel_me - Bits[14:13], RW, default = 2'b00  */
    UINT32 rsvd_15 : 8;
    /* rsvd_15 - Bits[22:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 rangesel_iou23_upper_x2 : 2;
    /* rangesel_iou23_upper_x2 - Bits[24:23], RW, default = 2'b00  */
    UINT32 rangesel_iou24_upper_x2 : 2;
    /* rangesel_iou24_upper_x2 - Bits[26:25], RW, default = 2'b00  */
    UINT32 rangesel_dmi_20_22 : 2;
    /* rangesel_dmi_20_22 - Bits[28:27], RW, default = 2'b00  */
    UINT32 rsvd_29 : 3;
    /* rsvd_29 - Bits[31:29], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} IOTLBPARTITION_IIO_VTD_STRUCT;


/* VTUNCERRSTS_IIO_VTD_REG supported on:                                      */
/*       SKX_A0 (0x401281A8)                                                  */
/*       SKX (0x401281A8)                                                     */
/* Register default value:              0x00000000                            */
#define VTUNCERRSTS_IIO_VTD_REG 0x110041A8
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x1a8
 */
typedef union {
  struct {
    UINT32 perr_context_cache : 1;
    /* perr_context_cache - Bits[0:0], RW1CS, default = 1'b0  */
    UINT32 perr_l1_lookup : 1;
    /* perr_l1_lookup - Bits[1:1], RW1CS, default = 1'b0  */
    UINT32 perr_l2_lookup : 1;
    /* perr_l2_lookup - Bits[2:2], RW1CS, default = 1'b0  */
    UINT32 perr_l3_lookup : 1;
    /* perr_l3_lookup - Bits[3:3], RW1CS, default = 1'b0  */
    UINT32 perr_tlb0 : 1;
    /* perr_tlb0 - Bits[4:4], RW1CS, default = 1'b0  */
    UINT32 perr_tlb1 : 1;
    /* perr_tlb1 - Bits[5:5], RW1CS, default = 1'b0  */
    UINT32 unsucc_ci_rdcp : 1;
    /* unsucc_ci_rdcp - Bits[6:6], RW1CS, default = 1'b0  */
    UINT32 miscerrs : 1;
    /* miscerrs - Bits[7:7], RW1CS, default = 1'b0 
       his error bit is set:
       1. When TE is off DMA/INTR request has AT set to nonzero value.
       2. When TE is on and vtdprivc0 bit 30 is set to 1:
       a. The DMA read request is in interrupt address range 0XFEE.
       b. The DMA request is a translated write request(AT=10)
     */
    UINT32 protmemviol : 1;
    /* protmemviol - Bits[8:8], RW1CS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[30:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 vtderr : 1;
    /* vtderr - Bits[31:31], RW1CS, default = 1'b0 
       When set, this bit is set when a VT-d spec defined error has been detected (and 
       logged in the VT-d fault registers) 
     */
  } Bits;
  UINT32 Data;
} VTUNCERRSTS_IIO_VTD_STRUCT;


/* VTUNCERRMSK_IIO_VTD_REG supported on:                                      */
/*       SKX_A0 (0x401281AC)                                                  */
/*       SKX (0x401281AC)                                                     */
/* Register default value:              0x80000000                            */
#define VTUNCERRMSK_IIO_VTD_REG 0x110041AC
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Mask out error reporting to IIO.  Bit [31] should always be set to 1.  We 
 * recommend that the other bits be left as zero so these internal errors are 
 * reported out. 
 * Setting bits will not prevent any error collecting INSIDE of VTd (in the VTd 
 * Fault Recording Registers).   
 */
typedef union {
  struct {
    UINT32 perr_context_cache_msk : 1;
    /* perr_context_cache_msk - Bits[0:0], RWS, default = 1'b0  */
    UINT32 perr_l1_lookup_msk : 1;
    /* perr_l1_lookup_msk - Bits[1:1], RWS, default = 1'b0  */
    UINT32 perr_l2_lookup_msk : 1;
    /* perr_l2_lookup_msk - Bits[2:2], RWS, default = 1'b0  */
    UINT32 perr_l3_lookup_msk : 1;
    /* perr_l3_lookup_msk - Bits[3:3], RWS, default = 1'b0  */
    UINT32 perr_tlb0_msk : 1;
    /* perr_tlb0_msk - Bits[4:4], RWS, default = 1'b0  */
    UINT32 perr_tlb1_msk : 1;
    /* perr_tlb1_msk - Bits[5:5], RWS, default = 1'b0  */
    UINT32 unsucc_ci_rdcp_msk : 1;
    /* unsucc_ci_rdcp_msk - Bits[6:6], RWS, default = 1'b0  */
    UINT32 miscerrm : 1;
    /* miscerrm - Bits[7:7], RWS, default = 1'b0  */
    UINT32 protmemviol_msk : 1;
    /* protmemviol_msk - Bits[8:8], RWS, default = 1'b0  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[30:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 vtderr_msk : 1;
    /* vtderr_msk - Bits[31:31], RWS, default = 1'b1 
       This bit should be set to 1 by BIOS. It is highly recommended that this bit is 
       never set to 0. 
       If VTd errors are configured to be fatal, leaving this bit set to 0 will cause 
       Fatal errors to be reported when devices send illegal requests. This is 
       generally undesireable. 
       
     */
  } Bits;
  UINT32 Data;
} VTUNCERRMSK_IIO_VTD_STRUCT;


/* VTUNCERRSEV_IIO_VTD_REG supported on:                                      */
/*       SKX_A0 (0x401281B0)                                                  */
/*       SKX (0x401281B0)                                                     */
/* Register default value:              0x000001BF                            */
#define VTUNCERRSEV_IIO_VTD_REG 0x110041B0
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x1b0
 */
typedef union {
  struct {
    UINT32 perr_context_cache_sev : 1;
    /* perr_context_cache_sev - Bits[0:0], RWS, default = 1'b1  */
    UINT32 perr_l1_lookup_sev : 1;
    /* perr_l1_lookup_sev - Bits[1:1], RWS, default = 1'b1  */
    UINT32 perr_l2_lookup_sev : 1;
    /* perr_l2_lookup_sev - Bits[2:2], RWS, default = 1'b1  */
    UINT32 perr_l3_lookup_sev : 1;
    /* perr_l3_lookup_sev - Bits[3:3], RWS, default = 1'b1  */
    UINT32 perr_tlb0_sev : 1;
    /* perr_tlb0_sev - Bits[4:4], RWS, default = 1'b1  */
    UINT32 perr_tlb1_sev : 1;
    /* perr_tlb1_sev - Bits[5:5], RWS, default = 1'b1  */
    UINT32 unsucc_ci_rdcp_sev : 1;
    /* unsucc_ci_rdcp_sev - Bits[6:6], RWS, default = 1'b0  */
    UINT32 miscerrsev : 1;
    /* miscerrsev - Bits[7:7], RWS, default = 1'b1  */
    UINT32 protmemviol_sev : 1;
    /* protmemviol_sev - Bits[8:8], RWS, default = 1'b1  */
    UINT32 rsvd : 22;
    /* rsvd - Bits[30:9], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 vtderr_sev : 1;
    /* vtderr_sev - Bits[31:31], RWS, default = 1'b0 
       When set, this bit escalates reporting of VT-d spec defined errors, as FATAL 
       errors. When clear, those errors are escalated as Nonfatal errors. 
       Setting this bit to a 1 can allow a guest VM to trigger an unrecoverable FATAL 
       error at the platform. It is HIGHLY recommended that BIOS keep this bit set to 
       0, as such behavior is generally undesirable. 
     */
  } Bits;
  UINT32 Data;
} VTUNCERRSEV_IIO_VTD_STRUCT;


/* VTUNCERRPTR_IIO_VTD_REG supported on:                                      */
/*       SKX_A0 (0x101281B4)                                                  */
/*       SKX (0x101281B4)                                                     */
/* Register default value:              0x00                                  */
#define VTUNCERRPTR_IIO_VTD_REG 0x110011B4
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x1b4
 */
typedef union {
  struct {
    UINT8 vt_uncferr_ptr : 5;
    /* vt_uncferr_ptr - Bits[4:0], ROS_V, default = 5'b00000 
       This field points to which of the unmasked uncorrectable errors happened first. 
       This field is only valid when the corresponding error is unmasked and the status 
       bit is set and this field is rearmed to load again when the status bit indicated 
       to by this pointer is cleared by software from 1 to 0. 
       Value of 0x0 corresponds to bit 0 in VTUNCERRSTS register, value of 0x1 
       corresponds to bit 1 etc. 
     */
    UINT8 rsvd : 3;
    /* rsvd - Bits[7:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT8 Data;
} VTUNCERRPTR_IIO_VTD_STRUCT;


/* IIOMISCCTRL_N0_IIO_VTD_REG supported on:                                   */
/*       SKX_A0 (0x401281C0)                                                  */
/*       SKX (0x401281C0)                                                     */
/* Register default value:              0x40050270                            */
#define IIOMISCCTRL_N0_IIO_VTD_REG 0x110041C0
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x1c0
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    UINT32 uniphy_disable : 1;
    /* uniphy_disable - Bits[1:1], RWS_O, default = 1'b0 
       Place entire UNIPHY in L2 (for when no ports are used, as in some multi-socket 
       configurations) 
     */
    UINT32 en1k : 1;
    /* en1k - Bits[2:2], RW_LB, default = 1'b0 
       This bit when set, enables 1K granularity for I/O space decode in each of the 
       virtual P2P bridges corresponding to root ports, and DMI ports. 
     */
    UINT32 tocm : 5;
    /* tocm - Bits[7:3], RW_LB, default = 5'b01110 
       Indicates the top of Core physical addressability limit.
       00000-00100: Reserved
       00101: 2^37
       00110: 2^38
       ...
       1110: 2^46
       01111 -11111: Reserved
       iio uses this to abort all inbound transactions that cross this limit.
     */
    UINT32 tocmvalid : 1;
    /* tocmvalid - Bits[8:8], RW_LB, default = 1'b0 
       Enables the TOCM field.
     */
    UINT32 azalia_on_vcp : 1;
    /* azalia_on_vcp - Bits[9:9], RW, default = 1'b1 
       This bit indicates whether Isoch Azalia traffic from PCH will use the VCp 
       channel or the VC1 channel. It is used to optimized isoch traffic flow. 
       0: traffic on VCP will not use the low latency VC1 paths, but VCP will use VC0 
       resources. 
       1: Isoch Azalia traffic optimized for VCp - VC1 and VCp will use the low latency 
       paths 
     */
    UINT32 legacy_port : 1;
    /* legacy_port - Bits[10:10], RW_LBV, default = 1'b0 
       Sockets where the NodeID=0 are generally identified as having the legacy DMI 
       port. But there is still a possibility that another socket also has a NodeID=0. 
       The system is configured by software to route legacy transactions to the correct 
       socket. However, inbound legacy messages received on a PCIe port of a socket 
       with NodeID=0 that is not the true legacy port need to be routed to a remote 
       socket that is the true legacy port. 
       For a local NodeID is zero, this bit is used to determine if inbound messages 
       should be routed to a DMI port on a remote socket with NodeID=0, or if the 
       messages should be sent to the local DMI port, since the local NodeID is also 0. 
       If the local NodeID is not zero, then this bit is ignored. 
       0: indicates this socket has the true DMI legacy port, send legacy transactions 
       to local DMI port 
       1: indicates this is a non-legacy socket, send legacy transactions to the 
       Coherent Interface 
       Notes:
       This bit does not affect routing for non-message transactions. It only affects 
       inbound messages that need to be routed to the true legacy port. 
       This bit is NOT used for any outbound address decode/routing purposes. Outbound 
       traffic that is subtractively decoded will always be forwarded to local DMI 
       port, if one exists, or it will be aborted. 
       The default value of this field is based on the NodeID and FWAGENT_DMIMODE 
       straps. 
       Software can only change this bit after reset during early boot phase, but must 
       guarantee there is no traffic flowing through the system, except for the write 
       that changes this bit. 
     */
    UINT32 rsvd_11 : 1;
    /* rsvd_11 - Bits[11:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 lock_thaw_mode : 1;
    /* lock_thaw_mode - Bits[12:12], RW, default = 1'b0 
       Mode controls how inbound queues in the south agents (PCIE, DMI) thaw when they 
       are target of a locked read. 
       0: Thaw only posted requests
       1: Thaw posted and non-posted requests.
       Note that if the lock target is also a 'problematic' port (as indicated by in 
       MISCCTRLSTS register), then this becomes meaningless because both posted and 
       non-posted requests are thawed. 
     */
    UINT32 vc1_reads_bypass_writes : 1;
    /* vc1_reads_bypass_writes - Bits[13:13], RW, default = 1'b0 
       0: VC1 Reads push VC1 writes
       1: VC1 Reads are allowed to bypass VC1 writes
       
     */
    UINT32 pipeline_ns_writes_on_csi : 1;
    /* pipeline_ns_writes_on_csi - Bits[14:14], RW, default = 1'b0 
       When set, allows inbound non-snooped writes to pipeline at the coherent 
       interface - issuing the writes before previous writes are completed in the 
       coherent domain. 
     */
    UINT32 dmi_vc1_vt_d_fetch_ordering : 1;
    /* dmi_vc1_vt_d_fetch_ordering - Bits[15:15], RW, default = 1'b0 
       This mode is to allow VC1 VT-d conflicts with outstanding VC0 VT-d reads on IDI 
       to be pipelined. This can occur when VT-d tables are shared between Azalia (VC1) 
       and other devices. To ensure QoS the VT-d reads from VC1 need to be issued in 
       parallel with non-Isoc accesses to the same cacheline. 
       0: Serialize all IDI address conflicts to DRAM
       1: Pipeline VT-d reads from VC1 with address conflict on IDI
       Notes:
       A maximum of 1 VC1 VT-d read and 1 non-VC1 VT-d read to the same address can be 
       outstanding on IDI. 
     */
    UINT32 dmi_vc1_write_ordering : 2;
    /* dmi_vc1_write_ordering - Bits[17:16], RW, default = 2'b01 
       Mode is used to control VC1 write traffic from DMI (Azalia).
       00: Reserved
       01: Serialize writes on Intel QPI issuing one at a time
       10: Reserved
       11: Pipeline writes on Intel QPI based on RO bit i.e. if RO=1, pipeline a write 
       on QPI without waiting for prior write to have reached global observability. If 
       RO=0, then it needs to wait till prior writes have all reached global 
       observability. 
     */
    UINT32 disable_inbound_ro_for_vc0 : 1;
    /* disable_inbound_ro_for_vc0 - Bits[18:18], RW, default = 1'b1 
       When enabled this mode will treat all inbound write traffic as RO=0 for VC0. 
       This affects all PCI Express ports and the DMI port.0 - Ordering of inbound 
       transactions is based on RO bit for VC0 
       1 - RO bit is treated as '0' for all inbound VC0 traffic
       Note that this pretty much impacts only the NS write traffic because for snooped 
       traffic RO bit is ignored by h/w. When this bit is set, the NS write (if 
       enabled) BW is going to be generally bad. 
       Note that this bit does not impact VC1 and VCm writes
     */
    UINT32 rvgaen : 1;
    /* rvgaen - Bits[19:19], RW_LB, default = 1'b0 
       Remote VGA EnableEnables VGA accesses to be sent to remote node.
       If set, accesses to the VGA region (A_0000 to B_FFFF) will be forwarded to the 
       CBo where it will determine the node ID where the VGA region resides. It will 
       then be forwarded to the given remote node. 
       If clear, then VGA accesses will be forwarded to the local PCIe port that has 
       it's VGAEN set. If none have their VGAEN set, then the request will be forwarded 
       to the local DMI port, if operating in DMI mode. If it is not operating in DMI 
       mode, then the request will be aborted. 
     */
    UINT32 rsvd_20 : 2;
    /* rsvd_20 - Bits[21:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 disable_ro_on_writes_from_cb_dma : 1;
    /* disable_ro_on_writes_from_cb_dma - Bits[22:22], RW, default = 1'b0  */
    UINT32 disable_ro_on_vcm_writes : 1;
    /* disable_ro_on_vcm_writes - Bits[23:23], RW, default = 1'b0 
       When set, all writes on VCm are treated as if RO=0.
     */
    UINT32 disable_all_allocating_flows : 1;
    /* disable_all_allocating_flows - Bits[24:24], RW, default = 1'b0 
       When this bit is set, IIO will force coherent inbound writes to use the 
       non-allocating flow (PCIItoM/RFO followed by CLFlush). This is provided 
       primarily for PSMI where we need a mode to leave LLC invalidated after a certain 
       point (but non-allocating writes on HSX will still use LLC, so things like LRU 
       may be affected). 
     */
    UINT32 rsvd_25 : 5;
    /* rsvd_25 - Bits[29:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 treat_last_write_in_descriptor_specially : 1;
    /* treat_last_write_in_descriptor_specially - Bits[30:30], RW, default = 1'b1 
       Treat CB DMA writes with NS=RO=1 & NS is enabled in CB DMA & 'last write in 
       descriptor', as-if NS=1 and RO=0 write 
     */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} IIOMISCCTRL_N0_IIO_VTD_STRUCT;


/* IIOMISCCTRL_N1_IIO_VTD_REG supported on:                                   */
/*       SKX_A0 (0x401281C4)                                                  */
/*       SKX (0x401281C4)                                                     */
/* Register default value:              0x00260050                            */
#define IIOMISCCTRL_N1_IIO_VTD_REG 0x110041C4
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x1c0
 */
typedef union {
  struct {
    UINT32 showportid : 1;
    /* showportid - Bits[0:0], RWS, default = 1'b0 
       A Port Identifier that identifies which PCI Express port a transaction comes 
       from will be placed in the AD Ring TNID[3:0] field of the request packet, when 
       enabled. This field is normally used for DCAHint and is not used for normal 
       demand read. 
       Since there are up to 11 specific ports, then Port ID is encoded in 4 bits.
       The PortIDs are mapped as follows:
       0: Device 0 Function 0 DMI/PCIe port 0 (IOU2)
       1: Device 1 Function 0 Port 1a (x4 or x8) (IOU2)
       2: Device 1 Function 1 Port 1b (x4) (IOU2)
       3: Device 2 Function 0 Port 2a (x4, x8, or x16) (IOU0)
       4: Device 2 Function 1 Port 2b (x4) (IOU0)
       5: Device 2 Function 2 Port 2c (x4 or x8) (IOU0)
       6: Device 2 Function 3 Port 2d (x4) (IOU0)
       7: Device 3 Function 0 Port 3a (x4, x8, or x16) or NTB port (x4 or x8) (IOU1)
       8: Device 3 Function 1 Port 3b (x4) (IOU1)
       9: Device 3 Function 2 Port 3c (x4 or x8) (IOU1)
       10: Device 3 Function 3 Port 3d (x4) (IOU1)
       11: CB
       12: VT
       The TNID[3:0] value will be copied to the TORID[4:0] by CBo, if the packet is to 
       be sent to the Intel QPI port. 
     */
    UINT32 force_6b_mc_group : 1;
    /* force_6b_mc_group - Bits[1:1], RW_LB, default = 1'b0  */
    UINT32 rsvd_2 : 2;
    /* rsvd_2 - Bits[3:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 poisocfen : 1;
    /* poisocfen - Bits[4:4], RW, default = 1'b1 
       Standard RAS: 
       1. Set this bit - If end device supports EP bit handling or if end device does 
       not support EP bit handling but stop and scream is enabled 
       2. Clear this bit - if DMI3 port or if end device does not support EP bit 
       handling and Stop and Scream is disabled 
       
       Advanced RAS:
       1. Set this bit - If end device supports EP bit handling or if end device does 
       not support EP bit handling but LER is enabled 
       2. Clear this bit - if DMI3 port or if end device does not support EP bit 
       handling and LER is disabled 
       
     */
    UINT32 poisfen : 1;
    /* poisfen - Bits[5:5], RW, default = 1'b0 
       Enables poisoned data received inbound to be forwarded to the destination (DRAM 
       or Cache or PCIe Peer). 
       0: Poison indication is not forwarded with the data
       (this may result in silent corruption if AER poison reporting is disabled).
       1: Poison indication is forwarded with the data
       (this may result in a conflict with MCA poison reporting if AER poison reporting 
       is enabled) 
       
     */
    UINT32 uniphy_en_fuse4_pwrdn : 1;
    /* uniphy_en_fuse4_pwrdn - Bits[6:6], RWS_O, default = 1'b1  */
    UINT32 disable_new_apic_ordering : 1;
    /* disable_new_apic_ordering - Bits[7:7], RW_LB, default = 1'b0 
       TBG found a problem in the IOAPIC block that causes a hang. A fix is provided
       for JKT. When this bit is set, behavior returns to the original behavior.
     */
    UINT32 enable_io_mca : 1;
    /* enable_io_mca - Bits[8:8], RW, default = 1'b0  */
    UINT32 en_poismsg_spec_behavior : 1;
    /* en_poismsg_spec_behavior - Bits[9:9], RW, default = 1'b0 
       For the processor a POISFEN bit forces the poison error to be logged as an 
       Advisory Non-Fatal error. When this bit is set, the poison severity bit can 
       force Fatal behavior regardless of POISFEN. Generally, however, MCA needs to 
       have priority over AER drivers, so this bit default is 0. Note that the PCIe 
       spec requires this bit to be 0. 
       When this bit is clear:
       sev pfen error
       0 0 non-fatal
       0 1 correctable
       1 0 fatal
       1 1 correctable
       When this bit is set:
       sev pfen error
       0 0 non-fatal
       0 1 correctable
       1 0 fatal
       1 1 fatal
     */
    UINT32 enable_pcc_eq0_sev1 : 1;
    /* enable_pcc_eq0_sev1 - Bits[10:10], RW_LB, default = 1'b0  */
    UINT32 rsvd_11 : 5;
    UINT32 disable_reqid_filter : 1;
    /* disable_reqid_filter - Bits[16:16], RW_O, default = 1'b0  */
    UINT32 enable_read_bypass_irp : 1;
    /* enable_read_bypass_irp - Bits[17:17], RW_L, default = 1'b1  */
    UINT32 cb_prioritize_tph : 1;
    /* cb_prioritize_tph - Bits[18:18], RW, default = 1'b1  */
    UINT32 cb_implicit_tph : 1;
    /* cb_implicit_tph - Bits[19:19], RW, default = 1'b0  */
    UINT32 cb_implicit_nosnp : 1;
    /* cb_implicit_nosnp - Bits[20:20], RW, default = 1'b0  */
    UINT32 mmiolock : 1;
    /* mmiolock - Bits[21:21], RW_LB, default = 1'b1  */
    UINT32 smmmmiolockoverride : 1;
    /* smmmmiolockoverride - Bits[22:22], RW_LB, default = 1'b0  */
    UINT32 rsvd_23 : 9;
    /* rsvd_23 - Bits[31:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} IIOMISCCTRL_N1_IIO_VTD_STRUCT;


/* GENPROTRANGE0_BASE_N0_IIO_VTD_REG supported on:                            */
/*       SKX_A0 (0x40128200)                                                  */
/*       SKX (0x40128200)                                                     */
/* Register default value:              0x7FFFFFFFF0000                       */
#define GENPROTRANGE0_BASE_N0_IIO_VTD_REG 0x11004200
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 base address
 */
typedef union {
  struct {
    UINT32 rsvd : 16;
    /* rsvd - Bits[15:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_address : 16;
    /* base_address - Bits[31:16], RW_LB, default = 35'h7ffffffff 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Base address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE0_BASE_N0_IIO_VTD_STRUCT;


/* GENPROTRANGE0_BASE_N1_IIO_VTD_REG supported on:                            */
/*       SKX_A0 (0x40128204)                                                  */
/*       SKX (0x40128204)                                                     */
/* Register default value:              0x7FFFFFFFF                           */
#define GENPROTRANGE0_BASE_N1_IIO_VTD_REG 0x11004204
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 base address
 */
typedef union {
  struct {
    UINT32 base_address : 19;
    /* base_address - Bits[18:0], RW_LB, default = 35'h7ffffffff 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Base address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE0_BASE_N1_IIO_VTD_STRUCT;


/* GENPROTRANGE0_LIMIT_N0_IIO_VTD_REG supported on:                           */
/*       SKX_A0 (0x40128208)                                                  */
/*       SKX (0x40128208)                                                     */
/* Register default value:              0x00000000                            */
#define GENPROTRANGE0_LIMIT_N0_IIO_VTD_REG 0x11004208
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 limit address
 */
typedef union {
  struct {
    UINT32 rsvd : 16;
    /* rsvd - Bits[15:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limit_address : 16;
    /* limit_address - Bits[31:16], RW_LB, default = 35'h0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Limit address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE0_LIMIT_N0_IIO_VTD_STRUCT;


/* GENPROTRANGE0_LIMIT_N1_IIO_VTD_REG supported on:                           */
/*       SKX_A0 (0x4012820C)                                                  */
/*       SKX (0x4012820C)                                                     */
/* Register default value:              0x00000000                            */
#define GENPROTRANGE0_LIMIT_N1_IIO_VTD_REG 0x1100420C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 limit address
 */
typedef union {
  struct {
    UINT32 limit_address : 19;
    /* limit_address - Bits[18:0], RW_LB, default = 35'h0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Limit address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE0_LIMIT_N1_IIO_VTD_STRUCT;


/* GENPROTRANGE1_BASE_N0_IIO_VTD_REG supported on:                            */
/*       SKX_A0 (0x40128210)                                                  */
/*       SKX (0x40128210)                                                     */
/* Register default value:              0x7FFFFFFFF0000                       */
#define GENPROTRANGE1_BASE_N0_IIO_VTD_REG 0x11004210
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 base address
 */
typedef union {
  struct {
    UINT32 rsvd : 16;
    /* rsvd - Bits[15:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_address : 16;
    /* base_address - Bits[31:16], RW_LB, default = 35'h7ffffffff 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Base address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE1_BASE_N0_IIO_VTD_STRUCT;


/* GENPROTRANGE1_BASE_N1_IIO_VTD_REG supported on:                            */
/*       SKX_A0 (0x40128214)                                                  */
/*       SKX (0x40128214)                                                     */
/* Register default value:              0x7FFFFFFFF                           */
#define GENPROTRANGE1_BASE_N1_IIO_VTD_REG 0x11004214
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 base address
 */
typedef union {
  struct {
    UINT32 base_address : 19;
    /* base_address - Bits[18:0], RW_LB, default = 35'h7ffffffff 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Base address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE1_BASE_N1_IIO_VTD_STRUCT;


/* GENPROTRANGE1_LIMIT_N0_IIO_VTD_REG supported on:                           */
/*       SKX_A0 (0x40128218)                                                  */
/*       SKX (0x40128218)                                                     */
/* Register default value:              0x00000000                            */
#define GENPROTRANGE1_LIMIT_N0_IIO_VTD_REG 0x11004218
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 limit address
 */
typedef union {
  struct {
    UINT32 rsvd : 16;
    /* rsvd - Bits[15:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limit_address : 16;
    /* limit_address - Bits[31:16], RW_LB, default = 35'h0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Limit address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE1_LIMIT_N0_IIO_VTD_STRUCT;


/* GENPROTRANGE1_LIMIT_N1_IIO_VTD_REG supported on:                           */
/*       SKX_A0 (0x4012821C)                                                  */
/*       SKX (0x4012821C)                                                     */
/* Register default value:              0x00000000                            */
#define GENPROTRANGE1_LIMIT_N1_IIO_VTD_REG 0x1100421C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 limit address
 */
typedef union {
  struct {
    UINT32 limit_address : 19;
    /* limit_address - Bits[18:0], RW_LB, default = 35'h0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Limit address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE1_LIMIT_N1_IIO_VTD_STRUCT;


/* GENPROTRANGE2_BASE_N0_IIO_VTD_REG supported on:                            */
/*       SKX_A0 (0x40128220)                                                  */
/*       SKX (0x40128220)                                                     */
/* Register default value:              0x7FFFFFFFF0000                       */
#define GENPROTRANGE2_BASE_N0_IIO_VTD_REG 0x11004220
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 base address
 */
typedef union {
  struct {
    UINT32 rsvd : 16;
    /* rsvd - Bits[15:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_address : 16;
    /* base_address - Bits[31:16], RW_LB, default = 35'h7ffffffff 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Base address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE2_BASE_N0_IIO_VTD_STRUCT;


/* GENPROTRANGE2_BASE_N1_IIO_VTD_REG supported on:                            */
/*       SKX_A0 (0x40128224)                                                  */
/*       SKX (0x40128224)                                                     */
/* Register default value:              0x7FFFFFFFF                           */
#define GENPROTRANGE2_BASE_N1_IIO_VTD_REG 0x11004224
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 base address
 */
typedef union {
  struct {
    UINT32 base_address : 19;
    /* base_address - Bits[18:0], RW_LB, default = 35'h7ffffffff 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Base address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE2_BASE_N1_IIO_VTD_STRUCT;


/* GENPROTRANGE2_LIMIT_N0_IIO_VTD_REG supported on:                           */
/*       SKX_A0 (0x40128228)                                                  */
/*       SKX (0x40128228)                                                     */
/* Register default value:              0x00000000                            */
#define GENPROTRANGE2_LIMIT_N0_IIO_VTD_REG 0x11004228
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 limit address
 */
typedef union {
  struct {
    UINT32 rsvd : 16;
    /* rsvd - Bits[15:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limit_address : 16;
    /* limit_address - Bits[31:16], RW_LB, default = 35'h0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Limit address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE2_LIMIT_N0_IIO_VTD_STRUCT;


/* GENPROTRANGE2_LIMIT_N1_IIO_VTD_REG supported on:                           */
/*       SKX_A0 (0x4012822C)                                                  */
/*       SKX (0x4012822C)                                                     */
/* Register default value:              0x00000000                            */
#define GENPROTRANGE2_LIMIT_N1_IIO_VTD_REG 0x1100422C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 limit address
 */
typedef union {
  struct {
    UINT32 limit_address : 19;
    /* limit_address - Bits[18:0], RW_LB, default = 35'h0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Limit address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE2_LIMIT_N1_IIO_VTD_STRUCT;


/* GENPROTRANGE3_BASE_N0_IIO_VTD_REG supported on:                            */
/*       SKX_A0 (0x40128230)                                                  */
/*       SKX (0x40128230)                                                     */
/* Register default value:              0x7FFFFFFFF0000                       */
#define GENPROTRANGE3_BASE_N0_IIO_VTD_REG 0x11004230
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 base address
 */
typedef union {
  struct {
    UINT32 rsvd : 16;
    /* rsvd - Bits[15:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_address : 16;
    /* base_address - Bits[31:16], RW_LB, default = 35'h7ffffffff 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Base address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE3_BASE_N0_IIO_VTD_STRUCT;


/* GENPROTRANGE3_BASE_N1_IIO_VTD_REG supported on:                            */
/*       SKX_A0 (0x40128234)                                                  */
/*       SKX (0x40128234)                                                     */
/* Register default value:              0x7FFFFFFFF                           */
#define GENPROTRANGE3_BASE_N1_IIO_VTD_REG 0x11004234
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 base address
 */
typedef union {
  struct {
    UINT32 base_address : 19;
    /* base_address - Bits[18:0], RW_LB, default = 35'h7ffffffff 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Base address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE3_BASE_N1_IIO_VTD_STRUCT;


/* GENPROTRANGE3_LIMIT_N0_IIO_VTD_REG supported on:                           */
/*       SKX_A0 (0x40128238)                                                  */
/*       SKX (0x40128238)                                                     */
/* Register default value:              0x00000000                            */
#define GENPROTRANGE3_LIMIT_N0_IIO_VTD_REG 0x11004238
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 limit address
 */
typedef union {
  struct {
    UINT32 rsvd : 16;
    /* rsvd - Bits[15:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limit_address : 16;
    /* limit_address - Bits[31:16], RW_LB, default = 35'h0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Limit address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE3_LIMIT_N0_IIO_VTD_STRUCT;


/* GENPROTRANGE3_LIMIT_N1_IIO_VTD_REG supported on:                           */
/*       SKX_A0 (0x4012823C)                                                  */
/*       SKX (0x4012823C)                                                     */
/* Register default value:              0x00000000                            */
#define GENPROTRANGE3_LIMIT_N1_IIO_VTD_REG 0x1100423C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 limit address
 */
typedef union {
  struct {
    UINT32 limit_address : 19;
    /* limit_address - Bits[18:0], RW_LB, default = 35'h0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Limit address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE3_LIMIT_N1_IIO_VTD_STRUCT;


/* GENPROTRANGE4_BASE_N0_IIO_VTD_REG supported on:                            */
/*       SKX_A0 (0x40128240)                                                  */
/*       SKX (0x40128240)                                                     */
/* Register default value:              0x7FFFFFFFF0000                       */
#define GENPROTRANGE4_BASE_N0_IIO_VTD_REG 0x11004240
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 base address
 */
typedef union {
  struct {
    UINT32 rsvd : 16;
    /* rsvd - Bits[15:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 base_address : 16;
    /* base_address - Bits[31:16], RW_LB, default = 35'h7ffffffff 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Base address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE4_BASE_N0_IIO_VTD_STRUCT;


/* GENPROTRANGE4_BASE_N1_IIO_VTD_REG supported on:                            */
/*       SKX_A0 (0x40128244)                                                  */
/*       SKX (0x40128244)                                                     */
/* Register default value:              0x7FFFFFFFF                           */
#define GENPROTRANGE4_BASE_N1_IIO_VTD_REG 0x11004244
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 base address
 */
typedef union {
  struct {
    UINT32 base_address : 19;
    /* base_address - Bits[18:0], RW_LB, default = 35'h7ffffffff 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Base address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE4_BASE_N1_IIO_VTD_STRUCT;


/* GENPROTRANGE4_LIMIT_N0_IIO_VTD_REG supported on:                           */
/*       SKX_A0 (0x40128248)                                                  */
/*       SKX (0x40128248)                                                     */
/* Register default value:              0x00000000                            */
#define GENPROTRANGE4_LIMIT_N0_IIO_VTD_REG 0x11004248
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 limit address
 */
typedef union {
  struct {
    UINT32 rsvd : 16;
    /* rsvd - Bits[15:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limit_address : 16;
    /* limit_address - Bits[31:16], RW_LB, default = 35'h0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Limit address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE4_LIMIT_N0_IIO_VTD_STRUCT;


/* GENPROTRANGE4_LIMIT_N1_IIO_VTD_REG supported on:                           */
/*       SKX_A0 (0x4012824C)                                                  */
/*       SKX (0x4012824C)                                                     */
/* Register default value:              0x00000000                            */
#define GENPROTRANGE4_LIMIT_N1_IIO_VTD_REG 0x1100424C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Generic protected memory range 0 limit address
 */
typedef union {
  struct {
    UINT32 limit_address : 19;
    /* limit_address - Bits[18:0], RW_LB, default = 35'h0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
       Limit address
       [50:16] of generic memory address range that needs to be protected from inbound 
       dma accesses. The protected memory range can be anywhere in the memory space 
       addressable by the processor. Addresses that fall in this range i.e. 
       GenProtRange.Base[63:16] < Address [63:16] < GenProtRange.Limit [63:16], are 
       completer aborted by IIO.  
       Setting the Protected range base address greater than the limit address disables 
       the protected memory region. Note that this range is orthogonal to VT-d spec 
       defined protected address range. 
               
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} GENPROTRANGE4_LIMIT_N1_IIO_VTD_STRUCT;


/* LTDPR_IIO_VTD_REG supported on:                                            */
/*       SKX_A0 (0x40128290)                                                  */
/*       SKX (0x40128290)                                                     */
/* Register default value:              0x00000000                            */
#define LTDPR_IIO_VTD_REG 0x11004290
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * General Description: This register holds the address and size of the DMA 
 * protected memory region for Intel TXT usage. 
 */
typedef union {
  struct {
    UINT32 lock : 1;
    /* lock - Bits[0:0], RW_O, default = 1'b0 
       Bits 19:0 are locked down in this register when this bit is set. Can this be set 
       while other bits are being written to in the same write transaction? 
     */
    UINT32 protregsts : 1;
    /* protregsts - Bits[1:1], RO, default = 1'b0 
       IIO sets this bit when the protection has been enabled in hardware and for all 
       practical purposes this should be immediate. When protection is disabled, then 
       this bit is clear 
     */
    UINT32 commandbit : 1;
    /* commandbit - Bits[2:2], RW_L, default = 1'b0 
       Writing a '1' to this bit will enable protection.
       Writing a '0' to this bit will disable protection.
     */
    UINT32 rsvd_3 : 1;
    /* rsvd_3 - Bits[3:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 size : 8;
    /* size - Bits[11:4], RW_L, default = 8'b00000000 
       This is the size of memory, in MB, that will be protected from DMA accesses. A 
       value of 0x00 in this field means no additional memory is protected. The maximum 
       amount of memory that will be protected is 255 MB. 
       The amount of memory reported in this field will be protected from all DMA 
       accesses. The top of the protected range is typically the BASE of TSEG -1. BIOS 
       is expected to program that in to bits 31:20 of this register. 
       Notes:
       If TSEG is not enabled, then the top of this range becomes the base ME stolen 
       space, whichever would have been the location of TSEG, assuming it had been 
       enabled. 
       The DPR range works independently of any other range - Generic Protected ranges, 
       TSEG range, VT-d tables, VT-d protection ranges, MMCFG protection range and is 
       done post any VTd translation or Intel TXT checks. Therefore incoming cycles are 
       checked against this range after the VTd translation and faulted if they hit 
       this protected range, even if they passed the VTd translation. 
       All the memory checks are OR'ed with respect to NOT being allowed to go to 
       memory. So if either Generic protection range, DPR, VT-d, TSEG range disallows 
       the cycle, then the cycle is not allowed to go to memory. Or in other words, all 
       the above checks must pass before a cycle is allowed to DRAM. 
       DMA remap engines are allowed to access the DPR region without any faulting. It 
       is always legal for any DMA remap engine to read or write into the DPR region, 
       thus DMA remap accesses must not be checked against the DPR range. 
     */
    UINT32 rsvd_12 : 8;
    /* rsvd_12 - Bits[19:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 topofdpr : 12;
    /* topofdpr - Bits[31:20], RO_V, default = 12'b000000000000 
       Top address + 1 of DPR. This is RO, and it is copied by HW from TSEGBASE[31:20].
     */
  } Bits;
  UINT32 Data;
} LTDPR_IIO_VTD_STRUCT;


/* DETMCFGTIMER_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x4012829C)                                                  */
/*       SKX (0x4012829C)                                                     */
/* Register default value:              0x00000060                            */
#define DETMCFGTIMER_IIO_VTD_REG 0x1100429C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * generated by critter 05_0_0x29c
 */
typedef union {
  struct {
    UINT32 detcfgtmr : 32;
    /* detcfgtmr - Bits[31:0], RWS, default = 32'b00000000000000000000000001100000  */
  } Bits;
  UINT32 Data;
} DETMCFGTIMER_IIO_VTD_STRUCT;


/* MMIOL_RULE0_IIO_VTD_REG supported on:                                      */
/*       SKX_A0 (0x40128300)                                                  */
/*       SKX (0x40128300)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOL_RULE0_IIO_VTD_REG 0x11004300
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Rule 0
 */
typedef union {
  struct {
    UINT32 ruleenable : 1;
    /* ruleenable - Bits[0:0], RW_LB, default = 'b0 
       
                   Enable for this MMIO rule.
                
     */
    UINT32 serializerule : 2;
    /* serializerule - Bits[2:1], RW_LB, default = 'b00 
       
                   Specifies the serialization rules for ordering.
                   RuleEnable
                   Enable for this MMIO rule.
                
     */
    UINT32 rsvd_3 : 3;
    /* rsvd_3 - Bits[5:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 baseaddress : 10;
    /* baseaddress - Bits[15:6], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule base address. Both 
       base and limit must match to declare a match to this MMIO rule. The granularity 
       of MMIO rule is 4MB. 
                
     */
    UINT32 remotestackid : 3;
    /* remotestackid - Bits[18:16], RW_LB, default = 'b000 
       
                   Specifies the target IIO stack in the target socket.
                
     */
    UINT32 rsvd_19 : 3;
    /* rsvd_19 - Bits[21:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limitaddress : 10;
    /* limitaddress - Bits[31:22], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule top limit address. 
       Both base and limit must match to declare a match to this MMIO rule. 
                
     */
  } Bits;
  UINT32 Data;
} MMIOL_RULE0_IIO_VTD_STRUCT;


/* MMIOL_RULE1_IIO_VTD_REG supported on:                                      */
/*       SKX_A0 (0x40128304)                                                  */
/*       SKX (0x40128304)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOL_RULE1_IIO_VTD_REG 0x11004304
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Rule 1
 */
typedef union {
  struct {
    UINT32 ruleenable : 1;
    /* ruleenable - Bits[0:0], RW_LB, default = 'b0 
       
                   Enable for this MMIO rule.
                
     */
    UINT32 serializerule : 2;
    /* serializerule - Bits[2:1], RW_LB, default = 'b00 
       
                   Specifies the serialization rules for ordering.
                   RuleEnable
                   Enable for this MMIO rule.
                
     */
    UINT32 rsvd_3 : 3;
    /* rsvd_3 - Bits[5:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 baseaddress : 10;
    /* baseaddress - Bits[15:6], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule base address. Both 
       base and limit must match to declare a match to this MMIO rule. The granularity 
       of MMIO rule is 4MB. 
                
     */
    UINT32 remotestackid : 3;
    /* remotestackid - Bits[18:16], RW_LB, default = 'b000 
       
                   Specifies the target IIO stack in the target socket.
                
     */
    UINT32 rsvd_19 : 3;
    /* rsvd_19 - Bits[21:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limitaddress : 10;
    /* limitaddress - Bits[31:22], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule top limit address. 
       Both base and limit must match to declare a match to this MMIO rule. 
                
     */
  } Bits;
  UINT32 Data;
} MMIOL_RULE1_IIO_VTD_STRUCT;


/* MMIOL_RULE2_IIO_VTD_REG supported on:                                      */
/*       SKX_A0 (0x40128308)                                                  */
/*       SKX (0x40128308)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOL_RULE2_IIO_VTD_REG 0x11004308
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Rule 2
 */
typedef union {
  struct {
    UINT32 ruleenable : 1;
    /* ruleenable - Bits[0:0], RW_LB, default = 'b0 
       
                   Enable for this MMIO rule.
                
     */
    UINT32 serializerule : 2;
    /* serializerule - Bits[2:1], RW_LB, default = 'b00 
       
                   Specifies the serialization rules for ordering.
                   RuleEnable
                   Enable for this MMIO rule.
                
     */
    UINT32 rsvd_3 : 3;
    /* rsvd_3 - Bits[5:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 baseaddress : 10;
    /* baseaddress - Bits[15:6], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule base address. Both 
       base and limit must match to declare a match to this MMIO rule. The granularity 
       of MMIO rule is 4MB. 
                
     */
    UINT32 remotestackid : 3;
    /* remotestackid - Bits[18:16], RW_LB, default = 'b000 
       
                   Specifies the target IIO stack in the target socket.
                
     */
    UINT32 rsvd_19 : 3;
    /* rsvd_19 - Bits[21:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limitaddress : 10;
    /* limitaddress - Bits[31:22], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule top limit address. 
       Both base and limit must match to declare a match to this MMIO rule. 
                
     */
  } Bits;
  UINT32 Data;
} MMIOL_RULE2_IIO_VTD_STRUCT;


/* MMIOL_RULE3_IIO_VTD_REG supported on:                                      */
/*       SKX_A0 (0x4012830C)                                                  */
/*       SKX (0x4012830C)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOL_RULE3_IIO_VTD_REG 0x1100430C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Rule 3
 */
typedef union {
  struct {
    UINT32 ruleenable : 1;
    /* ruleenable - Bits[0:0], RW_LB, default = 'b0 
       
                   Enable for this MMIO rule.
                
     */
    UINT32 serializerule : 2;
    /* serializerule - Bits[2:1], RW_LB, default = 'b00 
       
                   Specifies the serialization rules for ordering.
                   RuleEnable
                   Enable for this MMIO rule.
                
     */
    UINT32 rsvd_3 : 3;
    /* rsvd_3 - Bits[5:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 baseaddress : 10;
    /* baseaddress - Bits[15:6], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule base address. Both 
       base and limit must match to declare a match to this MMIO rule. The granularity 
       of MMIO rule is 4MB. 
                
     */
    UINT32 remotestackid : 3;
    /* remotestackid - Bits[18:16], RW_LB, default = 'b000 
       
                   Specifies the target IIO stack in the target socket.
                
     */
    UINT32 rsvd_19 : 3;
    /* rsvd_19 - Bits[21:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limitaddress : 10;
    /* limitaddress - Bits[31:22], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule top limit address. 
       Both base and limit must match to declare a match to this MMIO rule. 
                
     */
  } Bits;
  UINT32 Data;
} MMIOL_RULE3_IIO_VTD_STRUCT;


/* MMIOL_RULE4_IIO_VTD_REG supported on:                                      */
/*       SKX_A0 (0x40128310)                                                  */
/*       SKX (0x40128310)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOL_RULE4_IIO_VTD_REG 0x11004310
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Rule 4
 */
typedef union {
  struct {
    UINT32 ruleenable : 1;
    /* ruleenable - Bits[0:0], RW_LB, default = 'b0 
       
                   Enable for this MMIO rule.
                
     */
    UINT32 serializerule : 2;
    /* serializerule - Bits[2:1], RW_LB, default = 'b00 
       
                   Specifies the serialization rules for ordering.
                   RuleEnable
                   Enable for this MMIO rule.
                
     */
    UINT32 rsvd_3 : 3;
    /* rsvd_3 - Bits[5:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 baseaddress : 10;
    /* baseaddress - Bits[15:6], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule base address. Both 
       base and limit must match to declare a match to this MMIO rule. The granularity 
       of MMIO rule is 4MB. 
                
     */
    UINT32 remotestackid : 3;
    /* remotestackid - Bits[18:16], RW_LB, default = 'b000 
       
                   Specifies the target IIO stack in the target socket.
                
     */
    UINT32 rsvd_19 : 3;
    /* rsvd_19 - Bits[21:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limitaddress : 10;
    /* limitaddress - Bits[31:22], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule top limit address. 
       Both base and limit must match to declare a match to this MMIO rule. 
                
     */
  } Bits;
  UINT32 Data;
} MMIOL_RULE4_IIO_VTD_STRUCT;


/* MMIOL_RULE5_IIO_VTD_REG supported on:                                      */
/*       SKX_A0 (0x40128314)                                                  */
/*       SKX (0x40128314)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOL_RULE5_IIO_VTD_REG 0x11004314
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Rule 5
 */
typedef union {
  struct {
    UINT32 ruleenable : 1;
    /* ruleenable - Bits[0:0], RW_LB, default = 'b0 
       
                   Enable for this MMIO rule.
                
     */
    UINT32 serializerule : 2;
    /* serializerule - Bits[2:1], RW_LB, default = 'b00 
       
                   Specifies the serialization rules for ordering.
                   RuleEnable
                   Enable for this MMIO rule.
                
     */
    UINT32 rsvd_3 : 3;
    /* rsvd_3 - Bits[5:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 baseaddress : 10;
    /* baseaddress - Bits[15:6], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule base address. Both 
       base and limit must match to declare a match to this MMIO rule. The granularity 
       of MMIO rule is 4MB. 
                
     */
    UINT32 remotestackid : 3;
    /* remotestackid - Bits[18:16], RW_LB, default = 'b000 
       
                   Specifies the target IIO stack in the target socket.
                
     */
    UINT32 rsvd_19 : 3;
    /* rsvd_19 - Bits[21:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limitaddress : 10;
    /* limitaddress - Bits[31:22], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule top limit address. 
       Both base and limit must match to declare a match to this MMIO rule. 
                
     */
  } Bits;
  UINT32 Data;
} MMIOL_RULE5_IIO_VTD_STRUCT;


/* MMIOL_RULE6_IIO_VTD_REG supported on:                                      */
/*       SKX_A0 (0x40128318)                                                  */
/*       SKX (0x40128318)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOL_RULE6_IIO_VTD_REG 0x11004318
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Rule 6
 */
typedef union {
  struct {
    UINT32 ruleenable : 1;
    /* ruleenable - Bits[0:0], RW_LB, default = 'b0 
       
                   Enable for this MMIO rule.
                
     */
    UINT32 serializerule : 2;
    /* serializerule - Bits[2:1], RW_LB, default = 'b00 
       
                   Specifies the serialization rules for ordering.
                   RuleEnable
                   Enable for this MMIO rule.
                
     */
    UINT32 rsvd_3 : 3;
    /* rsvd_3 - Bits[5:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 baseaddress : 10;
    /* baseaddress - Bits[15:6], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule base address. Both 
       base and limit must match to declare a match to this MMIO rule. The granularity 
       of MMIO rule is 4MB. 
                
     */
    UINT32 remotestackid : 3;
    /* remotestackid - Bits[18:16], RW_LB, default = 'b000 
       
                   Specifies the target IIO stack in the target socket.
                
     */
    UINT32 rsvd_19 : 3;
    /* rsvd_19 - Bits[21:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limitaddress : 10;
    /* limitaddress - Bits[31:22], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule top limit address. 
       Both base and limit must match to declare a match to this MMIO rule. 
                
     */
  } Bits;
  UINT32 Data;
} MMIOL_RULE6_IIO_VTD_STRUCT;


/* MMIOL_RULE7_IIO_VTD_REG supported on:                                      */
/*       SKX_A0 (0x4012831C)                                                  */
/*       SKX (0x4012831C)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOL_RULE7_IIO_VTD_REG 0x1100431C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Rule 7
 */
typedef union {
  struct {
    UINT32 ruleenable : 1;
    /* ruleenable - Bits[0:0], RW_LB, default = 'b0 
       
                   Enable for this MMIO rule.
                
     */
    UINT32 serializerule : 2;
    /* serializerule - Bits[2:1], RW_LB, default = 'b00 
       
                   Specifies the serialization rules for ordering.
                   RuleEnable
                   Enable for this MMIO rule.
                
     */
    UINT32 rsvd_3 : 3;
    /* rsvd_3 - Bits[5:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 baseaddress : 10;
    /* baseaddress - Bits[15:6], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule base address. Both 
       base and limit must match to declare a match to this MMIO rule. The granularity 
       of MMIO rule is 4MB. 
                
     */
    UINT32 remotestackid : 3;
    /* remotestackid - Bits[18:16], RW_LB, default = 'b000 
       
                   Specifies the target IIO stack in the target socket.
                
     */
    UINT32 rsvd_19 : 3;
    /* rsvd_19 - Bits[21:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limitaddress : 10;
    /* limitaddress - Bits[31:22], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule top limit address. 
       Both base and limit must match to declare a match to this MMIO rule. 
                
     */
  } Bits;
  UINT32 Data;
} MMIOL_RULE7_IIO_VTD_STRUCT;


/* MMIOL_RULE8_IIO_VTD_REG supported on:                                      */
/*       SKX_A0 (0x40128320)                                                  */
/*       SKX (0x40128320)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOL_RULE8_IIO_VTD_REG 0x11004320
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Rule 8
 */
typedef union {
  struct {
    UINT32 ruleenable : 1;
    /* ruleenable - Bits[0:0], RW_LB, default = 'b0 
       
                   Enable for this MMIO rule.
                
     */
    UINT32 serializerule : 2;
    /* serializerule - Bits[2:1], RW_LB, default = 'b00 
       
                   Specifies the serialization rules for ordering.
                   RuleEnable
                   Enable for this MMIO rule.
                
     */
    UINT32 rsvd_3 : 3;
    /* rsvd_3 - Bits[5:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 baseaddress : 10;
    /* baseaddress - Bits[15:6], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule base address. Both 
       base and limit must match to declare a match to this MMIO rule. The granularity 
       of MMIO rule is 4MB. 
                
     */
    UINT32 remotestackid : 3;
    /* remotestackid - Bits[18:16], RW_LB, default = 'b000 
       
                   Specifies the target IIO stack in the target socket.
                
     */
    UINT32 rsvd_19 : 3;
    /* rsvd_19 - Bits[21:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limitaddress : 10;
    /* limitaddress - Bits[31:22], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule top limit address. 
       Both base and limit must match to declare a match to this MMIO rule. 
                
     */
  } Bits;
  UINT32 Data;
} MMIOL_RULE8_IIO_VTD_STRUCT;


/* MMIOL_RULE9_IIO_VTD_REG supported on:                                      */
/*       SKX_A0 (0x40128324)                                                  */
/*       SKX (0x40128324)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOL_RULE9_IIO_VTD_REG 0x11004324
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Rule 9
 */
typedef union {
  struct {
    UINT32 ruleenable : 1;
    /* ruleenable - Bits[0:0], RW_LB, default = 'b0 
       
                   Enable for this MMIO rule.
                
     */
    UINT32 serializerule : 2;
    /* serializerule - Bits[2:1], RW_LB, default = 'b00 
       
                   Specifies the serialization rules for ordering.
                   RuleEnable
                   Enable for this MMIO rule.
                
     */
    UINT32 rsvd_3 : 3;
    /* rsvd_3 - Bits[5:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 baseaddress : 10;
    /* baseaddress - Bits[15:6], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule base address. Both 
       base and limit must match to declare a match to this MMIO rule. The granularity 
       of MMIO rule is 4MB. 
                
     */
    UINT32 remotestackid : 3;
    /* remotestackid - Bits[18:16], RW_LB, default = 'b000 
       
                   Specifies the target IIO stack in the target socket.
                
     */
    UINT32 rsvd_19 : 3;
    /* rsvd_19 - Bits[21:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limitaddress : 10;
    /* limitaddress - Bits[31:22], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule top limit address. 
       Both base and limit must match to declare a match to this MMIO rule. 
                
     */
  } Bits;
  UINT32 Data;
} MMIOL_RULE9_IIO_VTD_STRUCT;


/* MMIOL_RULE10_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x40128328)                                                  */
/*       SKX (0x40128328)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOL_RULE10_IIO_VTD_REG 0x11004328
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Rule 10
 */
typedef union {
  struct {
    UINT32 ruleenable : 1;
    /* ruleenable - Bits[0:0], RW_LB, default = 'b0 
       
                   Enable for this MMIO rule.
                
     */
    UINT32 serializerule : 2;
    /* serializerule - Bits[2:1], RW_LB, default = 'b00 
       
                   Specifies the serialization rules for ordering.
                   RuleEnable
                   Enable for this MMIO rule.
                
     */
    UINT32 rsvd_3 : 3;
    /* rsvd_3 - Bits[5:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 baseaddress : 10;
    /* baseaddress - Bits[15:6], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule base address. Both 
       base and limit must match to declare a match to this MMIO rule. The granularity 
       of MMIO rule is 4MB. 
                
     */
    UINT32 remotestackid : 3;
    /* remotestackid - Bits[18:16], RW_LB, default = 'b000 
       
                   Specifies the target IIO stack in the target socket.
                
     */
    UINT32 rsvd_19 : 3;
    /* rsvd_19 - Bits[21:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limitaddress : 10;
    /* limitaddress - Bits[31:22], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule top limit address. 
       Both base and limit must match to declare a match to this MMIO rule. 
                
     */
  } Bits;
  UINT32 Data;
} MMIOL_RULE10_IIO_VTD_STRUCT;


/* MMIOL_RULE11_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x4012832C)                                                  */
/*       SKX (0x4012832C)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOL_RULE11_IIO_VTD_REG 0x1100432C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Rule 11
 */
typedef union {
  struct {
    UINT32 ruleenable : 1;
    /* ruleenable - Bits[0:0], RW_LB, default = 'b0 
       
                   Enable for this MMIO rule.
                
     */
    UINT32 serializerule : 2;
    /* serializerule - Bits[2:1], RW_LB, default = 'b00 
       
                   Specifies the serialization rules for ordering.
                   RuleEnable
                   Enable for this MMIO rule.
                
     */
    UINT32 rsvd_3 : 3;
    /* rsvd_3 - Bits[5:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 baseaddress : 10;
    /* baseaddress - Bits[15:6], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule base address. Both 
       base and limit must match to declare a match to this MMIO rule. The granularity 
       of MMIO rule is 4MB. 
                
     */
    UINT32 remotestackid : 3;
    /* remotestackid - Bits[18:16], RW_LB, default = 'b000 
       
                   Specifies the target IIO stack in the target socket.
                
     */
    UINT32 rsvd_19 : 3;
    /* rsvd_19 - Bits[21:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limitaddress : 10;
    /* limitaddress - Bits[31:22], RW_LB, default = None 
       
                   This correspond to Addr[31:22] of the MMIO rule top limit address. 
       Both base and limit must match to declare a match to this MMIO rule. 
                
     */
  } Bits;
  UINT32 Data;
} MMIOL_RULE11_IIO_VTD_STRUCT;


/* MMIOH_NON_INTERLEAVE_N0_IIO_VTD_REG supported on:                          */
/*       SKX_A0 (0x40128340)                                                  */
/*       SKX (0x40128340)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOH_NON_INTERLEAVE_N0_IIO_VTD_REG 0x11004340
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO High Non-Interleave Rule
 */
typedef union {
  struct {
    UINT32 ruleenable : 1;
    /* ruleenable - Bits[0:0], RW_LB, default = 'b0 
       
                   Enable for this MMIO rule.
                
     */
    UINT32 serializerule : 2;
    /* serializerule - Bits[2:1], RW_LB, default = 'b00 
       
                   Specifies the serialization rules for ordering.
                   RuleEnable
                   Enable for this MMIO rule.
                
     */
    UINT32 rsvd_3 : 5;
    /* rsvd_3 - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 baseaddress : 22;
    /* baseaddress - Bits[29:8], RW_LB, default = None 
       
                   This correspond to Addr[45:24] of the MMIO non-interleave rule base 
       address. Both base and limit must match to declare a match to this MMIO rule. 
       The granularity of MMIO rule is 4MB. 
                
     */
    UINT32 rsvd_30 : 2;
    /* rsvd_30 - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MMIOH_NON_INTERLEAVE_N0_IIO_VTD_STRUCT;


/* MMIOH_NON_INTERLEAVE_N1_IIO_VTD_REG supported on:                          */
/*       SKX_A0 (0x40128344)                                                  */
/*       SKX (0x40128344)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOH_NON_INTERLEAVE_N1_IIO_VTD_REG 0x11004344
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO High Non-Interleave Rule
 */
typedef union {
  struct {
    UINT32 remotestackid : 3;
    /* remotestackid - Bits[2:0], RW_LB, default = 'b000 
       
                   Specifies the target IIO stack in the target socket.
                
     */
    UINT32 rsvd_3 : 5;
    /* rsvd_3 - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limitaddress : 22;
    /* limitaddress - Bits[29:8], RW_LB, default = None 
       
                   This correspond to Addr[45:24] of the MMIO rule top limit address. 
       Both base and limit must match to declare a match to this MMIO rule. 
                
     */
    UINT32 rsvd_30 : 2;
    /* rsvd_30 - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MMIOH_NON_INTERLEAVE_N1_IIO_VTD_STRUCT;


/* MMIOH_INTERLEAVE_N0_IIO_VTD_REG supported on:                              */
/*       SKX_A0 (0x40128348)                                                  */
/*       SKX (0x40128348)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOH_INTERLEAVE_N0_IIO_VTD_REG 0x11004348
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO High Interleave Rule
 */
typedef union {
  struct {
    UINT32 ruleenable : 1;
    /* ruleenable - Bits[0:0], RW_LB, default = 'b0 
       
                   Enable for this MMIO rule.
                
     */
    UINT32 remoteserializerule : 2;
    /* remoteserializerule - Bits[2:1], RW_LB, default = 'b00 
       
                   Specifies the serialization rules for a remote target
                   RuleEnable
                   Enable for this MMIO rule.
                
     */
    UINT32 interleavemode : 3;
    /* interleavemode - Bits[5:3], RW_LB, default = 'b000 
       
                   Specifies the interleave mode:
       0 - 1G interleave
       1 - 4G
       2 - 16G
       3 - 64G
       4 - 256G
       5 - 1T
                
     */
    UINT32 rsvd_6 : 2;
    /* rsvd_6 - Bits[7:6], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 baseaddress : 22;
    /* baseaddress - Bits[29:8], RW_LB, default = None 
       
                   This correspond to Addr[45:24] of the MMIO non-interleave rule base 
       address. Both base and limit must match to declare a match to this MMIO rule. 
       The granularity of MMIO rule is 4MB. 
                
     */
    UINT32 rsvd_30 : 2;
    /* rsvd_30 - Bits[31:30], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MMIOH_INTERLEAVE_N0_IIO_VTD_STRUCT;


/* MMIOH_INTERLEAVE_N1_IIO_VTD_REG supported on:                              */
/*       SKX_A0 (0x4012834C)                                                  */
/*       SKX (0x4012834C)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOH_INTERLEAVE_N1_IIO_VTD_REG 0x1100434C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO High Interleave Rule
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 1;
    /* rsvd_0 - Bits[0:0], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
    UINT32 localserializerule : 2;
    /* localserializerule - Bits[2:1], RW_LB, default = 'b000 
       
                   Specifies the serialization rules for a local target
                
     */
    UINT32 rsvd_3 : 5;
    /* rsvd_3 - Bits[7:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 limitaddress : 22;
    /* limitaddress - Bits[29:8], RW_LB, default = None 
       
                   This correspond to Addr[45:24] of the MMIO rule top limit address. 
       Both base and limit must match to declare a match to this MMIO rule. 
                
     */
    UINT32 rsvd_30 : 2;
    /* rsvd_30 - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MMIOH_INTERLEAVE_N1_IIO_VTD_STRUCT;


/* MMIOL_TGT_LIST0_IIO_VTD_REG supported on:                                  */
/*       SKX_A0 (0x40128380)                                                  */
/*       SKX (0x40128380)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOL_TGT_LIST0_IIO_VTD_REG 0x11004380
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Target List 0
 */
typedef union {
  struct {
    UINT32 mmiol0_tgt : 4;
    /* mmiol0_tgt - Bits[3:0], RW_LB, default = 'b0 
       
                   Target Node ID for the MMIOL Rule 0
                
     */
    UINT32 mmiol1_tgt : 4;
    /* mmiol1_tgt - Bits[7:4], RW_LB, default = 'b0 
       
                   Target Node ID for the MMIOL Rule 1
                
     */
    UINT32 mmiol2_tgt : 4;
    /* mmiol2_tgt - Bits[11:8], RW_LB, default = 'b0 
       
                   Target Node ID for the MMIOL Rule 2
                
     */
    UINT32 mmiol3_tgt : 4;
    /* mmiol3_tgt - Bits[15:12], RW_LB, default = 'b0 
       
                   Target Node ID for the MMIOL Rule 3
                
     */
    UINT32 mmiol4_tgt : 4;
    /* mmiol4_tgt - Bits[19:16], RW_LB, default = 'b0 
       
                   Target Node ID for the MMIOL Rule 4
                
     */
    UINT32 mmiol5_tgt : 4;
    /* mmiol5_tgt - Bits[23:20], RW_LB, default = 'b0 
       
                   Target Node ID for the MMIOL Rule 5
                
     */
    UINT32 mmiol6_tgt : 4;
    /* mmiol6_tgt - Bits[27:24], RW_LB, default = 'b0 
       
                   Target Node ID for the MMIOL Rule 6
                
     */
    UINT32 mmiol7_tgt : 4;
    /* mmiol7_tgt - Bits[31:28], RW_LB, default = 'b0 
       
                   Target Node ID for the MMIOL Rule 7
                
     */
  } Bits;
  UINT32 Data;
} MMIOL_TGT_LIST0_IIO_VTD_STRUCT;


/* MMIOL_TGT_LIST1_IIO_VTD_REG supported on:                                  */
/*       SKX_A0 (0x40128384)                                                  */
/*       SKX (0x40128384)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOL_TGT_LIST1_IIO_VTD_REG 0x11004384
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Target List 1
 */
typedef union {
  struct {
    UINT32 mmiol8_tgt : 4;
    /* mmiol8_tgt - Bits[3:0], RW_LB, default = 'b0 
       
                   Target Node ID for the MMIOL Rule 8
                
     */
    UINT32 mmiol9_tgt : 4;
    /* mmiol9_tgt - Bits[7:4], RW_LB, default = 'b0 
       
                   Target Node ID for the MMIOL Rule 9
                
     */
    UINT32 mmiol10_tgt : 4;
    /* mmiol10_tgt - Bits[11:8], RW_LB, default = 'b0 
       
                   Target Node ID for the MMIOL Rule 10
                
     */
    UINT32 mmiol11_tgt : 4;
    /* mmiol11_tgt - Bits[15:12], RW_LB, default = 'b0 
       
                   Target Node ID for the MMIOL Rule 11
                
     */
    UINT32 mmioh_non_interleave_tgt : 4;
    /* mmioh_non_interleave_tgt - Bits[19:16], RW_LB, default = 'b00 
       
                   Target Node ID for the MMIOH Non-Interleave Rule
                
     */
    UINT32 rsvd : 12;
    /* rsvd - Bits[31:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MMIOL_TGT_LIST1_IIO_VTD_STRUCT;


/* MMIOH_INTLV_TGT_LIST0_IIO_VTD_REG supported on:                            */
/*       SKX_A0 (0x40128390)                                                  */
/*       SKX (0x40128390)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOH_INTLV_TGT_LIST0_IIO_VTD_REG 0x11004390
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Target List 0
 */
typedef union {
  struct {
    UINT32 intlv0_tgt : 4;
    /* intlv0_tgt - Bits[3:0], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 0
                
     */
    UINT32 intlv1_tgt : 4;
    /* intlv1_tgt - Bits[7:4], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 1
                
     */
    UINT32 intlv2_tgt : 4;
    /* intlv2_tgt - Bits[11:8], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 2
                
     */
    UINT32 intlv3_tgt : 4;
    /* intlv3_tgt - Bits[15:12], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 3
                
     */
    UINT32 intlv4_tgt : 4;
    /* intlv4_tgt - Bits[19:16], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 4
                
     */
    UINT32 intlv5_tgt : 4;
    /* intlv5_tgt - Bits[23:20], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 5
                
     */
    UINT32 intlv6_tgt : 4;
    /* intlv6_tgt - Bits[27:24], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 6
                
     */
    UINT32 intlv7_tgt : 4;
    /* intlv7_tgt - Bits[31:28], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 7
                
     */
  } Bits;
  UINT32 Data;
} MMIOH_INTLV_TGT_LIST0_IIO_VTD_STRUCT;


/* MMIOH_INTLV_TGT_LIST1_IIO_VTD_REG supported on:                            */
/*       SKX_A0 (0x40128394)                                                  */
/*       SKX (0x40128394)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOH_INTLV_TGT_LIST1_IIO_VTD_REG 0x11004394
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Target List 1
 */
typedef union {
  struct {
    UINT32 intlv0_tgt : 4;
    /* intlv0_tgt - Bits[3:0], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 8
                
     */
    UINT32 intlv1_tgt : 4;
    /* intlv1_tgt - Bits[7:4], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 9
                
     */
    UINT32 intlv2_tgt : 4;
    /* intlv2_tgt - Bits[11:8], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 10
                
     */
    UINT32 intlv3_tgt : 4;
    /* intlv3_tgt - Bits[15:12], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 11
                
     */
    UINT32 intlv4_tgt : 4;
    /* intlv4_tgt - Bits[19:16], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 12
                
     */
    UINT32 intlv5_tgt : 4;
    /* intlv5_tgt - Bits[23:20], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 13
                
     */
    UINT32 intlv6_tgt : 4;
    /* intlv6_tgt - Bits[27:24], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 14
                
     */
    UINT32 intlv7_tgt : 4;
    /* intlv7_tgt - Bits[31:28], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 15
                
     */
  } Bits;
  UINT32 Data;
} MMIOH_INTLV_TGT_LIST1_IIO_VTD_STRUCT;


/* MMIOH_INTLV_TGT_LIST2_IIO_VTD_REG supported on:                            */
/*       SKX_A0 (0x40128398)                                                  */
/*       SKX (0x40128398)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOH_INTLV_TGT_LIST2_IIO_VTD_REG 0x11004398
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Target List 2
 */
typedef union {
  struct {
    UINT32 intlv0_tgt : 4;
    /* intlv0_tgt - Bits[3:0], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 16
                
     */
    UINT32 intlv1_tgt : 4;
    /* intlv1_tgt - Bits[7:4], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 17
                
     */
    UINT32 intlv2_tgt : 4;
    /* intlv2_tgt - Bits[11:8], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 18
                
     */
    UINT32 intlv3_tgt : 4;
    /* intlv3_tgt - Bits[15:12], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 19
                
     */
    UINT32 intlv4_tgt : 4;
    /* intlv4_tgt - Bits[19:16], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 20
                
     */
    UINT32 intlv5_tgt : 4;
    /* intlv5_tgt - Bits[23:20], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 21
                
     */
    UINT32 intlv6_tgt : 4;
    /* intlv6_tgt - Bits[27:24], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 22
                
     */
    UINT32 intlv7_tgt : 4;
    /* intlv7_tgt - Bits[31:28], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 23
                
     */
  } Bits;
  UINT32 Data;
} MMIOH_INTLV_TGT_LIST2_IIO_VTD_STRUCT;


/* MMIOH_INTLV_TGT_LIST3_IIO_VTD_REG supported on:                            */
/*       SKX_A0 (0x4012839C)                                                  */
/*       SKX (0x4012839C)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOH_INTLV_TGT_LIST3_IIO_VTD_REG 0x1100439C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Target List 3
 */
typedef union {
  struct {
    UINT32 intlv0_tgt : 4;
    /* intlv0_tgt - Bits[3:0], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 24
                
     */
    UINT32 intlv1_tgt : 4;
    /* intlv1_tgt - Bits[7:4], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 25
                
     */
    UINT32 intlv2_tgt : 4;
    /* intlv2_tgt - Bits[11:8], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 26
                
     */
    UINT32 intlv3_tgt : 4;
    /* intlv3_tgt - Bits[15:12], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 27
                
     */
    UINT32 intlv4_tgt : 4;
    /* intlv4_tgt - Bits[19:16], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 28
                
     */
    UINT32 intlv5_tgt : 4;
    /* intlv5_tgt - Bits[23:20], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 29
                
     */
    UINT32 intlv6_tgt : 4;
    /* intlv6_tgt - Bits[27:24], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 30
                
     */
    UINT32 intlv7_tgt : 4;
    /* intlv7_tgt - Bits[31:28], RW_LB, default = 'b0 
       
                   Target Node ID for the Interleave Region 31
                
     */
  } Bits;
  UINT32 Data;
} MMIOH_INTLV_TGT_LIST3_IIO_VTD_STRUCT;


/* MMIOH_INTLV_STACK_LIST0_IIO_VTD_REG supported on:                          */
/*       SKX_A0 (0x401283B0)                                                  */
/*       SKX (0x401283B0)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOH_INTLV_STACK_LIST0_IIO_VTD_REG 0x110043B0
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Stack List 0
 */
typedef union {
  struct {
    UINT32 intlv0_rem_stack : 3;
    /* intlv0_rem_stack - Bits[2:0], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 0
                
     */
    UINT32 rsvd_3 : 1;
    /* rsvd_3 - Bits[3:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv1_rem_stack : 3;
    /* intlv1_rem_stack - Bits[6:4], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 1
                
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv2_rem_stack : 3;
    /* intlv2_rem_stack - Bits[10:8], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 2
                
     */
    UINT32 rsvd_11 : 1;
    /* rsvd_11 - Bits[11:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv3_rem_stack : 3;
    /* intlv3_rem_stack - Bits[14:12], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 3
                
     */
    UINT32 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv4_rem_stack : 3;
    /* intlv4_rem_stack - Bits[18:16], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 4
                
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv5_rem_stack : 3;
    /* intlv5_rem_stack - Bits[22:20], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 5
                
     */
    UINT32 rsvd_23 : 1;
    /* rsvd_23 - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv6_rem_stack : 3;
    /* intlv6_rem_stack - Bits[26:24], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 6
                
     */
    UINT32 rsvd_27 : 1;
    /* rsvd_27 - Bits[27:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv7_rem_stack : 3;
    /* intlv7_rem_stack - Bits[30:28], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 7
                
     */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MMIOH_INTLV_STACK_LIST0_IIO_VTD_STRUCT;


/* MMIOH_INTLV_STACK_LIST1_IIO_VTD_REG supported on:                          */
/*       SKX_A0 (0x401283B4)                                                  */
/*       SKX (0x401283B4)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOH_INTLV_STACK_LIST1_IIO_VTD_REG 0x110043B4
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Stack List 1
 */
typedef union {
  struct {
    UINT32 intlv0_rem_stack : 3;
    /* intlv0_rem_stack - Bits[2:0], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 8
                
     */
    UINT32 rsvd_3 : 1;
    /* rsvd_3 - Bits[3:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv1_rem_stack : 3;
    /* intlv1_rem_stack - Bits[6:4], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 9
                
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv2_rem_stack : 3;
    /* intlv2_rem_stack - Bits[10:8], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 10
                
     */
    UINT32 rsvd_11 : 1;
    /* rsvd_11 - Bits[11:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv3_rem_stack : 3;
    /* intlv3_rem_stack - Bits[14:12], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 11
                
     */
    UINT32 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv4_rem_stack : 3;
    /* intlv4_rem_stack - Bits[18:16], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 12
                
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv5_rem_stack : 3;
    /* intlv5_rem_stack - Bits[22:20], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 13
                
     */
    UINT32 rsvd_23 : 1;
    /* rsvd_23 - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv6_rem_stack : 3;
    /* intlv6_rem_stack - Bits[26:24], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 14
                
     */
    UINT32 rsvd_27 : 1;
    /* rsvd_27 - Bits[27:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv7_rem_stack : 3;
    /* intlv7_rem_stack - Bits[30:28], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 15
                
     */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MMIOH_INTLV_STACK_LIST1_IIO_VTD_STRUCT;


/* MMIOH_INTLV_STACK_LIST2_IIO_VTD_REG supported on:                          */
/*       SKX_A0 (0x401283B8)                                                  */
/*       SKX (0x401283B8)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOH_INTLV_STACK_LIST2_IIO_VTD_REG 0x110043B8
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Stack List 2
 */
typedef union {
  struct {
    UINT32 intlv0_rem_stack : 3;
    /* intlv0_rem_stack - Bits[2:0], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 16
                
     */
    UINT32 rsvd_3 : 1;
    /* rsvd_3 - Bits[3:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv1_rem_stack : 3;
    /* intlv1_rem_stack - Bits[6:4], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 17
                
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv2_rem_stack : 3;
    /* intlv2_rem_stack - Bits[10:8], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 18
                
     */
    UINT32 rsvd_11 : 1;
    /* rsvd_11 - Bits[11:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv3_rem_stack : 3;
    /* intlv3_rem_stack - Bits[14:12], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 19
                
     */
    UINT32 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv4_rem_stack : 3;
    /* intlv4_rem_stack - Bits[18:16], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 20
                
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv5_rem_stack : 3;
    /* intlv5_rem_stack - Bits[22:20], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 21
                
     */
    UINT32 rsvd_23 : 1;
    /* rsvd_23 - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv6_rem_stack : 3;
    /* intlv6_rem_stack - Bits[26:24], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 22
                
     */
    UINT32 rsvd_27 : 1;
    /* rsvd_27 - Bits[27:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv7_rem_stack : 3;
    /* intlv7_rem_stack - Bits[30:28], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 23
                
     */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MMIOH_INTLV_STACK_LIST2_IIO_VTD_STRUCT;


/* MMIOH_INTLV_STACK_LIST3_IIO_VTD_REG supported on:                          */
/*       SKX_A0 (0x401283BC)                                                  */
/*       SKX (0x401283BC)                                                     */
/* Register default value:              0x00000000                            */
#define MMIOH_INTLV_STACK_LIST3_IIO_VTD_REG 0x110043BC
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * MMIO Low Stack List 3
 */
typedef union {
  struct {
    UINT32 intlv0_rem_stack : 3;
    /* intlv0_rem_stack - Bits[2:0], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 24
                
     */
    UINT32 rsvd_3 : 1;
    /* rsvd_3 - Bits[3:3], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv1_rem_stack : 3;
    /* intlv1_rem_stack - Bits[6:4], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 25
                
     */
    UINT32 rsvd_7 : 1;
    /* rsvd_7 - Bits[7:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv2_rem_stack : 3;
    /* intlv2_rem_stack - Bits[10:8], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 26
                
     */
    UINT32 rsvd_11 : 1;
    /* rsvd_11 - Bits[11:11], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv3_rem_stack : 3;
    /* intlv3_rem_stack - Bits[14:12], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 27
                
     */
    UINT32 rsvd_15 : 1;
    /* rsvd_15 - Bits[15:15], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv4_rem_stack : 3;
    /* intlv4_rem_stack - Bits[18:16], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 28
                
     */
    UINT32 rsvd_19 : 1;
    /* rsvd_19 - Bits[19:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv5_rem_stack : 3;
    /* intlv5_rem_stack - Bits[22:20], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 29
                
     */
    UINT32 rsvd_23 : 1;
    /* rsvd_23 - Bits[23:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv6_rem_stack : 3;
    /* intlv6_rem_stack - Bits[26:24], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 30
                
     */
    UINT32 rsvd_27 : 1;
    /* rsvd_27 - Bits[27:27], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 intlv7_rem_stack : 3;
    /* intlv7_rem_stack - Bits[30:28], RW_LB, default = 'b0 
       
                   Target Stack ID for the Interleave Region 31
                
     */
    UINT32 rsvd_31 : 1;
    /* rsvd_31 - Bits[31:31], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} MMIOH_INTLV_STACK_LIST3_IIO_VTD_STRUCT;


/* BUSID_LOCAL_RULE_ADDRESS_0_IIO_VTD_REG supported on:                       */
/*       SKX_A0 (0x401283D0)                                                  */
/*       SKX (0x401283D0)                                                     */
/* Register default value:              0x00000000                            */
#define BUSID_LOCAL_RULE_ADDRESS_0_IIO_VTD_REG 0x110043D0
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * BusID Local Rule 0
 */
typedef union {
  struct {
    UINT32 busidl0_base : 8;
    /* busidl0_base - Bits[7:0], RW_LB, default = 'b0 
       
                   Bus Base for Local 0 Target
                
     */
    UINT32 busidl0_limit : 8;
    /* busidl0_limit - Bits[15:8], RW_LB, default = 'b0 
       
                   Bus Limit for Local 0 Target
                
     */
    UINT32 busidl1_limit : 8;
    /* busidl1_limit - Bits[23:16], RW_LB, default = 'b0 
       
                   Bus Limit for Local 1 Target
                
     */
    UINT32 busidl2_limit : 8;
    /* busidl2_limit - Bits[31:24], RW_LB, default = 'b0 
       
                   Bus Limit for Local 2 Target
                
     */
  } Bits;
  UINT32 Data;
} BUSID_LOCAL_RULE_ADDRESS_0_IIO_VTD_STRUCT;


/* BUSID_LOCAL_RULE_ADDRESS_1_IIO_VTD_REG supported on:                       */
/*       SKX_A0 (0x401283D4)                                                  */
/*       SKX (0x401283D4)                                                     */
/* Register default value:              0x00000000                            */
#define BUSID_LOCAL_RULE_ADDRESS_1_IIO_VTD_REG 0x110043D4
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * BusID Local Rule 1
 */
typedef union {
  struct {
    UINT32 busidl3_limit : 8;
    /* busidl3_limit - Bits[7:0], RW_LB, default = 'b0 
       
                   Bus Limit for Local 3 Target
                
     */
    UINT32 busidl4_limit : 8;
    /* busidl4_limit - Bits[15:8], RW_LB, default = 'b0 
       
                   Bus Limit for Local 4 Target
                
     */
    UINT32 busidl5_limit : 8;
    /* busidl5_limit - Bits[23:16], RW_LB, default = 'b0 
       
                   Bus Limit for Local 5 Target
                
     */
    UINT32 rsvd : 8;
    /* rsvd - Bits[31:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} BUSID_LOCAL_RULE_ADDRESS_1_IIO_VTD_STRUCT;


/* BUSID_LOCAL_RULE_TGT_IIO_VTD_REG supported on:                             */
/*       SKX_A0 (0x401283D8)                                                  */
/*       SKX (0x401283D8)                                                     */
/* Register default value:              0x00000000                            */
#define BUSID_LOCAL_RULE_TGT_IIO_VTD_REG 0x110043D8
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * BusID Local Rule Target
 */
typedef union {
  struct {
    UINT32 busidl0_tgt : 4;
    /* busidl0_tgt - Bits[3:0], RW_LB, default = 'b0 
       
                   Local 0 Target IIO StackID
                
     */
    UINT32 busidl1_tgt : 4;
    /* busidl1_tgt - Bits[7:4], RW_LB, default = 'b0 
       
                   Local 1 Target Local IIO StackID
                
     */
    UINT32 busidl2_tgt : 4;
    /* busidl2_tgt - Bits[11:8], RW_LB, default = 'b0 
       
                   Local 2 Target Local IIO StackID
                
     */
    UINT32 busidl3_tgt : 4;
    /* busidl3_tgt - Bits[15:12], RW_LB, default = 'b0 
       
                   Local 3 Target Local IIO StackID
                
     */
    UINT32 busidl4_tgt : 4;
    /* busidl4_tgt - Bits[19:16], RW_LB, default = 'b0 
       
                   Local 4 Target Local IIO StackID
                
     */
    UINT32 busidl5_tgt : 4;
    /* busidl5_tgt - Bits[23:20], RW_LB, default = 'b0 
       
                   Local 5 Target Local IIO StackID
                
     */
    UINT32 rsvd : 8;
    /* rsvd - Bits[31:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} BUSID_LOCAL_RULE_TGT_IIO_VTD_STRUCT;


/* BUSID_GLOB_RULE_IIO_VTD_REG supported on:                                  */
/*       SKX_A0 (0x401283E0)                                                  */
/*       SKX (0x401283E0)                                                     */
/* Register default value:              0x00003FC8                            */
#define BUSID_GLOB_RULE_IIO_VTD_REG 0x110043E0
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * BusID Global Rule
 */
typedef union {
  struct {
    UINT32 rule_enable : 1;
    /* rule_enable - Bits[0:0], RW_LB, default = 'b0 
       
                   Enable for this Bus Number interleave decoder.
                
     */
    UINT32 length : 3;
    /* length - Bits[3:1], RW_LB, default = 3'b100 
       
                   This field document the max bus number supported by the interleave 
       decoder. 
                   SKX supports the following configurations:
                   110: MaxBusNumber = 63 (ie. 64MB MMCFG range)
                   101: MaxBusNumber = 127 (ie 128MB MMCFG range)
                   100: MaxBusNumber = 256 (ie 256MB MMCFG range)
                   010: MaxBusNumber = 512 (ie 512MB MMCFG range)
                   001: MaxBusNumber = 1048 (ie 1G MMCFG range)
                   000: MaxBusNumber = 2048 (ie 2G MMCFG range)
                   Minimum granularity of MMCFG range will be 64MB.
                   RULE_ENABLE
                   Enable for this Bus Number interleave decoder.
                
     */
    UINT32 rsvd_4 : 2;
    /* rsvd_4 - Bits[5:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 valid_targets : 8;
    /* valid_targets - Bits[13:6], RW_LB, default = 8'hFF 
       
                   Marks the valid targets. Request to an invalid target will result in 
       an ABORT. 
                
     */
    UINT32 rsvd_14 : 18;
    /* rsvd_14 - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} BUSID_GLOB_RULE_IIO_VTD_STRUCT;


/* BUSID_GLOB_RULE_TGT_IIO_VTD_REG supported on:                              */
/*       SKX_A0 (0x401283E4)                                                  */
/*       SKX (0x401283E4)                                                     */
/* Register default value:              0x00000000                            */
#define BUSID_GLOB_RULE_TGT_IIO_VTD_REG 0x110043E4
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * BusID Global Rule Target
 */
typedef union {
  struct {
    UINT32 busidg0_tgt : 4;
    /* busidg0_tgt - Bits[3:0], RW_LB, default = 'b0 
       
                   Remote Bus Range 0 Target NodeID
                
     */
    UINT32 busidg1_tgt : 4;
    /* busidg1_tgt - Bits[7:4], RW_LB, default = 'b0 
       
                   Remote Bus Range 1 Target NodeID
                
     */
    UINT32 busidg2_tgt : 4;
    /* busidg2_tgt - Bits[11:8], RW_LB, default = 'b0 
       
                   Remote Bus Range 2 Target NodeID
                
     */
    UINT32 busidg3_tgt : 4;
    /* busidg3_tgt - Bits[15:12], RW_LB, default = 'b0 
       
                   Remote Bus Range 3 Target NodeID
                
     */
    UINT32 busidg4_tgt : 4;
    /* busidg4_tgt - Bits[19:16], RW_LB, default = 'b0 
       
                   Remote Bus Range 4 Target NodeID
                
     */
    UINT32 busidg5_tgt : 4;
    /* busidg5_tgt - Bits[23:20], RW_LB, default = 'b0 
       
                   Remote Bus Range 5 Target NodeID
                
     */
    UINT32 busidg6_tgt : 4;
    /* busidg6_tgt - Bits[27:24], RW_LB, default = 'b0 
       
                   Remote Bus Range 6 Target NodeID
                
     */
    UINT32 busidg7_tgt : 4;
    /* busidg7_tgt - Bits[31:28], RW_LB, default = 'b0 
       
                   Remote Bus Range 7 Target NodeID
                
     */
  } Bits;
  UINT32 Data;
} BUSID_GLOB_RULE_TGT_IIO_VTD_STRUCT;


/* SAD_TARGET_IIO_VTD_REG supported on:                                       */
/*       SKX_A0 (0x401283F0)                                                  */
/*       SKX (0x401283F0)                                                     */
/* Register default value:              0x00000000                            */
#define SAD_TARGET_IIO_VTD_REG 0x110043F0
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * SAD Target Configuration
 */
typedef union {
  struct {
    UINT32 flash_target : 4;
    /* flash_target - Bits[3:0], RO, default = 'b0000 
       
                   Target NodeID of the Flash Target
                   Note: This field is not used since peer to peer traffic is not 
       allowed to target the Flash range. 
                
     */
    UINT32 legacy_pch_target : 4;
    /* legacy_pch_target - Bits[7:4], RW_LB, default = 'b0000 
       
                   Target NodeID of the Legacy PCH Target
                
     */
    UINT32 vga_target : 4;
    /* vga_target - Bits[11:8], RW_LB, default = 'b0000 
       
                   Target NodeID of the VGA Target
                
     */
    UINT32 rsvd_12 : 4;
    /* rsvd_12 - Bits[15:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 vga_stack : 3;
    /* vga_stack - Bits[18:16], RW_LB, default = 'b000 
       
                   StackID of the VGA Target
                
     */
    UINT32 pch_stack : 3;
    /* pch_stack - Bits[21:19], RW_LB, default = 'b000 
       
                   StackID of the legacy PCH Target
                
     */
    UINT32 rsvd_22 : 10;
    /* rsvd_22 - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SAD_TARGET_IIO_VTD_STRUCT;


/* SAD_CONTROL_IIO_VTD_REG supported on:                                      */
/*       SKX_A0 (0x401283F4)                                                  */
/*       SKX (0x401283F4)                                                     */
/* Register default value:              0x00000000                            */
#define SAD_CONTROL_IIO_VTD_REG 0x110043F4
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * SAD Target Configuration
 */
typedef union {
  struct {
    UINT32 local_nodeid : 4;
    /* local_nodeid - Bits[3:0], RW_LB, default = 'b0000 
       
                   NodeID of the local socket.
                
     */
    UINT32 rsvd_4 : 12;
    /* rsvd_4 - Bits[15:4], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mmiol_granularity : 4;
    /* mmiol_granularity - Bits[19:16], RW_LB, default = 'b0000 
       
                   The minimum granularity of the MMIOL SAD Decode
                
     */
    UINT32 rsvd_20 : 4;
    /* rsvd_20 - Bits[23:20], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 mmioh_granularity : 5;
    /* mmioh_granularity - Bits[28:24], RW_LB, default = 'b00000 
       
                   The minimum granularity of the MMIOH SAD Decode
                
     */
    UINT32 rsvd_29 : 3;
    /* rsvd_29 - Bits[31:29], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SAD_CONTROL_IIO_VTD_STRUCT;






/* SNC_CONFIG_IIO_VTD_REG supported on:                                       */
/*       SKX_A0 (0x4012842C)                                                  */
/*       SKX (0x4012842C)                                                     */
/* Register default value:              0x00000000                            */
#define SNC_CONFIG_IIO_VTD_REG 0x1100442C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * SNC Config
 */
typedef union {
  struct {
    UINT32 full_snc_en : 1;
    /* full_snc_en - Bits[0:0], RWS_LB, default = 1'b0 
       full snc enable
     */
    UINT32 snc_ind_en : 1;
    /* snc_ind_en - Bits[1:1], RWS_LB, default = 1'b0 
       SNC IND enable
     */
    UINT32 num_snc_clu : 2;
    /* num_snc_clu - Bits[3:2], RWS_LB, default = 2'b00 
       Num of SNC Clusters
     */
    UINT32 lowest_cbo_id_clus1 : 5;
    /* lowest_cbo_id_clus1 - Bits[8:4], RWS_LB, default = 5'b00000 
       Lowest cbo id or base of snc cluster 1
     */
    UINT32 lowest_cbo_id_clus2 : 5;
    /* lowest_cbo_id_clus2 - Bits[13:9], RWS_LB, default = 5'b00000 
       Lowest cbo id or base of snc cluster 2
     */
    UINT32 lowest_cbo_id_clus3 : 5;
    /* lowest_cbo_id_clus3 - Bits[18:14], RWS_LB, default = 5'b00000 
       Lowest cbo id or base of snc cluster 3
     */
    UINT32 rsvd : 13;
    /* rsvd - Bits[31:19], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SNC_CONFIG_IIO_VTD_STRUCT;


/* SNC_BASE_1_IIO_VTD_REG supported on:                                       */
/*       SKX_A0 (0x40128430)                                                  */
/*       SKX (0x40128430)                                                     */
/* Register default value:              0x00000000                            */
#define SNC_BASE_1_IIO_VTD_REG 0x11004430
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * SNC base 1
 */
typedef union {
  struct {
    UINT32 starting_addr_0 : 16;
    /* starting_addr_0 - Bits[15:0], RWS_LB, default = 16'b0000000000000000 
       starting address for cluster 0
     */
    UINT32 address_mask_45_40 : 6;
    /* address_mask_45_40 - Bits[21:16], RWS_LB, default = 6'b000000 
       Controls bits [45:40] of the 2LM hash address mask
     */
    UINT32 rsvd : 10;
    /* rsvd - Bits[31:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SNC_BASE_1_IIO_VTD_STRUCT;


/* SNC_BASE_2_IIO_VTD_REG supported on:                                       */
/*       SKX_A0 (0x40128434)                                                  */
/*       SKX (0x40128434)                                                     */
/* Register default value:              0x00000000                            */
#define SNC_BASE_2_IIO_VTD_REG 0x11004434
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * SNC base 2
 */
typedef union {
  struct {
    UINT32 starting_addr_1 : 16;
    /* starting_addr_1 - Bits[15:0], RWS_LB, default = 16'b0000000000000000 
       starting address for cluster 1
     */
    UINT32 rsvd_16 : 4;
    /* rsvd_16 - Bits[19:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 address_mask_39_31 : 9;
    /* address_mask_39_31 - Bits[28:20], RWS_LB, default = 9'b000000000 
       Controls bits [39:31] of the 2LM hash address mask
     */
    UINT32 rsvd_29 : 3;
    /* rsvd_29 - Bits[31:29], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SNC_BASE_2_IIO_VTD_STRUCT;


/* SNC_BASE_3_IIO_VTD_REG supported on:                                       */
/*       SKX_A0 (0x40128438)                                                  */
/*       SKX (0x40128438)                                                     */
/* Register default value:              0x00000000                            */
#define SNC_BASE_3_IIO_VTD_REG 0x11004438
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * SNC base 3
 */
typedef union {
  struct {
    UINT32 starting_addr_2 : 16;
    /* starting_addr_2 - Bits[15:0], RWS_LB, default = 16'b0000000000000000 
       starting address for cluster 2
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SNC_BASE_3_IIO_VTD_STRUCT;


/* SNC_BASE_4_IIO_VTD_REG supported on:                                       */
/*       SKX_A0 (0x4012843C)                                                  */
/*       SKX (0x4012843C)                                                     */
/* Register default value:              0x00000000                            */
#define SNC_BASE_4_IIO_VTD_REG 0x1100443C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * SNC base 4
 */
typedef union {
  struct {
    UINT32 starting_addr_3 : 16;
    /* starting_addr_3 - Bits[15:0], RWS_LB, default = 16'b0000000000000000 
       starting address for cluster 3
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SNC_BASE_4_IIO_VTD_STRUCT;


/* SNC_BASE_5_IIO_VTD_REG supported on:                                       */
/*       SKX_A0 (0x40128440)                                                  */
/*       SKX (0x40128440)                                                     */
/* Register default value:              0x00000000                            */
#define SNC_BASE_5_IIO_VTD_REG 0x11004440
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * SNC base 5
 */
typedef union {
  struct {
    UINT32 starting_addr_4 : 16;
    /* starting_addr_4 - Bits[15:0], RWS_LB, default = 16'b0000000000000000 
       starting address for cluster 4
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} SNC_BASE_5_IIO_VTD_STRUCT;


/* TCMCRCVST0_N0_IIO_VTD_REG supported on:                                    */
/*       SKX_A0 (0x40128500)                                                  */
/*       SKX (0x40128500)                                                     */
/* Register default value:              0x00000000                            */
#define TCMCRCVST0_N0_IIO_VTD_REG 0x11004500
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Multicast receiver stack 0
 */
typedef union {
  struct {
    UINT32 multicastrcvstack0 : 16;
    /* multicastrcvstack0 - Bits[15:0], RWS, default = 'h00 
       
                    For each bit that is Set, this peer IIO stack gets a
                    copy of any Multicast TLPs for the associated Multicast Group.
                    This should be set if the corresponding bit of the MC_Receive 
       register for any of the root ports connected to the peer IIO stack is set. 
                 
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TCMCRCVST0_N0_IIO_VTD_STRUCT;




/* TCMCRCVST1_N0_IIO_VTD_REG supported on:                                    */
/*       SKX_A0 (0x40128508)                                                  */
/*       SKX (0x40128508)                                                     */
/* Register default value:              0x00000000                            */
#define TCMCRCVST1_N0_IIO_VTD_REG 0x11004508
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Multicast receiver stack 1
 */
typedef union {
  struct {
    UINT32 multicastrcvstack1 : 16;
    /* multicastrcvstack1 - Bits[15:0], RWS, default = 'h00 
       
                    For each bit that is Set, this peer IIO stack gets a
                    copy of any Multicast TLPs for the associated Multicast Group.
                    This should be set if the corresponding bit of the MC_Receive 
       register for any of the root ports connected to the peer IIO stack is set. 
                 
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TCMCRCVST1_N0_IIO_VTD_STRUCT;










/* TCMCRCVST4_N0_IIO_VTD_REG supported on:                                    */
/*       SKX_A0 (0x40128520)                                                  */
/*       SKX (0x40128520)                                                     */
/* Register default value:              0x00000000                            */
#define TCMCRCVST4_N0_IIO_VTD_REG 0x11004520
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Multicast receiver stack 4
 */
typedef union {
  struct {
    UINT32 multicastrcvstack4 : 16;
    /* multicastrcvstack4 - Bits[15:0], RWS, default = 'h00 
       
                    For each bit that is Set, this peer IIO stack gets a
                    copy of any Multicast TLPs for the associated Multicast Group.
                    This should be set if the corresponding bit of the MC_Receive 
       register for any of the root ports connected to the peer IIO stack is set. 
                 
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TCMCRCVST4_N0_IIO_VTD_STRUCT;




/* TCMCRCVST5_N0_IIO_VTD_REG supported on:                                    */
/*       SKX_A0 (0x40128528)                                                  */
/*       SKX (0x40128528)                                                     */
/* Register default value:              0x00000000                            */
#define TCMCRCVST5_N0_IIO_VTD_REG 0x11004528
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Multicast receiver stack 5
 */
typedef union {
  struct {
    UINT32 multicastrcvstack5 : 16;
    /* multicastrcvstack5 - Bits[15:0], RWS, default = 'h00 
       
                    For each bit that is Set, this peer IIO stack gets a
                    copy of any Multicast TLPs for the associated Multicast Group.
                    This should be set if the corresponding bit of the MC_Receive 
       register for any of the root ports connected to the peer IIO stack is set. 
                 
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TCMCRCVST5_N0_IIO_VTD_STRUCT;




/* TCMCRCVMEM_IIO_VTD_REG supported on:                                       */
/*       SKX_A0 (0x40128530)                                                  */
/*       SKX (0x40128530)                                                     */
/* Register default value:              0x000000FF                            */
#define TCMCRCVMEM_IIO_VTD_REG 0x11004530
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Multicast receiver memory
 */
typedef union {
  struct {
    UINT32 multicastrcvmem : 16;
    /* multicastrcvmem - Bits[15:0], RWS, default = 16'b0000000011111111 
       
                    Multicast receiver memory.
                 
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TCMCRCVMEM_IIO_VTD_STRUCT;


/* TCSKTSAD_IIO_VTD_REG supported on:                                         */
/*       SKX_A0 (0x40128534)                                                  */
/*       SKX (0x40128534)                                                     */
/* Register default value:              0x00000006                            */
#define TCSKTSAD_IIO_VTD_REG 0x11004534
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Socket and SAD target
 */
typedef union {
  struct {
    UINT32 mctpb_loc_skt : 6;
    /* mctpb_loc_skt - Bits[5:0], RWS_L, default = 6'b000110 
       
                    For broadcast messages (MCTP): which IIO stack in the local sockets 
       to forward broadcast messages. 
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 mctpb_rem_skt : 8;
    /* mctpb_rem_skt - Bits[13:6], RWS_L, default = 'h00 
       
                    For broadcast messages (MCTP): which IIO stacks in the remote 
       sockets to forward broadcast messages. 
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 rsvd : 18;
    /* rsvd - Bits[31:14], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TCSKTSAD_IIO_VTD_STRUCT;


/* TCPRHCRDTCOUNT_IIO_VTD_REG supported on:                                   */
/*       SKX_A0 (0x40128538)                                                  */
/*       SKX (0x40128538)                                                     */
/* Register default value:              0x007156C4                            */
#define TCPRHCRDTCOUNT_IIO_VTD_REG 0x11004538
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * PRH Credit count
 */
typedef union {
  struct {
    UINT32 prh_crdt_cnt_vcx : 3;
    /* prh_crdt_cnt_vcx - Bits[2:0], RWS_L, default = 3'b100 
       
                    Prh Crdt count for Vcx
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 prh_crdt_cnt_vc0 : 5;
    /* prh_crdt_cnt_vc0 - Bits[7:3], RWS_L, default = 5'b11000 
       
                    Prh Crdt count for Vc0
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 prh_crdt_cnt_cbdma : 7;
    /* prh_crdt_cnt_cbdma - Bits[14:8], RWS_L, default = 7'b1010110 
       
                    Prh Crdt count for CBDMA
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 prh_crdt_cnt_misc : 3;
    /* prh_crdt_cnt_misc - Bits[17:15], RWS_L, default = 3'b010 
       
                    Prh Crdt count for MISC channel
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 prh_crdt_cnt_pcie : 5;
    /* prh_crdt_cnt_pcie - Bits[22:18], RWS_L, default = 5'b11100 
       
                    Prh Crdt count for PCIE X4
                    PCIE x8 will get 2x
                    PCIE x16 will get 4x
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 rsvd : 9;
    /* rsvd - Bits[31:23], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TCPRHCRDTCOUNT_IIO_VTD_STRUCT;


/* TCHDRDATCRDTCOUNT_IIO_VTD_REG supported on:                                */
/*       SKX_A0 (0x4012853C)                                                  */
/*       SKX (0x4012853C)                                                     */
/* Register default value:              0x3DFB140A                            */
#define TCHDRDATCRDTCOUNT_IIO_VTD_REG 0x1100453C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Header and data Credit count
 */
typedef union {
  struct {
    UINT32 dat_crdt_cnt_misc : 8;
    /* dat_crdt_cnt_misc - Bits[7:0], RWS_L, default = 8'b00001010 
       
                    Data Credit count for MISC cluster
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 hdr_crdt_cnt_misc : 7;
    /* hdr_crdt_cnt_misc - Bits[14:8], RWS_L, default = 7'b0010100 
       
                    Hdr Credit count for MISC cluster
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 dat_crdt_cnt_pcie : 8;
    /* dat_crdt_cnt_pcie - Bits[22:15], RWS_L, default = 8'b11110110 
       
                    Data Credit count for x4
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 hdr_crdt_cnt_pcie : 7;
    /* hdr_crdt_cnt_pcie - Bits[29:23], RWS_L, default = 7'b1111011 
       
                    Hdr Credit count for x4
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 rsvd : 2;
    /* rsvd - Bits[31:30], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TCHDRDATCRDTCOUNT_IIO_VTD_STRUCT;


/* ITCCTRL01_N0_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x40128540)                                                  */
/*       SKX (0x40128540)                                                     */
/* Register default value:              0x04000810                            */
#define ITCCTRL01_N0_IIO_VTD_REG 0x11004540
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * ITC control 01
 */
typedef union {
  struct {
    UINT32 rsvd_0 : 3;
    /* rsvd_0 - Bits[2:0], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 dis_convert_cpllk : 1;
    /* dis_convert_cpllk - Bits[3:3], RWS_L, default = 'h0 
       
                    When 0, ITC will convert locked completions to normal completions.
                    When 1, ITC will not convert locked completions to normal 
       completions. 
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 dis_ns_on_tph : 1;
    /* dis_ns_on_tph - Bits[4:4], RWS_L, default = 1'b1 
       
                    When 0, NS and TPH bits may both be set.
                    When 1, NS bit will be cleared if the TPH bit is set and TPH is not 
       disabled. 
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 csr_atomic_tph_disable : 1;
    /* csr_atomic_tph_disable - Bits[5:5], RWS_L, default = 'h00 
       
                    Atomic TPH disable
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 csr_force_tph_writes : 1;
    /* csr_force_tph_writes - Bits[6:6], RWS_L, default = 'h00 
       
                    Force TPH on all inbound writes
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 rsvd_7 : 4;
    /* rsvd_7 - Bits[10:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 csr_cballocen : 1;
    /* csr_cballocen - Bits[11:11], RWS_L, default = 1'b1 
       
                    CB allocation enable
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 spare : 10;
    /* spare - Bits[21:12], RWS_L, default = 'h00 
       
                    Spare CSRs
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 rsvd_22 : 2;
    /* rsvd_22 - Bits[23:22], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 en_ro_c : 1;
    /* en_ro_c - Bits[24:24], RWS_L, default = 'h00 
       
                    EN RO completion
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 en_ro_np : 1;
    /* en_ro_np - Bits[25:25], RWS_L, default = 'h00 
       
                    Enable RO Non-Posted
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 en_ro_p : 1;
    /* en_ro_p - Bits[26:26], RWS_L, default = 1'b1 
       
                    Enable RO Posted
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 cr_disable_dword_mask : 1;
    /* cr_disable_dword_mask - Bits[27:27], RWS_L, default = 'h00 
       
                    Disable Dword Mask
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 rsvd_28 : 1;
    /* rsvd_28 - Bits[28:28], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 itc_inb_ler_disable : 1;
    /* itc_inb_ler_disable - Bits[29:29], RWS_L, default = 'h0 
       
                    When set to 1, Disable ITC logging MAbort error due to PCIE port 
       being in LER mode. 
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 legacy_busno_en : 1;
    /* legacy_busno_en - Bits[30:30], RWS_L, default = 'h0 
       
                    Legacy code use 0 for bug number.
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 en_ovrd_attr_ns : 1;
    /* en_ovrd_attr_ns - Bits[31:31], RWS_L, default = 'h00 
       
                    enable non-snoop override attribute
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
  } Bits;
  UINT32 Data;
} ITCCTRL01_N0_IIO_VTD_STRUCT;


/* ITCCTRL01_N1_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x40128544)                                                  */
/*       SKX (0x40128544)                                                     */
/* Register default value:              0x00900000                            */
#define ITCCTRL01_N1_IIO_VTD_REG 0x11004544
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * ITC control 01
 */
typedef union {
  struct {
    UINT32 check_p_dest_every_state : 1;
    /* check_p_dest_every_state - Bits[0:0], RWS_L, default = 'h00 
       
                    Check Posted destination every state
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 check_p_dest_every_line : 1;
    /* check_p_dest_every_line - Bits[1:1], RWS_L, default = 'h00 
       
                    Check Posted destination every line
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 serialize_mcast : 1;
    /* serialize_mcast - Bits[2:2], RWS_L, default = 'h00 
       
                    Serialize Multicast
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 serialize_all : 1;
    /* serialize_all - Bits[3:3], RWS_L, default = 'h00 
       
                    Serialize all    
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 loopback_p2p_targets : 8;
    /* loopback_p2p_targets - Bits[11:4], RWS_L, default = 'h0 
       
                    Loopback P2P targets
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 rsvd_12 : 8;
    /* rsvd_12 - Bits[19:12], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 p2p_timer_scale : 5;
    /* p2p_timer_scale - Bits[24:20], RWS_L, default = 5'b01001 
       
                    P2P timer scale  
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 rsvd_25 : 7;
    /* rsvd_25 - Bits[31:25], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} ITCCTRL01_N1_IIO_VTD_STRUCT;


/* ITCCTRL23_N0_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x40128548)                                                  */
/*       SKX (0x40128548)                                                     */
/* Register default value:              0x2080FFFF                            */
#define ITCCTRL23_N0_IIO_VTD_REG 0x11004548
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * ITC control 23
 */
typedef union {
  struct {
    UINT32 en_gbl_serialize_irp_p2p_np : 8;
    /* en_gbl_serialize_irp_p2p_np - Bits[7:0], RWS_L, default = 8'b11111111 
       
                    Enable serialization of non-posted p2p when destination queue is 
       backed up on any channel 
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 en_gbl_serialize_irp_p2p_p : 8;
    /* en_gbl_serialize_irp_p2p_p - Bits[15:8], RWS_L, default = 8'b11111111 
       
                    Enable serialization of posted p2p when destination queue is backed 
       up on any channel. 
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 max_irp_p2p_np : 8;
    /* max_irp_p2p_np - Bits[23:16], RWS_L, default = 8'b10000000 
       
                    Max outstanding p2p non-posted per x4
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 max_irp_p2p_p : 8;
    /* max_irp_p2p_p - Bits[31:24], RWS_L, default = 8'b00100000 
       
                    Max outstanding p2p posted per x4
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
  } Bits;
  UINT32 Data;
} ITCCTRL23_N0_IIO_VTD_STRUCT;


/* ITCCTRL23_N1_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x4012854C)                                                  */
/*       SKX (0x4012854C)                                                     */
/* Register default value:              0x03FFFC00                            */
#define ITCCTRL23_N1_IIO_VTD_REG 0x1100454C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * ITC control 23
 */
typedef union {
  struct {
    UINT32 en_32b_data : 1;
    /* en_32b_data - Bits[0:0], RWS_LB, default = 'h0 
       
                    Enable 32 byte data
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 rcb128 : 1;
    /* rcb128 - Bits[1:1], RWS_LB, default = 'h0 
       
                    RCB is 128 Byte
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 mctp_segid_size : 2;
    /* mctp_segid_size - Bits[3:2], RWS_L, default = 'h0 
       
                    MCTP segment ID size
                 
     */
    UINT32 cfg_my_seg : 3;
    /* cfg_my_seg - Bits[6:4], RWS_L, default = 'h0 
       
                    MCTP segment ID size, shadowed to IOTC
                 
     */
    UINT32 gldtr_segno : 3;
    /* gldtr_segno - Bits[9:7], RWS_L, default = 'h0 
       
                    Gladiator Segno, shadowed to IOTC
                 
     */
    UINT32 en_chnl_serialize_irp_p2p_p : 8;
    /* en_chnl_serialize_irp_p2p_p - Bits[17:10], RWS_L, default = 8'b11111111 
       
                    Enable serialization of posted p2p when destination queue is backed 
       up on that same channel. 
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 en_chnl_serialize_irp_p2p_np : 8;
    /* en_chnl_serialize_irp_p2p_np - Bits[25:18], RWS_L, default = 8'b11111111 
       
                    Enable serialization of non-posted p2p when destination queue is 
       backed up on that same channel 
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 disable_msg_immune_to_viral : 1;
    /* disable_msg_immune_to_viral - Bits[26:26], RWS_L, default = 'h0 
       
                    ITC dfx for disable_msg_immune_to_viral 
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 disable_cfg_immune_to_viral : 1;
    /* disable_cfg_immune_to_viral - Bits[27:27], RWS_L, default = 'h0 
       
                    ITC dfx for disable_cfg_immune_to_viral 
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 dis_sb01base_decode_fix : 1;
    /* dis_sb01base_decode_fix - Bits[28:28], RWS_L, default = 'h0 
       
                    ITC dfx for dis_sb01base_decode_fix 
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 dis_sb01base_vtd_fix : 1;
    /* dis_sb01base_vtd_fix - Bits[29:29], RWS_L, default = 'h0 
       
                    ITC dfx for dis_sb01base_vtd_fix 
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 itc_ctrl_misc : 2;
    /* itc_ctrl_misc - Bits[31:30], RWS_L, default = 'h0 
       
                    ITC MISC control bits 
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
  } Bits;
  UINT32 Data;
} ITCCTRL23_N1_IIO_VTD_STRUCT;








/* OTCCTRL23_N0_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x40128560)                                                  */
/*       SKX (0x40128560)                                                     */
/* Register default value:              0x00000000                            */
#define OTCCTRL23_N0_IIO_VTD_REG 0x11004560
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * OTC control 23
 */
typedef union {
  struct {
    UINT32 retry_buff_empty_check_disable : 1;
    /* retry_buff_empty_check_disable - Bits[0:0], RWS_L, default = 'h0 
       
                     retry_buff_empty_check_disable during lock 
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 legacy_busno_en : 1;
    /* legacy_busno_en - Bits[1:1], RWS_L, default = 'h0 
       
                    DFT for legacy_busno_en
                 
     */
    UINT32 disable_ur_viral_mask : 1;
    /* disable_ur_viral_mask - Bits[2:2], RWS_L, default = 'h0 
       
                    DFT for disable_ur_viral_mask
                 
     */
    UINT32 block_secbar_alias_wr : 1;
    /* block_secbar_alias_wr - Bits[3:3], RWS_L, default = 'h0 
       
                    DFT for block_secbar_alias_wr
                 
     */
    UINT32 block_secbar_alias_rd : 1;
    /* block_secbar_alias_rd - Bits[4:4], RWS_L, default = 'h0 
       
                    DFT for block_secbar_alias_rd
                 
     */
    UINT32 block_pribar_alias_wr : 1;
    /* block_pribar_alias_wr - Bits[5:5], RWS_L, default = 'h0 
       
                    DFT for block_pribar_alias_wr
                 
     */
    UINT32 block_pribar_alias_rd : 1;
    /* block_pribar_alias_rd - Bits[6:6], RWS_L, default = 'h0 
       
                    DFT for block_pribar_alias_rd
                 
     */
    UINT32 viral_ob_c_stat_ur : 1;
    /* viral_ob_c_stat_ur - Bits[7:7], RWS_L, default = 'h0 
       
                    DFT for viral_ob_c_stat_ur
                 
     */
    UINT32 dis_sb01base_cfg_fix : 1;
    /* dis_sb01base_cfg_fix - Bits[8:8], RWS_L, default = 'h0 
       
                    DFT for dis_sb01base_cfg_fix
                 
     */
    UINT32 dis_2nd_vtd_ob_entry : 1;
    /* dis_2nd_vtd_ob_entry - Bits[9:9], RWS_L, default = 'h0 
       
                    DFT for dis_2nd_vtd_ob_entry
                 
     */
    UINT32 dis_p_pool_borrow : 1;
    /* dis_p_pool_borrow - Bits[10:10], RWS_L, default = 'h0 
       
                    DFT for dis_p_pool_borrow
                 
     */
    UINT32 dis_np_pool_borrow : 1;
    /* dis_np_pool_borrow - Bits[11:11], RWS_L, default = 'h0 
       
                    DFT for dis_np_pool_borrow
                 
     */
    UINT32 dis_c_borrow : 1;
    /* dis_c_borrow - Bits[12:12], RWS_L, default = 'h0 
       
                    DFT for dis_c_borrow
                 
     */
    UINT32 dis_p2p_np_borrow : 1;
    /* dis_p2p_np_borrow - Bits[13:13], RWS_L, default = 'h0 
       
                    DFT for dis_p2p_np_borrow
                 
     */
    UINT32 dis_p2p_p_borrow : 1;
    /* dis_p2p_p_borrow - Bits[14:14], RWS_L, default = 'h0 
       
                    DFT for dis_p2p_p_borrow
                 
     */
    UINT32 misc_dft : 17;
    /* misc_dft - Bits[31:15], RWS_L, default = 'h0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
                    Reserved for DFT
                    15: disable reqid check when set(hsd: 304472) 
                 
     */
  } Bits;
  UINT32 Data;
} OTCCTRL23_N0_IIO_VTD_STRUCT;


/* OTCCTRL23_N1_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x40128564)                                                  */
/*       SKX (0x40128564)                                                     */
/* Register default value:              0x00000000                            */
#define OTCCTRL23_N1_IIO_VTD_REG 0x11004564
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * OTC control 23
 */
typedef union {
  struct {
    UINT32 misc_dft : 32;
    /* misc_dft - Bits[31:0], RWS_L, default = 'h0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
                    Reserved for DFT
                    15: disable reqid check when set(hsd: 304472) 
                 
     */
  } Bits;
  UINT32 Data;
} OTCCTRL23_N1_IIO_VTD_STRUCT;


/* TCNPTOTCRDTS_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x40128568)                                                  */
/*       SKX (0x40128568)                                                     */
/* Register default value:              0x00000010                            */
#define TCNPTOTCRDTS_IIO_VTD_REG 0x11004568
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * TC  NP total credits
 */
typedef union {
  struct {
    UINT32 np_max_crdt_used : 10;
    /* np_max_crdt_used - Bits[9:0], RWS_L, default = 10'b0000010000 
       
                    NP maximum credit used.
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 rsvd : 22;
    /* rsvd - Bits[31:10], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TCNPTOTCRDTS_IIO_VTD_STRUCT;


/* OTCNUMMAXCRDT_N0_IIO_VTD_REG supported on:                                 */
/*       SKX_A0 (0x40128578)                                                  */
/*       SKX (0x40128578)                                                     */
/* Register default value:              0x11212469                            */
#define OTCNUMMAXCRDT_N0_IIO_VTD_REG 0x11004578
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * OTC Maximum total credits
 */
typedef union {
  struct {
    UINT32 p_pool : 4;
    /* p_pool - Bits[3:0], RWS_L, default = 4'b1001 
       
                    Posted pool
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 np_pool : 4;
    /* np_pool - Bits[7:4], RWS_L, default = 4'b0110 
       
                    Non-posted pool
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 cbdma_c : 4;
    /* cbdma_c - Bits[11:8], RWS_L, default = 4'b0100 
       
                    CBDMA completion
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 vcm_c : 4;
    /* vcm_c - Bits[15:12], RWS_L, default = 4'h2 
       
                    VCM completion
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 vcp_c : 4;
    /* vcp_c - Bits[19:16], RWS_L, default = 1'b1 
       
                    VCP completion
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 vc1_c : 4;
    /* vc1_c - Bits[23:20], RWS_L, default = 4'h2 
       
                    VC1 completion
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 vtd_isoch_c : 4;
    /* vtd_isoch_c - Bits[27:24], RWS_L, default = 1'b1 
       
                    VTD ISOCH completion
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 vtd_c : 4;
    /* vtd_c - Bits[31:28], RWS_L, default = 1'b1 
       
                    VTD Completion
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
  } Bits;
  UINT32 Data;
} OTCNUMMAXCRDT_N0_IIO_VTD_STRUCT;


/* OTCNUMMAXCRDT_N1_IIO_VTD_REG supported on:                                 */
/*       SKX_A0 (0x4012857C)                                                  */
/*       SKX (0x4012857C)                                                     */
/* Register default value:              0x00114111                            */
#define OTCNUMMAXCRDT_N1_IIO_VTD_REG 0x1100457C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * OTC Maximum total credits
 */
typedef union {
  struct {
    UINT32 misc_c : 4;
    /* misc_c - Bits[3:0], RWS_L, default = 1'b1 
       
                    MISC completion
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 misc_np : 4;
    /* misc_np - Bits[7:4], RWS_L, default = 1'b1 
       
                    Misc non-posted
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 misc_p : 4;
    /* misc_p - Bits[11:8], RWS_L, default = 1'b1 
       
                    Misc posted
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 x4_c : 4;
    /* x4_c - Bits[15:12], RWS_L, default = 4'h4 
       
                    X4 completion
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 x4_np : 4;
    /* x4_np - Bits[19:16], RWS_L, default = 1'b1 
       
                    X4 non posted
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 x4_p : 4;
    /* x4_p - Bits[23:20], RWS_L, default = 1'b1 
       
                    X4 posted
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 rsvd : 8;
    /* rsvd - Bits[31:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} OTCNUMMAXCRDT_N1_IIO_VTD_STRUCT;


/* OTCNUMMINCRDT_N0_IIO_VTD_REG supported on:                                 */
/*       SKX_A0 (0x40128580)                                                  */
/*       SKX (0x40128580)                                                     */
/* Register default value:              0x11212414                            */
#define OTCNUMMINCRDT_N0_IIO_VTD_REG 0x11004580
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * OTC Minimum total credits
 */
typedef union {
  struct {
    UINT32 p_pool : 4;
    /* p_pool - Bits[3:0], RWS_L, default = 4'b0100 
       
                    Posted pool
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 np_pool : 4;
    /* np_pool - Bits[7:4], RWS_L, default = 4'b0001 
       
                    Non-posted pool
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 cbdma_c : 4;
    /* cbdma_c - Bits[11:8], RWS_L, default = 4'b0100 
       
                    CBDMA completion
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 vcm_c : 4;
    /* vcm_c - Bits[15:12], RWS_L, default = 4'h2 
       
                    VCM completion
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 vcp_c : 4;
    /* vcp_c - Bits[19:16], RWS_L, default = 1'b1 
       
                    VCP completion
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 vc1_c : 4;
    /* vc1_c - Bits[23:20], RWS_L, default = 4'h2 
       
                    VC1 completion
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 vtd_isoch_c : 4;
    /* vtd_isoch_c - Bits[27:24], RWS_L, default = 1'b1 
       
                    VTD ISOCH completion
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 vtd_c : 4;
    /* vtd_c - Bits[31:28], RWS_L, default = 1'b1 
       
                    VTD Completion
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
  } Bits;
  UINT32 Data;
} OTCNUMMINCRDT_N0_IIO_VTD_STRUCT;


/* OTCNUMMINCRDT_N1_IIO_VTD_REG supported on:                                 */
/*       SKX_A0 (0x40128584)                                                  */
/*       SKX (0x40128584)                                                     */
/* Register default value:              0x00114111                            */
#define OTCNUMMINCRDT_N1_IIO_VTD_REG 0x11004584
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * OTC Minimum total credits
 */
typedef union {
  struct {
    UINT32 misc_c : 4;
    /* misc_c - Bits[3:0], RWS_L, default = 1'b1 
       
                    MISC completion
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 misc_np : 4;
    /* misc_np - Bits[7:4], RWS_L, default = 1'b1 
       
                    Misc non-posted
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 misc_p : 4;
    /* misc_p - Bits[11:8], RWS_L, default = 1'b1 
       
                    Misc posted
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 x4_c : 4;
    /* x4_c - Bits[15:12], RWS_L, default = 4'h4 
       
                    X4 completion
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 x4_np : 4;
    /* x4_np - Bits[19:16], RWS_L, default = 1'b1 
       
                    X4 non posted
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 x4_p : 4;
    /* x4_p - Bits[23:20], RWS_L, default = 1'b1 
       
                    X4 posted
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 rsvd : 8;
    /* rsvd - Bits[31:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} OTCNUMMINCRDT_N1_IIO_VTD_STRUCT;


/* ITCCTRL67_N0_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x40128588)                                                  */
/*       SKX (0x40128588)                                                     */
/* Register default value:              0x00000000                            */
#define ITCCTRL67_N0_IIO_VTD_REG 0x11004588
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * ITC control 67
 */
typedef union {
  struct {
    UINT32 misc_dft_rws_lb : 32;
    /* misc_dft_rws_lb - Bits[31:0], RWS_LB, default = 'h0 
       
                    Reserved for DFT with RWS_LB
                    bit 0: disable the ntb ib cfg fix
                    bit 28: disable the sequenced draining of NP and P within StopReq3 
       of the lock flow 
                 
     */
  } Bits;
  UINT32 Data;
} ITCCTRL67_N0_IIO_VTD_STRUCT;


/* ITCCTRL67_N1_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x4012858C)                                                  */
/*       SKX (0x4012858C)                                                     */
/* Register default value:              0x00000000                            */
#define ITCCTRL67_N1_IIO_VTD_REG 0x1100458C
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * ITC control 67
 */
typedef union {
  struct {
    UINT32 misc_dft_rws : 32;
    /* misc_dft_rws - Bits[31:0], RWS, default = 'h0 
       
                    Reserved for DFT with RWS
                 
     */
  } Bits;
  UINT32 Data;
} ITCCTRL67_N1_IIO_VTD_STRUCT;


/* TCMCRCVST2_N0_IIO_VTD_REG supported on:                                    */
/*       SKX_A0 (0x40128590)                                                  */
/*       SKX (0x40128590)                                                     */
/* Register default value:              0x00000000                            */
#define TCMCRCVST2_N0_IIO_VTD_REG 0x11004590
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Multicast receiver stack 2
 */
typedef union {
  struct {
    UINT32 multicastrcvstack2 : 16;
    /* multicastrcvstack2 - Bits[15:0], RWS, default = 'h00 
       
                    For each bit that is Set, this peer IIO stack gets a
                    copy of any Multicast TLPs for the associated Multicast Group.
                    This should be set if the corresponding bit of the MC_Receive 
       register for any of the root ports connected to the peer IIO stack is set. 
                 
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TCMCRCVST2_N0_IIO_VTD_STRUCT;




/* TCMCRCVST3_N0_IIO_VTD_REG supported on:                                    */
/*       SKX_A0 (0x40128598)                                                  */
/*       SKX (0x40128598)                                                     */
/* Register default value:              0x00000000                            */
#define TCMCRCVST3_N0_IIO_VTD_REG 0x11004598
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * Multicast receiver stack 3
 */
typedef union {
  struct {
    UINT32 multicastrcvstack3 : 16;
    /* multicastrcvstack3 - Bits[15:0], RWS, default = 'h00 
       
                    For each bit that is Set, this peer IIO stack gets a
                    copy of any Multicast TLPs for the associated Multicast Group.
                    This should be set if the corresponding bit of the MC_Receive 
       register for any of the root ports connected to the peer IIO stack is set. 
                 
     */
    UINT32 rsvd : 16;
    /* rsvd - Bits[31:16], n/a, default = n/a 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} TCMCRCVST3_N0_IIO_VTD_STRUCT;




/* ITCCTRL45_N0_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x401285A0)                                                  */
/*       SKX (0x401285A0)                                                     */
/* Register default value:              0x2108C030                            */
#define ITCCTRL45_N0_IIO_VTD_REG 0x110045A0
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * ITC control 45
 */
typedef union {
  struct {
    UINT32 dfx_max_cache : 7;
    /* dfx_max_cache - Bits[6:0], RWS_L, default = 7'b0110000 
       
                    Max cache size 
                 
     */
    UINT32 rsvd : 7;
    /* rsvd - Bits[13:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 en_mmio_reads_from_cbmda : 1;
    /* en_mmio_reads_from_cbmda - Bits[14:14], RWS_L, default = 1'b1 
       
                    Allow MMIO reads from CBDMA
                 
     */
    UINT32 irp_posted_entry : 1;
    /* irp_posted_entry - Bits[15:15], RWS_L, default = 1'b1 
       
                    IRP posted entry
                 
     */
    UINT32 max_mem_rd : 5;
    /* max_mem_rd - Bits[20:16], RWS_L, default = 5'b01000 
       
                    Max memory read
                 
     */
    UINT32 max_ncp2ps : 5;
    /* max_ncp2ps - Bits[25:21], RWS_L, default = 5'b01000 
       
                    Max NCP2PS
                 
     */
    UINT32 max_ncp2pb : 5;
    /* max_ncp2pb - Bits[30:26], RWS_L, default = 5'b01000 
       
                    Max NCP2PB
                 
     */
    UINT32 isoch_absolute_priority : 1;
    /* isoch_absolute_priority - Bits[31:31], RWS_L, default = 'h0 
       
                    Isoch Absolute Priority
                 
     */
  } Bits;
  UINT32 Data;
} ITCCTRL45_N0_IIO_VTD_STRUCT;


/* ITCCTRL45_N1_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x401285A4)                                                  */
/*       SKX (0x401285A4)                                                     */
/* Register default value:              0x0040A007                            */
#define ITCCTRL45_N1_IIO_VTD_REG 0x110045A4
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * ITC control 45
 */
typedef union {
  struct {
    UINT32 max_isoch_count : 3;
    /* max_isoch_count - Bits[2:0], RWS_L, default = 3'b111 
       
                    Max number of credits given to ISOCH before a credit must be given 
       to non-ISOCH when non-ISOCH is waiting for a credit. 
                 
     */
    UINT32 max_isoch : 2;
    /* max_isoch - Bits[4:3], RWS_L, default = 'h0 
       
                    Number of IRP data credits reserved for ISOCH (cstack ? 2h1 : 2h0)
                 
     */
    UINT32 rsvd_5 : 7;
    /* rsvd_5 - Bits[11:5], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 max_cache_hdr_crdt : 5;
    /* max_cache_hdr_crdt - Bits[16:12], RWS_L, default = 6'b001010 
       
                    Max Cache header credit
                 
     */
    UINT32 rsvd_17 : 1;
    /* rsvd_17 - Bits[17:17], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 max_cache_dat_crdt : 5;
    /* max_cache_dat_crdt - Bits[22:18], RWS_L, default = 5'b01000 
       
                    Max Cache data credit
                 
     */
    UINT32 abort_p2p_dmi : 1;
    /* abort_p2p_dmi - Bits[23:23], RWS_L, default = 1'b0 
       
                    Abort all p2p to the CSTACK on this socket.  To avoid a possible 
       deadlock condition, 
                    this bit should be set for PSTACK1.  It should be cleared for all 
       other stacks. 
                 
     */
    UINT32 rsvd_24 : 8;
    /* rsvd_24 - Bits[31:24], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} ITCCTRL45_N1_IIO_VTD_STRUCT;


/* OTCCTRL01_N0_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x401285A8)                                                  */
/*       SKX (0x401285A8)                                                     */
/* Register default value:              0x108020031                           */
#define OTCCTRL01_N0_IIO_VTD_REG 0x110045A8
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * OTC control 01
 */
typedef union {
  struct {
    UINT32 mabort_req_during_lck : 1;
    /* mabort_req_during_lck - Bits[0:0], RWS_L, default = 1'b1 
       
                    Master Abort MMIO Request during lock.
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 otc_ob_ler_disable : 1;
    /* otc_ob_ler_disable - Bits[1:1], RWS_L, default = 'h0 
       
                    When set to 1, Disable OTC logging MAbort error due to PCIE port 
       being in LER mode. 
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
    UINT32 rsvd : 1;
    /* rsvd - Bits[2:2], n/a, default = n/a 
       Padding added by header generation tool.
     */
    UINT32 en_32b_data : 1;
    /* en_32b_data - Bits[3:3], RWS_L, default = 'h0 
       
                    Enable 32 byte data
                 
     */
    UINT32 cfg_thresh_chnl : 10;
    /* cfg_thresh_chnl - Bits[13:4], RWS_L, default = 8'b00000011 
       
                    Channel 0 threshold
                 
     */
    UINT32 np_serial_thresh : 10;
    /* np_serial_thresh - Bits[23:14], RWS_L, default = 10'b0000001000 
       
                    Free allocation reload
                 
     */
    UINT32 vt_vc0p_nprh_crdt : 5;
    /* vt_vc0p_nprh_crdt - Bits[28:24], RWS_L, default = 5'b01000 
       
                    Non posted credit for VT request header
                 
     */
    UINT32 vt_vc1_nprh_crdt : 3;
    /* vt_vc1_nprh_crdt - Bits[31:29], RWS_L, default = 5'b01000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
                    Non posted credit for VT request header
                 
     */
  } Bits;
  UINT32 Data;
} OTCCTRL01_N0_IIO_VTD_STRUCT;


/* OTCCTRL01_N1_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x401285AC)                                                  */
/*       SKX (0x401285AC)                                                     */
/* Register default value:              0x180420428                           */
#define OTCCTRL01_N1_IIO_VTD_REG 0x110045AC
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * OTC control 01
 */
typedef union {
  struct {
    UINT32 vt_vc1_nprh_crdt : 2;
    /* vt_vc1_nprh_crdt - Bits[1:0], RWS_L, default = 5'b01000 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
                    Non posted credit for VT request header
                 
     */
    UINT32 vt_misc_crdt : 5;
    /* vt_misc_crdt - Bits[6:2], RWS_L, default = 5'b00001 
       
                    VT misc credit for cplh, prh/d, nprh/d,cplh
                 
     */
    UINT32 non_vt_hdr_cred : 5;
    /* non_vt_hdr_cred - Bits[11:7], RWS_L, default = 5'b00001 
       
                    Non VT Header credit for nprh, cplh and prh
                 
     */
    UINT32 non_vt_dat_cred : 5;
    /* non_vt_dat_cred - Bits[16:12], RWS_L, default = 5'b00100 
       
                    Non VT Data credit for nprd,cpld and prd
                 
     */
    UINT32 np_max_crdt_use : 10;
    /* np_max_crdt_use - Bits[26:17], RWS_L, default = 10'b0000000100 
       
                    Non-posted maximum credit used.
                 
     */
    UINT32 free_alloc_reload : 1;
    /* free_alloc_reload - Bits[27:27], RWS_L, default = 'h0 
       
                    Free allocation reload
                 
     */
    UINT32 msg_max_crdt : 3;
    /* msg_max_crdt - Bits[30:28], RWS_L, default = 3'b011 
       
                    maximum credit for message.
                 
     */
    UINT32 otc_ctrl_misc : 1;
    /* otc_ctrl_misc - Bits[31:31], RWS_L, default = 'h0 
       
                    OTC spare Control bits 
                    Lock: IIO_DFX_LCK_CTL.DBGBUSLCK
                 
     */
  } Bits;
  UINT32 Data;
} OTCCTRL01_N1_IIO_VTD_STRUCT;


/* OTCCTRL45_N0_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x401285B0)                                                  */
/*       SKX (0x401285B0)                                                     */
/* Register default value:              0x00000000                            */
#define OTCCTRL45_N0_IIO_VTD_REG 0x110045B0
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * OTC control 45
 */
typedef union {
  struct {
    UINT32 misc_dft2 : 32;
    /* misc_dft2 - Bits[31:0], RWS_L, default = 'h0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
                    Reserved for DFT 2
                 
     */
  } Bits;
  UINT32 Data;
} OTCCTRL45_N0_IIO_VTD_STRUCT;


/* OTCCTRL45_N1_IIO_VTD_REG supported on:                                     */
/*       SKX_A0 (0x401285B4)                                                  */
/*       SKX (0x401285B4)                                                     */
/* Register default value:              0x00000000                            */
#define OTCCTRL45_N1_IIO_VTD_REG 0x110045B4
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * OTC control 45
 */
typedef union {
  struct {
    UINT32 misc_dft2 : 32;
    /* misc_dft2 - Bits[31:0], RWS_L, default = 'h0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
                    Reserved for DFT 2
                 
     */
  } Bits;
  UINT32 Data;
} OTCCTRL45_N1_IIO_VTD_STRUCT;


/* OTCVCLN_N0_IIO_VTD_REG supported on:                                       */
/*       SKX_A0 (0x401285B8)                                                  */
/*       SKX (0x401285B8)                                                     */
/* Register default value:              0x00000000                            */
#define OTCVCLN_N0_IIO_VTD_REG 0x110045B8
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 *  post-viral memory dump window 
 */
typedef union {
  struct {
    UINT32 vclean_enable : 1;
    /* vclean_enable - Bits[0:0], RWS_LB, default = 'h0 
       
                    clean_enable_dev0
                 
     */
    UINT32 vclean_size : 24;
    /* vclean_size - Bits[24:1], RWS_LB, default = 'h0 
       
                    vclean_size_dev0
                 
     */
    UINT32 vclean_base : 7;
    /* vclean_base - Bits[31:25], RWS_LB, default = 'h0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
                    vclean_base_dev0
                 
     */
  } Bits;
  UINT32 Data;
} OTCVCLN_N0_IIO_VTD_STRUCT;


/* OTCVCLN_N1_IIO_VTD_REG supported on:                                       */
/*       SKX_A0 (0x401285BC)                                                  */
/*       SKX (0x401285BC)                                                     */
/* Register default value:              0x00000000                            */
#define OTCVCLN_N1_IIO_VTD_REG 0x110045BC
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 *  post-viral memory dump window 
 */
typedef union {
  struct {
    UINT32 vclean_base : 13;
    /* vclean_base - Bits[12:0], RWS_LB, default = 'h0 
       This field was split. It's value spans this field and the field of similar name 
       in the next/preceding struct. 
       
                    vclean_base_dev0
                 
     */
    UINT32 ltlck_spare : 19;
    /* ltlck_spare - Bits[31:13], RWS_LB, default = 'h0 
       
                    ltlck_spare
                 
     */
  } Bits;
  UINT32 Data;
} OTCVCLN_N1_IIO_VTD_STRUCT;


/* IOTCLINKDOWNCTL_IIO_VTD_REG supported on:                                  */
/*       SKX_A0 (0x40128688)                                                  */
/*       SKX (0x40128688)                                                     */
/* Register default value:              0x00000022                            */
#define IOTCLINKDOWNCTL_IIO_VTD_REG 0x11004688
/* Struct format extracted from XML file SKX\1.5.0.CFG.xml.
 * IOTC PCIE link down control register
 */
typedef union {
  struct {
    UINT32 sel_delay_timer_base : 2;
    /* sel_delay_timer_base - Bits[1:0], RW_L, default = 2'b10 
       select delay timer base : 2'b00(128ns), 2'b01(8.1us), 2'b10(524us), 2'b11(33ms) 
     */
    UINT32 delay_timer_expire : 4;
    /* delay_timer_expire - Bits[5:2], RW_L, default = 4'b1000 
       delay timer expire count : 4'h0(no delay) else 4 * expire * base 
     */
    UINT32 disable_otc_abort : 1;
    /* disable_otc_abort - Bits[6:6], RW_L, default = 1'b0 
       set 1: OTC to disable MA/CA abort
     */
    UINT32 rsvd : 25;
    /* rsvd - Bits[31:7], n/a, default = n/a 
       Padding added by header generation tool.
     */
  } Bits;
  UINT32 Data;
} IOTCLINKDOWNCTL_IIO_VTD_STRUCT;




#endif /* IIO_VTD_h */
