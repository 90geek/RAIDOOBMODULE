/*++

Copyright (c) 2005-2015 Intel Corporation. All rights reserved
This software and associated documentation (if any) is furnished
under a license and may only be used or copied in accordance
with the terms of the license. Except as permitted by such
license, no part of this software or documentation may be
reproduced, stored in a retrieval system, or transmitted in any
form or by any means without the express written consent of
Intel Corporation.

Module Name:

    File name:    MCMAIN.h
    Input File:   SKX_MRC_for CTE updt-2015ww15.3.xlsx

Abstract:

    THIS FILE IS AUTO-GENERATED BY THE MMRC TOOL. DO NOT CHANGE THIS CODE.

    If edits are needed in this file, they must be done via the MMRC tool.

    If there is additional project-specific data required by the MMRC, it
    can be placed in MCMAIN.h, which is used for non-tool-generated
    data

    Includes register defines specific to a project.

--*/
#ifndef _MCMAIN_H_
#define _MCMAIN_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define VID_MCMAIN_REG                                    0x00000000
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The value is assigned by PCI-SIG to Intel.
    // 
    // Bits[15:0], RO, default = 0x8086
    //
    UINTX vendor_identification_number : 16;
  } Bits;
  UINTX Data;
} VID_MCMAIN_STRUCT;
#endif // ASM_INC

#define DID_MCMAIN_REG                                    0x00000002
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  
    // Start (h)	End (h)	Device
    // 0x203F		0x203F	
    // 0x2040		0x204B	MC
    // 0x204C		0x204F	M3KTI
    // 0x2054		0x2054	CHASADALL
    // 0x2055		0x2055	CHAUTILALL
    // 0x2056		0x2056	CHAUTILALL1
    // 0x2057		0x2057	CHAPMAALL
    // 0x2058		0x205B	KTI
    // 0x2066		0x2067	M2MEM
    // 0x2068		0x206F	MC DDRIO
    // 0x2078		0x207F	VCU
    // 0x2080		0x2087	PCU
    // 0x2088		0x2088	
    // 0x2089		0x2089	
    // 0x208A		0x208A	
    // 0x208B		0x208B	
    // 0x208C		0x208C	
    // 0x208D		0x208D	CHAUTIL
    // 0x208E		0x208E	CHASAD
    // 0x208F		0x208F	CMSCHA
    // 0x2090		0x209F	RSVD FOR PCU FUNCTION 3
    // 	
    // 
    // Bits[15:0], RO, default = 0x2040
    //
    UINTX device_identification_number : 16;
  } Bits;
  UINTX Data;
} DID_MCMAIN_STRUCT;
#endif // ASM_INC

#define PCICMD_MCMAIN_REG                                 0x00000004
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Hardwired to 0 since these devices don't decode any IO BARs
    // 
    // Bits[0:0], RO, default = 0x0
    //
    UINTX io_space_enable : 1;
    //
    // Hardwired to 0 since these devices don't decode any memory BARs
    // 
    // Bits[1:1], RO, default = 0x0
    //
    UINTX memory_space_enable : 1;
    //
    // Hardwired to 0 since these devices don't generate any transactions
    // 
    // Bits[2:2], RO, default = 0x0
    //
    UINTX bus_master_enable : 1;
    //
    // Not applicable. Hardwired to 0.
    // 
    // Bits[3:3], RO, default = 0x0
    //
    UINTX special_cycle_enable : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[4:4], RO, default = 0x0
    //
    UINTX memory_write_and_invalidate_enable : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[5:5], RO, default = 0x0
    //
    UINTX vga_palette_snoop_enable : 1;
    //
    // This bit has no impact on error reporting from these devices
    // 
    // Bits[6:6], RO, default = 0x0
    //
    UINTX parity_error_response : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX idsel_stepping_wait_cycle_control : 1;
    //
    // This bit has no impact on error reporting from these devices
    // 
    // Bits[8:8], RO, default = 0x0
    //
    UINTX serr_enable : 1;
    //
    // Not applicable to PCI Express and is hardwired to 0
    // 
    // Bits[9:9], RO, default = 0x0
    //
    UINTX fast_back_to_back_enable : 1;
    //
    // N/A for these devices
    // 
    // Bits[10:10], RO, default = 0x0
    //
    UINTX intx_disable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
  } Bits;
  UINTX Data;
} PCICMD_MCMAIN_STRUCT;
#endif // ASM_INC

#define PCISTS_MCMAIN_REG                                 0x00000006
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Reflects the state of the INTA# signal at the input of the enable/disable circuit.
    //  This bit is set by HW to 1 when the INTA# is asserted.  This bit is reset by
    // HW to 0 after the interrupt is cleared (independent of the state of the Interrupt
    // Disable bit in the 0.4.0.PCICMD register). 
    // Hardwired to 0 on the processor
    // 
    // Bits[3:3], RO, default = 0x0
    //
    UINTX intx_status : 1;
    //
    // This bit indicates the presence of a capabilities list structure. When set to
    // 1, indicates the register at 34h provides an offset into the function. 
    // 
    // Bits[4:4], RO, default = 0x1
    //
    UINTX capabilities_list : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[5:5], RO, default = 0x0
    //
    UINTX x66mhz_capable : 1;
    //
    // Reserved
    // 
    // Bits[6:6], RO, default = 0x0
    //
    UINTX reserved : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX fast_back_to_back : 1;
    //
    // Hardwired to 0
    // 
    // Bits[8:8], RO, default = 0x0
    //
    UINTX master_data_parity_error : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[10:9], RO, default = 0x0
    //
    UINTX devsel_timing : 2;
    //
    // Hardwired to 0
    // 
    // Bits[11:11], RO, default = 0x0
    //
    UINTX signaled_target_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[12:12], RO, default = 0x0
    //
    UINTX received_target_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[13:13], RO, default = 0x0
    //
    UINTX received_master_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[14:14], RO, default = 0x0
    //
    UINTX signaled_system_error : 1;
    //
    // This bit is set when the device receives a packet on the primary side with an
    // uncorrectable data error (including a packet with poison bit set) or an uncorrectable
    // address/control parity error. The setting of this bit is regardless of the Parity
    // Error Response bit (PERRE) in the PCICMD register. 
    // 
    // Bits[15:15], RO_V, default = 0x0
    //
    UINTX detected_parity_error : 1;
  } Bits;
  UINTX Data;
} PCISTS_MCMAIN_STRUCT;
#endif // ASM_INC

#define RID_MCMAIN_REG                                    0x00000008
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reflects the Uncore Revision ID after reset.
    // Reflects the Compatibility Revision ID after BIOS writes 0x69 to any RID register
    // in the processor uncore. 
    //         
    // 
    // Bits[7:0], RO_V, default = 0x0
    //
    UINTX revision_id : 8;
  } Bits;
  UINTX Data;
} RID_MCMAIN_STRUCT;
#endif // ASM_INC

#define CCR_MCMAIN_REG                                    0x00000009
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[7:0], RO_V, default = 0x0
    //
    UINTX register_level_programming_interface : 8;
    //
    // The value changes dependent upon the dev/func accessed. A table of the values
    // can be found in the Class-code tab of the msgch spread-sheet  
    // 	  Most dev-func will return 8'h80 for this field except for the following dev-func0,func1,...
    // combinations. The following exceptions will return 8'h01. Please refer to /src/uncore/ncu/f_ccr_reg.vh
    // for the full lookingup table. 
    //           bus-0, dev-8 func-1 
    //           bus-3, dev-14 to 16, func-0
    //           bus-3, dev-18, func-0, 1, 4, 5
    //         
    // 
    // Bits[15:8], RO_V, default = 0x80
    //
    UINTX sub_class : 8;
    //
    // The value changes dependent upon the dev-func accessed. A table of the values
    // can be found in the Class-code tab of the msgch spread-sheet  
    // 	  Most bus-dev-func will return 8'h08 for this field except for the following
    // bus-dev-func0,func1,... combinations. The following exceptions will return 8'h11.
    // Please refer to /src/uncore/ncu/f_ccr_reg.vhfor the full lookingup table. 
    //           bus-0, dev-8 func-1 
    //           bus-3, dev-14 to 16, func-0
    //           bus-3, dev-18, func-0, 1, 4, 5
    //         
    // 
    // Bits[23:16], RO_V, default = 0x8
    //
    UINTX base_class : 8;
  } Bits;
  UINTX Data;
} CCR_MCMAIN_STRUCT;
#endif // ASM_INC

#define CLSR_MCMAIN_REG                                   0x0000000C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Size of Cacheline
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX cacheline_size : 8;
  } Bits;
  UINTX Data;
} CLSR_MCMAIN_STRUCT;
#endif // ASM_INC

#define PLAT_MCMAIN_REG                                   0x0000000D
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Not applicable to PCI-Express. Hardwired to 00h.
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX primary_latency_timer : 8;
  } Bits;
  UINTX Data;
} PLAT_MCMAIN_STRUCT;
#endif // ASM_INC

#define HDR_MCMAIN_REG                                    0x0000000E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Type 0 header
    // 
    // Bits[6:0], RO, default = 0x0
    //
    UINTX configuration_layout : 7;
    //
    // This bit defaults to 1b since all these devices are multi-function
    // 
    // Bits[7:7], RO, default = 0x1
    //
    UINTX multi_function_device : 1;
  } Bits;
  UINTX Data;
} HDR_MCMAIN_STRUCT;
#endif // ASM_INC

#define BIST_MCMAIN_REG                                   0x0000000F
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Not supported. Hardwired to 00h
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX bist_tests : 8;
  } Bits;
  UINTX Data;
} BIST_MCMAIN_STRUCT;
#endif // ASM_INC

#define CAPPTR_MCMAIN_REG                                 0x00000034
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Points to the first capability structure for the device which is the PCIe capability.
    // 
    // Bits[7:0], RO, default = 0x40
    //
    UINTX capability_pointer : 8;
  } Bits;
  UINTX Data;
} CAPPTR_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTL_MCMAIN_REG                                   0x0000003C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A for these devices
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX interrupt_line : 8;
  } Bits;
  UINTX Data;
} INTL_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTPIN_MCMAIN_REG                                 0x0000003D
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A since these devices do not generate any interrupt on their own
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX interrupt_pin : 8;
  } Bits;
  UINTX Data;
} INTPIN_MCMAIN_STRUCT;
#endif // ASM_INC

#define MINGNT_MCMAIN_REG                                 0x0000003E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The device does not burst as a PCI compliant master.
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX mgv : 8;
  } Bits;
  UINTX Data;
} MINGNT_MCMAIN_STRUCT;
#endif // ASM_INC

#define MAXLAT_MCMAIN_REG                                 0x0000003F
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The device has no specific requirements for how often it needs to access the PCI
    // bus. 
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX mlv : 8;
  } Bits;
  UINTX Data;
} MAXLAT_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG0_MCMAIN_REG                      0x00000600
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG0_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG1_MCMAIN_REG                      0x00000604
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG1_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG2_MCMAIN_REG                      0x00000608
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG2_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG3_MCMAIN_REG                      0x0000060C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG3_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG4_MCMAIN_REG                      0x00000610
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG4_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG5_MCMAIN_REG                      0x00000614
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG5_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG6_MCMAIN_REG                      0x00000618
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG6_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG7_MCMAIN_REG                      0x0000061C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG7_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG8_MCMAIN_REG                      0x00000620
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG8_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG9_MCMAIN_REG                      0x00000624
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG9_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG10_MCMAIN_REG                     0x00000628
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG10_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG11_MCMAIN_REG                     0x0000062C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG11_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG12_MCMAIN_REG                     0x00000630
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG12_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG13_MCMAIN_REG                     0x00000634
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG13_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG14_MCMAIN_REG                     0x00000638
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG14_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG15_MCMAIN_REG                     0x0000063C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG15_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG16_MCMAIN_REG                     0x00000640
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG16_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG17_MCMAIN_REG                     0x00000644
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG17_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG18_MCMAIN_REG                     0x00000648
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG18_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG19_MCMAIN_REG                     0x0000064C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG19_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG20_MCMAIN_REG                     0x00000650
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG20_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG21_MCMAIN_REG                     0x00000654
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG21_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG22_MCMAIN_REG                     0x00000658
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG22_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_DRAM_RULE_CFG23_MCMAIN_REG                     0x0000065C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} NM_DRAM_RULE_CFG23_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG0_MCMAIN_REG                0x00000660
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG0_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG1_MCMAIN_REG                0x00000664
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG1_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG2_MCMAIN_REG                0x00000668
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG2_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG3_MCMAIN_REG                0x0000066C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG3_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG4_MCMAIN_REG                0x00000670
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG4_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG5_MCMAIN_REG                0x00000674
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG5_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG6_MCMAIN_REG                0x00000678
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG6_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG7_MCMAIN_REG                0x0000067C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG7_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG8_MCMAIN_REG                0x00000680
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG8_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG9_MCMAIN_REG                0x00000684
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG9_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG10_MCMAIN_REG               0x00000688
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG10_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG11_MCMAIN_REG               0x0000068C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG11_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG12_MCMAIN_REG               0x00000690
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG12_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG13_MCMAIN_REG               0x00000694
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG13_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG14_MCMAIN_REG               0x00000698
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG14_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG15_MCMAIN_REG               0x0000069C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG15_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG16_MCMAIN_REG               0x000006A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG16_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG17_MCMAIN_REG               0x000006A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG17_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG18_MCMAIN_REG               0x000006A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG18_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG19_MCMAIN_REG               0x000006AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG19_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG20_MCMAIN_REG               0x000006B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG20_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG21_MCMAIN_REG               0x000006B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG21_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG22_MCMAIN_REG               0x000006B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG22_MCMAIN_STRUCT;
#endif // ASM_INC

#define NM_INTERLEAVE_LIST_CFG23_MCMAIN_REG               0x000006BC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} NM_INTERLEAVE_LIST_CFG23_MCMAIN_STRUCT;
#endif // ASM_INC

#define MC_NM_ROUTE_TABLE_CFG_MCMAIN_REG                  0x000006C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 12;
    //
    // Physical Channel ID
    // 
    // Bits[13:12], RW_LB, default = 0x0
    //
    UINTX channelid0 : 2;
    //
    // Physical Channel ID
    // 
    // Bits[15:14], RW_LB, default = 0x0
    //
    UINTX channelid1 : 2;
    //
    // Physical Channel ID
    // 
    // Bits[17:16], RW_LB, default = 0x0
    //
    UINTX channelid2 : 2;
    //
    // Physical Channel ID
    // 
    // Bits[19:18], RW_LB, default = 0x0
    //
    UINTX channelid3 : 2;
    //
    // Physical Channel ID
    // 
    // Bits[21:20], RW_LB, default = 0x0
    //
    UINTX channelid4 : 2;
    //
    // Physical Channel ID
    // 
    // Bits[23:22], RW_LB, default = 0x0
    //
    UINTX channelid5 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 8;
  } Bits;
  UINTX Data;
} MC_NM_ROUTE_TABLE_CFG_MCMAIN_STRUCT;
#endif // ASM_INC

#define MC_SAD2TAD_CFG0_MCMAIN_REG                        0x000006C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SAD2TAD mapping entry 0 for write through
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX sad2tad0 : 4;
    //
    // SAD2TAD mapping entry 1 for write through
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX sad2tad1 : 4;
    //
    // SAD2TAD mapping entry 2 for write through
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX sad2tad2 : 4;
    //
    // SAD2TAD mapping entry 3 for write through
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX sad2tad3 : 4;
    //
    // SAD2TAD mapping entry 4 for write through
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX sad2tad4 : 4;
    //
    // SAD2TAD mapping entry 5 for write through
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX sad2tad5 : 4;
    //
    // SAD2TAD mapping entry 6 for write through
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX sad2tad6 : 4;
    //
    // SAD2TAD mapping entry 7 for write through
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX sad2tad7 : 4;
  } Bits;
  UINTX Data;
} MC_SAD2TAD_CFG0_MCMAIN_STRUCT;
#endif // ASM_INC

#define MC_SAD2TAD_CFG1_MCMAIN_REG                        0x000006C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SAD2TAD mapping entry 8 for write through
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX sad2tad8 : 4;
    //
    // SAD2TAD mapping entry 9 for write through
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX sad2tad9 : 4;
    //
    // SAD2TAD mapping entry 10 for write through
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX sad2tad10 : 4;
    //
    // SAD2TAD mapping entry 11 for write through
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX sad2tad11 : 4;
    //
    // SAD2TAD mapping entry 12 for write through
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX sad2tad12 : 4;
    //
    // SAD2TAD mapping entry 13 for write through
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX sad2tad13 : 4;
    //
    // SAD2TAD mapping entry 14 for write through
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX sad2tad14 : 4;
    //
    // SAD2TAD mapping entry 15 for write through
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX sad2tad15 : 4;
  } Bits;
  UINTX Data;
} MC_SAD2TAD_CFG1_MCMAIN_STRUCT;
#endif // ASM_INC

#define MC_SAD2TAD_CFG2_MCMAIN_REG                        0x000006CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SAD2TAD mapping entry 16 for write through
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX sad2tad16 : 4;
    //
    // SAD2TAD mapping entry 17 for write through
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX sad2tad17 : 4;
    //
    // SAD2TAD mapping entry 18 for write through
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX sad2tad18 : 4;
    //
    // SAD2TAD mapping entry 19 for write through
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX sad2tad19 : 4;
    //
    // SAD2TAD mapping entry 20 for write through
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX sad2tad20 : 4;
    //
    // SAD2TAD mapping entry 21 for write through
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX sad2tad21 : 4;
    //
    // SAD2TAD mapping entry 22 for write through
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX sad2tad22 : 4;
    //
    // SAD2TAD mapping entry 23 for write through
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX sad2tad23 : 4;
  } Bits;
  UINTX Data;
} MC_SAD2TAD_CFG2_MCMAIN_STRUCT;
#endif // ASM_INC

#define PCOMMIT_CONTROL_MCMAIN_REG                        0x000006D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                          One bit per MC channel.
    //                          When the bit is set, then a Pcommit will target DDR4
    // on that channel. 
    //                          When the bit is clear, then a Pcommit will target DDRT
    // on that channel. 
    //                      
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX nvdimm_chn_msk : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 13;
  } Bits;
  UINTX Data;
} PCOMMIT_CONTROL_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG0_MCMAIN_REG                         0x00000700
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG0_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG1_MCMAIN_REG                         0x00000704
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG1_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG2_MCMAIN_REG                         0x00000708
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG2_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG3_MCMAIN_REG                         0x0000070C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG3_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG4_MCMAIN_REG                         0x00000710
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG4_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG5_MCMAIN_REG                         0x00000714
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG5_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG6_MCMAIN_REG                         0x00000718
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG6_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG7_MCMAIN_REG                         0x0000071C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG7_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG8_MCMAIN_REG                         0x00000720
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG8_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG9_MCMAIN_REG                         0x00000724
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG9_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG10_MCMAIN_REG                        0x00000728
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG10_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG11_MCMAIN_REG                        0x0000072C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG11_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG12_MCMAIN_REG                        0x00000730
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG12_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG13_MCMAIN_REG                        0x00000734
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG13_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG14_MCMAIN_REG                        0x00000738
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG14_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG15_MCMAIN_REG                        0x0000073C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG15_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG16_MCMAIN_REG                        0x00000740
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG16_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG17_MCMAIN_REG                        0x00000744
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG17_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG18_MCMAIN_REG                        0x00000748
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG18_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG19_MCMAIN_REG                        0x0000074C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG19_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG20_MCMAIN_REG                        0x00000750
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG20_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG21_MCMAIN_REG                        0x00000754
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG21_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG22_MCMAIN_REG                        0x00000758
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG22_MCMAIN_STRUCT;
#endif // ASM_INC

#define DRAM_RULE_CFG23_MCMAIN_REG                        0x0000075C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rule_enable : 1;
    //
    // DRAM rule interleave mode. If a dram_rule hits a 3 bit number is used to index
    // into the corresponding interleave_list to determain which package the DRAM belongs
    // to. This mode selects how that number is computed. 00: Address bits {8,7,6}. 01:
    // Address bits {10,9,8}. 10: Address bits {14,13,12}. 11: Address bits {32,31,30}
    // 
    // Bits[2:1], RW_LB, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 2 bit field used to indicate if mod3 or mod2 has to be used. For the mod2 case,
    // several options available, depending on how the mod2 result is mapped to 2 of
    // the 3 possible channels. 
    //             00->use mod3;
    //             01->use mod2, channels 0,1;
    //             10->use mod2, channels 1,2;
    //             11->use mod2, channels 0,2;
    //         
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX mod3_asamod2 : 2;
    //
    // This correspond to Addr[45:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:7], RW_LB, default = 0x0
    //
    UINTX limit : 20;
    //
    // Use mod3/mod2 in target idx calculation
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX mod3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Define the range of bits used for the mod3/mod2 calculation.
    //             00->Compute mod3/mod2 over PA[45:6]
    //             01->Compute mod3/mod2 over PA[45:8]
    //             10->Compute mod3/mod2 over PA[45:12]
    //             11->Unused
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX mod3_mode : 2;
  } Bits;
  UINTX Data;
} DRAM_RULE_CFG23_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG0_MCMAIN_REG                   0x00000760
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG0_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG1_MCMAIN_REG                   0x00000764
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG1_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG2_MCMAIN_REG                   0x00000768
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG2_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG3_MCMAIN_REG                   0x0000076C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG3_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG4_MCMAIN_REG                   0x00000770
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG4_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG5_MCMAIN_REG                   0x00000774
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG5_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG6_MCMAIN_REG                   0x00000778
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG6_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG7_MCMAIN_REG                   0x0000077C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG7_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG8_MCMAIN_REG                   0x00000780
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG8_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG9_MCMAIN_REG                   0x00000784
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG9_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG10_MCMAIN_REG                  0x00000788
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG10_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG11_MCMAIN_REG                  0x0000078C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG11_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG12_MCMAIN_REG                  0x00000790
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG12_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG13_MCMAIN_REG                  0x00000794
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG13_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG14_MCMAIN_REG                  0x00000798
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG14_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG15_MCMAIN_REG                  0x0000079C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG15_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG16_MCMAIN_REG                  0x000007A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG16_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG17_MCMAIN_REG                  0x000007A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG17_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG18_MCMAIN_REG                  0x000007A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG18_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG19_MCMAIN_REG                  0x000007AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG19_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG20_MCMAIN_REG                  0x000007B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG20_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG21_MCMAIN_REG                  0x000007B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG21_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG22_MCMAIN_REG                  0x000007B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG22_MCMAIN_STRUCT;
#endif // ASM_INC

#define INTERLEAVE_LIST_CFG23_MCMAIN_REG                  0x000007BC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX package0 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX package1 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX package2 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX package3 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX package4 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX package5 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX package6 : 4;
    //
    // Interleave list target.  Encoding is as follows:
    //             4b'0xyz  -  target is a remote socket with NodeId=3b'xyz
    //             4b'1xyz  -  target is a local memory controller which maps to MC_ROUTE_TABLE
    // index 3b'xyz 
    //             Note:  in the 4b'1xyz case, if mod3==1, the MC_ROUTE_TABLE index is
    // actually {mod3[1:0],z} (i.e., xy is ignored) 
    // 
    // Bits[31:28], RW_LB, default = 0x0
    //
    UINTX package7 : 4;
  } Bits;
  UINTX Data;
} INTERLEAVE_LIST_CFG23_MCMAIN_STRUCT;
#endif // ASM_INC

#define MC_ROUTE_TABLE_CFG_MCMAIN_REG                     0x000007C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 12;
    //
    // Physical Channel ID
    // 
    // Bits[13:12], RW_LB, default = 0x0
    //
    UINTX channelid0 : 2;
    //
    // Physical Channel ID
    // 
    // Bits[15:14], RW_LB, default = 0x0
    //
    UINTX channelid1 : 2;
    //
    // Physical Channel ID
    // 
    // Bits[17:16], RW_LB, default = 0x0
    //
    UINTX channelid2 : 2;
    //
    // Physical Channel ID
    // 
    // Bits[19:18], RW_LB, default = 0x0
    //
    UINTX channelid3 : 2;
    //
    // Physical Channel ID
    // 
    // Bits[21:20], RW_LB, default = 0x0
    //
    UINTX channelid4 : 2;
    //
    // Physical Channel ID
    // 
    // Bits[23:22], RW_LB, default = 0x0
    //
    UINTX channelid5 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 8;
  } Bits;
  UINTX Data;
} MC_ROUTE_TABLE_CFG_MCMAIN_STRUCT;
#endif // ASM_INC

#define SCRUBMASK2_MCMAIN_REG                             0x000007C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rank to skip for channel 0. Each bit represents one rank and set to 1 to skip
    // the rank. This field is used when scrubmask.ch_mask is not set. 
    // 
    // Bits[7:0], RW_L, default = 0x0
    //
    UINTX ch0_rank_dec : 8;
    //
    // Rank to skip for channel 1. Each bit represents one rank and set to 1 to skip
    // the rank. This field is used when scrubmask.ch_mask is not set. 
    // 
    // Bits[15:8], RW_L, default = 0x0
    //
    UINTX ch1_rank_dec : 8;
    //
    // Rank to skip for channel 2. Each bit represents one rank and set to 1 to skip
    // the rank. This field is used when scrubmask.ch_mask is not set. 
    // 
    // Bits[23:16], RW_L, default = 0x0
    //
    UINTX ch2_rank_dec : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} SCRUBMASK2_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCNMCACHINGCFG_MCMAIN_REG                         0x00000800
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables 2LM near memory caching of far memory if set. Locked by 2LM disable uCR.
    // This field is programmed on the per iMC basis, i.e. need to maintain consistency
    // with other populated channels in this iMC.  A related register - McNMCachingCfg2
    // - is per channel and is located in MC2LMCNTL block. 
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX mcnmcachingenb : 1;
    //
    // 1LM or 2LM mode but with AG2 memory enabled if set. Locked by PMem disable uCR.
    // This field is programmed on the per iMC basis, i.e. need to maintain consistency
    // with other populated channels in this iMC. 
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX mcpmemenb : 1;
    //
    // For PMem transactions, write to both near and far memory if set. Locked by PMem
    // Write-Thru disable uCR. This field is programmed on the per iMC basis, i.e. need
    // to maintain consistency with other populated channels in this iMC. 
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX mcnmcachingpmemwt : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // Configured for mirroring - far memory is in the same channel as near memory if
    // set. Locked by mirroring disable uCR. This field is programmed on the per iMC
    // basis, i.e. need to maintain consistency with other populated channels in this
    // iMC. 
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX mcmirrormode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 23;
  } Bits;
  UINTX Data;
} MCNMCACHINGCFG_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADBASE_0_MCMAIN_REG                              0x00000850
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The position of the MC in the socket interleave list in the SAD rule that maps
    // to this TAD rule. 
    //                      If 1-way interleaved to one MC, base_offset is 0.
    // 		     If 2-way interleaved across two MCs, base_offset is either 0 or 1.
    // 		     4-way, 0 through 3.  8-way, 0 through 7.
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX base_offset : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the chn_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11  reserved
    //           
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX chn_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[8:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //               Downgrades patrol scrubbing uncorrectable errors to correactable
    // for this TAD range. Use for partial mirroring mode. 
    //           
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX ign_ptrl_uc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[45:26].
    // 
    // Bits[31:12], RW_LB, default = 0x0
    //
    UINTX base : 20;
  } Bits;
  UINTX Data;
} TADBASE_0_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADBASE_1_MCMAIN_REG                              0x00000854
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The position of the MC in the socket interleave list in the SAD rule that maps
    // to this TAD rule. 
    //                      If 1-way interleaved to one MC, base_offset is 0.
    // 		     If 2-way interleaved across two MCs, base_offset is either 0 or 1.
    // 		     4-way, 0 through 3.  8-way, 0 through 7.
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX base_offset : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the chn_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11  reserved
    //           
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX chn_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[8:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //               Downgrades patrol scrubbing uncorrectable errors to correactable
    // for this TAD range. Use for partial mirroring mode. 
    //           
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX ign_ptrl_uc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[45:26].
    // 
    // Bits[31:12], RW_LB, default = 0x0
    //
    UINTX base : 20;
  } Bits;
  UINTX Data;
} TADBASE_1_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADBASE_2_MCMAIN_REG                              0x00000858
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The position of the MC in the socket interleave list in the SAD rule that maps
    // to this TAD rule. 
    //                      If 1-way interleaved to one MC, base_offset is 0.
    // 		     If 2-way interleaved across two MCs, base_offset is either 0 or 1.
    // 		     4-way, 0 through 3.  8-way, 0 through 7.
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX base_offset : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the chn_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11  reserved
    //           
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX chn_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[8:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //               Downgrades patrol scrubbing uncorrectable errors to correactable
    // for this TAD range. Use for partial mirroring mode. 
    //           
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX ign_ptrl_uc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[45:26].
    // 
    // Bits[31:12], RW_LB, default = 0x0
    //
    UINTX base : 20;
  } Bits;
  UINTX Data;
} TADBASE_2_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADBASE_3_MCMAIN_REG                              0x0000085C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The position of the MC in the socket interleave list in the SAD rule that maps
    // to this TAD rule. 
    //                      If 1-way interleaved to one MC, base_offset is 0.
    // 		     If 2-way interleaved across two MCs, base_offset is either 0 or 1.
    // 		     4-way, 0 through 3.  8-way, 0 through 7.
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX base_offset : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the chn_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11  reserved
    //           
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX chn_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[8:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //               Downgrades patrol scrubbing uncorrectable errors to correactable
    // for this TAD range. Use for partial mirroring mode. 
    //           
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX ign_ptrl_uc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[45:26].
    // 
    // Bits[31:12], RW_LB, default = 0x0
    //
    UINTX base : 20;
  } Bits;
  UINTX Data;
} TADBASE_3_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADBASE_4_MCMAIN_REG                              0x00000860
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The position of the MC in the socket interleave list in the SAD rule that maps
    // to this TAD rule. 
    //                      If 1-way interleaved to one MC, base_offset is 0.
    // 		     If 2-way interleaved across two MCs, base_offset is either 0 or 1.
    // 		     4-way, 0 through 3.  8-way, 0 through 7.
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX base_offset : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the chn_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11  reserved
    //           
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX chn_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[8:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //               Downgrades patrol scrubbing uncorrectable errors to correactable
    // for this TAD range. Use for partial mirroring mode. 
    //           
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX ign_ptrl_uc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[45:26].
    // 
    // Bits[31:12], RW_LB, default = 0x0
    //
    UINTX base : 20;
  } Bits;
  UINTX Data;
} TADBASE_4_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADBASE_5_MCMAIN_REG                              0x00000864
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The position of the MC in the socket interleave list in the SAD rule that maps
    // to this TAD rule. 
    //                      If 1-way interleaved to one MC, base_offset is 0.
    // 		     If 2-way interleaved across two MCs, base_offset is either 0 or 1.
    // 		     4-way, 0 through 3.  8-way, 0 through 7.
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX base_offset : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the chn_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11  reserved
    //           
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX chn_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[8:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //               Downgrades patrol scrubbing uncorrectable errors to correactable
    // for this TAD range. Use for partial mirroring mode. 
    //           
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX ign_ptrl_uc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[45:26].
    // 
    // Bits[31:12], RW_LB, default = 0x0
    //
    UINTX base : 20;
  } Bits;
  UINTX Data;
} TADBASE_5_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADBASE_6_MCMAIN_REG                              0x00000868
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The position of the MC in the socket interleave list in the SAD rule that maps
    // to this TAD rule. 
    //                      If 1-way interleaved to one MC, base_offset is 0.
    // 		     If 2-way interleaved across two MCs, base_offset is either 0 or 1.
    // 		     4-way, 0 through 3.  8-way, 0 through 7.
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX base_offset : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the chn_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11  reserved
    //           
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX chn_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[8:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //               Downgrades patrol scrubbing uncorrectable errors to correactable
    // for this TAD range. Use for partial mirroring mode. 
    //           
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX ign_ptrl_uc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[45:26].
    // 
    // Bits[31:12], RW_LB, default = 0x0
    //
    UINTX base : 20;
  } Bits;
  UINTX Data;
} TADBASE_6_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADBASE_7_MCMAIN_REG                              0x0000086C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The position of the MC in the socket interleave list in the SAD rule that maps
    // to this TAD rule. 
    //                      If 1-way interleaved to one MC, base_offset is 0.
    // 		     If 2-way interleaved across two MCs, base_offset is either 0 or 1.
    // 		     4-way, 0 through 3.  8-way, 0 through 7.
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX base_offset : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the chn_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11  reserved
    //           
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX chn_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[8:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //               Downgrades patrol scrubbing uncorrectable errors to correactable
    // for this TAD range. Use for partial mirroring mode. 
    //           
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX ign_ptrl_uc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[45:26].
    // 
    // Bits[31:12], RW_LB, default = 0x0
    //
    UINTX base : 20;
  } Bits;
  UINTX Data;
} TADBASE_7_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCMTR_MCMAIN_REG                                  0x0000087C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Use close page address mapping if set; otherwise, open page.
    // 
    // Bits[0:0], RWS_LB, default = 0x0
    //
    UINTX close_pg : 1;
    //
    //  Not used in SKX.  Do not set.  Do not set for static Virtual Lockstep.
    // 
    // Bits[1:1], RWS_LBV, default = 0x0
    //
    UINTX ls_en : 1;
    //
    // ECC enable.
    // 
    // Bits[2:2], RWS_LBV, default = 0x0
    //
    UINTX ecc_en : 1;
    //
    // Directory Enable. Read-Only (RO) with 0 value if not supported. 
    //             (Only supported on processors which support directory) 
    //         
    // 
    // Bits[3:3], RWS_LBV, default = 0x0
    //
    UINTX dir_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // 0: Training mode
    // 1: Normal Mode
    // 
    // Bits[8:8], RW_LB, default = 0x0
    //
    UINTX normal : 1;
    //
    // When set, this bit will enable bank XOR'ing. This is targeted at workloads that
    // bank thrashing caused by certain stride or page mappings. If one detects unexpectedly
    // poor page hit rates, one can attempt to flip this bit to see if it helps. 
    // [0]: Our base configuration. Bank selection is done using rank address bits 12:17:18
    // for open page mapping and bits 6:7:8 for close page mapping. 
    // [1]: Bank XOR'ing enabled. Bank selection is done using rank address bits:
    // (12^19):(17^20):(18^21) for open page mapping
    // (6^19):(7^20):(8^21) for close page mapping
    // 
    // Bits[9:9], RWS_LB, default = 0x0
    //
    UINTX bank_xor_enable : 1;
    //
    // 00: reserved
    // 01: Native CPGC Mode. (mcmtr.normal must be zero for this mode)
    // 10: reserved
    // 11: Normal Mode (mcmtr.normal is a don't care for this mode)
    // 
    // Bits[11:10], RW_LB, default = 0x0
    //
    UINTX trng_mode : 2;
    //
    // Memory mode:
    // 00: Native DDR
    // 01: Reserved
    // 10: Reserved
    // 11: Reserved
    // 
    // Bits[13:12], RWS_LB, default = 0x0
    //
    UINTX imc_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[17:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
    //
    // Channel disable control. When set, the corresponding channel is disabled. 
    //             bit 0 - Ch0
    //             bit 1 - Ch1
    //             bit 2 - Ch2
    //             Note: Message Channel may not work if all channels are set to disable
    // in this field. 
    // 
    // Bits[20:18], RWS_LB, default = 0x0
    //
    UINTX chn_disable : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[21:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // N/A
    // 
    // Bits[22:22], RWS_LB, default = 0x0
    //
    UINTX ch23cmd_ctl_delay : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // In ADDDC mode. Memory transactions will not arrive back-to-back.
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX adddc_mode : 1;
    //
    // Per channel based target. 
    //             0 = CPGC transactions go to DRAM scheduler.
    //             1 = CPGC transactions go to DDRT scheduler.  
    //         
    // 
    // Bits[27:25], RW_LB, default = 0x0
    //
    UINTX trng_target : 3;
    //
    // When set 1, and when uclk is less than dclk, enable issuing of read CAS and DDRT
    // GNT only in certain slot. Should be set when NGN DIMM is populated. 
    // 
    // Bits[28:28], RW_LB, default = 0x0
    //
    UINTX enable_slot_use : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 3;
  } Bits;
  UINTX Data;
} MCMTR_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADWAYNESS_0_MCMAIN_REG                           0x00000880
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 0 (used for 1/2/3/4-way TAD interleaving). 
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt0 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 1 (used for 2/3/4-way TAD interleaving). 
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt1 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 2 (used for 3/4-way TAD interleaving). 
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt2 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 3 (used for 4-way TAD interleaving). 
    // This register is used in the IMC only for reverse address translation for logging
    // spare/patrol errors, converting a rank address back to a system address. 
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt3 : 2;
    //
    // channel interleave wayness
    // 00 - interleave across 1 channel or mirror pair
    // 01 - interleave across 2 channels or mirror pairs
    // 10 - interleave across 3 channels
    // 11 - interleave across 4 channels
    // Note: This parameter effectively tells IMC how much to divide the system address
    // by when adjusting for the channel interleave. Since both channels in a pair store
    // every line of data, we want to divide by 1 when interleaving across one pair and
    // 2 when interleaving across two pairs. For M2M, it tells how may channels to distribute
    // the read requests across. When we interleaving across 1 pair, we want to distribute
    // the reads to two channels, when interleaving across 2 pairs, we distribute the
    // reads across 4 pairs. Writes always go to both channels in the pair when the read
    // target is either channel. 
    // 
    // Bits[9:8], RW_LB, default = 0x0
    //
    UINTX tad_ch_way : 2;
    //
    // socket interleave wayness
    // 00 = 1 way,
    // 01 = 2 way,
    // 10 = 4 way,
    // 11 = 8 way.
    // 
    // Bits[11:10], RW_LB, default = 0x0
    //
    UINTX tad_skt_way : 2;
    //
    // highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[45:26].
    // 
    // Bits[31:12], RW_LB, default = 0x0
    //
    UINTX tad_limit : 20;
  } Bits;
  UINTX Data;
} TADWAYNESS_0_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADWAYNESS_1_MCMAIN_REG                           0x00000884
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 0 (used for 1/2/3/4-way TAD interleaving). 
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt0 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 1 (used for 2/3/4-way TAD interleaving). 
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt1 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 2 (used for 3/4-way TAD interleaving). 
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt2 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 3 (used for 4-way TAD interleaving). 
    // This register is used in the IMC only for reverse address translation for logging
    // spare/patrol errors, converting a rank address back to a system address. 
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt3 : 2;
    //
    // channel interleave wayness
    // 00 - interleave across 1 channel or mirror pair
    // 01 - interleave across 2 channels or mirror pairs
    // 10 - interleave across 3 channels
    // 11 - interleave across 4 channels
    // Note: This parameter effectively tells IMC how much to divide the system address
    // by when adjusting for the channel interleave. Since both channels in a pair store
    // every line of data, we want to divide by 1 when interleaving across one pair and
    // 2 when interleaving across two pairs. For M2M, it tells how may channels to distribute
    // the read requests across. When we interleaving across 1 pair, we want to distribute
    // the reads to two channels, when interleaving across 2 pairs, we distribute the
    // reads across 4 pairs. Writes always go to both channels in the pair when the read
    // target is either channel. 
    // 
    // Bits[9:8], RW_LB, default = 0x0
    //
    UINTX tad_ch_way : 2;
    //
    // socket interleave wayness
    // 00 = 1 way,
    // 01 = 2 way,
    // 10 = 4 way,
    // 11 = 8 way.
    // 
    // Bits[11:10], RW_LB, default = 0x0
    //
    UINTX tad_skt_way : 2;
    //
    // highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[45:26].
    // 
    // Bits[31:12], RW_LB, default = 0x0
    //
    UINTX tad_limit : 20;
  } Bits;
  UINTX Data;
} TADWAYNESS_1_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADWAYNESS_2_MCMAIN_REG                           0x00000888
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 0 (used for 1/2/3/4-way TAD interleaving). 
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt0 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 1 (used for 2/3/4-way TAD interleaving). 
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt1 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 2 (used for 3/4-way TAD interleaving). 
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt2 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 3 (used for 4-way TAD interleaving). 
    // This register is used in the IMC only for reverse address translation for logging
    // spare/patrol errors, converting a rank address back to a system address. 
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt3 : 2;
    //
    // channel interleave wayness
    // 00 - interleave across 1 channel or mirror pair
    // 01 - interleave across 2 channels or mirror pairs
    // 10 - interleave across 3 channels
    // 11 - interleave across 4 channels
    // Note: This parameter effectively tells IMC how much to divide the system address
    // by when adjusting for the channel interleave. Since both channels in a pair store
    // every line of data, we want to divide by 1 when interleaving across one pair and
    // 2 when interleaving across two pairs. For M2M, it tells how may channels to distribute
    // the read requests across. When we interleaving across 1 pair, we want to distribute
    // the reads to two channels, when interleaving across 2 pairs, we distribute the
    // reads across 4 pairs. Writes always go to both channels in the pair when the read
    // target is either channel. 
    // 
    // Bits[9:8], RW_LB, default = 0x0
    //
    UINTX tad_ch_way : 2;
    //
    // socket interleave wayness
    // 00 = 1 way,
    // 01 = 2 way,
    // 10 = 4 way,
    // 11 = 8 way.
    // 
    // Bits[11:10], RW_LB, default = 0x0
    //
    UINTX tad_skt_way : 2;
    //
    // highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[45:26].
    // 
    // Bits[31:12], RW_LB, default = 0x0
    //
    UINTX tad_limit : 20;
  } Bits;
  UINTX Data;
} TADWAYNESS_2_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADWAYNESS_3_MCMAIN_REG                           0x0000088C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 0 (used for 1/2/3/4-way TAD interleaving). 
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt0 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 1 (used for 2/3/4-way TAD interleaving). 
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt1 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 2 (used for 3/4-way TAD interleaving). 
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt2 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 3 (used for 4-way TAD interleaving). 
    // This register is used in the IMC only for reverse address translation for logging
    // spare/patrol errors, converting a rank address back to a system address. 
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt3 : 2;
    //
    // channel interleave wayness
    // 00 - interleave across 1 channel or mirror pair
    // 01 - interleave across 2 channels or mirror pairs
    // 10 - interleave across 3 channels
    // 11 - interleave across 4 channels
    // Note: This parameter effectively tells IMC how much to divide the system address
    // by when adjusting for the channel interleave. Since both channels in a pair store
    // every line of data, we want to divide by 1 when interleaving across one pair and
    // 2 when interleaving across two pairs. For M2M, it tells how may channels to distribute
    // the read requests across. When we interleaving across 1 pair, we want to distribute
    // the reads to two channels, when interleaving across 2 pairs, we distribute the
    // reads across 4 pairs. Writes always go to both channels in the pair when the read
    // target is either channel. 
    // 
    // Bits[9:8], RW_LB, default = 0x0
    //
    UINTX tad_ch_way : 2;
    //
    // socket interleave wayness
    // 00 = 1 way,
    // 01 = 2 way,
    // 10 = 4 way,
    // 11 = 8 way.
    // 
    // Bits[11:10], RW_LB, default = 0x0
    //
    UINTX tad_skt_way : 2;
    //
    // highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[45:26].
    // 
    // Bits[31:12], RW_LB, default = 0x0
    //
    UINTX tad_limit : 20;
  } Bits;
  UINTX Data;
} TADWAYNESS_3_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADWAYNESS_4_MCMAIN_REG                           0x00000890
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 0 (used for 1/2/3/4-way TAD interleaving). 
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt0 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 1 (used for 2/3/4-way TAD interleaving). 
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt1 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 2 (used for 3/4-way TAD interleaving). 
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt2 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 3 (used for 4-way TAD interleaving). 
    // This register is used in the IMC only for reverse address translation for logging
    // spare/patrol errors, converting a rank address back to a system address. 
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt3 : 2;
    //
    // channel interleave wayness
    // 00 - interleave across 1 channel or mirror pair
    // 01 - interleave across 2 channels or mirror pairs
    // 10 - interleave across 3 channels
    // 11 - interleave across 4 channels
    // Note: This parameter effectively tells IMC how much to divide the system address
    // by when adjusting for the channel interleave. Since both channels in a pair store
    // every line of data, we want to divide by 1 when interleaving across one pair and
    // 2 when interleaving across two pairs. For M2M, it tells how may channels to distribute
    // the read requests across. When we interleaving across 1 pair, we want to distribute
    // the reads to two channels, when interleaving across 2 pairs, we distribute the
    // reads across 4 pairs. Writes always go to both channels in the pair when the read
    // target is either channel. 
    // 
    // Bits[9:8], RW_LB, default = 0x0
    //
    UINTX tad_ch_way : 2;
    //
    // socket interleave wayness
    // 00 = 1 way,
    // 01 = 2 way,
    // 10 = 4 way,
    // 11 = 8 way.
    // 
    // Bits[11:10], RW_LB, default = 0x0
    //
    UINTX tad_skt_way : 2;
    //
    // highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[45:26].
    // 
    // Bits[31:12], RW_LB, default = 0x0
    //
    UINTX tad_limit : 20;
  } Bits;
  UINTX Data;
} TADWAYNESS_4_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADWAYNESS_5_MCMAIN_REG                           0x00000894
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 0 (used for 1/2/3/4-way TAD interleaving). 
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt0 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 1 (used for 2/3/4-way TAD interleaving). 
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt1 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 2 (used for 3/4-way TAD interleaving). 
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt2 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 3 (used for 4-way TAD interleaving). 
    // This register is used in the IMC only for reverse address translation for logging
    // spare/patrol errors, converting a rank address back to a system address. 
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt3 : 2;
    //
    // channel interleave wayness
    // 00 - interleave across 1 channel or mirror pair
    // 01 - interleave across 2 channels or mirror pairs
    // 10 - interleave across 3 channels
    // 11 - interleave across 4 channels
    // Note: This parameter effectively tells IMC how much to divide the system address
    // by when adjusting for the channel interleave. Since both channels in a pair store
    // every line of data, we want to divide by 1 when interleaving across one pair and
    // 2 when interleaving across two pairs. For M2M, it tells how may channels to distribute
    // the read requests across. When we interleaving across 1 pair, we want to distribute
    // the reads to two channels, when interleaving across 2 pairs, we distribute the
    // reads across 4 pairs. Writes always go to both channels in the pair when the read
    // target is either channel. 
    // 
    // Bits[9:8], RW_LB, default = 0x0
    //
    UINTX tad_ch_way : 2;
    //
    // socket interleave wayness
    // 00 = 1 way,
    // 01 = 2 way,
    // 10 = 4 way,
    // 11 = 8 way.
    // 
    // Bits[11:10], RW_LB, default = 0x0
    //
    UINTX tad_skt_way : 2;
    //
    // highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[45:26].
    // 
    // Bits[31:12], RW_LB, default = 0x0
    //
    UINTX tad_limit : 20;
  } Bits;
  UINTX Data;
} TADWAYNESS_5_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADWAYNESS_6_MCMAIN_REG                           0x00000898
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 0 (used for 1/2/3/4-way TAD interleaving). 
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt0 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 1 (used for 2/3/4-way TAD interleaving). 
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt1 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 2 (used for 3/4-way TAD interleaving). 
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt2 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 3 (used for 4-way TAD interleaving). 
    // This register is used in the IMC only for reverse address translation for logging
    // spare/patrol errors, converting a rank address back to a system address. 
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt3 : 2;
    //
    // channel interleave wayness
    // 00 - interleave across 1 channel or mirror pair
    // 01 - interleave across 2 channels or mirror pairs
    // 10 - interleave across 3 channels
    // 11 - interleave across 4 channels
    // Note: This parameter effectively tells IMC how much to divide the system address
    // by when adjusting for the channel interleave. Since both channels in a pair store
    // every line of data, we want to divide by 1 when interleaving across one pair and
    // 2 when interleaving across two pairs. For M2M, it tells how may channels to distribute
    // the read requests across. When we interleaving across 1 pair, we want to distribute
    // the reads to two channels, when interleaving across 2 pairs, we distribute the
    // reads across 4 pairs. Writes always go to both channels in the pair when the read
    // target is either channel. 
    // 
    // Bits[9:8], RW_LB, default = 0x0
    //
    UINTX tad_ch_way : 2;
    //
    // socket interleave wayness
    // 00 = 1 way,
    // 01 = 2 way,
    // 10 = 4 way,
    // 11 = 8 way.
    // 
    // Bits[11:10], RW_LB, default = 0x0
    //
    UINTX tad_skt_way : 2;
    //
    // highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[45:26].
    // 
    // Bits[31:12], RW_LB, default = 0x0
    //
    UINTX tad_limit : 20;
  } Bits;
  UINTX Data;
} TADWAYNESS_6_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADWAYNESS_7_MCMAIN_REG                           0x0000089C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 0 (used for 1/2/3/4-way TAD interleaving). 
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt0 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 1 (used for 2/3/4-way TAD interleaving). 
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt1 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 2 (used for 3/4-way TAD interleaving). 
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt2 : 2;
    //
    // Obsolete register in SKX.  Should be removed from SKX.  target channel for channel
    // interleave 3 (used for 4-way TAD interleaving). 
    // This register is used in the IMC only for reverse address translation for logging
    // spare/patrol errors, converting a rank address back to a system address. 
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX tad_ch_tgt3 : 2;
    //
    // channel interleave wayness
    // 00 - interleave across 1 channel or mirror pair
    // 01 - interleave across 2 channels or mirror pairs
    // 10 - interleave across 3 channels
    // 11 - interleave across 4 channels
    // Note: This parameter effectively tells IMC how much to divide the system address
    // by when adjusting for the channel interleave. Since both channels in a pair store
    // every line of data, we want to divide by 1 when interleaving across one pair and
    // 2 when interleaving across two pairs. For M2M, it tells how may channels to distribute
    // the read requests across. When we interleaving across 1 pair, we want to distribute
    // the reads to two channels, when interleaving across 2 pairs, we distribute the
    // reads across 4 pairs. Writes always go to both channels in the pair when the read
    // target is either channel. 
    // 
    // Bits[9:8], RW_LB, default = 0x0
    //
    UINTX tad_ch_way : 2;
    //
    // socket interleave wayness
    // 00 = 1 way,
    // 01 = 2 way,
    // 10 = 4 way,
    // 11 = 8 way.
    // 
    // Bits[11:10], RW_LB, default = 0x0
    //
    UINTX tad_skt_way : 2;
    //
    // highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[45:26].
    // 
    // Bits[31:12], RW_LB, default = 0x0
    //
    UINTX tad_limit : 20;
  } Bits;
  UINTX Data;
} TADWAYNESS_7_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCMTR2_MCMAIN_REG                                 0x000008B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Monroe Technology software channel force SRcontrol. When set, the corresponding
    // channel is ignoring the ForceSRExit. A new transaction arrive at this channel
    // will still cause the SR exit. 
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX monroe_chn_force_sr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 28;
  } Bits;
  UINTX Data;
} MCMTR2_MCMAIN_STRUCT;
#endif // ASM_INC

#define MC_INIT_STATE_G_MCMAIN_REG                        0x000008B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This bit should be set to 1 by bios as soon as the MRC has successfully completed
    // and all required information (e.g. - training) is in the Bios flash. It indicates
    // that first MRC has been completed 
    // 
    // Bits[0:0], RWS_L, default = 0x0
    //
    UINTX pu_mrc_done : 1;
    //
    // DDR reset for all DIMMs from all channels within this socket. No IMC/DDRIO logic
    // is reset by asserting this register. 
    // It is important to note that this bit is negative logic! i.e. writing 0 to induce
    // a reset and write 1 for not reset. 
    // 
    // Bits[1:1], RW_L, default = 0x1
    //
    UINTX ddr_reset : 1;
    //
    // DCLK Enable (for all channels)
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX dclk_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // DDR IO reset
    // In order to reset the IO this bit has to be set for 20 DCLKs and then cleared.
    // Setting this bit will reset the DDRIO receive FIFO registers only. 
    // It is required in some of the training steps
    // It goes to both the left and right DDRIO blocks on MC on Romley and only the
    // left side DDRIO block on Brickland
    // 
    // Bits[5:5], RW_L, default = 0x1
    //
    UINTX reset_io : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // N/A
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX mrc_done : 1;
    //
    // This bit indicates if it is safe to keep the MC in SR during MC-reset. If it is
    // clear when reset occurs, it means that the reset is without warning and the DDR-reset
    // should be asserted. If set when reset occurs, it indicates that DDR is already
    // in SR and it can keep it this way. This bit can also indicate MRC if reset without
    // warning has occured, and if it has, cold-reset flow should be selected 
    // Note to MRC BIOS: clear this bit at MRC entry.
    // 
    // Bits[8:8], RWS_L, default = 0x1
    //
    UINTX safe_sr : 1;
    //
    // N/A
    // 
    // Bits[12:9], RWS_L, default = 0x0
    //
    UINTX cs_oe_en : 4;
    //
    // Reset is used to set up Intel SMI 2 2:1 mode correctly
    // in DDRIO. The register must be set and reset
    // after the IMC mode register is configured to
    // Intel SMI 2 2:1 mode.
    // 
    // Bits[13:13], RWS_L, default = 0x0
    //
    UINTX reset_vmse2to1 : 1;
    //
    // Training Reset for DDRIO. This signal is unused on Romley and goes
    // to Intel SMI 2 channel 1 on Brickland
    // 
    // Bits[14:14], RWS_L, default = 0x0
    //
    UINTX reset_io_vmse_rhs : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 17;
  } Bits;
  UINTX Data;
} MC_INIT_STATE_G_MCMAIN_STRUCT;
#endif // ASM_INC

#define RCOMP_TIMER_MCMAIN_REG                            0x000008C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DCLK cycle count that MC needs to wait from the point it has triggered RCOMP evaluation
    // until it can trigger the load to registers 
    // 
    // Bits[15:0], RW, default = 0xC00
    //
    UINTX count : 16;
    //
    // This is a status bit that indicates the first RCOMP has been completed. It is
    // cleared on reset, and set by MC HW when the first RCOMP is completed. Bios should
    // wait until this bit is set before executing any DDR command 
    // 
    // Bits[16:16], RW_LV, default = 0x0
    //
    UINTX first_rcomp_done : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // N/A
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX no_mdll_fsm_override : 1;
    //
    // N/A
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX ignore_mdll_locked_bit : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 8;
    //
    // RCOMP start via message channel control for bios.
    // RCOMP start only triggered when the register bit output is changing from 0 ->
    // 1 
    // MC will not be responsible for clearing this bit. MC already provides feedback
    // to bias 
    // when Rcomp is done via first_rcomp_done bit field.
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX rcomp : 1;
    //
    // N/A
    // 
    // Bits[31:31], RW_V, default = 0x0
    //
    UINTX rcomp_in_progress : 1;
  } Bits;
  UINTX Data;
} RCOMP_TIMER_MCMAIN_STRUCT;
#endif // ASM_INC

#define IMC_FUSE_DOWNLOAD_SHADOW_MCMAIN_REG               0x000008C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Fused channel disable control. When set, the corresponding channel is disabled.
    // Fuse download may change the default value after reset de-assertion. Setting to
    // all 1 may disable msg channel. 
    // 
    // Bits[2:0], RO_V, default = 0x0
    //
    UINTX fuse_shadow_chn_disable : 3;
    //
    // Force ddr4 command address parity to be zero. This requires DDR4 DRAMs to be initialized
    // to disable parity checking. 
    // 
    // Bits[3:3], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_ddr4_caparity : 1;
    //
    // Fused 2 DPC disable control. When set, CS signals for DIMM slot 1 (i.e. slot 0
    // is not disabled) are disabled. Note: some CS may have multiplexed with address
    // signal to support extended addressing. The CS signal disabling is only applicable
    // to CS not the being multiplexed with address. Fuse download may change the default
    // value after reset de-assertion. 
    // 
    // Bits[4:4], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_2_dpc : 1;
    //
    // Fused patrol scrub disable control. When set, rank patrol scrub is disabled. Fuse
    // download may change the default value after reset de-assertion. 
    // 
    // Bits[5:5], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_patrol_scrub : 1;
    //
    // Fused 3DS (3D stacked die) disable control. When set, the C0, C1 and C2 signals
    // will forced to zero. Fuse download may change the default value after reset de-assertion.
    // 
    // Bits[6:6], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_3ds : 1;
    //
    // Fused 16Gb or higher disable control. When set, the address decode to the corresponding
    // 16Gb or higher mapping is disabled. Note: LR-DIMM's logical device density is
    // also limited to 16Gb when this fuse is set. Fuse download may change the default
    // value after reset de-assertion. 
    // 
    // Bits[7:7], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_16gbit : 1;
    //
    // Reserved for future use.
    // 
    // Bits[8:8], RO_V, default = 0x0
    //
    UINTX fuse_shadow_rfu_0 : 1;
    //
    // Fused ADR disable control. When set, memory ignores ADR event. Fuse download may
    // change the default value after reset de-assertion. 
    // 
    // Bits[9:9], RO_V, default = 0x0
    //
    UINTX fuse_shadow_dis_asyncsr_adr : 1;
    //
    // Fused ECC disable control. When set, ECC is disabled. Fuse download may change
    // the default value after reset de-assertion. 
    // 
    // Bits[10:10], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_ecc : 1;
    //
    // Fused DIR disable control. When set, directory is disabled. Fuse download may
    // change the default value after reset de-assertion. 
    // 
    // Bits[11:11], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_dir : 1;
    //
    // Fuse for mc_mca_recovery. Blown to 0 for EP, HEDT, ... etc, i.e. Means recovery
    // from uncorrectable Patrol scrub errors is not supported. In addition, iMC hardware
    // logs uncorrectable PS errors in the MCA bank with MCi_STATUS.PCC when set. When
    // the fuse is blown to 1 in in EX only, this means that when poisoning is enabled,
    // recovery from uncorrectable patrol scrub errors is supported. MC hardware will
    // log uncorrectable Patrol scrub errors in the MCA bank with a recoverable error
    // signature. Please refer to MCA HAS for further details. 
    // 
    // Bits[12:12], RO_V, default = 0x1
    //
    UINTX fuse_shadow_mc_mca_recovery : 1;
    //
    // Fused RDIMM disable control. When set, RDIMM support is disabled by forcing the
    // upper 5 bits of the 13b T_STAB register to be zeros, i.e. the T_STAB can only
    // have max of 255 DCLK delay after clock-stopped power down mode which is in sufficient
    // for normal RDIMM clock stablization; hence, users will not be able to support
    // self-refresh with clock off mode (S3, pkg C6) if the RDIMM disable fuse is blown
    // to one. 
    // Fuse download may change the default value after reset de-assertion.
    // 
    // Bits[13:13], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_rdimm : 1;
    //
    // Fused UDIMM disable control. When set, UDIMM support is disabled by disabling
    // address bit swizzling. Fuse download may change the default value after reset
    // de-assertion. 
    // Note: Since LRDIMM also have UDIMM address swizzling, this UDIMM disable fuse
    // must not be blown to 1 for JKT SKU that may support LRDIMM. 
    // 
    // Bits[14:14], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_udimm : 1;
    //
    // EX fuse: 1=EX config, 0=EP config
    // 
    // Bits[15:15], RO_V, default = 0x1
    //
    UINTX fuse_shadow_is_ex : 1;
    //
    // Fused sparing disable control. When set, all sparing modes are disabled. Fuse
    // download may change the default value after reset de-assertion. 
    // 
    // Bits[16:16], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_sparing : 1;
    //
    // Fused ADDDC disable control. When set, all ADDDC regions are disabled. Fuse download
    // may change the default value after reset de-assertion. 
    // 
    // Bits[17:17], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_adddc : 1;
    //
    // Reserved for future use.
    // 
    // Bits[19:18], RO_V, default = 0x0
    //
    UINTX fuse_shadow_rfu_2 : 2;
    //
    // Single device data correction fuse download. When set, will disable 4-bit device
    // SDDC. 
    // 
    // Bits[20:20], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_sddc_x4 : 1;
    //
    // Single device data correction fuse download. When set, will disable 8-bit device
    // SDDC. 
    // 
    // Bits[21:21], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_sddc_x8 : 1;
    //
    // Single device data correction fuse download. When set, will disable SDDC plus
    // one for x4 SDDC mode. 
    // 
    // Bits[22:22], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_sddc_x4_plus1 : 1;
    //
    // Single device data correction fuse download. When set, will disable SDDC plus
    // one for x8 SDDC mode. 
    // 
    // Bits[23:23], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_sddc_x8_plus1 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[26:24], RO_V, default = 0x0
    //
    UINTX fuse_shadow_rfu_1 : 3;
    //
    // Disable two-level memory
    // 
    // Bits[27:27], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_2lm : 1;
    //
    // Disable the use of DDRT devices, once the fuse is blown to one, iMC will not issue
    // any DDRT commands or responding DDRT bus request. Internally, any request targeting
    // DDRT port is treated as programming error. System may hang. 
    // 
    // Bits[28:28], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_ddrt : 1;
    //
    // Disable use of Persistent Memory with Crystal Ridge.
    // 
    // Bits[29:29], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_cr_pmem : 1;
    //
    // Disable use of Persistent Memory Write Through with Crystal Ridge.
    // 
    // Bits[30:30], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_cr_pmem_wt : 1;
    //
    // Disable use of mirroring.
    // 
    // Bits[31:31], RO_V, default = 0x0
    //
    UINTX fuse_shadow_disable_mcmirrormode : 1;
  } Bits;
  UINTX Data;
} IMC_FUSE_DOWNLOAD_SHADOW_MCMAIN_STRUCT;
#endif // ASM_INC

#define IMC_FUSE_DOWNLOAD2_SHADOW_MCMAIN_REG              0x000008CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved for future use.
    // 
    // Bits[0:0], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_0 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[1:1], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_1 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[2:2], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_2 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[3:3], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_3 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[4:4], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_4 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[5:5], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_5 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[6:6], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_6 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[7:7], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_7 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[8:8], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_8 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[9:9], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_9 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[10:10], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_10 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[11:11], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_11 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[12:12], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_12 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[13:13], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_13 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[14:14], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_14 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[15:15], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_15 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[16:16], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_16 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[17:17], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_17 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[18:18], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_18 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[19:19], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_19 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[20:20], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_20 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[21:21], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_21 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[22:22], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_22 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[23:23], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_23 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[24:24], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_24 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[25:25], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_25 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[26:26], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_26 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[27:27], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_27 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[28:28], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_28 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[29:29], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_29 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[30:30], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_30 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[31:31], RO_V, default = 0x1
    //
    UINTX fuse_shadow_spare_fuse_31 : 1;
  } Bits;
  UINTX Data;
} IMC_FUSE_DOWNLOAD2_SHADOW_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCBGFTUNE_MCMAIN_REG                              0x000008D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Keep BgfRun asserted even though PMA deasserts it. This is use for fake GV for
    // debug 
    // lock bit is MCMAIN_CHICKEN_BITS.BGFTUNE_LK
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX bgfoverride : 1;
    //
    // Uratio at which to enable tuning
    // lock bit is MCMAIN_CHICKEN_BITS.BGFTUNE_LK
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX uratio : 8;
    //
    // Pointer Separation for non-command non msg channel BGF
    // lock bit is MCMAIN_CHICKEN_BITS.BGFTUNE_LK
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX ptrdist : 3;
    //
    // Pointer Separation for Command BGF
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX cmdptrdist : 3;
    //
    // Set when the ratio matches on assertion edge of BgfRun. Cleared by software.
    // lock bit for this in MCMAIN_CHICKEN_BITS.BGFTUNE_LK
    // 
    // Bits[15:15], RWS_LV, default = 0x0
    //
    UINTX uratiomatchsts : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[17:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // N/A
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX mccbgfd_en_u2d_2dratio : 1;
    //
    // Enable bubble generation when 3 channels are populated
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX mccbgfd_en_3ch : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} MCBGFTUNE_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCDECVISACFG_MCMAIN_REG                           0x000008D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RWS_L, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RWS_L, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RWS_L, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RWS_L, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RWS_L, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCDECVISACFG_MCMAIN_STRUCT;
#endif // ASM_INC

#define SCRATCHPAD_MCMAIN_REG                             0x000008D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SCRATCHPAD
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX scratchpad : 32;
  } Bits;
  UINTX Data;
} SCRATCHPAD_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCMAIN_CHKN_BITS_MCMAIN_REG                       0x000008E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Force sparing to issue one transaction at a time
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX frc_sngl_spr : 1;
    //
    // Disable signalling of SMI from patrol scrub engine. Patrol scrub is able to signal
    // SMI when it stops on error or reaches end of address range. See SCRUBCTL for details.
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX rsvd_chkn_b1 : 1;
    //
    // Disable spare error logging
    // 
    // Bits[2:2], RW_LB, default = 0x0
    //
    UINTX dis_spr_err_log : 1;
    //
    // Force spare start
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX frc_spr_strt : 1;
    //
    // Force spare end
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX frc_spr_end : 1;
    //
    // Disable spare RIR update
    // 
    // Bits[5:5], RW_LB, default = 0x0
    //
    UINTX dis_spr_rir_updt : 1;
    //
    // Disable patrol retry
    // 
    // Bits[6:6], RW_LB, default = 0x0
    //
    UINTX dis_ptrl_rty : 1;
    //
    // Disable patrol error logging
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX dis_ptrl_err_log : 1;
    //
    // Force single patrol
    // 
    // Bits[8:8], RW_LB, default = 0x0
    //
    UINTX frc_sngl_ptrl : 1;
    //
    // Disable mxb tsod polling when in Intel SMI 2 modes
    // 
    // Bits[9:9], RW_LB, default = 0x1
    //
    UINTX dis_mxb_tsod : 1;
    //
    // Force mem test to issue one transaction at a time
    // 
    // Bits[10:10], RW_LB, default = 0x0
    //
    UINTX frc_sngl_mtst : 1;
    //
    // Disable rcomp
    // 
    // Bits[11:11], RW_LB, default = 0x0
    //
    UINTX dis_rcomp : 1;
    //
    // Force rcomp completion ack
    // 
    // Bits[12:12], RW_LB, default = 0x0
    //
    UINTX frc_rcomp_cmp_ack : 1;
    //
    // Disable local clock gating - mcmains
    // 
    // Bits[13:13], RW_LB, default = 0x0
    //
    UINTX dis_lcl_ck_gate_mcmain : 1;
    //
    // Increase RCOMP quiet time
    // 
    // Bits[14:14], RW_LB, default = 0x0
    //
    UINTX increase_rcomp : 1;
    //
    // Disable IMC message channel clock gate when set.
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX dis_msg_ch_ck_gate_mc : 1;
    //
    // Disable DDRIO message channel clock gate when set.
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX dis_msg_ch_ck_gate_ddrio : 1;
    //
    // Disable Debug BGF Push when set
    // 
    // Bits[17:17], RW_LB, default = 0x0
    //
    UINTX dis_dbg_bgf_push : 1;
    //
    // Reserved Unused
    // 
    // Bits[18:18], RW_LB, default = 0x0
    //
    UINTX defeature_12 : 1;
    //
    // Lock bit for MCBGFTUNE register
    // 
    // Bits[19:19], RWS_L, default = 0x0
    //
    UINTX bgftune_lock : 1;
    //
    // Bug fix for HSD b3123628:
    // When set, tells MC that this is a frequency_change flow. When the bit is set,
    // following changes take place 
    // 1. When PmRsBlock is asserted, we block message channel to M2M
    // 2. PkgC Empty and FullEmpty will ignore msgChEmpty when this bit is set
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX freq_chng_flow : 1;
    //
    // Disable leaky bucket counter in mc_dec
    // 
    // Bits[21:21], RW_LB, default = 0x0
    //
    UINTX dis_leak_cntr : 1;
    //
    // When set to 1, disables the "hold" logic on the BlockAck going to the MC PMA,
    // that keeps the BlockAck asserted once set, until the BlockReq de-asserts 
    // 
    // Bits[22:22], RW_LB, default = 0x0
    //
    UINTX dis_pma_blockack_hold : 1;
    //
    // Enable send debug trigger to scalable memory buffers via SMbus SDA wire, per SMbus
    // master 
    // 
    // Bits[24:23], RW_LB, default = 0x0
    //
    UINTX sda_dbg : 2;
    //
    // MC PMA interface override for channel 3 when not occupied. When set to 1, MCActive
    // will de-assert and InSRD will assert. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX frc_not_occ_0 : 1;
    //
    // MC PMA interface override for channel 3 when not occupied. When set to 1, MCActive
    // will de-assert and InSRD will assert. 
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX frc_not_occ_1 : 1;
    //
    // MC PMA interface override for channel 3 when not occupied. When set to 1, MCActive
    // will de-assert and InSRD will assert. 
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX frc_not_occ_2 : 1;
    //
    // MC PMA interface override for channel 3 when not occupied. When set to 1, MCActive
    // will de-assert and InSRD will assert. 
    // 
    // Bits[28:28], RW_LB, default = 0x0
    //
    UINTX frc_not_occ_3 : 1;
    //
    // Disable patrol scrub poison line on finding uncorr error
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX dis_ptrl_psn : 1;
    //
    // When set to 1, the MC will not backpressure the M2M during an ADR sequence.
    // When set to 0 and the MC receives the AsyncSR signal from the PMA, the MC will
    // immediately backpressure the M2M, stopping any new transactions from being sent
    // to the MC. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX dis_asyncsr_habackpress : 1;
    //
    // Reserved Unused
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX defeature_10 : 1;
  } Bits;
  UINTX Data;
} MCMAIN_CHKN_BITS_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCMAIN_CHKN_BITS2_MCMAIN_REG                      0x000008E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Disable the fix for SprUfillOverride and LogUnCorSprOnError that only check CAP
    // error flow on channel running sparing 
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX dis_fix_ufilloverride : 1;
    //
    // Disable the fix for verr_seen that only check CAP error flow on channel running
    // sparing 
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX dis_fix_errseen : 1;
    //
    // 
    //         Disable all Pcommit performance optimizations. If this bit is
    //         set then all incoming pcommits will be treated as broadcast 
    //         
    // 
    // Bits[2:2], RW_LB, default = 0x0
    //
    UINTX dis_pcommit_perf : 1;
    //
    // When set 1, PkgCEmpty should check RT empty including patrol transaction
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX dis_pat_pkgc : 1;
    //
    // Selects the slot polarity for patrol request; make sure patrol request is in the
    // same slot as M2M request 
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX adddc_slot_sel : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 27;
  } Bits;
  UINTX Data;
} MCMAIN_CHKN_BITS2_MCMAIN_STRUCT;
#endif // ASM_INC

#define OCLA_MUX_SEL01_MCMAIN_REG                         0x000008E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // bus0 select
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX sel0 : 6;
    //
    // bus0 select
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX sel1 : 6;
    //
    // bus0 select
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX sel2 : 6;
    //
    // bus0 select
    // 
    // Bits[23:18], RW, default = 0x0
    //
    UINTX sel3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} OCLA_MUX_SEL01_MCMAIN_STRUCT;
#endif // ASM_INC

#define OCLA_MUX_SEL23_MCMAIN_REG                         0x000008EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // bus0 select
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX sel0 : 6;
    //
    // bus0 select
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINTX sel1 : 6;
    //
    // bus0 select
    // 
    // Bits[17:12], RW, default = 0x0
    //
    UINTX sel2 : 6;
    //
    // bus0 select
    // 
    // Bits[23:18], RW, default = 0x0
    //
    UINTX sel3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} OCLA_MUX_SEL23_MCMAIN_STRUCT;
#endif // ASM_INC

#define SPAREADDRESSLO_MCMAIN_REG                         0x00000900
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Always points to the lower address for the next sparing operation. This register
    // will not be affected by the M2M access to the spare source rank during the M2M
    // window. 
    // 
    // 
    // Bits[31:0], RW_LV, default = 0x0
    //
    UINTX rankadd : 32;
  } Bits;
  UINTX Data;
} SPAREADDRESSLO_MCMAIN_STRUCT;
#endif // ASM_INC

#define SPARECTL_MCMAIN_REG                               0x00000904
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Spare enable when set to 1. Hardware clear after the sparing completion.
    // 
    // Bits[0:0], RW_LBV, default = 0x0
    //
    UINTX spare_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Since there is only one spare-copy logic for all channels, this field selects
    // the channel or channel-pair for the spare-copy operation. 
    // For independent channel operation:
    // 00 = channel 0 is selected for the spare-copy operation
    // 01 = channel 1 is selected for the spare-copy operation
    // 10 = channel 2 is selected for the spare-copy operation
    // 11 = channel 3 is selected for the spare-copy operation
    // For lock-step channel operation:
    // 0x = channel 0 and channel 1 are selected for the spare-copy operation
    // 1x = channel 2 and channel 3 are selected for the spare-copy operation
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_sel : 2;
    //
    // Source logical rank that provides the data to be copied.
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX src_rank : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Destination logical rank used for the memory copy.
    // 
    // Bits[10:8], RW_LB, default = 0x0
    //
    UINTX dst_rank : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
    //
    // This field is available as a scratch pad for SSR operations
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX scratch_pad : 8;
    //
    // minimum water mark for M2M writes to failed rank. Actual wm is max of WPQ credit
    // level and HaFifoWM. When wm is hit the M2M is backpressured and a sparing window
    // is started. 
    // If DisWPQWM is clear, the spare window is started when the number of hits to the
    // failed DIMM exceed max(# of credits in WPQ not yet returned to the M2M, HaFifoWM)
    // If DisWPQWM is set, the spare window starts when the number of hits to the failed
    // DIMM exceed HaFifoWM. 
    // 
    // Bits[28:24], RW_LB, default = 0x0
    //
    UINTX hafifowm : 5;
    //
    // Disable WPQ level based water mark, so that sparing wm is only based on HaFifoWM.
    // If DisWPQWM is clear, the spare window is started when the number of hits to the
    // failed DIMM exceed max(# of credits in WPQ not yet returned to the M2M, HaFifoWM)
    // If DisWPQWM is set, the spare window starts when the number of hits to the failed
    // DIMM exceed HaFifoWM. 
    // In either case, if the number of hits to the failed DIMM do not hit the WM, the
    // spare window will still start after SPAREINTERVAL.NORMOPDUR timer expiration.
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX diswpqwm : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} SPARECTL_MCMAIN_STRUCT;
#endif // ASM_INC

#define SCRUBADDRESSLO_MCMAIN_REG                         0x0000090C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contains the rank address or bits 37:6 of the system address of the last scrub
    // issued. Can be written to specify the next scrub address with STARTSCRUB. Base
    // system address in scrubaddress2lo/hi also need to be programmed in system address
    // mode for the programmed address to work properly. In system address mode, scrubaddresshi.ptl_sa_mode
    // must be cleared to 0 and then set back to 1 after STARTSCRUB is set for address
    // written to take effect. RESTRICTIONS: Patrol Scrubs must be disabled when writing
    // to this field. Bit 0 of this register maps to bit 6 of address. 
    // 
    // Bits[31:0], RW_LBV, default = 0x0
    //
    UINTX rankadd : 32;
  } Bits;
  UINTX Data;
} SCRUBADDRESSLO_MCMAIN_STRUCT;
#endif // ASM_INC

#define SCRUBADDRESSHI_MCMAIN_REG                         0x00000910
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contains bits 46:38 of the system address of the last scrub issued. Can be written
    // to specify the next scrub address with STARTSCRUB. Base system address in scrubaddress2lo/hi
    // also need to be programmed in system address mode for the programmed address to
    // work properly. scrubaddresshi.ptl_sa_mode must be cleared to 0 and then set back
    // to 1 after STARTSCRUB is set for address written to take effect. RESTRICTIONS:
    // Patrol Scrubs must be disabled when writing to this field. Only used system address
    // patrol mode. 
    // 
    // Bits[8:0], RW_LBV, default = 0x0
    //
    UINTX rankaddhi : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Contains the physical rank ID of the last scrub issued. Can be written to specify
    // the next scrub address with STARTSCRUB. RESTRICTION: Patrol Scrubs must be disabled
    // when writing to this field. Only used for legacy (non system address) patrol mode.
    // 
    // Bits[15:12], RW_LBV, default = 0x0
    //
    UINTX rank : 4;
    //
    // Can be written to specify the next scrub address with STARTSCRUB. This register
    // is updated with channel address of the last scrub address issued. RESTRICTIONS:
    // Patrol Scrubs must be disabled when writing to this field. Only used for legacy
    // (non system address) patrol mode. 
    // 
    // Bits[17:16], RW_LBV, default = 0x0
    //
    UINTX chnl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Contains the TAD rule of the last scrub issued. Can be written to specify the
    // next scrub address with STARTSCRUB. scrubaddresshi.ptl_sa_mode must be cleared
    // to 0 and then set back to 1 after STARTSCRUB is set for address written to take
    // effect. RESTRICTION: Patrol Scrubs must be disabled when writing to this field.
    // Only used system address patrol mode. 
    // 
    // Bits[22:20], RW_LBV, default = 0x0
    //
    UINTX tad_rule : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // 
    //             First TAD rule used for patrol address generation. Set to 0 to begin
    // generating system addresses for patrol at the lowest address mapped to the MC.
    //         
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX minimum_tad_rule : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // 
    //             Last TAD rule used for patrol address generation. Set to the maximum
    // valid TAD rule number used on the MC to generate system addresses for patrol up
    // to the maximum address mapped to the MC. 
    //         
    // 
    // Bits[30:28], RW_LB, default = 0x0
    //
    UINTX maximum_tad_rule : 3;
    //
    // Patrol runs in system address generation mode if patrol is enabled.  If this mode
    // bit is not set, patrol runs in legacy mode if patrol is enabled. 
    // 
    // Bits[31:31], RW_LBV, default = 0x1
    //
    UINTX ptl_sa_mode : 1;
  } Bits;
  UINTX Data;
} SCRUBADDRESSHI_MCMAIN_STRUCT;
#endif // ASM_INC

#define SCRUBCTL_MCMAIN_REG                               0x00000914
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reserved Unused. Scrub interval is now defined in PCU.
    // 
    // Bits[23:0], RW_LB, default = 0x0
    //
    UINTX scrubinterval : 24;
    //
    // When Set, the Patrol scrub engine will start from the address in the scrub address
    // registers. Once the scrub is issued this bit is reset. 
    // 
    // Bits[24:24], RW_LBV, default = 0x0
    //
    UINTX startscrub : 1;
    //
    // When Set, the patrol scrub engine will issue the address in the scrub address
    // registers only once and stop.  Software is responsible to turn off periodic patrol
    // before issuing patrol once.  No cross product of patrol once with PkgC is allowed.
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX issueonce : 1;
    //
    // When Set, the scrub address registers contain the last scrub address issued
    // 
    // Bits[26:26], RW_LBV, default = 0x0
    //
    UINTX scrubissued : 1;
    //
    // When stop_on_err is set, patrol will stop on error and set this bit.
    // Patrol will resume at the next address when this bit or stop_on_err is cleared
    // by BIOS and patrol scrub is still enabled by scrub_en. 
    // 
    // Bits[27:27], RW_LBV, default = 0x0
    //
    UINTX ptl_stopped : 1;
    //
    // Stop patrol scrub on poison or uncorrectable. On poison, patrol will log error
    // then stop. On uncorr, patrol will convert to poison (if enabled) then stop. 
    // This mode is meant to be used as part of memory migration flow. SMI is signalled
    // by default. 
    // 
    // Bits[28:28], RW_LB, default = 0x0
    //
    UINTX stop_on_err : 1;
    //
    // When stop_on_cmpl is enabled, patrol will stop at the end of the address range
    // and set this bit. 
    // Patrol will resume from beginning of address range when this bit or stop_on_cmpl
    // is cleared by BIOS and patrol scrub is still enabled by scrub_en. 
    // 
    // Bits[29:29], RW_LBV, default = 0x0
    //
    UINTX ptl_cmpl : 1;
    //
    // Stop patrol scrub at end of memory range. This mode is meant to be used as part
    // of memory migration flow.  
    //             SMI is signalled by default.
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX stop_on_cmpl : 1;
    //
    // Scrub Enable when set.
    //             Lock bit is the DISABLE_PATROL_SCRUB from the IMC_FUSE_DOWNLOAD register.
    //         
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX scrub_en : 1;
  } Bits;
  UINTX Data;
} SCRUBCTL_MCMAIN_STRUCT;
#endif // ASM_INC

#define SPAREINTERVAL_MCMAIN_REG                          0x0000091C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Normal operation duration. System requests will be serviced during this interval.
    // 
    // Bits[15:0], RW_LB, default = 0xC80
    //
    UINTX normopdur : 16;
    //
    // Sparing operation duration. System requests will be blocked during this interval
    // and only sparing copy operations will be serviced. 
    // 
    // Bits[28:16], RW_LB, default = 0x320
    //
    UINTX numspare : 13;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
  } Bits;
  UINTX Data;
} SPAREINTERVAL_MCMAIN_STRUCT;
#endif // ASM_INC

#define RASENABLES_MCMAIN_REG                             0x00000920
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Mirror mode enable. The channel mapping must be set up before this bit will have
    // an effect on IMC operation. This changes the error policy. 
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mirroren : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 31;
  } Bits;
  UINTX Data;
} RASENABLES_MCMAIN_STRUCT;
#endif // ASM_INC

#define SMISPARECTL_MCMAIN_REG                            0x00000924
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 15;
    //
    // SMI enable. Set to enable SMI signaling. Clear to disable SMI signaling.
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX intrpt_sel_smi : 1;
    //
    // (CMCI used as a proxy for NMI signaling). Set to enable NMI signaling. Clear to
    // disable NMI signaling. If both NMI and SMI enable bits are set then only SMI is
    // sent 
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX intrpt_sel_cmci : 1;
    //
    // Enable pin signaling. When set the interrupt is signaled via the err[0] pin to
    // get the attention of a BMC. 
    // 
    // Bits[17:17], RW_LB, default = 0x0
    //
    UINTX intrpt_sel_pin : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 14;
  } Bits;
  UINTX Data;
} SMISPARECTL_MCMAIN_STRUCT;
#endif // ASM_INC

#define LEAKY_BUCKET_CFG_MCMAIN_REG                       0x00000928
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is the lower order bit select mask of the two hot encoding threshold. The
    // value of this field specify the bit position of the mask: 
    // 00h: reserved
    // 01h: LEAKY_BUCKET_CNTR_LO bit 1, i.e. bit 12 of the full 53b counter
    // ...
    // 1Fh: LEAKY_BUCKET_CNTR_LO bit 31, i.e. bit 42 of the full 53b counter
    // 20h: LEAKY_BUCKET_CNTR_HI bit 0, i.e. bit 43 of the full 53b counter
    // ...
    // 29h: LEAKY_BUCKET_CNTR_HI bit 9, i.e. bit 52 of the full 53b counter
    // 2Ah - 3F: reserved
    // When both counter bits selected by the LEAKY_BKT_CFG_HI and LEAKY_BKT_CFG_LO are
    // set, the 53b leaky bucket counter will be reset and the logic will generate a
    // LEAK pulse to decrement the correctable error counter by 1. 
    // MRC BIOS must program this register to any non-zero value before switching to
    // NORMAL mode. 
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX leaky_bkt_cfg_lo : 6;
    //
    // This is the higher order bit select mask of the two hot encoding threshold. The
    // value of this field specify the bit position of the mask: 
    // 00h: reserved
    // 01h: LEAKY_BUCKET_CNTR_LO bit 1, i.e. bit 12 of the full 53b counter
    // ...
    // 1Fh: LEAKY_BUCKET_CNTR_LO bit 31, i.e. bit 42 of the full 53b counter
    // 20h: LEAKY_BUCKET_CNTR_HI bit 0, i.e. bit 43 of the full 53b counter
    // ...
    // 29h: LEAKY_BUCKET_CNTR_HI bit 9, i.e. bit 52 of the full 53b counter
    // 2Ah - 3F: reserved
    // When both counter bits selected by the LEAKY_BKT_CFG_HI and LEAKY_BKT_CFG_LO are
    // set, the 53b leaky bucket counter will be reset and the logic will generate a
    // LEAK pulse to decrement the correctable error counter by 1. 
    // MRC BIOS must program this register to any non-zero value before switching to
    // NORMAL mode. 
    // 
    // Bits[11:6], RW_LB, default = 0x0
    //
    UINTX leaky_bkt_cfg_hi : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 20;
  } Bits;
  UINTX Data;
} LEAKY_BUCKET_CFG_MCMAIN_STRUCT;
#endif // ASM_INC

#define LEAKY_BUCKET_CNTR_LO_MCMAIN_REG                   0x00000930
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is the lower half of the leaky bucket counter. The full counter is actually
    // a 53b "DCLK" counter. There is a least significant 11b of the 53b counter is not
    // captured in CSR. The carry "strobe" from the not-shown least significant 11b counter
    // will trigger this 42b counter pair to count. The 42b counter-pair is compared
    // with the two-hot encoding threshold specified by the LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO
    // pair. When the counter bits specified by the LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO
    // are both set, the 53b counter is reset and the leaky bucket logic will generate
    // a LEAK strobe last for 1 DCLK. 
    // This counter is subject to PSMI quiescense flow, i.e. pause at quiescense and
    // resume at PSMI-wipe. This register is defined as RW-V to enable PSMI handler to
    // force the counter to a known value during PSMI process. 
    // 
    // Bits[31:0], RW_V, default = 0x0
    //
    UINTX leaky_bkt_cntr_lo : 32;
  } Bits;
  UINTX Data;
} LEAKY_BUCKET_CNTR_LO_MCMAIN_STRUCT;
#endif // ASM_INC

#define LEAKY_BUCKET_CNTR_HI_MCMAIN_REG                   0x00000934
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is the upper half of the leaky bucket counter. The full counter is actually
    // a 53b "DCLK" counter. There is a least significant 11b of the 53b counter is not
    // captured in CSR. The carry "strobe" from the not-shown least significant 11b counter
    // will trigger this 42b counter pair to count. The 42b counter-pair is compared
    // with the two-hot encoding threshold specified by the LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO
    // pair. When the counter bits specified by the LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO
    // are both set, the 53b counter is reset and the leaky bucket logic will generate
    // a LEAK strobe last for 1 DCLK. 
    // This counter is subject to PSMI quiescense flow, i.e. pause at quiescense and
    // resume at PSMI-wipe. This register is defined as RW-V to enable PSMI handler to
    // force the counter to a known value during PSMI process. 
    // 
    // Bits[9:0], RW_V, default = 0x0
    //
    UINTX leaky_bkt_cntr_hi : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 22;
  } Bits;
  UINTX Data;
} LEAKY_BUCKET_CNTR_HI_MCMAIN_STRUCT;
#endif // ASM_INC

#define MAXMTR_MCMAIN_REG                                 0x00000944
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Max number of rows.
    // 000: 2^12 rows
    // 001: 2^13 rows
    // 010: 2^14 rows
    // 011: 2^15 rows
    // 100: 2^16 rows
    // 101: 2^17 rows
    // 110: 2^18 rows
    // Others: reserved
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINTX maxnumrow : 3;
    //
    // Max number of columns.
    // 00: 2^10 columns
    // 01: 2^11 columns
    // 10: 2^12 columns
    // 11: 2^13 columns (Reserved)
    // 
    // Bits[10:9], RW, default = 0x0
    //
    UINTX maxnumcol : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 21;
  } Bits;
  UINTX Data;
} MAXMTR_MCMAIN_STRUCT;
#endif // ASM_INC

#define SCRUBADDRESS2LO_MCMAIN_REG                        0x00000950
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contains bits 37:6 of the base system address of the last scrub issued. This is
    // the base of the current system address. Can be written to specify the next scrub
    // address with STARTSCRUB. System address in scrubaddresslo/hi also need to be programmed
    // in system address mode for the programmed address to take effect. scrubaddresshi.ptl_sa_mode
    // must be cleared to 0 and then set back to 1 after STARTSCRUB is set for address
    // written to take effect. RESTRICTIONS: Patrol Scrubs must be disabled when writing
    // to this field. Only used system address patrol mode. 
    // 
    // Bits[31:0], RW_LBV, default = 0x0
    //
    UINTX baseadd : 32;
  } Bits;
  UINTX Data;
} SCRUBADDRESS2LO_MCMAIN_STRUCT;
#endif // ASM_INC

#define SCRUBADDRESS2HI_MCMAIN_REG                        0x00000954
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Contains bits 46:38 of the base system address of the last scrub issued. This
    // is the base of the current system address. Can be written to specify the next
    // scrub address with STARTSCRUB. System address in scrubaddresslo/hi also need to
    // be programmed in system address mode for the programmed address to work properly.
    // scrubaddresshi.ptl_sa_mode must be cleared to 0 and then set back to 1 after STARTSCRUB
    // is set for address written to take effect. RESTRICTIONS: Patrol Scrubs must be
    // disabled when writing to this field. Only used system address patrol mode. 
    // 
    // Bits[8:0], RW_LBV, default = 0x0
    //
    UINTX baseaddhi : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
  } Bits;
  UINTX Data;
} SCRUBADDRESS2HI_MCMAIN_STRUCT;
#endif // ASM_INC

#define EMCALTCTL_MCMAIN_REG                              0x0000095C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SMI enable. Set to enable SMI signaling for each correctable error. Clear to disable
    // SMI signaling and signal CMCI when correctable error threshold is reached. 
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX emcalt_sel_smi : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} EMCALTCTL_MCMAIN_STRUCT;
#endif // ASM_INC

#define LBITMAP_MCMAIN_REG                                0x00000960
#ifndef ASM_INC
typedef union {
  struct {
    //
    // selects which bit to set in the one-hot payload of the Global Error Message that
    // iMC sends to UBOX.  
    // 
    // Bits[4:0], RW, default = 0x8
    //
    UINTX bit_select : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 27;
  } Bits;
  UINTX Data;
} LBITMAP_MCMAIN_STRUCT;
#endif // ASM_INC

#define VIRALCTL_MCMAIN_REG                               0x00000964
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When set to 1, clears viral level signal in MC. Clear to 0 to allow viral signal
    // to be set again. 
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX viral_clear : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Viral test bit for channel 0.
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX viral_ch0 : 1;
    //
    // Viral test bit for channel 1.
    // 
    // Bits[5:5], RW_LB, default = 0x0
    //
    UINTX viral_ch1 : 1;
    //
    // Viral test bit for channel 2.
    // 
    // Bits[6:6], RW_LB, default = 0x0
    //
    UINTX viral_ch2 : 1;
    //
    // Viral test bit for channel 3.
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX viral_ch3 : 1;
  } Bits;
  UINTX Data;
} VIRALCTL_MCMAIN_STRUCT;
#endif // ASM_INC

#define HOTPLUG_MCMAIN_REG                                0x00000968
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Status bit for hot plug. BIOS to write this bit to indicate to MC that it is currently
    // in the memory hot add/ hot remove flow. 
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX active : 1;
    //
    // This bit will be 1 when all WDB entries are drained on all channels, 0 when any
    // WDB has valid entries. 
    // 
    // Bits[1:1], RO_V, default = 0x0
    //
    UINTX wpqdrained : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
  } Bits;
  UINTX Data;
} HOTPLUG_MCMAIN_STRUCT;
#endif // ASM_INC

#define SCRUBMASK_MCMAIN_REG                              0x0000096C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Patrol scrub channel mask, one bit per channel. Setting this bit will skip patrol
    // scrub on that channel according to the all_ranks and chx_rank fields. 
    // lock bit is the scrub_en in scrubctl register.
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX ch_mask : 4;
    //
    // Setting this bit will skip all ranks on the channel when the channel mask is set.
    // Else it will skip the rank specified on chx_rank. 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX all_ranks : 4;
    //
    // Rank to skip for channel 0 when all_ranks is set to 0.
    // 
    // Bits[10:8], RW_L, default = 0x0
    //
    UINTX ch0_rank : 3;
    //
    // Rank to skip for channel 1 when all_ranks is set to 0.
    // 
    // Bits[13:11], RW_L, default = 0x0
    //
    UINTX ch1_rank : 3;
    //
    // Rank to skip for channel 2 when all_ranks is set to 0.
    // 
    // Bits[16:14], RW_L, default = 0x0
    //
    UINTX ch2_rank : 3;
    //
    // Rank to skip for channel 3 when all_ranks is set to 0.
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX ch3_rank : 3;
    //
    // N/A
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX link_fail : 4;
    //
    // When set to 1, patrol fsm will not stop if ECC error flow is on.
    // 
    // Bits[24:24], RW_L, default = 0x0
    //
    UINTX no_stop_on_ecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} SCRUBMASK_MCMAIN_STRUCT;
#endif // ASM_INC

#define SPARING_CONTROL_MCMAIN_REG                        0x00000970
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Spare enable when set to 1. Hardware clears this bit after the sparing completion.
    // 
    // Bits[0:0], RW_LBV, default = 0x0
    //
    UINTX spare_enable : 1;
    //
    // 
    //                   Setting this bit will cause sparing engine to be run in reverse
    // (move from virtual lockstep back to independent) when sparing has been started
    // via the spare_enable bit. 
    //                   Expected usage models are upgrading a region failure from bank
    // to rank and post-silicon testing  
    //               
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX reverse : 1;
    //
    // 
    //                   This bit causes the sparing copy to be rank sparing when sparing
    // copy has been started via the spare_enable bit. 
    // This bit is mutually exclusive with the adddc_sparing and sddc_sparing bits.
    //                   This register is locked by the DISABLE_RANK_SPARING bit from
    // IMC_FUSE_DOWNLOAD register. 
    //               
    // 
    // Bits[2:2], RW_LB, default = 0x0
    //
    UINTX rank_sparing : 1;
    //
    // 
    //                   This bit causes the sparing copy to be ADDDC sparing when sparing
    // copy has been started via the spare_enable bit. 
    //                   This bit is mutually exclusive with the rank_sparing and sddc_sparing
    // bits. 
    //                   This register is locked by the DISABLE_ADDDC_SPARING bit from
    // IMC_FUSE_DOWNLOAD register. 
    //               
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX adddc_sparing : 1;
    //
    // 
    //                   This bit causes the sparing copy to transition ECC to the SDDC
    // state when sparing copy has been started via the spare_enable bit. 
    //                   This bit is mutually exclusive with the adddc_sparing and rank_sparing
    // bits. 
    //                   This register is locked by the DISABLE_SDDC bit from IMC_FUSE_DOWNLOAD
    // register. 
    //               
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX sddc_sparing : 1;
    //
    // 
    //                   Since there is only one sparing copy engine for all channels,
    // this field selects the channel for the sparing copy operation. 
    //                   00 = channel 0 is selected for the sparing copy operation
    //                   01 = channel 1 is selected for the sparing copy operation
    //                   10 = channel 2 is selected for the sparing copy operation; 
    // reserved on EX 
    //                   11 = reserved
    //               
    // 
    // Bits[6:5], RW_LB, default = 0x0
    //
    UINTX channel_select : 2;
    //
    // 
    //                       This field selects the granularity for the sparing copy
    // operation: 
    //                       00=Bank
    //                       01=Rank
    //                       1X=Reserved
    //                   
    // 
    // Bits[8:7], RW_LB, default = 0x0
    //
    UINTX region_size : 2;
    //
    // 
    //                       When set, this iMC is being used in static Virtual Lockstep
    // mode. 
    //                       ADDDC sparing flow may not be initiated when this bit is
    // set, though rank sparing or sddc sparing may still be used. 
    //                       This bit should be set and locked before memory initialization.
    //                   
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX virtual_lockstep_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 
    //                       First TAD rule used for spare address generation.
    // 		      Set to 0 to begin generating system addresses for sparing
    // 		      at the lowest address mapped to the MC.
    //                   
    // 
    // Bits[14:12], RW_LB, default = 0x0
    //
    UINTX minimum_tad_rule : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //                       Last TAD rule used for spare address generation.
    // 		      Set to the maximum valid TAD rule number used on the MC
    // 		      to generate system addresses for sparing up to the maximum
    // 		      address mapped to the MC.
    //                   
    // 
    // Bits[18:16], RW_LB, default = 0x0
    //
    UINTX maximum_tad_rule : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 13;
  } Bits;
  UINTX Data;
} SPARING_CONTROL_MCMAIN_STRUCT;
#endif // ASM_INC

#define SPARING_CONTROL_SOURCE_MCMAIN_REG                 0x00000974
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                          The value in this field is encoded (Chip Selects are
    // normally 1-hot), corresponding to CS0-CS7.   
    //                          For SDDC or rank sparing this field specifies the source
    // rank (Chip Select, CS0-CS7) for the sparing copy.   
    //                          For ADDDC, this field specifies the failed rank for the
    // sparing copy.   
    //                       
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX source_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //                           For ADDDC used at the bank granularity (region_size=bank),
    // this field specifies the subrank (C0-C2) to match for the sparing copy. 
    //                       
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX source_c : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //                           For ADDDC used at the bank granularity (region_size=bank),
    // this field specifies the bank address (BA0-BA1) to match for the sparing copy.
    //                       
    // 
    // Bits[9:8], RW_LB, default = 0x0
    //
    UINTX source_ba : 2;
    //
    // 
    //                           For ADDDC used at the bank granularity (region_size=bank),
    // this field specifies the bank group (BG0-BG1) to match for the sparing copy. 
    //                       
    // 
    // Bits[11:10], RW_LB, default = 0x0
    //
    UINTX source_bg : 2;
    //
    //  Reserved for future use.  
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX reserved : 4;
    //
    // 
    //                          The enable bit for buddy_cs field. This enable bit is
    // only set for SDDC sparing in x8 mode, or SDDC sparing after ADDDC is enabled.
    //                       
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX buddy_cs_en : 1;
    //
    // 
    //                          The value in this field is encoded (Chip Selects are
    // normally 1-hot), corresponding to CS0-CS7.   
    //                          This field is only used for SDDC sparing in x8 mode,
    // or SDDC sparing after ADDDC is enabled. 
    //                          This field specifies the primary rank (Chip Select, CS0-CS7)
    // of an ADDDC transaction whose buddy is in the rank represented by source_cs. 
    //                          This field is used only if buddy_cs_en bit is set to
    // 1. 
    //                       
    // 
    // Bits[19:17], RW_LB, default = 0x0
    //
    UINTX buddy_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 12;
  } Bits;
  UINTX Data;
} SPARING_CONTROL_SOURCE_MCMAIN_STRUCT;
#endif // ASM_INC

#define SPARING_CONTROL_DESTINATION_MCMAIN_REG            0x00000978
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                           The value in this field is encoded (Chip Selects are
    // normally 1-hot), corresponding to CS0-CS7.   
    //                           For rank sparing this field specifies the destination
    // rank (Chip Select, CS0-CS7) for the sparing copy.   
    // 
    //                           For ADDDC, this field specifies the nonfailed rank for
    // the sparing copy.   
    //                           For ADDDC at the bank granularity (region_size = bank),
    // this field must be equal to the source_cs.   
    //                           For ADDDC at the rank granularity (region_size = rank)
    // in EP bit 0 of this field should always be the inverse of bit 0 of SPARING_CONTROL_SOURCE.source_cs
    // except for single rank DIMMs where instead bit 1 of the source_cs should be inverted.
    // 
    // 
    //                      
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX destination_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //                           This field is unused for rank sparing and SDDC sparing.
    //                           For ADDDC used at the bank granularity, this field specifies
    // the subrank (C2-C0) of the nonfailed region for the sparing copy. 
    //                           For ADDDC on EP at the bank granularity, this register
    // is not used.  Instead, the destination_c (nonfailed subrank) is equal to the source_c
    // (failed subrank). 
    //                      
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX destination_c : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //                           This field is unused for rank sparing and SDDC sparing.
    //                           For ADDDC used at the bank granularity, this field specifies
    // the bank of the nonfailed region for the sparing copy. 
    //                           For ADDDC on EP at the bank granularity, this register
    // is not used.  Instead, the destination_ba (nonfailed bank address) is equal to
    // the source_ba (failed bank address). 
    // 
    //                      
    // 
    // Bits[9:8], RW_LB, default = 0x0
    //
    UINTX destination_ba : 2;
    //
    // 
    //                           This field is unused for rank sparing and SDDC sparing.
    // For ADDDC used at the bank granularity, this field specifies bank of the nonfailed
    // region for the sparing copy. 
    // For ADDDC on EP at the bank granularity, this register is not used.  Instead,
    // the destination_bg (nonfailed bank group) is equal to the source_bg (primary bank)
    // with bank group bit 0 inverted (~BG0). 
    //                      
    // 
    // Bits[11:10], RW_LB, default = 0x0
    //
    UINTX destination_bg : 2;
    //
    //  Reserved for future use.  
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX reserved : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 16;
  } Bits;
  UINTX Data;
} SPARING_CONTROL_DESTINATION_MCMAIN_STRUCT;
#endif // ASM_INC

#define SPARING_PATROL_STATUS_MCMAIN_REG                  0x0000097C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                   This bit indicates that the sparing copy operation is in progress.
    //  
    //                   This bit is set by hardware once the sparing copy has started.
    // It is cleared by hardware once the copy operation is complete or fails. 
    //               
    // 
    // Bits[0:0], RW_LBV, default = 0x0
    //
    UINTX copy_in_progress : 1;
    //
    // 
    //                   Sparing copy operation complete. Set by hardware once operation
    // is complete.  
    //                   This bit is cleared by hardware when a new operation is enabled.
    //               
    // 
    // Bits[1:1], RW_LBV, default = 0x0
    //
    UINTX copy_complete : 1;
    //
    // 
    //                   All memory has been scrubbed. Hardware sets this bit each time
    // the patrol engine steps through all memory locations. If software wants to monitor
    // 0 to 1 transition after the bit has been set, the software will need to clear
    // the bit by writing a one to clear this bit in order to distinguish the next patrol
    // scrub completion. Clearing the bit will not affect the patrol scrub operation.
    //               
    // 
    // Bits[2:2], RW1C, default = 0x0
    //
    UINTX patrol_complete : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 29;
  } Bits;
  UINTX Data;
} SPARING_PATROL_STATUS_MCMAIN_STRUCT;
#endif // ASM_INC

#define IMC0_POISON_SOURCE_MCMAIN_REG                     0x00000980
#ifndef ASM_INC
typedef union {
  struct {
    //
    // System address for poison source
    // 
    // Bits[39:0], RWS_LB, default = 0x0
    //
    UINTX address : 40;
    //
    // This bit will be 1 when poison is due patrol uncorectable error.
    // 
    // Bits[40:40], RWS_LB, default = 0x0
    //
    UINTX patrol_err : 1;
    //
    // This bit will be 1 when poison is due spare copy uncorectable error.
    // 
    // Bits[41:41], RWS_LB, default = 0x0
    //
    UINTX spare_err : 1;
    //
    // This bit will be 1 when poison is due WDB parity error.
    // 
    // Bits[42:42], RWS_LB, default = 0x0
    //
    UINTX wdb_parity_err : 1;
    //
    // This bit will be 1 when poison is due DDRT VDB parity error.
    // 
    // Bits[43:43], RWS_LB, default = 0x0
    //
    UINTX vdb_parity_err : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[60:44], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 17;
    //
    // Set this bit to 1 to enable logging in this register.
    // 
    // Bits[61:61], RWS_LB, default = 0x0
    //
    UINTX en : 1;
    //
    // When set to 1, indicates new poison source is detected when information logged
    // in this register is still valid. 
    // 
    // Bits[62:62], RWS_LB, default = 0x0
    //
    UINTX overflow : 1;
    //
    // When set to 1, a poison source is logged in this register and no new error source
    // can be logged. Software clears this bit to 0 to re-enable logging. 
    // 
    // Bits[63:63], RWS_LB, default = 0x0
    //
    UINTX valid : 1;
  } Bits;
  UINTX Data;
} IMC0_POISON_SOURCE_MCMAIN_STRUCT;
#endif // ASM_INC

#define IMC1_POISON_SOURCE_MCMAIN_REG                     0x00000988
#ifndef ASM_INC
typedef union {
  struct {
    //
    // System address for poison source
    // 
    // Bits[39:0], RWS_LB, default = 0x0
    //
    UINTX address : 40;
    //
    // This bit will be 1 when poison is due patrol uncorectable error.
    // 
    // Bits[40:40], RWS_LB, default = 0x0
    //
    UINTX patrol_err : 1;
    //
    // This bit will be 1 when poison is due spare copy uncorectable error.
    // 
    // Bits[41:41], RWS_LB, default = 0x0
    //
    UINTX spare_err : 1;
    //
    // This bit will be 1 when poison is due WDB parity error.
    // 
    // Bits[42:42], RWS_LB, default = 0x0
    //
    UINTX wdb_parity_err : 1;
    //
    // This bit will be 1 when poison is due DDRT VDB parity error.
    // 
    // Bits[43:43], RWS_LB, default = 0x0
    //
    UINTX vdb_parity_err : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[60:44], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 17;
    //
    // Set this bit to 1 to enable logging in this register.
    // 
    // Bits[61:61], RWS_LB, default = 0x0
    //
    UINTX en : 1;
    //
    // When set to 1, indicates new poison source is detected when information logged
    // in this register is still valid. 
    // 
    // Bits[62:62], RWS_LB, default = 0x0
    //
    UINTX overflow : 1;
    //
    // When set to 1, a poison source is logged in this register and no new error source
    // can be logged. Software clears this bit to 0 to re-enable logging. 
    // 
    // Bits[63:63], RWS_LB, default = 0x0
    //
    UINTX valid : 1;
  } Bits;
  UINTX Data;
} IMC1_POISON_SOURCE_MCMAIN_STRUCT;
#endif // ASM_INC

#define IMC2_POISON_SOURCE_MCMAIN_REG                     0x00000990
#ifndef ASM_INC
typedef union {
  struct {
    //
    // System address for poison source
    // 
    // Bits[39:0], RWS_LB, default = 0x0
    //
    UINTX address : 40;
    //
    // This bit will be 1 when poison is due patrol uncorectable error.
    // 
    // Bits[40:40], RWS_LB, default = 0x0
    //
    UINTX patrol_err : 1;
    //
    // This bit will be 1 when poison is due spare copy uncorectable error.
    // 
    // Bits[41:41], RWS_LB, default = 0x0
    //
    UINTX spare_err : 1;
    //
    // This bit will be 1 when poison is due WDB parity error.
    // 
    // Bits[42:42], RWS_LB, default = 0x0
    //
    UINTX wdb_parity_err : 1;
    //
    // This bit will be 1 when poison is due DDRT VDB parity error.
    // 
    // Bits[43:43], RWS_LB, default = 0x0
    //
    UINTX vdb_parity_err : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[60:44], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 17;
    //
    // Set this bit to 1 to enable logging in this register.
    // 
    // Bits[61:61], RWS_LB, default = 0x0
    //
    UINTX en : 1;
    //
    // When set to 1, indicates new poison source is detected when information logged
    // in this register is still valid. 
    // 
    // Bits[62:62], RWS_LB, default = 0x0
    //
    UINTX overflow : 1;
    //
    // When set to 1, a poison source is logged in this register and no new error source
    // can be logged. Software clears this bit to 0 to re-enable logging. 
    // 
    // Bits[63:63], RWS_LB, default = 0x0
    //
    UINTX valid : 1;
  } Bits;
  UINTX Data;
} IMC2_POISON_SOURCE_MCMAIN_STRUCT;
#endif // ASM_INC

#define SPARE_FSM_STATE_MCMAIN_REG                        0x00000998
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current encoded state of spare copy FSM
    // 
    // Bits[4:0], RO_V, default = 0x1F
    //
    UINTX spr_current_state : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Previous encoded state of spare copy FSM
    // 
    // Bits[12:8], RO_V, default = 0x1F
    //
    UINTX spr_previous_state : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Current encoded state of system address FSM for spare copy
    // 
    // Bits[19:16], RO_V, default = 0xF
    //
    UINTX ssa_current_state : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
    //
    // Previous encoded state of system address FSM for spare copy
    // 
    // Bits[27:24], RO_V, default = 0xF
    //
    UINTX ssa_previous_state : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 4;
  } Bits;
  UINTX Data;
} SPARE_FSM_STATE_MCMAIN_STRUCT;
#endif // ASM_INC

#define PATROL_FSM_STATE_MCMAIN_REG                       0x0000099C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current encoded state of patrol scrub FSM
    // 
    // Bits[4:0], RO_V, default = 0x1F
    //
    UINTX pat_current_state : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Previous encoded state of patrol scrub FSM
    // 
    // Bits[12:8], RO_V, default = 0x1F
    //
    UINTX pat_previous_state : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Current encoded state of system address FSM for patrol scrub
    // 
    // Bits[19:16], RO_V, default = 0xF
    //
    UINTX psa_current_state : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
    //
    // Previous encoded state of system address FSM for patrol scrub
    // 
    // Bits[27:24], RO_V, default = 0xF
    //
    UINTX psa_previous_state : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 4;
  } Bits;
  UINTX Data;
} PATROL_FSM_STATE_MCMAIN_STRUCT;
#endif // ASM_INC

#define SPARING_2LM_ADDR0LO_MCMAIN_REG                    0x000009A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bits 37:6 of sparing address 0. Software should program the starting address and
    // hardware will update when spare address changes. 
    // 
    // Bits[31:0], RW_LBV, default = 0x0
    //
    UINTX curr_addr : 32;
  } Bits;
  UINTX Data;
} SPARING_2LM_ADDR0LO_MCMAIN_STRUCT;
#endif // ASM_INC

#define SPARING_2LM_ADDR0HI_MCMAIN_REG                    0x000009A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bits 45:38 of sparing address 0. Software should program the starting address
    // and hardware will update when spare address changes. 
    // 
    // Bits[7:0], RW_LBV, default = 0x0
    //
    UINTX curr_addr : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 24;
  } Bits;
  UINTX Data;
} SPARING_2LM_ADDR0HI_MCMAIN_STRUCT;
#endif // ASM_INC

#define SPARING_2LM_ADDR1LO_MCMAIN_REG                    0x000009A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bits 37:6 of sparing address 1. Software should program the starting address and
    // hardware will update when spare address changes. 
    // 
    // Bits[31:0], RW_LBV, default = 0x0
    //
    UINTX curr_addr : 32;
  } Bits;
  UINTX Data;
} SPARING_2LM_ADDR1LO_MCMAIN_STRUCT;
#endif // ASM_INC

#define SPARING_2LM_ADDR1HI_MCMAIN_REG                    0x000009AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bits 45:38 of sparing address 1. Software should program the starting address
    // and hardware will update when spare address changes. 
    // 
    // Bits[7:0], RW_LBV, default = 0x0
    //
    UINTX curr_addr : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 24;
  } Bits;
  UINTX Data;
} SPARING_2LM_ADDR1HI_MCMAIN_STRUCT;
#endif // ASM_INC

#define SPARING_2LM_ADDR2LO_MCMAIN_REG                    0x000009B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bits 37:6 of sparing address 2. Software should program the starting address and
    // hardware will update when spare address changes. 
    // 
    // Bits[31:0], RW_LBV, default = 0x0
    //
    UINTX curr_addr : 32;
  } Bits;
  UINTX Data;
} SPARING_2LM_ADDR2LO_MCMAIN_STRUCT;
#endif // ASM_INC

#define SPARING_2LM_ADDR2HI_MCMAIN_REG                    0x000009B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bits 45:38 of sparing address 2. Software should program the starting address
    // and hardware will update when spare address changes. 
    // 
    // Bits[7:0], RW_LBV, default = 0x0
    //
    UINTX curr_addr : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 24;
  } Bits;
  UINTX Data;
} SPARING_2LM_ADDR2HI_MCMAIN_STRUCT;
#endif // ASM_INC

#define SPARING_2LM_CONTROL_MCMAIN_REG                    0x000009B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bits 45:26 to represent near memory size. Minimum size is 64 MB. NM size must
    // be power of 2. 
    // 
    // Bits[19:0], RW_LB, default = 0x0
    //
    UINTX nm_size : 20;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 11;
    //
    // Set to 1 to enable system address generation use addresses from these 6 sparing_2lm_control
    // registers. This bit should only be set to 1 when fast div-3 is used and ADDDC
    // spare copy enabled. 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX enable : 1;
  } Bits;
  UINTX Data;
} SPARING_2LM_CONTROL_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCMAINDBGPRESEL0_MCMAIN_REG                       0x00000A40
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This selects which set of signals will be driven on lane 0 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[4:0], RWS_L, default = 0x0
    //
    UINTX ln0dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // This selects which set of signals will be driven on lane 1 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[12:8], RWS_L, default = 0x0
    //
    UINTX ln1dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // This selects which set of signals will be driven on lane 2 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[20:16], RWS_L, default = 0x0
    //
    UINTX ln2dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // This selects which set of signals will be driven on lane 3 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[28:24], RWS_L, default = 0x0
    //
    UINTX ln3dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
  } Bits;
  UINTX Data;
} MCMAINDBGPRESEL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCMAINDBGPRESEL1_MCMAIN_REG                       0x00000A44
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This selects which set of signals will be driven on lane 4 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[4:0], RWS_L, default = 0x0
    //
    UINTX ln4dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // This selects which set of signals will be driven on lane 5 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[12:8], RWS_L, default = 0x0
    //
    UINTX ln5dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // This selects which set of signals will be driven on lane 6 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[20:16], RWS_L, default = 0x0
    //
    UINTX ln6dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // This selects which set of signals will be driven on lane 7 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[28:24], RWS_L, default = 0x0
    //
    UINTX ln7dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
  } Bits;
  UINTX Data;
} MCMAINDBGPRESEL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCMAINDBGSEL_MCMAIN_REG                           0x00000A60
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RWS_L, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RWS_L, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RWS_L, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RWS_L, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RWS_L, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCMAINDBGSEL_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCDBGBUSMATCH_MCMAIN_REG                          0x00000A64
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The value specified here is matched with data on the debug bus to generate a trigger.
    // 
    // Bits[31:0], RWS_L, default = 0x0
    //
    UINTX dbgbusmatchval : 32;
  } Bits;
  UINTX Data;
} MCDBGBUSMATCH_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCDBGBUSMASK_MCMAIN_REG                           0x00000A68
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This specifies which match results will be used to generate the trigger. A value
    // of 1 in a bit position will mask the match for that bit. A value of all 1's means
    // that match will always be true. 
    // 
    // Bits[31:0], RWS_L, default = 0x0
    //
    UINTX dbgbusmaskval : 32;
  } Bits;
  UINTX Data;
} MCDBGBUSMASK_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCDBGBUSCNTRL0_MCMAIN_REG                         0x00000A6C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay pipe stages for the Lane0 match value. Used for deskewing data on the lanes.
    // 
    // Bits[3:0], RWS_L, default = 0x0
    //
    UINTX ln0delay : 4;
    //
    // Delay pipe stages for the Lane1 match value. Used for deskewing data on the lanes.
    // 
    // Bits[7:4], RWS_L, default = 0x0
    //
    UINTX ln1delay : 4;
    //
    // Delay pipe stages for the Lane2 match value. Used for deskewing data on the lanes.
    // 
    // Bits[11:8], RWS_L, default = 0x0
    //
    UINTX ln2delay : 4;
    //
    // Delay pipe stages for the Lane3 match value. Used for deskewing data on the lanes.
    // 
    // Bits[15:12], RWS_L, default = 0x0
    //
    UINTX ln3delay : 4;
    //
    // Delay pipe stages for the Lane4 match value. Used for deskewing data on the lanes.
    // 
    // Bits[19:16], RWS_L, default = 0x0
    //
    UINTX ln4delay : 4;
    //
    // Delay pipe stages for the Lane5 match value. Used for deskewing data on the lanes.
    // 
    // Bits[23:20], RWS_L, default = 0x0
    //
    UINTX ln5delay : 4;
    //
    // Delay pipe stages for the Lane6 match value. Used for deskewing data on the lanes.
    // 
    // Bits[27:24], RWS_L, default = 0x0
    //
    UINTX ln6delay : 4;
    //
    // Delay pipe stages for the Lane7 match value. Used for deskewing data on the lanes.
    // 
    // Bits[31:28], RWS_L, default = 0x0
    //
    UINTX ln7delay : 4;
  } Bits;
  UINTX Data;
} MCDBGBUSCNTRL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCDBGBUSCNTRL1_MCMAIN_REG                         0x00000A70
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Specifies if the final Match output is logical AND or OR of all individual matches.
    // 0: Logically OR all match outputs
    // 1: Logically AND all match outputs.
    // 
    // Bits[0:0], RWS_L, default = 0x1
    //
    UINTX dbgbusmatchand : 1;
    //
    // Invert the final match result.
    // 0: Do not invert.
    // 1: Invert the final match result.
    // 
    // Bits[1:1], RWS_L, default = 0x0
    //
    UINTX matchinv : 1;
    //
    // Select between regulat match and Sequencer output.
    // 0: Select Match/Mask result
    // 1: Select sequencer output
    // 
    // Bits[2:2], RWS_L, default = 0x0
    //
    UINTX seqtrigsel : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // This bit will enable capture in snapshot register.
    // 0: Snapshot register disable
    // 1: Snapshot register enable
    // 
    // Bits[8:8], RWS_L, default = 0x0
    //
    UINTX dbssen : 1;
    //
    // Setting this bit will put the register in coverage mode. The register bits are
    // updated to 1 when trigger selected by the DBSSTrig is asserted and the corresponding
    // bit on the debug is 1. 
    // 0: Capture on the first rising edge of the selected trigger. All subsequent triggers
    // are ignored. 
    // 1: Capture as long as the trigger is asserted.
    // 
    // Bits[9:9], RWS_L, default = 0x0
    //
    UINTX dbssmode : 1;
    //
    // Setting this bit will clear the snapshot register and the trigger so that another
    // snapshot can occur. 
    // 0: Do not clear.
    // 1: Clear all.
    // 
    // Bits[10:10], RWS_L, default = 0x0
    //
    UINTX dbssclr : 1;
    //
    // Select the trigger source for the snapshot register
    // 000: MBP_OUT[0]
    // 001: MBP_OUT[1]
    // 111: Immediate trigger.
    // others: reserved
    // If DBSSMODE is 0 then it will enable one snapshot of the debug bus. If DBSSMODE
    // is 1 then the snapshot register will be continuously updated. 
    // 
    // Bits[13:11], RWS_L, default = 0x0
    //
    UINTX dbsstrig : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // This will enable the debug bus. Can be used to gate clocks for all Debug flops.
    // This should really be RWS-L but the tool is not allowing me to do that.
    // 
    // Bits[15:15], RWS_L, default = 0x0
    //
    UINTX dbgbusen : 1;
  } Bits;
  UINTX Data;
} MCDBGBUSCNTRL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCDBGBUSCNTRL2_MCMAIN_REG                         0x00000A72
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Setting this bit enables the sequencer. It will assert the trigger out (SeqSt1En
    // is not set) or transition to state 1 (SeqSt1En is set) when a match is asserted.
    // 0: Sequencer disabled.
    // 1: Sequencer enabled.
    // 
    // Bits[0:0], RWS_L, default = 0x0
    //
    UINTX seqen : 1;
    //
    // Setting this bit enables the transition from state 0 to state 1 when a match is
    // true. It will assert the trigger out (SeqSt2En is not set) or transition to state
    // 1 (SeqSt2En is set) when a match is asserted. 
    // 0: Disable transition to State 1.
    // 1: Enable transition to State 1.
    // 
    // Bits[1:1], RWS_L, default = 0x0
    //
    UINTX seqst1en : 1;
    //
    // Setting this bit enables the transition from state 1 to state 2 when a match is
    // true. It will assert the trigger out when a match is asserted and transition back
    // to state 0. 
    // 0: Disable transition to State 2.
    // 1: Enable transition to State 2.
    // 
    // Bits[2:2], RWS_L, default = 0x0
    //
    UINTX seqst2en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // The sequencer state machine waits for this many clock cycles in any state before
    // transitioning back to state 0. 
    // 
    // Bits[15:4], RWS_L, default = 0x0
    //
    UINTX seqtmoutval : 12;
  } Bits;
  UINTX Data;
} MCDBGBUSCNTRL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCDBGBUSCNTRL3_MCMAIN_REG                         0x00000A74
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Mask for deciding which lane matcheswill be used by Sequncer in state 0 to transition
    // to next state. A 1 in a bit position masks that match value from the decision.
    // If all bits are set to 1, the sequencer will transition to next state immediately.
    // 
    // Bits[7:0], RWS_L, default = 0x0
    //
    UINTX st0mask : 8;
    //
    // Mask for deciding which lane matcheswill be used by Sequncer in state 1 to transition
    // to next state. A 1 in a bit position masks that match value from the decision.
    // If all bits are set to 1, the sequencer will transition to next state immediately.
    // 
    // Bits[15:8], RWS_L, default = 0x0
    //
    UINTX st1mask : 8;
    //
    // Mask for deciding which lane matcheswill be used by Sequncer in state 2 to transition
    // to transition back to state 0. A 1 in a bit position masks that match value from
    // the decision. If all bits are set to 1, the sequencer will assert trigger out
    // immediately and exit back to state0. 
    // 
    // Bits[23:16], RWS_L, default = 0x0
    //
    UINTX st2mask : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} MCDBGBUSCNTRL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCDBGBUSSSREG_MCMAIN_REG                          0x00000A78
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This has the debug bus snapshot value.
    // 
    // Bits[31:0], RWS_LV, default = 0x0
    //
    UINTX dbgbusssval : 32;
  } Bits;
  UINTX Data;
} MCDBGBUSSSREG_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCGLBRSPCNTL_MCMAIN_REG                           0x00000A80
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This selects which trigger will be driven out.
    // 000: MBP_OUT[0]
    // 001: MBP_OUT[1]
    // 010: ASC[0] output
    // 011: ASC[1] output
    // 100: CTS trigger out
    // 101: Do it forever
    // 110: Always 1
    // 111: Never assert output
    // 
    // Bits[2:0], RWS_L, default = 0x7
    //
    UINTX glbrsp0starttrigsel : 3;
    //
    // This selects the vent thatwill cause th output to be deasserted.
    // 000: MBP[0]
    // 001: MBP[1]
    // 010: ASC[0]
    // 011: ASC[1]
    // 100: CTS Trigger out
    // 101: Stop 1 cycle after start
    // 110: Do it forever
    // 111: Stop when start is false
    // 
    // Bits[5:3], RWS_L, default = 0x0
    //
    UINTX glbrsp0stopsel : 3;
    //
    // Disable Global response logic 0.  This will abort any pending response.
    // 
    // Bits[6:6], RWS_L, default = 0x0
    //
    UINTX glbrsp0respdis : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // This selects which trigger will be driven out.
    // 000: MBP_OUT[0]
    // 001: MBP_OUT[1]
    // 010: ASC[0] output
    // 011: ASC[1] output
    // 100: CTS trigger out
    // 101: Do it forever
    // 110: Always 1
    // 111: Never assert output
    // 
    // Bits[10:8], RWS_L, default = 0x7
    //
    UINTX glbrsp1starttrigsel : 3;
    //
    // This selects the vent thatwill cause th output to be deasserted.
    // 000: MBP[0]
    // 001: MBP[1]
    // 010: ASC[0]
    // 011: ASC[1]
    // 100: CTS Trigger out
    // 101: Stop 1 cycle after start
    // 110: Do it forever
    // 111: Stop when start is false
    // 
    // Bits[13:11], RWS_L, default = 0x0
    //
    UINTX glbrsp1stopsel : 3;
    //
    // Disable Global response logic 1.  This will abort any pending response.
    // 
    // Bits[14:14], RWS_L, default = 0x0
    //
    UINTX glbrsp1respdis : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // This selects which trigger will be driven out.
    // 000: MBP_OUT[0]
    // 001: MBP_OUT[1]
    // 010: ASC[0] output
    // 011: ASC[1] output
    // 100: CTS trigger out
    // 101: Reserved
    // 110: Always 1
    // 111: Never assert output
    // 
    // Bits[18:16], RWS_L, default = 0x7
    //
    UINTX glbrsp2starttrigsel : 3;
    //
    // This selects the vent thatwill cause th output to be deasserted.
    // 000: MBP[0]
    // 001: MBP[1]
    // 010: ASC[0]
    // 011: ASC[1]
    // 100: CTS Trigger out
    // 101: Stop 1 cycle after start
    // 110: Do it forever
    // 111: Stop when start is false
    // 
    // Bits[21:19], RWS_L, default = 0x0
    //
    UINTX glbrsp2stopsel : 3;
    //
    // Disable Global response logic 2.  This will abort any pending response.
    // 
    // Bits[22:22], RWS_L, default = 0x0
    //
    UINTX glbrsp2respdis : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 9;
  } Bits;
  UINTX Data;
} MCGLBRSPCNTL_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCASCCNTR0_MCMAIN_REG                             0x00000A84
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The current value of the ASC0 counter.
    // 
    // Bits[31:0], RWS_LV, default = 0x0
    //
    UINTX asc0val : 32;
  } Bits;
  UINTX Data;
} MCASCCNTR0_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCASCCNTR1_MCMAIN_REG                             0x00000A88
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The current value of the ASC1 counter.
    // 
    // Bits[31:0], RWS_LV, default = 0x0
    //
    UINTX asc1val : 32;
  } Bits;
  UINTX Data;
} MCASCCNTR1_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCASC0LDVALLO_MCMAIN_REG                          0x00000A8C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This value will be loaded into the counter when the ouput state transitions to
    // 0. 
    // 
    // Bits[31:0], RWS_L, default = 0x0
    //
    UINTX ldlowval : 32;
  } Bits;
  UINTX Data;
} MCASC0LDVALLO_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCASC0LDVALHI_MCMAIN_REG                          0x00000A90
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This value will be loaded into the counter when the ouput state transitions to
    // 1. 
    // 
    // Bits[31:0], RWS_L, default = 0x0
    //
    UINTX ldhival : 32;
  } Bits;
  UINTX Data;
} MCASC0LDVALHI_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCASC1LDVALLO_MCMAIN_REG                          0x00000A94
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This value will be loaded into the counter when the ouput state transitions to
    // 0. 
    // 
    // Bits[31:0], RWS_L, default = 0x0
    //
    UINTX ldlowval : 32;
  } Bits;
  UINTX Data;
} MCASC1LDVALLO_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCASC1LDVALHI_MCMAIN_REG                          0x00000A98
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This value will be loaded into the counter when the ouput state transitions to
    // 1. 
    // 
    // Bits[31:0], RWS_L, default = 0x0
    //
    UINTX ldhival : 32;
  } Bits;
  UINTX Data;
} MCASC1LDVALHI_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCASCCONTROL_MCMAIN_REG                           0x00000A9C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The output state of ASC0.
    // 
    // Bits[0:0], RWS_LV, default = 0x0
    //
    UINTX asc0state : 1;
    //
    // The enable bit for ASC0.
    // 
    // Bits[1:1], RWS_L, default = 0x0
    //
    UINTX asc0en : 1;
    //
    // Control for ASC0. Provides ability to OR or AND ASC0 with ASC1.
    // 00: ASC0's output is asc0_state.
    // 01: ASC0's output is asc0_state AND asc1_state.
    // 10: ASC0's output is asc0_state OR asc1_state.
    // 11: Reserved.
    // 
    // Bits[3:2], RWS_L, default = 0x0
    //
    UINTX asc0mode : 2;
    //
    // The output state of ASC1.
    // 
    // Bits[4:4], RWS_LV, default = 0x0
    //
    UINTX asc1state : 1;
    //
    // The enable bit for ASC1.
    // 
    // Bits[5:5], RWS_L, default = 0x0
    //
    UINTX asc1en : 1;
    //
    // Specifies if ASC1 counter is an extension of ASC0 or not. if set, ASC1 does not
    // depend on MBPQUAL even if it is set. 
    // 0: ASC1 counter is independent.
    // 1: ASC1 is an extension of ASC0 counter. ASC counts when the falling edge of ASC0
    // state is detected. 
    // 
    // Bits[6:6], RWS_L, default = 0x0
    //
    UINTX asc1mode : 1;
    //
    // When set, the enable bits for ASC0 and ASC1 must be qualified by the assertion
    // of the MBP selected by MBPSel for these counters to operate. 
    // 
    // Bits[7:7], RWS_L, default = 0x0
    //
    UINTX mbpqual : 1;
    //
    // When MBPQUAL is set, ASC0 and ASC1 only operate when their respective enable bits
    // are asserted and the MBP selected by this bit field is asserted. 
    // 0: MBP[0]
    // 1: MBP[1]
    // 
    // 
    // Bits[8:8], RWS_L, default = 0x0
    //
    UINTX mbpsel : 1;
    //
    // ASC0 output will clear on stop when set
    // 
    // Bits[9:9], RWS_L, default = 0x0
    //
    UINTX asc0clronstop : 1;
    //
    // ASC1 output will clear on stop when set
    // 
    // Bits[10:10], RWS_L, default = 0x0
    //
    UINTX asc1clronstop : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
  } Bits;
  UINTX Data;
} MCASCCONTROL_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCNOASEL_MCMAIN_REG                               0x00000AA0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 12;
    //
    // This level of muxing will be used for taking only 8 bits of data instead of 16
    // to reduce the data rate on the NOA bus. The 8 bits selected will be accumulated
    // for 2 cycles and sent as one 16 bit value at half the rate. Output8[7:0]: 0 selects
    // output16[7:0]; 1 selects output16[15:8] 
    // 
    // Bits[12:12], RWS_L, default = 0x0
    //
    UINTX muxsel2 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Selects if the full rate or the half rate data should be sent out on the NOA bus.
    // 0: Select full speed data
    // 1: Select half rate data.
    // 
    // Bits[14:14], RWS_L, default = 0x0
    //
    UINTX noaoutsel : 1;
    //
    // This bit enables the NOA logic. No output is sent out on the NOA bus from iMC
    // if this bit is not set. 
    // 0: Disable NOA output from MC
    // 1: Enable NOA output from iMC.
    // 
    // Bits[15:15], RWS_L, default = 0x0
    //
    UINTX noaen : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 16;
  } Bits;
  UINTX Data;
} MCNOASEL_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_GLOBALCTRL_MCMAIN_REG                        0x00000B00
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Setting to 1 will immediately initiate a transition to Loopback.Pattern on all
    // channels that have their global_control bit set. 
    // This field is cleared when all channels transition to Loopback.Marker from loopback.Pattern
    // for channels that have their global_control bit set. 
    // If channels are not expected to transition to Loopback.Marker at the same time
    // (because of programming or other differences) 
    // then start_test bit will not clear by itself.
    // To start the test again, BIOS will need to clear this bit field followed by setting
    // it to 1 again. 
    // 
    // Bits[0:0], RW_LBV, default = 0x0
    //
    UINTX start_test : 1;
    //
    // Setting Global_Stop_Test to 1 will force a transition to Loopback.Marker on all
    // channels that have their Global_Control bit set. 
    // Global_Stop_Test will immediately clear to 0 after forcing a transition to Loopback.Marker
    // on all channels that have their Global_Control bit set. 
    // 
    // Bits[1:1], RW_LBV, default = 0x0
    //
    UINTX stop_test : 1;
    //
    // Setting Global_Clear_Errors to 1 will immediately clear all error status registers
    // (the same effect as asserting assert the Local_Clear_Errors) 
    // on any channels that have their Global Control bit is set.
    // Global_Clear_Errors will immediately be reset to 0 after all Channels_Err Status
    // Registers are cleared that have their Global Control bit Set 
    // 
    // Bits[2:2], RW_LBV, default = 0x0
    //
    UINTX clear_errs : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Setting Global_Stop_Test_On_Any_Error to 1 will immediately force a transition
    // to Loopback.Marker after any error on any channels 
    // (indicated by a no zero value in Channel_Error_Status) that also have their Global
    // Control bit set. 
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX stop_test_on_any_err : 1;
    //
    // Currently Address bits [2:0] of the Column Addr are hard tied to zero, Setting
    // this bit will 
    // enable bit control over Addres bit [2] as well thus enabling BL4 mode full addressing.
    // 
    // Bits[5:5], RW_LB, default = 0x0
    //
    UINTX use_bl4_col_addr : 1;
    //
    // Programmable credits for CPGC Multi Credit Scheme -
    // 6'd-zero: Use hardcoded defaults of 6'd16 (vmse2:1) and 6'd32 (vmse1:1)
    // 6'd-nonzero: Programmable credits for CPGC Multi-credit scheme
    // 
    // Bits[11:6], RW_LB, default = 0x0
    //
    UINTX cpgc_credits : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // When enabled, CPGC sequencer will wait for all credits to be returned before moving
    // to the next sub-sequence. 
    // Usage of this de-feature bit is
    // - limited to WAIT states between two sub-sequences.
    // - limited to when CPGC is using multi-credit scheme.
    // 
    // Bits[13:13], RW_LB, default = 0x0
    //
    UINTX cpgc_crdt_wait : 1;
    //
    // N/A
    // 
    // Bits[14:14], RW_LB, default = 0x0
    //
    UINTX multiwr_singlerd_mode : 1;
    //
    // 
    //         3b per channel vector that should be set for DDRT. 
    //         If this bit is set then 
    //         - Sequencer uses BL4 addressing mode for adddresses to DDRT scheduler
    //  
    //         
    // 
    // Bits[17:15], RW_LB, default = 0x0
    //
    UINTX ddrt_addr_mode : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 14;
  } Bits;
  UINTX Data;
} CPGC_GLOBALCTRL_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_GLOBALERR_MCMAIN_REG                         0x00000B04
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Channel_Error_Status_0 corresponds to Channel 0. When set this indicated Channel
    // 0 has at least one Data (Data_Error_Status) or ECC 
    // (Ecc_Error_Status) error status bit set.
    // Channel_Error_Status_0 will be cleared when setting Local_Clear_Errors or (Global_Control
    // and Global_Clear_Errors) . 
    // 
    // Bits[0:0], RO_V, default = 0x0
    //
    UINTX channel_err_status_0 : 1;
    //
    // Channel_Error_Status_1 corresponds to Channel 1. When set this indicated Channel
    // 1 has at least one Data (Data_Error_Status) or ECC 
    // (Ecc_Error_Status) error status bit set.
    // Channel_Error_Status_1 will be cleared when setting Local_Clear_Errors or (Global_Control
    // and Global_Clear_Errors) . 
    // 
    // Bits[1:1], RO_V, default = 0x0
    //
    UINTX channel_err_status_1 : 1;
    //
    // Channel_Error_Status_2 corresponds to Channel 2. When set this indicated Channel
    // 2 has at least one Data (Data_Error_Status) or ECC 
    // (Ecc_Error_Status) error status bit set.
    // Channel_Error_Status_2 will be cleared when setting Local_Clear_Errors or (Global_Control
    // and Global_Clear_Errors) . 
    // 
    // Bits[2:2], RO_V, default = 0x0
    //
    UINTX channel_err_status_2 : 1;
    //
    // Channel_Error_Status_3 corresponds to Channel 3. When set this indicated Channel
    // 3 has at least one Data (Data_Error_Status) or ECC 
    // (Ecc_Error_Status) error status bit set.
    // Channel_Error_Status_3 will be cleared when setting Local_Clear_Errors or (Global_Control
    // and Global_Clear_Errors) . 
    // 
    // Bits[3:3], RO_V, default = 0x0
    //
    UINTX channel_err_status_3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 12;
    //
    // Channel_Test_Done_Status_0 corresponds to Channel 0 and is set in Loopback.Marker
    // and cleared in Loopback.Pattern 
    // 
    // Bits[16:16], RO_V, default = 0x1
    //
    UINTX channel_test_done_status_0 : 1;
    //
    // Channel_Test_Done_Status_1 corresponds to Channel 1 and is set in Loopback.Marker
    // and cleared in Loopback.Pattern 
    // 
    // Bits[17:17], RO_V, default = 0x1
    //
    UINTX channel_test_done_status_1 : 1;
    //
    // Channel_Test_Done_Status_2 corresponds to Channel 2 and is set in Loopback.Marker
    // and cleared in Loopback.Pattern 
    // 
    // Bits[18:18], RO_V, default = 0x1
    //
    UINTX channel_test_done_status_2 : 1;
    //
    // Channel_Test_Done_Status_3 corresponds to Channel 3 and is set in Loopback.Marker
    // and cleared in Loopback.Pattern 
    // 
    // Bits[19:19], RO_V, default = 0x1
    //
    UINTX channel_test_done_status_3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} CPGC_GLOBALERR_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQCTL0_MCMAIN_REG                           0x00000B08
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Setting Local_Start_Test or (Global_Control and Global_Start_Test) to 1 will immediately
    // initiate a transition to Loopback.Pattern 
    // from Loopback.Marker.
    // Local_Start_Test must be cleared when a test transitions from Loopback.Pattern
    // to Loopback.Marker. 
    // 
    // Bits[0:0], RW_LBV, default = 0x0
    //
    UINTX local_start_test : 1;
    //
    // If Local_Stop_Test or (Global_Control and Global_Stop_Test) is set to 1 will force
    // a transition on this Channel # to Loopback.Marker 
    // from Loopback.Pattern.
    // Local_Start_Test must be cleared when a test transitions from Loopback.Pattern
    // to Loopback.Marker. 
    // 
    // Bits[1:1], RW_LBV, default = 0x0
    //
    UINTX local_stop_test : 1;
    //
    // Setting Local_Clear_Errors or (Global_Control and Global_Clear_Errors) to 1 will
    // immediately clear all local channel errors status registers 
    // (CPGC#_CH#_ERR_* registers).
    // Local_Clear_Errors will immediately clear to 0 after clearing all error status
    // registers 
    // 
    // Bits[2:2], RW_LBV, default = 0x0
    //
    UINTX local_clear_errs : 1;
    //
    // If Stop_Base_Seq_On_Wrap_Trigger is set then any Base Address Wrap Trigger that
    // occurs will immediately force a test to stop 
    // (i.e. creates a transition from Loopback.Pattern to Loopback.Marker).
    // Stop_On_Wrap_Trigger at the sequence level only makes sense when the Address_Update_Rate_Mode
    // is set to 0x1 where the four Address Update Rate 
    // fields (Rank, Bank, Row, and Column) are updated by based on the Loopcount (the
    // # of loops through from the start of the test). 
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the former 
    // causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX stop_base_seq_on_wrap_trigger : 1;
    //
    // Address_Update_Rate_Mode dictates whether the address increment is based on #
    // of cachelines written and read or by Loopcount (# of sequences performed). 
    // Address_Update_Rate_Mode = 0 means that the four Address Update Rate fields (Rank,
    // Bank, Row, and Column) are updated based on the # of read and 
    // write cacheline transactions.
    // Address_Update_Rate_Mode = 1 means that the four Address Update Rate fields (Rank,
    // Bank, Row, and Column) are updated by based on the Loopcount 
    // (# of sequences perfromed).
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX address_update_rate_mode : 1;
    //
    // If set then the Dummy Read state machine is Enabled during this sequence creating
    // ACT and PRE in the same Rank that is being targeted. 
    // See CPGC_CH#_SEQ#_DUMMYREAD_*
    // 
    // Bits[5:5], RW_LB, default = 0x0
    //
    UINTX enable_dummy_reads : 1;
    //
    // This bit is UNUSED in design. Refer to be4536804 for details.
    // Setting Enable_Constant_Write_Strobe will cause the Tx write Strobe to be driven
    // out constantly while a test is in progress 
    // (while in Loopback.Pattern).
    // This is most often used to help train the correct setting for per Rank write leveling
    // using the following steps. 
    // 
    // Bits[6:6], RW_LB, default = 0x0
    //
    UINTX enable_constant_write_strobe : 1;
    //
    // Enables the CPGC_GLOBAL_CTRL register to control this CPGC#_CH# engine in multiple
    // ways 
    // (i.e. Global_Start_Test, Global_Stop_Test, Global_Clear_Errors, Global_Clear_Errors_On_Start_Test,
    // and Global_Stop_Test_on_Any_Error). 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX global_control : 1;
    //
    // A change to Initialization Mode occurs immediately and does not require a Physical
    // Layer Reset to be asserted. 
    // 00 - Idle on MC Reset
    // 01 - CPGC Testing Once the Initialization_Mode is set to 01 then the channel enters
    // immediately 
    // into the Loopback.Marker state and the ability to start a test becomes enabled.
    // 10 - MRS Mode.
    // 11 - RSVD.
    // 
    // Bits[9:8], RW_LBV, default = 0x0
    //
    UINTX initialization_mode : 2;
    //
    // 2^(Loopcount-1) determines how many iterations of the complete Sequence loop takes
    // place before a test stops, where a 
    // Sequence loop is defined by the completion of all SubSequences indicated by the
    // SubSequence Start pointer to 
    // SubSequence End pointer.
    // Loopcount = 0 means the test is infinite.
    // Loopcount = 1 means the test will end after one loop through the sub sequences.
    // Loopcount = 2 means the test will end after two Loops through the sub sequences.
    // Loopcount = 3 means the test will end after four Loops through the sub sequences.
    // 
    // Bits[14:10], RW_LB, default = 0x0
    //
    UINTX loopcount : 5;
    //
    // Initial SubSequence pointer when beginning a Sequence. Subseq_Start_Pointer values
    // of 0 9 are valid 
    // 
    // Bits[18:15], RW_LB, default = 0x0
    //
    UINTX subseq_start_pointer : 4;
    //
    // Subsequence pointer when completed the Loopcount is incremented by 1 and the Current_Subseq_Pointer
    // is reset to the Subseq_Start_Pointer. 
    // Subseq_End_Pointer values of 0 9 are valid
    // The Subseq_End_Pointer must always be set to equal or greater than the Subseq_Start_Pointer.
    // 
    // Bits[22:19], RW_LB, default = 0x0
    //
    UINTX subseq_end_pointer : 4;
    //
    // Delay period (in DClks) between the setting of Local_Start_Test or (Global_Control
    // and Global_Start_Test) and the actual entry 
    // to Loopback.Pattern where the first SubSequence is executed immediately.
    // 
    // Bits[30:23], RW_LB, default = 0x0
    //
    UINTX start_test_delay : 8;
    //
    // This bit enables CPGC mode wherein more then 1 CPGC WR credits are available at
    // a time. 
    // 1'b0: Default CPGC Wr credit of 1
    // 1'b1: 32 (vmse1:1) or 16 (vmse2:1) Wr-credits per scheduler to enable VMSE Write
    // and Write leveling training steps 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX vmse_wrtrn_enb : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQCTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQCTL1_MCMAIN_REG                           0x00000B0C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Setting Local_Start_Test or (Global_Control and Global_Start_Test) to 1 will immediately
    // initiate a transition to Loopback.Pattern 
    // from Loopback.Marker.
    // Local_Start_Test must be cleared when a test transitions from Loopback.Pattern
    // to Loopback.Marker. 
    // 
    // Bits[0:0], RW_LBV, default = 0x0
    //
    UINTX local_start_test : 1;
    //
    // If Local_Stop_Test or (Global_Control and Global_Stop_Test) is set to 1 will force
    // a transition on this Channel # to Loopback.Marker 
    // from Loopback.Pattern.
    // Local_Start_Test must be cleared when a test transitions from Loopback.Pattern
    // to Loopback.Marker. 
    // 
    // Bits[1:1], RW_LBV, default = 0x0
    //
    UINTX local_stop_test : 1;
    //
    // Setting Local_Clear_Errors or (Global_Control and Global_Clear_Errors) to 1 will
    // immediately clear all local channel errors status registers 
    // (CPGC#_CH#_ERR_* registers).
    // Local_Clear_Errors will immediately clear to 0 after clearing all error status
    // registers 
    // 
    // Bits[2:2], RW_LBV, default = 0x0
    //
    UINTX local_clear_errs : 1;
    //
    // If Stop_Base_Seq_On_Wrap_Trigger is set then any Base Address Wrap Trigger that
    // occurs will immediately force a test to stop 
    // (i.e. creates a transition from Loopback.Pattern to Loopback.Marker).
    // Stop_On_Wrap_Trigger at the sequence level only makes sense when the Address_Update_Rate_Mode
    // is set to 0x1 where the four Address Update Rate 
    // fields (Rank, Bank, Row, and Column) are updated by based on the Loopcount (the
    // # of loops through from the start of the test). 
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the former 
    // causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX stop_base_seq_on_wrap_trigger : 1;
    //
    // Address_Update_Rate_Mode dictates whether the address increment is based on #
    // of cachelines written and read or by Loopcount (# of sequences performed). 
    // Address_Update_Rate_Mode = 0 means that the four Address Update Rate fields (Rank,
    // Bank, Row, and Column) are updated based on the # of read and 
    // write cacheline transactions.
    // Address_Update_Rate_Mode = 1 means that the four Address Update Rate fields (Rank,
    // Bank, Row, and Column) are updated by based on the Loopcount 
    // (# of sequences perfromed).
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX address_update_rate_mode : 1;
    //
    // If set then the Dummy Read state machine is Enabled during this sequence creating
    // ACT and PRE in the same Rank that is being targeted. 
    // See CPGC_CH#_SEQ#_DUMMYREAD_*
    // 
    // Bits[5:5], RW_LB, default = 0x0
    //
    UINTX enable_dummy_reads : 1;
    //
    // This bit is UNUSED in design. Refer to be4536804 for details.
    // Setting Enable_Constant_Write_Strobe will cause the Tx write Strobe to be driven
    // out constantly while a test is in progress 
    // (while in Loopback.Pattern).
    // This is most often used to help train the correct setting for per Rank write leveling
    // using the following steps. 
    // 
    // Bits[6:6], RW_LB, default = 0x0
    //
    UINTX enable_constant_write_strobe : 1;
    //
    // Enables the CPGC_GLOBAL_CTRL register to control this CPGC#_CH# engine in multiple
    // ways 
    // (i.e. Global_Start_Test, Global_Stop_Test, Global_Clear_Errors, Global_Clear_Errors_On_Start_Test,
    // and Global_Stop_Test_on_Any_Error). 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX global_control : 1;
    //
    // A change to Initialization Mode occurs immediately and does not require a Physical
    // Layer Reset to be asserted. 
    // 00 - Idle on MC Reset
    // 01 - CPGC Testing Once the Initialization_Mode is set to 01 then the channel enters
    // immediately 
    // into the Loopback.Marker state and the ability to start a test becomes enabled.
    // 10 - MRS Mode.
    // 11 - Normal Operation. This is the normal protocol mode for the Link. (i.e. CPGC
    // is disabled). 
    // If currently in one of the other modes, an exit will occur as soon as possible.
    // 
    // Bits[9:8], RW_LBV, default = 0x0
    //
    UINTX initialization_mode : 2;
    //
    // 2^(Loopcount-1) determines how many iterations of the complete Sequence loop takes
    // place before a test stops, where a 
    // Sequence loop is defined by the completion of all SubSequences indicated by the
    // SubSequence Start pointer to 
    // SubSequence End pointer.
    // Loopcount = 0 means the test is infinite.
    // Loopcount = 1 means the test will end after one loop through the sub sequences.
    // Loopcount = 2 means the test will end after two Loops through the sub sequences.
    // Loopcount = 3 means the test will end after four Loops through the sub sequences.
    // 
    // Bits[14:10], RW_LB, default = 0x0
    //
    UINTX loopcount : 5;
    //
    // Initial SubSequence pointer when beginning a Sequence. Subseq_Start_Pointer values
    // of 0 9 are valid 
    // 
    // Bits[18:15], RW_LB, default = 0x0
    //
    UINTX subseq_start_pointer : 4;
    //
    // Subsequence pointer when completed the Loopcount is incremented by 1 and the Current_Subseq_Pointer
    // is reset to the Subseq_Start_Pointer. 
    // Subseq_End_Pointer values of 0 9 are valid
    // The Subseq_End_Pointer must always be set to equal or greater than the Subseq_Start_Pointer.
    // 
    // Bits[22:19], RW_LB, default = 0x0
    //
    UINTX subseq_end_pointer : 4;
    //
    // Delay period (in DClks) between the setting of Local_Start_Test or (Global_Control
    // and Global_Start_Test) and the actual entry 
    // to Loopback.Pattern where the first SubSequence is executed immediately.
    // 
    // Bits[30:23], RW_LB, default = 0x0
    //
    UINTX start_test_delay : 8;
    //
    // This bit enables CPGC mode wherein more then 1 CPGC WR credits are available at
    // a time. 
    // 1'b0: Default CPGC Wr credit of 1
    // 1'b1: 32 (vmse1:1) or 16 (vmse2:1) Wr-credits per scheduler to enable VMSE Write
    // and Write leveling training steps 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX vmse_wrtrn_enb : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQCTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQCTL2_MCMAIN_REG                           0x00000B10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Setting Local_Start_Test or (Global_Control and Global_Start_Test) to 1 will immediately
    // initiate a transition to Loopback.Pattern 
    // from Loopback.Marker.
    // Local_Start_Test must be cleared when a test transitions from Loopback.Pattern
    // to Loopback.Marker. 
    // 
    // Bits[0:0], RW_LBV, default = 0x0
    //
    UINTX local_start_test : 1;
    //
    // If Local_Stop_Test or (Global_Control and Global_Stop_Test) is set to 1 will force
    // a transition on this Channel # to Loopback.Marker 
    // from Loopback.Pattern.
    // Local_Start_Test must be cleared when a test transitions from Loopback.Pattern
    // to Loopback.Marker. 
    // 
    // Bits[1:1], RW_LBV, default = 0x0
    //
    UINTX local_stop_test : 1;
    //
    // Setting Local_Clear_Errors or (Global_Control and Global_Clear_Errors) to 1 will
    // immediately clear all local channel errors status registers 
    // (CPGC#_CH#_ERR_* registers).
    // Local_Clear_Errors will immediately clear to 0 after clearing all error status
    // registers 
    // 
    // Bits[2:2], RW_LBV, default = 0x0
    //
    UINTX local_clear_errs : 1;
    //
    // If Stop_Base_Seq_On_Wrap_Trigger is set then any Base Address Wrap Trigger that
    // occurs will immediately force a test to stop 
    // (i.e. creates a transition from Loopback.Pattern to Loopback.Marker).
    // Stop_On_Wrap_Trigger at the sequence level only makes sense when the Address_Update_Rate_Mode
    // is set to 0x1 where the four Address Update Rate 
    // fields (Rank, Bank, Row, and Column) are updated by based on the Loopcount (the
    // # of loops through from the start of the test). 
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the former 
    // causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX stop_base_seq_on_wrap_trigger : 1;
    //
    // Address_Update_Rate_Mode dictates whether the address increment is based on #
    // of cachelines written and read or by Loopcount (# of sequences performed). 
    // Address_Update_Rate_Mode = 0 means that the four Address Update Rate fields (Rank,
    // Bank, Row, and Column) are updated based on the # of read and 
    // write cacheline transactions.
    // Address_Update_Rate_Mode = 1 means that the four Address Update Rate fields (Rank,
    // Bank, Row, and Column) are updated by based on the Loopcount 
    // (# of sequences perfromed).
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX address_update_rate_mode : 1;
    //
    // If set then the Dummy Read state machine is Enabled during this sequence creating
    // ACT and PRE in the same Rank that is being targeted. 
    // See CPGC_CH#_SEQ#_DUMMYREAD_*
    // 
    // Bits[5:5], RW_LB, default = 0x0
    //
    UINTX enable_dummy_reads : 1;
    //
    // This bit is UNUSED in design. Refer to be4536804 for details.
    // Setting Enable_Constant_Write_Strobe will cause the Tx write Strobe to be driven
    // out constantly while a test is in progress 
    // (while in Loopback.Pattern).
    // This is most often used to help train the correct setting for per Rank write leveling
    // using the following steps. 
    // 
    // Bits[6:6], RW_LB, default = 0x0
    //
    UINTX enable_constant_write_strobe : 1;
    //
    // Enables the CPGC_GLOBAL_CTRL register to control this CPGC#_CH# engine in multiple
    // ways 
    // (i.e. Global_Start_Test, Global_Stop_Test, Global_Clear_Errors, Global_Clear_Errors_On_Start_Test,
    // and Global_Stop_Test_on_Any_Error). 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX global_control : 1;
    //
    // A change to Initialization Mode occurs immediately and does not require a Physical
    // Layer Reset to be asserted. 
    // 00 - Idle on MC Reset
    // 01 - CPGC Testing Once the Initialization_Mode is set to 01 then the channel enters
    // immediately 
    // into the Loopback.Marker state and the ability to start a test becomes enabled.
    // 10 - MRS Mode.
    // 11 - Normal Operation. This is the normal protocol mode for the Link. (i.e. CPGC
    // is disabled). 
    // If currently in one of the other modes, an exit will occur as soon as possible.
    // 
    // Bits[9:8], RW_LBV, default = 0x0
    //
    UINTX initialization_mode : 2;
    //
    // 2^(Loopcount-1) determines how many iterations of the complete Sequence loop takes
    // place before a test stops, where a 
    // Sequence loop is defined by the completion of all SubSequences indicated by the
    // SubSequence Start pointer to 
    // SubSequence End pointer.
    // Loopcount = 0 means the test is infinite.
    // Loopcount = 1 means the test will end after one loop through the sub sequences.
    // Loopcount = 2 means the test will end after two Loops through the sub sequences.
    // Loopcount = 3 means the test will end after four Loops through the sub sequences.
    // 
    // Bits[14:10], RW_LB, default = 0x0
    //
    UINTX loopcount : 5;
    //
    // Initial SubSequence pointer when beginning a Sequence. Subseq_Start_Pointer values
    // of 0 9 are valid 
    // 
    // Bits[18:15], RW_LB, default = 0x0
    //
    UINTX subseq_start_pointer : 4;
    //
    // Subsequence pointer when completed the Loopcount is incremented by 1 and the Current_Subseq_Pointer
    // is reset to the Subseq_Start_Pointer. 
    // Subseq_End_Pointer values of 0 9 are valid
    // The Subseq_End_Pointer must always be set to equal or greater than the Subseq_Start_Pointer.
    // 
    // Bits[22:19], RW_LB, default = 0x0
    //
    UINTX subseq_end_pointer : 4;
    //
    // Delay period (in DClks) between the setting of Local_Start_Test or (Global_Control
    // and Global_Start_Test) and the actual entry 
    // to Loopback.Pattern where the first SubSequence is executed immediately.
    // 
    // Bits[30:23], RW_LB, default = 0x0
    //
    UINTX start_test_delay : 8;
    //
    // This bit enables CPGC mode wherein more then 1 CPGC WR credits are available at
    // a time. 
    // 1'b0: Default CPGC Wr credit of 1
    // 1'b1: 32 (vmse1:1) or 16 (vmse2:1) Wr-credits per scheduler to enable VMSE Write
    // and Write leveling training steps 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX vmse_wrtrn_enb : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQCTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQCTL3_MCMAIN_REG                           0x00000B14
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Setting Local_Start_Test or (Global_Control and Global_Start_Test) to 1 will immediately
    // initiate a transition to Loopback.Pattern 
    // from Loopback.Marker.
    // Local_Start_Test must be cleared when a test transitions from Loopback.Pattern
    // to Loopback.Marker. 
    // 
    // Bits[0:0], RW_LBV, default = 0x0
    //
    UINTX local_start_test : 1;
    //
    // If Local_Stop_Test or (Global_Control and Global_Stop_Test) is set to 1 will force
    // a transition on this Channel # to Loopback.Marker 
    // from Loopback.Pattern.
    // Local_Start_Test must be cleared when a test transitions from Loopback.Pattern
    // to Loopback.Marker. 
    // 
    // Bits[1:1], RW_LBV, default = 0x0
    //
    UINTX local_stop_test : 1;
    //
    // Setting Local_Clear_Errors or (Global_Control and Global_Clear_Errors) to 1 will
    // immediately clear all local channel errors status registers 
    // (CPGC#_CH#_ERR_* registers).
    // Local_Clear_Errors will immediately clear to 0 after clearing all error status
    // registers 
    // 
    // Bits[2:2], RW_LBV, default = 0x0
    //
    UINTX local_clear_errs : 1;
    //
    // If Stop_Base_Seq_On_Wrap_Trigger is set then any Base Address Wrap Trigger that
    // occurs will immediately force a test to stop 
    // (i.e. creates a transition from Loopback.Pattern to Loopback.Marker).
    // Stop_On_Wrap_Trigger at the sequence level only makes sense when the Address_Update_Rate_Mode
    // is set to 0x1 where the four Address Update Rate 
    // fields (Rank, Bank, Row, and Column) are updated by based on the Loopcount (the
    // # of loops through from the start of the test). 
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the former 
    // causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX stop_base_seq_on_wrap_trigger : 1;
    //
    // Address_Update_Rate_Mode dictates whether the address increment is based on #
    // of cachelines written and read or by Loopcount (# of sequences performed). 
    // Address_Update_Rate_Mode = 0 means that the four Address Update Rate fields (Rank,
    // Bank, Row, and Column) are updated based on the # of read and 
    // write cacheline transactions.
    // Address_Update_Rate_Mode = 1 means that the four Address Update Rate fields (Rank,
    // Bank, Row, and Column) are updated by based on the Loopcount 
    // (# of sequences perfromed).
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX address_update_rate_mode : 1;
    //
    // If set then the Dummy Read state machine is Enabled during this sequence creating
    // ACT and PRE in the same Rank that is being targeted. 
    // See CPGC_CH#_SEQ#_DUMMYREAD_*
    // 
    // Bits[5:5], RW_LB, default = 0x0
    //
    UINTX enable_dummy_reads : 1;
    //
    // This bit is UNUSED in design. Refer to be4536804 for details.
    // Setting Enable_Constant_Write_Strobe will cause the Tx write Strobe to be driven
    // out constantly while a test is in progress 
    // (while in Loopback.Pattern).
    // This is most often used to help train the correct setting for per Rank write leveling
    // using the following steps. 
    // 
    // Bits[6:6], RW_LB, default = 0x0
    //
    UINTX enable_constant_write_strobe : 1;
    //
    // Enables the CPGC_GLOBAL_CTRL register to control this CPGC#_CH# engine in multiple
    // ways 
    // (i.e. Global_Start_Test, Global_Stop_Test, Global_Clear_Errors, Global_Clear_Errors_On_Start_Test,
    // and Global_Stop_Test_on_Any_Error). 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX global_control : 1;
    //
    // A change to Initialization Mode occurs immediately and does not require a Physical
    // Layer Reset to be asserted. 
    // 00 - Idle on MC Reset
    // 01 - CPGC Testing Once the Initialization_Mode is set to 01 then the channel enters
    // immediately 
    // into the Loopback.Marker state and the ability to start a test becomes enabled.
    // 10 - MRS Mode.
    // 11 - Normal Operation. This is the normal protocol mode for the Link. (i.e. CPGC
    // is disabled). 
    // If currently in one of the other modes, an exit will occur as soon as possible.
    // 
    // Bits[9:8], RW_LBV, default = 0x0
    //
    UINTX initialization_mode : 2;
    //
    // 2^(Loopcount-1) determines how many iterations of the complete Sequence loop takes
    // place before a test stops, where a 
    // Sequence loop is defined by the completion of all SubSequences indicated by the
    // SubSequence Start pointer to 
    // SubSequence End pointer.
    // Loopcount = 0 means the test is infinite.
    // Loopcount = 1 means the test will end after one loop through the sub sequences.
    // Loopcount = 2 means the test will end after two Loops through the sub sequences.
    // Loopcount = 3 means the test will end after four Loops through the sub sequences.
    // 
    // Bits[14:10], RW_LB, default = 0x0
    //
    UINTX loopcount : 5;
    //
    // Initial SubSequence pointer when beginning a Sequence. Subseq_Start_Pointer values
    // of 0 9 are valid 
    // 
    // Bits[18:15], RW_LB, default = 0x0
    //
    UINTX subseq_start_pointer : 4;
    //
    // Subsequence pointer when completed the Loopcount is incremented by 1 and the Current_Subseq_Pointer
    // is reset to the Subseq_Start_Pointer. 
    // Subseq_End_Pointer values of 0 9 are valid
    // The Subseq_End_Pointer must always be set to equal or greater than the Subseq_Start_Pointer.
    // 
    // Bits[22:19], RW_LB, default = 0x0
    //
    UINTX subseq_end_pointer : 4;
    //
    // Delay period (in DClks) between the setting of Local_Start_Test or (Global_Control
    // and Global_Start_Test) and the actual entry 
    // to Loopback.Pattern where the first SubSequence is executed immediately.
    // 
    // Bits[30:23], RW_LB, default = 0x0
    //
    UINTX start_test_delay : 8;
    //
    // This bit enables CPGC mode wherein more then 1 CPGC WR credits are available at
    // a time. 
    // 1'b0: Default CPGC Wr credit of 1
    // 1'b1: 32 (vmse1:1) or 16 (vmse2:1) Wr-credits per scheduler to enable VMSE Write
    // and Write leveling training steps 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX vmse_wrtrn_enb : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQCTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_LPCNT_STS0_MCMAIN_REG                    0x00000B18
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current_Loopcount indicates how many times the full Sequence has been executed
    // completely. 
    // Current_Loopcount is used to -
    // 1) Drive the Base Address Increment Logic (CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL) when
    // CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode is set to 1. 
    // 2) Help determine what the failing pattern is in conjunction with the control
    // signal to Stop_On_Nth_Error and the status provided by the 
    // Physical Layer Address logged for the Nth Error (CPGC#_CH#_ERROR_ADDR).
    // 
    // Bits[31:0], RO_V, default = 0x0
    //
    UINTX current_loopcount : 32;
  } Bits;
  UINTX Data;
} CPGC_SEQ_LPCNT_STS0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_LPCNT_STS1_MCMAIN_REG                    0x00000B1C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current_Loopcount indicates how many times the full Sequence has been executed
    // completely. 
    // Current_Loopcount is used to -
    // 1) Drive the Base Address Increment Logic (CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL) when
    // CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode is set to 1. 
    // 2) Help determine what the failing pattern is in conjunction with the control
    // signal to Stop_On_Nth_Error and the status provided by the 
    // Physical Layer Address logged for the Nth Error (CPGC#_CH#_ERROR_ADDR).
    // 
    // Bits[31:0], RO_V, default = 0x0
    //
    UINTX current_loopcount : 32;
  } Bits;
  UINTX Data;
} CPGC_SEQ_LPCNT_STS1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_LPCNT_STS2_MCMAIN_REG                    0x00000B20
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current_Loopcount indicates how many times the full Sequence has been executed
    // completely. 
    // Current_Loopcount is used to -
    // 1) Drive the Base Address Increment Logic (CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL) when
    // CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode is set to 1. 
    // 2) Help determine what the failing pattern is in conjunction with the control
    // signal to Stop_On_Nth_Error and the status provided by the 
    // Physical Layer Address logged for the Nth Error (CPGC#_CH#_ERROR_ADDR).
    // 
    // Bits[31:0], RO_V, default = 0x0
    //
    UINTX current_loopcount : 32;
  } Bits;
  UINTX Data;
} CPGC_SEQ_LPCNT_STS2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_LPCNT_STS3_MCMAIN_REG                    0x00000B24
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current_Loopcount indicates how many times the full Sequence has been executed
    // completely. 
    // Current_Loopcount is used to -
    // 1) Drive the Base Address Increment Logic (CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL) when
    // CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode is set to 1. 
    // 2) Help determine what the failing pattern is in conjunction with the control
    // signal to Stop_On_Nth_Error and the status provided by the 
    // Physical Layer Address logged for the Nth Error (CPGC#_CH#_ERROR_ADDR).
    // 
    // Bits[31:0], RO_V, default = 0x0
    //
    UINTX current_loopcount : 32;
  } Bits;
  UINTX Data;
} CPGC_SEQ_LPCNT_STS3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_SUBSEQ_PNTR_MCMAIN_REG                   0x00000B28
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Indicates what the current Subsequence value is in the Sequence for ch-0.
    // 
    // Bits[3:0], RO_V, default = 0x0
    //
    UINTX currentpntr0 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Indicates what the current Subsequence value is in the Sequence for ch-1.
    // 
    // Bits[9:6], RO_V, default = 0x0
    //
    UINTX currentpntr1 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Indicates what the current Subsequence value is in the Sequence for ch-2.
    // 
    // Bits[15:12], RO_V, default = 0x0
    //
    UINTX currentpntr2 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[17:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Indicates what the current Subsequence value is in the Sequence for ch-3.
    // 
    // Bits[21:18], RO_V, default = 0x0
    //
    UINTX currentpntr3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 10;
  } Bits;
  UINTX Data;
} CPGC_SEQ_SUBSEQ_PNTR_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_CLSTS0_MCMAIN_REG                        0x00000B2C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current_Cacheline indicates the number of cachelines executed within the current
    // subsequence (CPGC#_CH#_SEQ_SUBSEQ_PNTR). 
    // Current_Cacheline is used to -
    // 1) Drive the Base Address Increment Logic (CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL) when
    // CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode 
    // is set to 0.
    // 2) Help determine what the failing pattern is in conjunction with the control
    // signal to Stop_On_Nth_Error and the status provided 
    // by the Physical Layer Address logged for the Nth Error (CPGC#_CH#_ERROR_ADDR).
    // 
    // Bits[31:0], RO_V, default = 0x0
    //
    UINTX current_cl : 32;
  } Bits;
  UINTX Data;
} CPGC_SEQ_CLSTS0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_CLSTS1_MCMAIN_REG                        0x00000B30
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current_Cacheline indicates the number of cachelines executed within the current
    // subsequence (CPGC#_CH#_SEQ_SUBSEQ_PNTR). 
    // Current_Cacheline is used to -
    // 1) Drive the Base Address Increment Logic (CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL) when
    // CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode 
    // is set to 0.
    // 2) Help determine what the failing pattern is in conjunction with the control
    // signal to Stop_On_Nth_Error and the status provided 
    // by the Physical Layer Address logged for the Nth Error (CPGC#_CH#_ERROR_ADDR).
    // 
    // Bits[31:0], RO_V, default = 0x0
    //
    UINTX current_cl : 32;
  } Bits;
  UINTX Data;
} CPGC_SEQ_CLSTS1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_CLSTS2_MCMAIN_REG                        0x00000B34
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current_Cacheline indicates the number of cachelines executed within the current
    // subsequence (CPGC#_CH#_SEQ_SUBSEQ_PNTR). 
    // Current_Cacheline is used to -
    // 1) Drive the Base Address Increment Logic (CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL) when
    // CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode 
    // is set to 0.
    // 2) Help determine what the failing pattern is in conjunction with the control
    // signal to Stop_On_Nth_Error and the status provided 
    // by the Physical Layer Address logged for the Nth Error (CPGC#_CH#_ERROR_ADDR).
    // 
    // Bits[31:0], RO_V, default = 0x0
    //
    UINTX current_cl : 32;
  } Bits;
  UINTX Data;
} CPGC_SEQ_CLSTS2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_CLSTS3_MCMAIN_REG                        0x00000B38
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current_Cacheline indicates the number of cachelines executed within the current
    // subsequence (CPGC#_CH#_SEQ_SUBSEQ_PNTR). 
    // Current_Cacheline is used to -
    // 1) Drive the Base Address Increment Logic (CPGC#_CH#_SEQ_BASE_ADDR_INC_CTL) when
    // CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode 
    // is set to 0.
    // 2) Help determine what the failing pattern is in conjunction with the control
    // signal to Stop_On_Nth_Error and the status provided 
    // by the Physical Layer Address logged for the Nth Error (CPGC#_CH#_ERROR_ADDR).
    // 
    // Bits[31:0], RO_V, default = 0x0
    //
    UINTX current_cl : 32;
  } Bits;
  UINTX Data;
} CPGC_SEQ_CLSTS3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRSTART_LO0_MCMAIN_REG             0x00000B3C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Starting Column Address. Normally the lowest three column bits are reserved since
    // all transfers are done on a cacheline basis (8 chunks 0-7), 
    // but for implementations that address to a sub cacheline then these reserved bits
    // might be used as needed. 
    // expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used only
    // for DDRT addresses.  
    // 
    // Bits[20:3], RW_LB, default = 0x0
    //
    UINTX column_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Starting Bank Address
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX bank_addr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRSTART_LO0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRSTART_LO1_MCMAIN_REG             0x00000B40
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Starting Column Address. Normally the lowest three column bits are reserved since
    // all transfers are done on a cacheline basis (8 chunks 0-7), 
    // but for implementations that address to a sub cacheline then these reserved bits
    // might be used as needed. 
    // expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used only
    // for DDRT addresses.  
    // 
    // 
    // Bits[20:3], RW_LB, default = 0x0
    //
    UINTX column_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Starting Bank Address
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX bank_addr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRSTART_LO1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRSTART_LO2_MCMAIN_REG             0x00000B44
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Starting Column Address. Normally the lowest three column bits are reserved since
    // all transfers are done on a cacheline basis (8 chunks 0-7), 
    // but for implementations that address to a sub cacheline then these reserved bits
    // might be used as needed. 
    // expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used only
    // for DDRT addresses.  
    // 
    // Bits[20:3], RW_LB, default = 0x0
    //
    UINTX column_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Starting Bank Address
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX bank_addr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRSTART_LO2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRSTART_LO3_MCMAIN_REG             0x00000B48
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Starting Column Address. Normally the lowest three column bits are reserved since
    // all transfers are done on a cacheline basis (8 chunks 0-7), 
    // but for implementations that address to a sub cacheline then these reserved bits
    // might be used as needed. 
    // expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used only
    // for DDRT addresses.  
    // 
    // Bits[20:3], RW_LB, default = 0x0
    //
    UINTX column_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Starting Bank Address
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX bank_addr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRSTART_LO3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRWRAP_LO0_MCMAIN_REG              0x00000B4C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // If the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address = CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address
    // then any further request to modify 
    // (increment or decrement) the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address immediately
    // causes a Wrap to occur with the following actions: 
    // 1. CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address must be set equal to the CPGC#_CH#_SEQ_BASE_ADDR_Start.Column_Address:
    // 2. If Column_Base_Wrap_Carry_Enable is set bit to 1 a carry increment from the
    // Column Address (order N) will propagate to the N+1 order 
    // Address field(s).
    // 3. If Column_Base_Wrap_Trigger_Enable is set to 1 then an Address Wrap Trigger
    // has occurred which can be used in conjunction with Stop_On_Wrap_Trigger. 
    // expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used only
    // for DDRT addresses.  
    // 
    // Bits[20:3], RW_LB, default = 0x0
    //
    UINTX column_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Same as field [6:0] for Bank-Addr
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX bank_addr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRWRAP_LO0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRWRAP_LO1_MCMAIN_REG              0x00000B50
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // If the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address = CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address
    // then any further request to modify 
    // (increment or decrement) the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address immediately
    // causes a Wrap to occur with the following actions: 
    // 1. CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address must be set equal to the CPGC#_CH#_SEQ_BASE_ADDR_Start.Column_Address:
    // 2. If Column_Base_Wrap_Carry_Enable is set bit to 1 a carry increment from the
    // Column Address (order N) will propagate to the N+1 order 
    // Address field(s).
    // 3. If Column_Base_Wrap_Trigger_Enable is set to 1 then an Address Wrap Trigger
    // has occurred which can be used in conjunction with Stop_On_Wrap_Trigger. 
    // expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used only
    // for DDRT addresses.  
    // 
    // Bits[20:3], RW_LB, default = 0x0
    //
    UINTX column_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Same as field [6:0] for Bank-Addr
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX bank_addr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRWRAP_LO1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRWRAP_LO2_MCMAIN_REG              0x00000B54
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // If the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address = CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address
    // then any further request to modify 
    // (increment or decrement) the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address immediately
    // causes a Wrap to occur with the following actions: 
    // 1. CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address must be set equal to the CPGC#_CH#_SEQ_BASE_ADDR_Start.Column_Address:
    // 2. If Column_Base_Wrap_Carry_Enable is set bit to 1 a carry increment from the
    // Column Address (order N) will propagate to the N+1 order 
    // Address field(s).
    // 3. If Column_Base_Wrap_Trigger_Enable is set to 1 then an Address Wrap Trigger
    // has occurred which can be used in conjunction with Stop_On_Wrap_Trigger. 
    // expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used only
    // for DDRT addresses.  
    // 
    // Bits[20:3], RW_LB, default = 0x0
    //
    UINTX column_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Same as field [6:0] for Bank-Addr
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX bank_addr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRWRAP_LO2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRWRAP_LO3_MCMAIN_REG              0x00000B58
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // If the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address = CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address
    // then any further request to modify 
    // (increment or decrement) the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address immediately
    // causes a Wrap to occur with the following actions: 
    // 1. CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column Address must be set equal to the CPGC#_CH#_SEQ_BASE_ADDR_Start.Column_Address:
    // 2. If Column_Base_Wrap_Carry_Enable is set bit to 1 a carry increment from the
    // Column Address (order N) will propagate to the N+1 order 
    // Address field(s).
    // 3. If Column_Base_Wrap_Trigger_Enable is set to 1 then an Address Wrap Trigger
    // has occurred which can be used in conjunction with Stop_On_Wrap_Trigger. 
    // expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used only
    // for DDRT addresses.  
    // 
    // Bits[20:3], RW_LB, default = 0x0
    //
    UINTX column_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Same as field [6:0] for Bank-Addr
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX bank_addr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRWRAP_LO3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRCURR_LO0_MCMAIN_REG              0x00000B5C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Current Column Address. Normally the lowest three column bits are reserved since
    // all transfers are done on a cacheline basis (8 chunks 0-7), 
    // but for implementations that address to a sub cacheline then these reserved bits
    // might be used as needed. 
    // expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used only
    // for DDRT addresses.  
    // 
    // Bits[20:3], RO_V, default = 0x0
    //
    UINTX column_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Current Bank Base Address
    // 
    // Bits[27:24], RO_V, default = 0x0
    //
    UINTX bank_addr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRCURR_LO0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRCURR_LO1_MCMAIN_REG              0x00000B60
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Current Column Address. Normally the lowest three column bits are reserved since
    // all transfers are done on a cacheline basis (8 chunks 0-7), 
    // but for implementations that address to a sub cacheline then these reserved bits
    // might be used as needed. 
    // expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used only
    // for DDRT addresses.  
    // 
    // Bits[20:3], RO_V, default = 0x0
    //
    UINTX column_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Current Bank Base Address
    // 
    // Bits[27:24], RO_V, default = 0x0
    //
    UINTX bank_addr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRCURR_LO1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRCURR_LO2_MCMAIN_REG              0x00000B64
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Current Column Address. Normally the lowest three column bits are reserved since
    // all transfers are done on a cacheline basis (8 chunks 0-7), 
    // but for implementations that address to a sub cacheline then these reserved bits
    // might be used as needed. 
    // expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used only
    // for DDRT addresses.  
    // 
    // Bits[20:3], RO_V, default = 0x0
    //
    UINTX column_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Current Bank Base Address
    // 
    // Bits[27:24], RO_V, default = 0x0
    //
    UINTX bank_addr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRCURR_LO2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRCURR_LO3_MCMAIN_REG              0x00000B68
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Current Column Address. Normally the lowest three column bits are reserved since
    // all transfers are done on a cacheline basis (8 chunks 0-7), 
    // but for implementations that address to a sub cacheline then these reserved bits
    // might be used as needed. 
    // expanded to 10 bits (cpgcbl4 support+14bit column ddr3). Bits 20:13 are used only
    // for DDRT addresses.  
    // 
    // Bits[20:3], RO_V, default = 0x0
    //
    UINTX column_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Current Bank Base Address
    // 
    // Bits[27:24], RO_V, default = 0x0
    //
    UINTX bank_addr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRCURR_LO3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BAOCIC0_MCMAIN_REG                       0x00000B6C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Determines the relative ordering of the Column address update logic in the nested
    // for loop in relation to the Rank, Bank, and Row 
    // address update logic. Any address fields set to the same order that roll over
    // will cause a distinct carry of 1 to the next higher order 
    // address field (multiple simultaneous carries will cause only one increment). All
    // fields can be arbitrarily placed in any order as long 
    // as all address order fields are set in a continuous order starting from 0 and
    // may not skip over an order number. 
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX column_addr_order : 2;
    //
    // Same as Column_Addr_Order for Row
    // 
    // Bits[3:2], RW_LB, default = 0x1
    //
    UINTX row_addr_order : 2;
    //
    // Same as Column_Addr_Order for Bank
    // 
    // Bits[5:4], RW_LB, default = 0x2
    //
    UINTX bank_addr_order : 2;
    //
    // Same as Column_Addr_Order for Rank
    // 
    // Bits[7:6], RW_LB, default = 0x3
    //
    UINTX rank_addr_order : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // Address_Update_Rate_Mode dictates whether the Base address inversion logic is
    // based on # of cachelines written and read or by 
    // Loopcount (# of sequences perfromed).
    // Address_Update_Rate_Mode = 0 means that the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT is
    // inverted based on 2^(Base_Address_Invert_Rate) read and 
    // write cacheline transactions.
    // Address_Update_Rate_Mode = 1 means that the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT is
    // inverted based on 2^(Base_Address_Invert_Rate) Loops through 
    // the Sequence.
    // 
    // Bits[16:13], RW_LB, default = 0x0
    //
    UINTX addr_inv_rate : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Setting Column_Base_Address_Invert_Enable bit = 1 will cause the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column
    // Address to be inverted 
    // every time 2^Base_Address_Invert_Rate cachelines are written or read or by Loopcount
    // (see Base_Address_Invert_Rate). 
    // One must consider the address update rate when using this field.
    // This feature is most often used for Memory array testing.
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX column_ba_inven : 1;
    //
    // Same as Column_Ba_Inven for Row
    // 
    // Bits[21:21], RW_LB, default = 0x0
    //
    UINTX row_ba_inven : 1;
    //
    // Same as Column_Ba_Inven for Bank
    // 
    // Bits[22:22], RW_LB, default = 0x0
    //
    UINTX bank_ba_inven : 1;
    //
    // Same as Column_Ba_Inven for Rank
    // 
    // Bits[23:23], RW_LB, default = 0x0
    //
    UINTX rank_ba_inven : 1;
    //
    // If a Base Column Address Wrap occurs (see CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address)
    // and Column_Base_Wrap_Trigger_Enable 
    // is set to 1 then an Address Wrap Trigger has occurred which can be used in conjunction
    // with Stop_On_Wrap_Trigger to stop a 
    // Subsequence or Sequence.
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX column_bw_trigen : 1;
    //
    // Same as Column_Bw_Trigen for Row
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX row_bw_trigen : 1;
    //
    // Same as Column_Bw_Trigen for Bank
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX bank_bw_trigen : 1;
    //
    // Same as Column_Bw_Trigen for Rank
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX rank_bw_trigen : 1;
    //
    // If a Base Column Address Wrap occurs (see CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address)
    // and Column_Base_Wrap_Carry_Enable 
    // is set to 1 then a carry increment from the Column Address (order N) will propagate
    // to the N+1 order Address field(s) . 
    // 
    // Bits[28:28], RW_LB, default = 0x1
    //
    UINTX column_bw_cryen : 1;
    //
    // Same as Column_Bw_Cryen for Row
    // 
    // Bits[29:29], RW_LB, default = 0x1
    //
    UINTX row_bw_cryen : 1;
    //
    // Same as Column_Bw_Cryen for Bank
    // 
    // Bits[30:30], RW_LB, default = 0x1
    //
    UINTX bank_bw_cryen : 1;
    //
    // Same as Column_Bw_Cryen for Rank
    // 
    // Bits[31:31], RW_LB, default = 0x1
    //
    UINTX rank_bw_cryen : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BAOCIC0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BAOCIC1_MCMAIN_REG                       0x00000B70
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Determines the relative ordering of the Column address update logic in the nested
    // for loop in relation to the Rank, Bank, and Row 
    // address update logic. Any address fields set to the same order that roll over
    // will cause a distinct carry of 1 to the next higher order 
    // address field (multiple simultaneous carries will cause only one increment). All
    // fields can be arbitrarily placed in any order as long 
    // as all address order fields are set in a continuous order starting from 0 and
    // may not skip over an order number. 
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX column_addr_order : 2;
    //
    // Same as Column_Addr_Order for Row
    // 
    // Bits[3:2], RW_LB, default = 0x1
    //
    UINTX row_addr_order : 2;
    //
    // Same as Column_Addr_Order for Bank
    // 
    // Bits[5:4], RW_LB, default = 0x2
    //
    UINTX bank_addr_order : 2;
    //
    // Same as Column_Addr_Order for Rank
    // 
    // Bits[7:6], RW_LB, default = 0x3
    //
    UINTX rank_addr_order : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // Address_Update_Rate_Mode dictates whether the Base address inversion logic is
    // based on # of cachelines written and read or by 
    // Loopcount (# of sequences perfromed).
    // Address_Update_Rate_Mode = 0 means that the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT is
    // inverted based on 2^(Base_Address_Invert_Rate) read and 
    // write cacheline transactions.
    // Address_Update_Rate_Mode = 1 means that the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT is
    // inverted based on 2^(Base_Address_Invert_Rate) Loops through 
    // the Sequence.
    // 
    // Bits[16:13], RW_LB, default = 0x0
    //
    UINTX addr_inv_rate : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Setting Column_Base_Address_Invert_Enable bit = 1 will cause the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column
    // Address to be inverted 
    // every time 2^Base_Address_Invert_Rate cachelines are written or read or by Loopcount
    // (see Base_Address_Invert_Rate). 
    // One must consider the address update rate when using this field.
    // This feature is most often used for Memory array testing.
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX column_ba_inven : 1;
    //
    // Same as Column_Ba_Inven for Row
    // 
    // Bits[21:21], RW_LB, default = 0x0
    //
    UINTX row_ba_inven : 1;
    //
    // Same as Column_Ba_Inven for Bank
    // 
    // Bits[22:22], RW_LB, default = 0x0
    //
    UINTX bank_ba_inven : 1;
    //
    // Same as Column_Ba_Inven for Rank
    // 
    // Bits[23:23], RW_LB, default = 0x0
    //
    UINTX rank_ba_inven : 1;
    //
    // If a Base Column Address Wrap occurs (see CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address)
    // and Column_Base_Wrap_Trigger_Enable 
    // is set to 1 then an Address Wrap Trigger has occurred which can be used in conjunction
    // with Stop_On_Wrap_Trigger to stop a 
    // Subsequence or Sequence.
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX column_bw_trigen : 1;
    //
    // Same as Column_Bw_Trigen for Row
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX row_bw_trigen : 1;
    //
    // Same as Column_Bw_Trigen for Bank
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX bank_bw_trigen : 1;
    //
    // Same as Column_Bw_Trigen for Rank
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX rank_bw_trigen : 1;
    //
    // If a Base Column Address Wrap occurs (see CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address)
    // and Column_Base_Wrap_Carry_Enable 
    // is set to 1 then a carry increment from the Column Address (order N) will propagate
    // to the N+1 order Address field(s) . 
    // 
    // Bits[28:28], RW_LB, default = 0x1
    //
    UINTX column_bw_cryen : 1;
    //
    // Same as Column_Bw_Cryen for Row
    // 
    // Bits[29:29], RW_LB, default = 0x1
    //
    UINTX row_bw_cryen : 1;
    //
    // Same as Column_Bw_Cryen for Bank
    // 
    // Bits[30:30], RW_LB, default = 0x1
    //
    UINTX bank_bw_cryen : 1;
    //
    // Same as Column_Bw_Cryen for Rank
    // 
    // Bits[31:31], RW_LB, default = 0x1
    //
    UINTX rank_bw_cryen : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BAOCIC1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BAOCIC2_MCMAIN_REG                       0x00000B74
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Determines the relative ordering of the Column address update logic in the nested
    // for loop in relation to the Rank, Bank, and Row 
    // address update logic. Any address fields set to the same order that roll over
    // will cause a distinct carry of 1 to the next higher order 
    // address field (multiple simultaneous carries will cause only one increment). All
    // fields can be arbitrarily placed in any order as long 
    // as all address order fields are set in a continuous order starting from 0 and
    // may not skip over an order number. 
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX column_addr_order : 2;
    //
    // Same as Column_Addr_Order for Row
    // 
    // Bits[3:2], RW_LB, default = 0x1
    //
    UINTX row_addr_order : 2;
    //
    // Same as Column_Addr_Order for Bank
    // 
    // Bits[5:4], RW_LB, default = 0x2
    //
    UINTX bank_addr_order : 2;
    //
    // Same as Column_Addr_Order for Rank
    // 
    // Bits[7:6], RW_LB, default = 0x3
    //
    UINTX rank_addr_order : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // Address_Update_Rate_Mode dictates whether the Base address inversion logic is
    // based on # of cachelines written and read or by 
    // Loopcount (# of sequences perfromed).
    // Address_Update_Rate_Mode = 0 means that the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT is
    // inverted based on 2^(Base_Address_Invert_Rate) read and 
    // write cacheline transactions.
    // Address_Update_Rate_Mode = 1 means that the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT is
    // inverted based on 2^(Base_Address_Invert_Rate) Loops through 
    // the Sequence.
    // 
    // Bits[16:13], RW_LB, default = 0x0
    //
    UINTX addr_inv_rate : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Setting Column_Base_Address_Invert_Enable bit = 1 will cause the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column
    // Address to be inverted 
    // every time 2^Base_Address_Invert_Rate cachelines are written or read or by Loopcount
    // (see Base_Address_Invert_Rate). 
    // One must consider the address update rate when using this field.
    // This feature is most often used for Memory array testing.
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX column_ba_inven : 1;
    //
    // Same as Column_Ba_Inven for Row
    // 
    // Bits[21:21], RW_LB, default = 0x0
    //
    UINTX row_ba_inven : 1;
    //
    // Same as Column_Ba_Inven for Bank
    // 
    // Bits[22:22], RW_LB, default = 0x0
    //
    UINTX bank_ba_inven : 1;
    //
    // Same as Column_Ba_Inven for Rank
    // 
    // Bits[23:23], RW_LB, default = 0x0
    //
    UINTX rank_ba_inven : 1;
    //
    // If a Base Column Address Wrap occurs (see CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address)
    // and Column_Base_Wrap_Trigger_Enable 
    // is set to 1 then an Address Wrap Trigger has occurred which can be used in conjunction
    // with Stop_On_Wrap_Trigger to stop a 
    // Subsequence or Sequence.
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX column_bw_trigen : 1;
    //
    // Same as Column_Bw_Trigen for Row
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX row_bw_trigen : 1;
    //
    // Same as Column_Bw_Trigen for Bank
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX bank_bw_trigen : 1;
    //
    // Same as Column_Bw_Trigen for Rank
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX rank_bw_trigen : 1;
    //
    // If a Base Column Address Wrap occurs (see CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address)
    // and Column_Base_Wrap_Carry_Enable 
    // is set to 1 then a carry increment from the Column Address (order N) will propagate
    // to the N+1 order Address field(s) . 
    // 
    // Bits[28:28], RW_LB, default = 0x1
    //
    UINTX column_bw_cryen : 1;
    //
    // Same as Column_Bw_Cryen for Row
    // 
    // Bits[29:29], RW_LB, default = 0x1
    //
    UINTX row_bw_cryen : 1;
    //
    // Same as Column_Bw_Cryen for Bank
    // 
    // Bits[30:30], RW_LB, default = 0x1
    //
    UINTX bank_bw_cryen : 1;
    //
    // Same as Column_Bw_Cryen for Rank
    // 
    // Bits[31:31], RW_LB, default = 0x1
    //
    UINTX rank_bw_cryen : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BAOCIC2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BAOCIC3_MCMAIN_REG                       0x00000B78
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Determines the relative ordering of the Column address update logic in the nested
    // for loop in relation to the Rank, Bank, and Row 
    // address update logic. Any address fields set to the same order that roll over
    // will cause a distinct carry of 1 to the next higher order 
    // address field (multiple simultaneous carries will cause only one increment). All
    // fields can be arbitrarily placed in any order as long 
    // as all address order fields are set in a continuous order starting from 0 and
    // may not skip over an order number. 
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX column_addr_order : 2;
    //
    // Same as Column_Addr_Order for Row
    // 
    // Bits[3:2], RW_LB, default = 0x1
    //
    UINTX row_addr_order : 2;
    //
    // Same as Column_Addr_Order for Bank
    // 
    // Bits[5:4], RW_LB, default = 0x2
    //
    UINTX bank_addr_order : 2;
    //
    // Same as Column_Addr_Order for Rank
    // 
    // Bits[7:6], RW_LB, default = 0x3
    //
    UINTX rank_addr_order : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // Address_Update_Rate_Mode dictates whether the Base address inversion logic is
    // based on # of cachelines written and read or by 
    // Loopcount (# of sequences perfromed).
    // Address_Update_Rate_Mode = 0 means that the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT is
    // inverted based on 2^(Base_Address_Invert_Rate) read and 
    // write cacheline transactions.
    // Address_Update_Rate_Mode = 1 means that the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT is
    // inverted based on 2^(Base_Address_Invert_Rate) Loops through 
    // the Sequence.
    // 
    // Bits[16:13], RW_LB, default = 0x0
    //
    UINTX addr_inv_rate : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Setting Column_Base_Address_Invert_Enable bit = 1 will cause the CPGC#_CH#_SEQ_BASE_ADDR_CURRENT.Column
    // Address to be inverted 
    // every time 2^Base_Address_Invert_Rate cachelines are written or read or by Loopcount
    // (see Base_Address_Invert_Rate). 
    // One must consider the address update rate when using this field.
    // This feature is most often used for Memory array testing.
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX column_ba_inven : 1;
    //
    // Same as Column_Ba_Inven for Row
    // 
    // Bits[21:21], RW_LB, default = 0x0
    //
    UINTX row_ba_inven : 1;
    //
    // Same as Column_Ba_Inven for Bank
    // 
    // Bits[22:22], RW_LB, default = 0x0
    //
    UINTX bank_ba_inven : 1;
    //
    // Same as Column_Ba_Inven for Rank
    // 
    // Bits[23:23], RW_LB, default = 0x0
    //
    UINTX rank_ba_inven : 1;
    //
    // If a Base Column Address Wrap occurs (see CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address)
    // and Column_Base_Wrap_Trigger_Enable 
    // is set to 1 then an Address Wrap Trigger has occurred which can be used in conjunction
    // with Stop_On_Wrap_Trigger to stop a 
    // Subsequence or Sequence.
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX column_bw_trigen : 1;
    //
    // Same as Column_Bw_Trigen for Row
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX row_bw_trigen : 1;
    //
    // Same as Column_Bw_Trigen for Bank
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX bank_bw_trigen : 1;
    //
    // Same as Column_Bw_Trigen for Rank
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX rank_bw_trigen : 1;
    //
    // If a Base Column Address Wrap occurs (see CPGC#_CH#_SEQ_BASE_ADDR_WRAP.Column_Address)
    // and Column_Base_Wrap_Carry_Enable 
    // is set to 1 then a carry increment from the Column Address (order N) will propagate
    // to the N+1 order Address field(s) . 
    // 
    // Bits[28:28], RW_LB, default = 0x1
    //
    UINTX column_bw_cryen : 1;
    //
    // Same as Column_Bw_Cryen for Row
    // 
    // Bits[29:29], RW_LB, default = 0x1
    //
    UINTX row_bw_cryen : 1;
    //
    // Same as Column_Bw_Cryen for Bank
    // 
    // Bits[30:30], RW_LB, default = 0x1
    //
    UINTX bank_bw_cryen : 1;
    //
    // Same as Column_Bw_Cryen for Rank
    // 
    // Bits[31:31], RW_LB, default = 0x1
    //
    UINTX rank_bw_cryen : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BAOCIC3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BAINCCTL00_MCMAIN_REG                    0x00000B7C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When dictated by Column Address Update Rate the current Column Address will be
    // modified by the Column Address Increment 
    // (which is a 2's compliment field).
    // A value of 0x0 means the Column Address Increment is effectively disabled since
    // no offset will be applied. 
    // Disabling the Column Address Increment by setting Column Address Increment to
    // 0x0 does not affect a carry from a lower order 
    // field rolling over to a higher order field which will also result in an increment
    // to the higher order field of 1. 
    // 
    // Bits[7:0], RW_LB, default = 0x0
    //
    UINTX column_ba_inc : 8;
    //
    // In linear mode (see Column_Address_Update_Rate_Scale setting), this field +1 defines
    // how many times a specific Column address is repeated 
    // before adding the Column_Base_Address_Increment.
    // In exponential mode, 2^(value in this field) defines how many times a specific
    // Rank address is repeated before adding the 
    // Column_Base_Address_Increment.
    // CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode dictates whether the address increment
    // logic is driven by either the # of cachelines written and 
    // read or by Loopcount (# of sequences performed).
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX column_ba_updrate : 5;
    //
    // 1= Column Address Update Rate is a linear number, 0 = Column Address Update Rate
    // is an exponential number 
    // 
    // Bits[13:13], RW_LB, default = 0x0
    //
    UINTX column_ba_updscale : 1;
    //
    // Same as Column_Ba_Inc for Row
    // 
    // Bits[25:14], RW_LB, default = 0x0
    //
    UINTX row_ba_inc : 12;
    //
    // Same as Column_Ba_Updrate for Row
    // 
    // Bits[30:26], RW_LB, default = 0x0
    //
    UINTX row_ba_updrate : 5;
    //
    // Same as Column_Ba_Updscale for Row
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX row_ba_updscale : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BAINCCTL00_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BAINCCTL10_MCMAIN_REG                    0x00000B80
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Same as Column_Ba_Inc for Bank
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX bank_ba_inc : 4;
    //
    // Same as Column_Ba_Updrate for Bank
    // 
    // Bits[8:4], RW_LB, default = 0x0
    //
    UINTX bank_ba_updrate : 5;
    //
    // Same as Column_Ba_Updscale for Bank
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX bank_ba_updscale : 1;
    //
    // Same as Column_Ba_Inc for Rank
    // 
    // Bits[12:10], RW_LB, default = 0x0
    //
    UINTX rank_ba_inc : 3;
    //
    // Same as Column_Ba_Updrate for Rank
    // 
    // Bits[17:13], RW_LB, default = 0x0
    //
    UINTX rank_ba_updrate : 5;
    //
    // Same as Column_Ba_Updscale for Rank
    // 
    // Bits[18:18], RW_LB, default = 0x0
    //
    UINTX rank_ba_updscale : 1;
    //
    // MSB of CPGC_SEQ_BAINCCTL00. Bits 28:21 should be 0 for DDR4 and should be programmed
    // only for DDRT training  
    // 
    // Bits[28:19], RW_LB, default = 0x0
    //
    UINTX column_ba_inc_msb : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BAINCCTL10_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BAINCCTL01_MCMAIN_REG                    0x00000B84
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When dictated by Column Address Update Rate the current Column Address will be
    // modified by the Column Address Increment 
    // (which is a 2's compliment field).
    // A value of 0x0 means the Column Address Increment is effectively disabled since
    // no offset will be applied. 
    // Disabling the Column Address Increment by setting Column Address Increment to
    // 0x0 does not affect a carry from a lower order 
    // field rolling over to a higher order field which will also result in an increment
    // to the higher order field of 1. 
    // 
    // Bits[7:0], RW_LB, default = 0x0
    //
    UINTX column_ba_inc : 8;
    //
    // In linear mode (see Column_Address_Update_Rate_Scale setting), this field +1 defines
    // how many times a specific Column address is repeated 
    // before adding the Column_Base_Address_Increment.
    // In exponential mode, 2^(value in this field) defines how many times a specific
    // Rank address is repeated before adding the 
    // Column_Base_Address_Increment.
    // CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode dictates whether the address increment
    // logic is driven by either the # of cachelines written and 
    // read or by Loopcount (# of sequences performed).
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX column_ba_updrate : 5;
    //
    // 1= Column Address Update Rate is a linear number, 0 = Column Address Update Rate
    // is an exponential number 
    // 
    // Bits[13:13], RW_LB, default = 0x0
    //
    UINTX column_ba_updscale : 1;
    //
    // Same as Column_Ba_Inc for Row
    // 
    // Bits[25:14], RW_LB, default = 0x0
    //
    UINTX row_ba_inc : 12;
    //
    // Same as Column_Ba_Updrate for Row
    // 
    // Bits[30:26], RW_LB, default = 0x0
    //
    UINTX row_ba_updrate : 5;
    //
    // Same as Column_Ba_Updscale for Row
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX row_ba_updscale : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BAINCCTL01_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BAINCCTL11_MCMAIN_REG                    0x00000B88
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Same as Column_Ba_Inc for Bank
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX bank_ba_inc : 4;
    //
    // Same as Column_Ba_Updrate for Bank
    // 
    // Bits[8:4], RW_LB, default = 0x0
    //
    UINTX bank_ba_updrate : 5;
    //
    // Same as Column_Ba_Updscale for Bank
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX bank_ba_updscale : 1;
    //
    // Same as Column_Ba_Inc for Rank
    // 
    // Bits[12:10], RW_LB, default = 0x0
    //
    UINTX rank_ba_inc : 3;
    //
    // Same as Column_Ba_Updrate for Rank
    // 
    // Bits[17:13], RW_LB, default = 0x0
    //
    UINTX rank_ba_updrate : 5;
    //
    // Same as Column_Ba_Updscale for Rank
    // 
    // Bits[18:18], RW_LB, default = 0x0
    //
    UINTX rank_ba_updscale : 1;
    //
    // MSB of CPGC_SEQ_BAINCCTL00. Bits 28:21 should be 0 for DDR4 and should be programmed
    // only for DDRT training  
    // 
    // Bits[28:19], RW_LB, default = 0x0
    //
    UINTX column_ba_inc_msb : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BAINCCTL11_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BAINCCTL02_MCMAIN_REG                    0x00000B8C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When dictated by Column Address Update Rate the current Column Address will be
    // modified by the Column Address Increment 
    // (which is a 2's compliment field).
    // A value of 0x0 means the Column Address Increment is effectively disabled since
    // no offset will be applied. 
    // Disabling the Column Address Increment by setting Column Address Increment to
    // 0x0 does not affect a carry from a lower order 
    // field rolling over to a higher order field which will also result in an increment
    // to the higher order field of 1. 
    // 
    // Bits[7:0], RW_LB, default = 0x0
    //
    UINTX column_ba_inc : 8;
    //
    // In linear mode (see Column_Address_Update_Rate_Scale setting), this field +1 defines
    // how many times a specific Column address is repeated 
    // before adding the Column_Base_Address_Increment.
    // In exponential mode, 2^(value in this field) defines how many times a specific
    // Rank address is repeated before adding the 
    // Column_Base_Address_Increment.
    // CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode dictates whether the address increment
    // logic is driven by either the # of cachelines written and 
    // read or by Loopcount (# of sequences performed).
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX column_ba_updrate : 5;
    //
    // 1= Column Address Update Rate is a linear number, 0 = Column Address Update Rate
    // is an exponential number 
    // 
    // Bits[13:13], RW_LB, default = 0x0
    //
    UINTX column_ba_updscale : 1;
    //
    // Same as Column_Ba_Inc for Row
    // 
    // Bits[25:14], RW_LB, default = 0x0
    //
    UINTX row_ba_inc : 12;
    //
    // Same as Column_Ba_Updrate for Row
    // 
    // Bits[30:26], RW_LB, default = 0x0
    //
    UINTX row_ba_updrate : 5;
    //
    // Same as Column_Ba_Updscale for Row
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX row_ba_updscale : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BAINCCTL02_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BAINCCTL12_MCMAIN_REG                    0x00000B90
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Same as Column_Ba_Inc for Bank
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX bank_ba_inc : 4;
    //
    // Same as Column_Ba_Updrate for Bank
    // 
    // Bits[8:4], RW_LB, default = 0x0
    //
    UINTX bank_ba_updrate : 5;
    //
    // Same as Column_Ba_Updscale for Bank
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX bank_ba_updscale : 1;
    //
    // Same as Column_Ba_Inc for Rank
    // 
    // Bits[12:10], RW_LB, default = 0x0
    //
    UINTX rank_ba_inc : 3;
    //
    // Same as Column_Ba_Updrate for Rank
    // 
    // Bits[17:13], RW_LB, default = 0x0
    //
    UINTX rank_ba_updrate : 5;
    //
    // Same as Column_Ba_Updscale for Rank
    // 
    // Bits[18:18], RW_LB, default = 0x0
    //
    UINTX rank_ba_updscale : 1;
    //
    // MSB of CPGC_SEQ_BAINCCTL00. Bits 28:21 should be 0 for DDR4 and should be programmed
    // only for DDRT training  
    // 
    // Bits[28:19], RW_LB, default = 0x0
    //
    UINTX column_ba_inc_msb : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BAINCCTL12_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BAINCCTL03_MCMAIN_REG                    0x00000B94
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When dictated by Column Address Update Rate the current Column Address will be
    // modified by the Column Address Increment 
    // (which is a 2's compliment field).
    // A value of 0x0 means the Column Address Increment is effectively disabled since
    // no offset will be applied. 
    // Disabling the Column Address Increment by setting Column Address Increment to
    // 0x0 does not affect a carry from a lower order 
    // field rolling over to a higher order field which will also result in an increment
    // to the higher order field of 1. 
    // 
    // Bits[7:0], RW_LB, default = 0x0
    //
    UINTX column_ba_inc : 8;
    //
    // In linear mode (see Column_Address_Update_Rate_Scale setting), this field +1 defines
    // how many times a specific Column address is repeated 
    // before adding the Column_Base_Address_Increment.
    // In exponential mode, 2^(value in this field) defines how many times a specific
    // Rank address is repeated before adding the 
    // Column_Base_Address_Increment.
    // CPGC#_CH#_SEQ_CTL.Address_Update_Rate_Mode dictates whether the address increment
    // logic is driven by either the # of cachelines written and 
    // read or by Loopcount (# of sequences performed).
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX column_ba_updrate : 5;
    //
    // 1= Column Address Update Rate is a linear number, 0 = Column Address Update Rate
    // is an exponential number 
    // 
    // Bits[13:13], RW_LB, default = 0x0
    //
    UINTX column_ba_updscale : 1;
    //
    // Same as Column_Ba_Inc for Row
    // 
    // Bits[25:14], RW_LB, default = 0x0
    //
    UINTX row_ba_inc : 12;
    //
    // Same as Column_Ba_Updrate for Row
    // 
    // Bits[30:26], RW_LB, default = 0x0
    //
    UINTX row_ba_updrate : 5;
    //
    // Same as Column_Ba_Updscale for Row
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX row_ba_updscale : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BAINCCTL03_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BAINCCTL13_MCMAIN_REG                    0x00000B98
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Same as Column_Ba_Inc for Bank
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX bank_ba_inc : 4;
    //
    // Same as Column_Ba_Updrate for Bank
    // 
    // Bits[8:4], RW_LB, default = 0x0
    //
    UINTX bank_ba_updrate : 5;
    //
    // Same as Column_Ba_Updscale for Bank
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX bank_ba_updscale : 1;
    //
    // Same as Column_Ba_Inc for Rank
    // 
    // Bits[12:10], RW_LB, default = 0x0
    //
    UINTX rank_ba_inc : 3;
    //
    // Same as Column_Ba_Updrate for Rank
    // 
    // Bits[17:13], RW_LB, default = 0x0
    //
    UINTX rank_ba_updrate : 5;
    //
    // Same as Column_Ba_Updscale for Rank
    // 
    // Bits[18:18], RW_LB, default = 0x0
    //
    UINTX rank_ba_updscale : 1;
    //
    // MSB of CPGC_SEQ_BAINCCTL00. Bits 28:21 should be 0 for DDR4 and should be programmed
    // only for DDRT training  
    // 
    // Bits[28:19], RW_LB, default = 0x0
    //
    UINTX column_ba_inc_msb : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BAINCCTL13_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_OFFADDRCUR0_MCMAIN_REG                   0x00000B9C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current Column Offset Address. Normally, the lowest three column bits are reserved
    // since all transfers are done on a 
    // cacheline basis (8 chunks 0-7), but for implementations that address to a sub
    // cacheline then these reserved bits might be used as needed. 
    // expanded to 10 bits (cpgcbl4 support+14bit column ddr3)
    // 
    // Bits[17:0], RO_V, default = 0x0
    //
    UINTX col_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
  } Bits;
  UINTX Data;
} CPGC_SEQ_OFFADDRCUR0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_OFFADDRCUR1_MCMAIN_REG                   0x00000BA0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current Column Offset Address. Normally, the lowest three column bits are reserved
    // since all transfers are done on a 
    // cacheline basis (8 chunks 0-7), but for implementations that address to a sub
    // cacheline then these reserved bits might be used as needed. 
    // expanded to 10 bits (cpgcbl4 support+14bit column ddr3)
    // 
    // Bits[17:0], RO_V, default = 0x0
    //
    UINTX col_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
  } Bits;
  UINTX Data;
} CPGC_SEQ_OFFADDRCUR1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_OFFADDRCUR2_MCMAIN_REG                   0x00000BA4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current Column Offset Address. Normally, the lowest three column bits are reserved
    // since all transfers are done on a 
    // cacheline basis (8 chunks 0-7), but for implementations that address to a sub
    // cacheline then these reserved bits might be used as needed. 
    // expanded to 10 bits (cpgcbl4 support+14bit column ddr3)
    // 
    // Bits[17:0], RO_V, default = 0x0
    //
    UINTX col_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
  } Bits;
  UINTX Data;
} CPGC_SEQ_OFFADDRCUR2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_OFFADDRCUR3_MCMAIN_REG                   0x00000BA8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current Column Offset Address. Normally, the lowest three column bits are reserved
    // since all transfers are done on a 
    // cacheline basis (8 chunks 0-7), but for implementations that address to a sub
    // cacheline then these reserved bits might be used as needed. 
    // expanded to 10 bits (cpgcbl4 support+14bit column ddr3)
    // 
    // Bits[17:0], RO_V, default = 0x0
    //
    UINTX col_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
  } Bits;
  UINTX Data;
} CPGC_SEQ_OFFADDRCUR3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_RANKLG2PHYMAP0_MCMAIN_REG                0x00000BAC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Defines what Physical Rank Address (Memory controller Rank Mapping) is mapped
    // to this logical Rank Address-0 
    // (Sequence Address logic doamin).
    // It is possible to use more Logical_to_Physical_Rank#_Mapping fileds than actual
    // Physical Ranks which is useful for more complex 
    // tests where non linear Physical Rank Sequences are needed.
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX rank0_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Rank Address-1 mapping
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX rank1_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Rank Address-2 mapping
    // 
    // Bits[10:8], RW_LB, default = 0x0
    //
    UINTX rank2_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Rank Address-3 mapping
    // 
    // Bits[14:12], RW_LB, default = 0x0
    //
    UINTX rank3_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // Rank Address-4 mapping
    // 
    // Bits[18:16], RW_LB, default = 0x0
    //
    UINTX rank4_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Rank Address-5 mapping
    // 
    // Bits[22:20], RW_LB, default = 0x0
    //
    UINTX rank5_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Rank Address-6 mapping
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX rank6_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
    //
    // Rank Address-7 mapping
    // 
    // Bits[30:28], RW_LB, default = 0x0
    //
    UINTX rank7_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_7 : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQ_RANKLG2PHYMAP0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_RANKLG2PHYMAP1_MCMAIN_REG                0x00000BB0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Defines what Physical Rank Address (Memory controller Rank Mapping) is mapped
    // to this logical Rank Address-0 
    // (Sequence Address logic doamin).
    // It is possible to use more Logical_to_Physical_Rank#_Mapping fileds than actual
    // Physical Ranks which is useful for more complex 
    // tests where non linear Physical Rank Sequences are needed.
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX rank0_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Rank Address-1 mapping
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX rank1_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Rank Address-2 mapping
    // 
    // Bits[10:8], RW_LB, default = 0x0
    //
    UINTX rank2_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Rank Address-3 mapping
    // 
    // Bits[14:12], RW_LB, default = 0x0
    //
    UINTX rank3_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // Rank Address-4 mapping
    // 
    // Bits[18:16], RW_LB, default = 0x0
    //
    UINTX rank4_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Rank Address-5 mapping
    // 
    // Bits[22:20], RW_LB, default = 0x0
    //
    UINTX rank5_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Rank Address-6 mapping
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX rank6_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
    //
    // Rank Address-7 mapping
    // 
    // Bits[30:28], RW_LB, default = 0x0
    //
    UINTX rank7_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_7 : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQ_RANKLG2PHYMAP1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_RANKLG2PHYMAP2_MCMAIN_REG                0x00000BB4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Defines what Physical Rank Address (Memory controller Rank Mapping) is mapped
    // to this logical Rank Address-0 
    // (Sequence Address logic doamin).
    // It is possible to use more Logical_to_Physical_Rank#_Mapping fileds than actual
    // Physical Ranks which is useful for more complex 
    // tests where non linear Physical Rank Sequences are needed.
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX rank0_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Rank Address-1 mapping
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX rank1_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Rank Address-2 mapping
    // 
    // Bits[10:8], RW_LB, default = 0x0
    //
    UINTX rank2_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Rank Address-3 mapping
    // 
    // Bits[14:12], RW_LB, default = 0x0
    //
    UINTX rank3_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // Rank Address-4 mapping
    // 
    // Bits[18:16], RW_LB, default = 0x0
    //
    UINTX rank4_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Rank Address-5 mapping
    // 
    // Bits[22:20], RW_LB, default = 0x0
    //
    UINTX rank5_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Rank Address-6 mapping
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX rank6_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
    //
    // Rank Address-7 mapping
    // 
    // Bits[30:28], RW_LB, default = 0x0
    //
    UINTX rank7_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_7 : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQ_RANKLG2PHYMAP2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_RANKLG2PHYMAP3_MCMAIN_REG                0x00000BB8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Defines what Physical Rank Address (Memory controller Rank Mapping) is mapped
    // to this logical Rank Address-0 
    // (Sequence Address logic doamin).
    // It is possible to use more Logical_to_Physical_Rank#_Mapping fileds than actual
    // Physical Ranks which is useful for more complex 
    // tests where non linear Physical Rank Sequences are needed.
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX rank0_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Rank Address-1 mapping
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX rank1_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Rank Address-2 mapping
    // 
    // Bits[10:8], RW_LB, default = 0x0
    //
    UINTX rank2_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Rank Address-3 mapping
    // 
    // Bits[14:12], RW_LB, default = 0x0
    //
    UINTX rank3_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // Rank Address-4 mapping
    // 
    // Bits[18:16], RW_LB, default = 0x0
    //
    UINTX rank4_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Rank Address-5 mapping
    // 
    // Bits[22:20], RW_LB, default = 0x0
    //
    UINTX rank5_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Rank Address-6 mapping
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX rank6_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
    //
    // Rank Address-7 mapping
    // 
    // Bits[30:28], RW_LB, default = 0x0
    //
    UINTX rank7_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_7 : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQ_RANKLG2PHYMAP3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_RASL0_MCMAIN_REG                         0x00000BBC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Defines how a particular logical Row Bit is remapped to a Physical Row Address.
    // The bits are essentially swizzled with each other. 
    // Remapping the lower Row bits allows one to more effectively test adjacent rows
    // in a DRAM when the Row swizzling is used within the DRAM. 
    // Remapping any two or more row bits to the same value is not allowed and the behavior
    // is undefined. 
    // Remapping is a 2 step process with a write required to both CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER
    // and CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER 
    // Example using Logical Row Bit X:
    // If a swizzle between X and Y is desired then
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle must be
    // set to Y 
    // And
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle must be
    // set to X 
    // Note:
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle can be only
    // be set to equal itself or the largest 
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle value
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX log2phy_row0_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[9:5], RW_LB, default = 0x1
    //
    UINTX log2phy_row1_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[14:10], RW_LB, default = 0x2
    //
    UINTX log2phy_row2_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[19:15], RW_LB, default = 0x3
    //
    UINTX log2phy_row3_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[24:20], RW_LB, default = 0x4
    //
    UINTX log2phy_row4_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[29:25], RW_LB, default = 0x5
    //
    UINTX log2phy_row5_swzl : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SEQ_RASL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_RASL1_MCMAIN_REG                         0x00000BC0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Defines how a particular logical Row Bit is remapped to a Physical Row Address.
    // The bits are essentially swizzled with each other. 
    // Remapping the lower Row bits allows one to more effectively test adjacent rows
    // in a DRAM when the Row swizzling is used within the DRAM. 
    // Remapping any two or more row bits to the same value is not allowed and the behavior
    // is undefined. 
    // Remapping is a 2 step process with a write required to both CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER
    // and CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER 
    // Example using Logical Row Bit X:
    // If a swizzle between X and Y is desired then
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle must be
    // set to Y 
    // And
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle must be
    // set to X 
    // Note:
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle can be only
    // be set to equal itself or the largest 
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle value
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX log2phy_row0_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[9:5], RW_LB, default = 0x1
    //
    UINTX log2phy_row1_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[14:10], RW_LB, default = 0x2
    //
    UINTX log2phy_row2_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[19:15], RW_LB, default = 0x3
    //
    UINTX log2phy_row3_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[24:20], RW_LB, default = 0x4
    //
    UINTX log2phy_row4_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[29:25], RW_LB, default = 0x5
    //
    UINTX log2phy_row5_swzl : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SEQ_RASL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_RASL2_MCMAIN_REG                         0x00000BC4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Defines how a particular logical Row Bit is remapped to a Physical Row Address.
    // The bits are essentially swizzled with each other. 
    // Remapping the lower Row bits allows one to more effectively test adjacent rows
    // in a DRAM when the Row swizzling is used within the DRAM. 
    // Remapping any two or more row bits to the same value is not allowed and the behavior
    // is undefined. 
    // Remapping is a 2 step process with a write required to both CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER
    // and CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER 
    // Example using Logical Row Bit X:
    // If a swizzle between X and Y is desired then
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle must be
    // set to Y 
    // And
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle must be
    // set to X 
    // Note:
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle can be only
    // be set to equal itself or the largest 
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle value
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX log2phy_row0_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[9:5], RW_LB, default = 0x1
    //
    UINTX log2phy_row1_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[14:10], RW_LB, default = 0x2
    //
    UINTX log2phy_row2_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[19:15], RW_LB, default = 0x3
    //
    UINTX log2phy_row3_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[24:20], RW_LB, default = 0x4
    //
    UINTX log2phy_row4_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[29:25], RW_LB, default = 0x5
    //
    UINTX log2phy_row5_swzl : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SEQ_RASL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_RASL3_MCMAIN_REG                         0x00000BC8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Defines how a particular logical Row Bit is remapped to a Physical Row Address.
    // The bits are essentially swizzled with each other. 
    // Remapping the lower Row bits allows one to more effectively test adjacent rows
    // in a DRAM when the Row swizzling is used within the DRAM. 
    // Remapping any two or more row bits to the same value is not allowed and the behavior
    // is undefined. 
    // Remapping is a 2 step process with a write required to both CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER
    // and CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER 
    // Example using Logical Row Bit X:
    // If a swizzle between X and Y is desired then
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle must be
    // set to Y 
    // And
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle must be
    // set to X 
    // Note:
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle can be only
    // be set to equal itself or the largest 
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle value
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX log2phy_row0_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[9:5], RW_LB, default = 0x1
    //
    UINTX log2phy_row1_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[14:10], RW_LB, default = 0x2
    //
    UINTX log2phy_row2_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[19:15], RW_LB, default = 0x3
    //
    UINTX log2phy_row3_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[24:20], RW_LB, default = 0x4
    //
    UINTX log2phy_row4_swzl : 5;
    //
    // Refer to Log2phy_Row1_Swzl for details
    // 
    // Bits[29:25], RW_LB, default = 0x5
    //
    UINTX log2phy_row5_swzl : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SEQ_RASL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_RASU00_MCMAIN_REG                        0x00000BCC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Defines how a particular logical Row Bit is remapped to a Physical Row Address.
    // The bits are essentially swizzled with each other. 
    // Example using Logical Row Bit X:
    // If a Logical_to_Physical_RowX_Swizzle = Y then this implies that
    // Physical Row bit Y = X
    // Physical Row bit X = Y
    // Remapping Row bits allows one to more effectively test adjacent rows in a DRAM
    // when the Row swizzling is used within the DRAM. 
    // Remapping any two or more row bits to the same value is not allowed and the behavior
    // is undefined. 
    // 
    // Bits[4:0], RW_LB, default = 0x6
    //
    UINTX log2phy_row6_swzl : 5;
    //
    // Refer to Log2phy_Row6_Swzl for details
    // 
    // Bits[9:5], RW_LB, default = 0x7
    //
    UINTX log2phy_row7_swzl : 5;
    //
    // Refer to Log2phy_Row6_Swzl for details
    // 
    // Bits[14:10], RW_LB, default = 0x8
    //
    UINTX log2phy_row8_swzl : 5;
    //
    // Refer to Log2phy_Row6_Swzl for details
    // 
    // Bits[19:15], RW_LB, default = 0x9
    //
    UINTX log2phy_row9_swzl : 5;
    //
    // Refer to Log2phy_Row6_Swzl for details
    // 
    // Bits[24:20], RW_LB, default = 0xA
    //
    UINTX log2phy_row10_swzl : 5;
    //
    // Defines how a particular logical Row Bit is remapped to a Physical Row Address.
    // The bits are essentially swizzled with each other. 
    // Remapping the lower Row bits allows one to more effectively test adjacent rows
    // in a DRAM when the Row swizzling is used within the DRAM. 
    // Remapping any two or more row bits to the same value is not allowed and the behavior
    // is undefined. 
    // Remapping is a 2 step process with a write required to both CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER
    // and CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER 
    // Example using Logical Row Bit X:
    // If a swizzle between X and Y is desired then
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle must be
    // set to Y 
    // And
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle must be
    // set to X 
    // Note:
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle can be only
    // be set to equal itself or the largest 
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle value
    // 
    // Bits[29:25], RW_LB, default = 0xB
    //
    UINTX log2phy_row11_swzl : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SEQ_RASU00_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_RASU10_MCMAIN_REG                        0x00000BD0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[4:0], RW_LB, default = 0xC
    //
    UINTX log2phy_row12_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[9:5], RW_LB, default = 0xD
    //
    UINTX log2phy_row13_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[14:10], RW_LB, default = 0xE
    //
    UINTX log2phy_row14_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[19:15], RW_LB, default = 0xF
    //
    UINTX log2phy_row15_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[24:20], RW_LB, default = 0x10
    //
    UINTX log2phy_row16_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[29:25], RW_LB, default = 0x11
    //
    UINTX log2phy_row17_swzl : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SEQ_RASU10_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_RASU01_MCMAIN_REG                        0x00000BD4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Defines how a particular logical Row Bit is remapped to a Physical Row Address.
    // The bits are essentially swizzled with each other. 
    // Example using Logical Row Bit X:
    // If a Logical_to_Physical_RowX_Swizzle = Y then this implies that
    // Physical Row bit Y = X
    // Physical Row bit X = Y
    // Remapping Row bits allows one to more effectively test adjacent rows in a DRAM
    // when the Row swizzling is used within the DRAM. 
    // Remapping any two or more row bits to the same value is not allowed and the behavior
    // is undefined. 
    // 
    // Bits[4:0], RW_LB, default = 0x6
    //
    UINTX log2phy_row6_swzl : 5;
    //
    // Refer to Log2phy_Row6_Swzl for details
    // 
    // Bits[9:5], RW_LB, default = 0x7
    //
    UINTX log2phy_row7_swzl : 5;
    //
    // Refer to Log2phy_Row6_Swzl for details
    // 
    // Bits[14:10], RW_LB, default = 0x8
    //
    UINTX log2phy_row8_swzl : 5;
    //
    // Refer to Log2phy_Row6_Swzl for details
    // 
    // Bits[19:15], RW_LB, default = 0x9
    //
    UINTX log2phy_row9_swzl : 5;
    //
    // Refer to Log2phy_Row6_Swzl for details
    // 
    // Bits[24:20], RW_LB, default = 0xA
    //
    UINTX log2phy_row10_swzl : 5;
    //
    // Defines how a particular logical Row Bit is remapped to a Physical Row Address.
    // The bits are essentially swizzled with each other. 
    // Remapping the lower Row bits allows one to more effectively test adjacent rows
    // in a DRAM when the Row swizzling is used within the DRAM. 
    // Remapping any two or more row bits to the same value is not allowed and the behavior
    // is undefined. 
    // Remapping is a 2 step process with a write required to both CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER
    // and CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER 
    // Example using Logical Row Bit X:
    // If a swizzle between X and Y is desired then
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle must be
    // set to Y 
    // And
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle must be
    // set to X 
    // Note:
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle can be only
    // be set to equal itself or the largest 
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle value
    // 
    // Bits[29:25], RW_LB, default = 0xB
    //
    UINTX log2phy_row11_swzl : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SEQ_RASU01_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_RASU11_MCMAIN_REG                        0x00000BD8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[4:0], RW_LB, default = 0xC
    //
    UINTX log2phy_row12_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[9:5], RW_LB, default = 0xD
    //
    UINTX log2phy_row13_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[14:10], RW_LB, default = 0xE
    //
    UINTX log2phy_row14_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[19:15], RW_LB, default = 0xF
    //
    UINTX log2phy_row15_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[24:20], RW_LB, default = 0x10
    //
    UINTX log2phy_row16_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[29:25], RW_LB, default = 0x11
    //
    UINTX log2phy_row17_swzl : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SEQ_RASU11_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_RASU02_MCMAIN_REG                        0x00000BDC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Defines how a particular logical Row Bit is remapped to a Physical Row Address.
    // The bits are essentially swizzled with each other. 
    // Example using Logical Row Bit X:
    // If a Logical_to_Physical_RowX_Swizzle = Y then this implies that
    // Physical Row bit Y = X
    // Physical Row bit X = Y
    // Remapping Row bits allows one to more effectively test adjacent rows in a DRAM
    // when the Row swizzling is used within the DRAM. 
    // Remapping any two or more row bits to the same value is not allowed and the behavior
    // is undefined. 
    // 
    // Bits[4:0], RW_LB, default = 0x6
    //
    UINTX log2phy_row6_swzl : 5;
    //
    // Refer to Log2phy_Row6_Swzl for details
    // 
    // Bits[9:5], RW_LB, default = 0x7
    //
    UINTX log2phy_row7_swzl : 5;
    //
    // Refer to Log2phy_Row6_Swzl for details
    // 
    // Bits[14:10], RW_LB, default = 0x8
    //
    UINTX log2phy_row8_swzl : 5;
    //
    // Refer to Log2phy_Row6_Swzl for details
    // 
    // Bits[19:15], RW_LB, default = 0x9
    //
    UINTX log2phy_row9_swzl : 5;
    //
    // Refer to Log2phy_Row6_Swzl for details
    // 
    // Bits[24:20], RW_LB, default = 0xA
    //
    UINTX log2phy_row10_swzl : 5;
    //
    // Defines how a particular logical Row Bit is remapped to a Physical Row Address.
    // The bits are essentially swizzled with each other. 
    // Remapping the lower Row bits allows one to more effectively test adjacent rows
    // in a DRAM when the Row swizzling is used within the DRAM. 
    // Remapping any two or more row bits to the same value is not allowed and the behavior
    // is undefined. 
    // Remapping is a 2 step process with a write required to both CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER
    // and CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER 
    // Example using Logical Row Bit X:
    // If a swizzle between X and Y is desired then
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle must be
    // set to Y 
    // And
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle must be
    // set to X 
    // Note:
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle can be only
    // be set to equal itself or the largest 
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle value
    // 
    // Bits[29:25], RW_LB, default = 0xB
    //
    UINTX log2phy_row11_swzl : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SEQ_RASU02_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_RASU12_MCMAIN_REG                        0x00000BE0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[4:0], RW_LB, default = 0xC
    //
    UINTX log2phy_row12_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[9:5], RW_LB, default = 0xD
    //
    UINTX log2phy_row13_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[14:10], RW_LB, default = 0xE
    //
    UINTX log2phy_row14_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[19:15], RW_LB, default = 0xF
    //
    UINTX log2phy_row15_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[24:20], RW_LB, default = 0x10
    //
    UINTX log2phy_row16_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[29:25], RW_LB, default = 0x11
    //
    UINTX log2phy_row17_swzl : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SEQ_RASU12_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_RASU03_MCMAIN_REG                        0x00000BE4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Defines how a particular logical Row Bit is remapped to a Physical Row Address.
    // The bits are essentially swizzled with each other. 
    // Example using Logical Row Bit X:
    // If a Logical_to_Physical_RowX_Swizzle = Y then this implies that
    // Physical Row bit Y = X
    // Physical Row bit X = Y
    // Remapping Row bits allows one to more effectively test adjacent rows in a DRAM
    // when the Row swizzling is used within the DRAM. 
    // Remapping any two or more row bits to the same value is not allowed and the behavior
    // is undefined. 
    // 
    // Bits[4:0], RW_LB, default = 0x6
    //
    UINTX log2phy_row6_swzl : 5;
    //
    // Refer to Log2phy_Row6_Swzl for details
    // 
    // Bits[9:5], RW_LB, default = 0x7
    //
    UINTX log2phy_row7_swzl : 5;
    //
    // Refer to Log2phy_Row6_Swzl for details
    // 
    // Bits[14:10], RW_LB, default = 0x8
    //
    UINTX log2phy_row8_swzl : 5;
    //
    // Refer to Log2phy_Row6_Swzl for details
    // 
    // Bits[19:15], RW_LB, default = 0x9
    //
    UINTX log2phy_row9_swzl : 5;
    //
    // Refer to Log2phy_Row6_Swzl for details
    // 
    // Bits[24:20], RW_LB, default = 0xA
    //
    UINTX log2phy_row10_swzl : 5;
    //
    // Defines how a particular logical Row Bit is remapped to a Physical Row Address.
    // The bits are essentially swizzled with each other. 
    // Remapping the lower Row bits allows one to more effectively test adjacent rows
    // in a DRAM when the Row swizzling is used within the DRAM. 
    // Remapping any two or more row bits to the same value is not allowed and the behavior
    // is undefined. 
    // Remapping is a 2 step process with a write required to both CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER
    // and CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER 
    // Example using Logical Row Bit X:
    // If a swizzle between X and Y is desired then
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle must be
    // set to Y 
    // And
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle must be
    // set to X 
    // Note:
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_UPPER.Logical_to_Physical_RowY_Swizzle can be only
    // be set to equal itself or the largest 
    // CPGC#_CH#_SEQ_ROW_ADDR_SWIZZLE_LOWER.Logical_to_Physical_RowX_Swizzle value
    // 
    // Bits[29:25], RW_LB, default = 0xB
    //
    UINTX log2phy_row11_swzl : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SEQ_RASU03_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_RASU13_MCMAIN_REG                        0x00000BE8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[4:0], RW_LB, default = 0xC
    //
    UINTX log2phy_row12_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[9:5], RW_LB, default = 0xD
    //
    UINTX log2phy_row13_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[14:10], RW_LB, default = 0xE
    //
    UINTX log2phy_row14_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[19:15], RW_LB, default = 0xF
    //
    UINTX log2phy_row15_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[24:20], RW_LB, default = 0x10
    //
    UINTX log2phy_row16_swzl : 5;
    //
    // Refer to Log2phy_Row11_Swzl for details
    // 
    // Bits[29:25], RW_LB, default = 0x11
    //
    UINTX log2phy_row17_swzl : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} CPGC_SEQ_RASU13_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_DMYRDADDR_LO_MCMAIN_REG                  0x00000BEC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // A one hot Mask that defines which Banks will be used in generating the Dummy Reads
    // which create Activates and 
    // pre-charges according to the functional behavior of the scheduler.
    // A 1 means that a Bank will not be used to issue the Dummy Read to cause a precharge
    // and activate. 
    // Bit 0 Bank 0
    // Bit 1 Bank 1
    // Bit 15 Bank 15
    // 
    // Bits[15:0], RW_LB, default = 0x0
    //
    UINTX bank_mask0 : 16;
    //
    // Refer to Bank_Mask0 for details
    // 
    // Bits[31:16], RW_LB, default = 0x0
    //
    UINTX bank_mask1 : 16;
  } Bits;
  UINTX Data;
} CPGC_SEQ_DMYRDADDR_LO_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_DMYRDSTS0_MCMAIN_REG                     0x00000BF0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Dummy_Read_Row_Current_Address defines the current Row Address for the Dummy Reads
    // which is updated while a test is in progress. 
    // The Dummy_Read_Row_Current_Address will be increment by 1 everytime a Dummy Read
    // is generated. 
    // One may program Dummy_Read_Row_Current_Address to a desired starting value if
    // a certain initial condition is desired otherwise 
    // the Dummy_Read_Row_Current_Address will resume from the current value as no hardware
    // mechanism exists to explicitly 
    // clear or modify this register.
    // 
    // Bits[17:0], RW_V, default = 0x0
    //
    UINTX row_curraddr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Refer to Row_Curraddr for details
    // 
    // Bits[27:24], RW_V, default = 0x0
    //
    UINTX bank_curraddr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_DMYRDSTS0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_DMYRDSTS1_MCMAIN_REG                     0x00000BF4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Dummy_Read_Row_Current_Address defines the current Row Address for the Dummy Reads
    // which is updated while a test is in progress. 
    // The Dummy_Read_Row_Current_Address will be increment by 1 everytime a Dummy Read
    // is generated. 
    // One may program Dummy_Read_Row_Current_Address to a desired starting value if
    // a certain initial condition is desired otherwise 
    // the Dummy_Read_Row_Current_Address will resume from the current value as no hardware
    // mechanism exists to explicitly 
    // clear or modify this register.
    // 
    // Bits[17:0], RW_V, default = 0x0
    //
    UINTX row_curraddr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Refer to Row_Curraddr for details
    // 
    // Bits[27:24], RW_V, default = 0x0
    //
    UINTX bank_curraddr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_DMYRDSTS1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_DMYRDSTS2_MCMAIN_REG                     0x00000BF8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Dummy_Read_Row_Current_Address defines the current Row Address for the Dummy Reads
    // which is updated while a test is in progress. 
    // The Dummy_Read_Row_Current_Address will be increment by 1 everytime a Dummy Read
    // is generated. 
    // One may program Dummy_Read_Row_Current_Address to a desired starting value if
    // a certain initial condition is desired otherwise 
    // the Dummy_Read_Row_Current_Address will resume from the current value as no hardware
    // mechanism exists to explicitly 
    // clear or modify this register.
    // 
    // Bits[17:0], RW_V, default = 0x0
    //
    UINTX row_curraddr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Refer to Row_Curraddr for details
    // 
    // Bits[27:24], RW_V, default = 0x0
    //
    UINTX bank_curraddr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_DMYRDSTS2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_DMYRDSTS3_MCMAIN_REG                     0x00000BFC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Dummy_Read_Row_Current_Address defines the current Row Address for the Dummy Reads
    // which is updated while a test is in progress. 
    // The Dummy_Read_Row_Current_Address will be increment by 1 everytime a Dummy Read
    // is generated. 
    // One may program Dummy_Read_Row_Current_Address to a desired starting value if
    // a certain initial condition is desired otherwise 
    // the Dummy_Read_Row_Current_Address will resume from the current value as no hardware
    // mechanism exists to explicitly 
    // clear or modify this register.
    // 
    // Bits[17:0], RW_V, default = 0x0
    //
    UINTX row_curraddr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Refer to Row_Curraddr for details
    // 
    // Bits[27:24], RW_V, default = 0x0
    //
    UINTX bank_curraddr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_DMYRDSTS3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_DMYRDCTL0_MCMAIN_REG                     0x00000C00
#ifndef ASM_INC
typedef union {
  struct {
    //
    // L_DummyRead_Select indicates whether Dummy Reads will be generated during the
    // first L Dclks after a test is started (entering Loopback.Pattern) 
    // 0x0 = Dummy Reads must be driven during the initial L counter Dclk delay with
    // minimum spacing as possible 
    // 0x1=Dummy Reads must be not be driven during the initial L counter Dclk delay
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX l_dmyrd_select : 1;
    //
    // After L_Counter Dclk cycles of Dummy Reads (L_DummyRead_Select =1) or no Dummy
    // Reads (DummyRead_Select = 0) 
    // are performed at the beginning of a test (entering Loopback.Pattern) then the
    // following dummy Read periodic pattern is 
    // continuously repeated depending on the value of Sweep Frequency.
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX sweep_freq : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // After L_Counter Dclk cycles of Dummy Reads (L_DummyRead_Select =1) or no Dummy
    // Reads (DummyRead_Select = 0) are performed 
    // at the beginning of a test (entering Loopback.Pattern) then the following dummy
    // Read periodic pattern is continuously 
    // repeated depending on the value of Sweep Frequency.
    // If Sweep_Frequency = 0 then a steady state frequency of Dummy Activiates driven
    // (see Sweep_Frequency for exact behavior) 
    // If Sweep_Frequency = 1 then a frequency sweep of Dummy Activates is continuously
    // generated ranging from 2*(M) to 2*(N) driven 
    // (see Sweep_Frequency for exact behavior)
    // 
    // Bits[15:8], RW_LB, default = 0x1
    //
    UINTX l_counter : 8;
    //
    // Refer to L_Counter for details
    // 
    // Bits[23:16], RW_LB, default = 0x1
    //
    UINTX m_counter : 8;
    //
    // Refer to L_Counter for details
    // 
    // Bits[31:24], RW_LB, default = 0x1
    //
    UINTX n_counter : 8;
  } Bits;
  UINTX Data;
} CPGC_SEQ_DMYRDCTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_DMYRDCTL1_MCMAIN_REG                     0x00000C04
#ifndef ASM_INC
typedef union {
  struct {
    //
    // L_DummyRead_Select indicates whether Dummy Reads will be generated during the
    // first L Dclks after a test is started (entering Loopback.Pattern) 
    // 0x0 = Dummy Reads must be driven during the initial L counter Dclk delay with
    // minimum spacing as possible 
    // 0x1=Dummy Reads must be not be driven during the initial L counter Dclk delay
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX l_dmyrd_select : 1;
    //
    // After L_Counter Dclk cycles of Dummy Reads (L_DummyRead_Select =1) or no Dummy
    // Reads (DummyRead_Select = 0) 
    // are performed at the beginning of a test (entering Loopback.Pattern) then the
    // following dummy Read periodic pattern is 
    // continuously repeated depending on the value of Sweep Frequency.
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX sweep_freq : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // After L_Counter Dclk cycles of Dummy Reads (L_DummyRead_Select =1) or no Dummy
    // Reads (DummyRead_Select = 0) are performed 
    // at the beginning of a test (entering Loopback.Pattern) then the following dummy
    // Read periodic pattern is continuously 
    // repeated depending on the value of Sweep Frequency.
    // If Sweep_Frequency = 0 then a steady state frequency of Dummy Activiates driven
    // (see Sweep_Frequency for exact behavior) 
    // If Sweep_Frequency = 1 then a frequency sweep of Dummy Activates is continuously
    // generated ranging from 2*(M) to 2*(N) driven 
    // (see Sweep_Frequency for exact behavior)
    // 
    // Bits[15:8], RW_LB, default = 0x1
    //
    UINTX l_counter : 8;
    //
    // Refer to L_Counter for details
    // 
    // Bits[23:16], RW_LB, default = 0x1
    //
    UINTX m_counter : 8;
    //
    // Refer to L_Counter for details
    // 
    // Bits[31:24], RW_LB, default = 0x1
    //
    UINTX n_counter : 8;
  } Bits;
  UINTX Data;
} CPGC_SEQ_DMYRDCTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_DMYRDCTL2_MCMAIN_REG                     0x00000C08
#ifndef ASM_INC
typedef union {
  struct {
    //
    // L_DummyRead_Select indicates whether Dummy Reads will be generated during the
    // first L Dclks after a test is started (entering Loopback.Pattern) 
    // 0x0 = Dummy Reads must be driven during the initial L counter Dclk delay with
    // minimum spacing as possible 
    // 0x1=Dummy Reads must be not be driven during the initial L counter Dclk delay
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX l_dmyrd_select : 1;
    //
    // After L_Counter Dclk cycles of Dummy Reads (L_DummyRead_Select =1) or no Dummy
    // Reads (DummyRead_Select = 0) 
    // are performed at the beginning of a test (entering Loopback.Pattern) then the
    // following dummy Read periodic pattern is 
    // continuously repeated depending on the value of Sweep Frequency.
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX sweep_freq : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // After L_Counter Dclk cycles of Dummy Reads (L_DummyRead_Select =1) or no Dummy
    // Reads (DummyRead_Select = 0) are performed 
    // at the beginning of a test (entering Loopback.Pattern) then the following dummy
    // Read periodic pattern is continuously 
    // repeated depending on the value of Sweep Frequency.
    // If Sweep_Frequency = 0 then a steady state frequency of Dummy Activiates driven
    // (see Sweep_Frequency for exact behavior) 
    // If Sweep_Frequency = 1 then a frequency sweep of Dummy Activates is continuously
    // generated ranging from 2*(M) to 2*(N) driven 
    // (see Sweep_Frequency for exact behavior)
    // 
    // Bits[15:8], RW_LB, default = 0x1
    //
    UINTX l_counter : 8;
    //
    // Refer to L_Counter for details
    // 
    // Bits[23:16], RW_LB, default = 0x1
    //
    UINTX m_counter : 8;
    //
    // Refer to L_Counter for details
    // 
    // Bits[31:24], RW_LB, default = 0x1
    //
    UINTX n_counter : 8;
  } Bits;
  UINTX Data;
} CPGC_SEQ_DMYRDCTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_DMYRDCTL3_MCMAIN_REG                     0x00000C0C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // L_DummyRead_Select indicates whether Dummy Reads will be generated during the
    // first L Dclks after a test is started (entering Loopback.Pattern) 
    // 0x0 = Dummy Reads must be driven during the initial L counter Dclk delay with
    // minimum spacing as possible 
    // 0x1=Dummy Reads must be not be driven during the initial L counter Dclk delay
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX l_dmyrd_select : 1;
    //
    // After L_Counter Dclk cycles of Dummy Reads (L_DummyRead_Select =1) or no Dummy
    // Reads (DummyRead_Select = 0) 
    // are performed at the beginning of a test (entering Loopback.Pattern) then the
    // following dummy Read periodic pattern is 
    // continuously repeated depending on the value of Sweep Frequency.
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX sweep_freq : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // After L_Counter Dclk cycles of Dummy Reads (L_DummyRead_Select =1) or no Dummy
    // Reads (DummyRead_Select = 0) are performed 
    // at the beginning of a test (entering Loopback.Pattern) then the following dummy
    // Read periodic pattern is continuously 
    // repeated depending on the value of Sweep Frequency.
    // If Sweep_Frequency = 0 then a steady state frequency of Dummy Activiates driven
    // (see Sweep_Frequency for exact behavior) 
    // If Sweep_Frequency = 1 then a frequency sweep of Dummy Activates is continuously
    // generated ranging from 2*(M) to 2*(N) driven 
    // (see Sweep_Frequency for exact behavior)
    // 
    // Bits[15:8], RW_LB, default = 0x1
    //
    UINTX l_counter : 8;
    //
    // Refer to L_Counter for details
    // 
    // Bits[23:16], RW_LB, default = 0x1
    //
    UINTX m_counter : 8;
    //
    // Refer to L_Counter for details
    // 
    // Bits[31:24], RW_LB, default = 0x1
    //
    UINTX n_counter : 8;
  } Bits;
  UINTX Data;
} CPGC_SEQ_DMYRDCTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ0_CTL0_MCMAIN_REG                      0x00000C10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // The interpretation of Number_Of_Cachelines is based on Number_Of_Cachelines_Scale
    // If Number_Of_Cachelines_Scale is set to 1 then Number_Of_Cachelines operates as
    // a linear counter with one notable exception: 
    // Setting Number_Of_Cachelines_Scale to 1 and Number_of_Cachelines to 0 will result
    // in an infinite # of cachelines being transmitted. 
    // If Number_Of_Cachelines_Scale is set to 0 then Number_Of_Cachelines operates as
    // an exponential counter with a value equal to (2^ Number_Of_Cachelines_Scale).
    // Only bits 0:4 are supported Number_Of_Cachelines_Scale is set to 0 (exponential
    // counter mode). 
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ0_CTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ0_OFFSETCTL0_MCMAIN_REG                0x00000C14
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ0_OFFSETCTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ1_CTL0_MCMAIN_REG                      0x00000C18
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ1_CTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ1_OFFSETCTL0_MCMAIN_REG                0x00000C1C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ1_OFFSETCTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ2_CTL0_MCMAIN_REG                      0x00000C20
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ2_CTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ2_OFFSETCTL0_MCMAIN_REG                0x00000C24
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ2_OFFSETCTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ3_CTL0_MCMAIN_REG                      0x00000C28
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ3_CTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ3_OFFSETCTL0_MCMAIN_REG                0x00000C2C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ3_OFFSETCTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ4_CTL0_MCMAIN_REG                      0x00000C30
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ4_CTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ4_OFFSETCTL0_MCMAIN_REG                0x00000C34
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ4_OFFSETCTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ5_CTL0_MCMAIN_REG                      0x00000C38
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ5_CTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ5_OFFSETCTL0_MCMAIN_REG                0x00000C3C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ5_OFFSETCTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ6_CTL0_MCMAIN_REG                      0x00000C40
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ6_CTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ6_OFFSETCTL0_MCMAIN_REG                0x00000C44
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ6_OFFSETCTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ7_CTL0_MCMAIN_REG                      0x00000C48
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ7_CTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ7_OFFSETCTL0_MCMAIN_REG                0x00000C4C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ7_OFFSETCTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ8_CTL0_MCMAIN_REG                      0x00000C50
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ8_CTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ8_OFFSETCTL0_MCMAIN_REG                0x00000C54
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ8_OFFSETCTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ9_CTL0_MCMAIN_REG                      0x00000C58
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ9_CTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ9_OFFSETCTL0_MCMAIN_REG                0x00000C5C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ9_OFFSETCTL0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ0_CTL1_MCMAIN_REG                      0x00000C60
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ0_CTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ0_OFFSETCTL1_MCMAIN_REG                0x00000C64
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ0_OFFSETCTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ1_CTL1_MCMAIN_REG                      0x00000C68
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ1_CTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ1_OFFSETCTL1_MCMAIN_REG                0x00000C6C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ1_OFFSETCTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ2_CTL1_MCMAIN_REG                      0x00000C70
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ2_CTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ2_OFFSETCTL1_MCMAIN_REG                0x00000C74
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ2_OFFSETCTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ3_CTL1_MCMAIN_REG                      0x00000C78
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ3_CTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ3_OFFSETCTL1_MCMAIN_REG                0x00000C7C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ3_OFFSETCTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ4_CTL1_MCMAIN_REG                      0x00000C80
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ4_CTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ4_OFFSETCTL1_MCMAIN_REG                0x00000C84
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ4_OFFSETCTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ5_CTL1_MCMAIN_REG                      0x00000C88
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ5_CTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ5_OFFSETCTL1_MCMAIN_REG                0x00000C8C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ5_OFFSETCTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ6_CTL1_MCMAIN_REG                      0x00000C90
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ6_CTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ6_OFFSETCTL1_MCMAIN_REG                0x00000C94
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ6_OFFSETCTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ7_CTL1_MCMAIN_REG                      0x00000C98
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ7_CTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ7_OFFSETCTL1_MCMAIN_REG                0x00000C9C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ7_OFFSETCTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ8_CTL1_MCMAIN_REG                      0x00000CA0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ8_CTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ8_OFFSETCTL1_MCMAIN_REG                0x00000CA4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ8_OFFSETCTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ9_CTL1_MCMAIN_REG                      0x00000CA8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ9_CTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ9_OFFSETCTL1_MCMAIN_REG                0x00000CAC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ9_OFFSETCTL1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ0_CTL2_MCMAIN_REG                      0x00000CB0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ0_CTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ0_OFFSETCTL2_MCMAIN_REG                0x00000CB4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ0_OFFSETCTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ1_CTL2_MCMAIN_REG                      0x00000CB8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ1_CTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ1_OFFSETCTL2_MCMAIN_REG                0x00000CBC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ1_OFFSETCTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ2_CTL2_MCMAIN_REG                      0x00000CC0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ2_CTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ2_OFFSETCTL2_MCMAIN_REG                0x00000CC4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ2_OFFSETCTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ3_CTL2_MCMAIN_REG                      0x00000CC8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ3_CTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ3_OFFSETCTL2_MCMAIN_REG                0x00000CCC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ3_OFFSETCTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ4_CTL2_MCMAIN_REG                      0x00000CD0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ4_CTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ4_OFFSETCTL2_MCMAIN_REG                0x00000CD4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ4_OFFSETCTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ5_CTL2_MCMAIN_REG                      0x00000CD8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ5_CTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ5_OFFSETCTL2_MCMAIN_REG                0x00000CDC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ5_OFFSETCTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ6_CTL2_MCMAIN_REG                      0x00000CE0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ6_CTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ6_OFFSETCTL2_MCMAIN_REG                0x00000CE4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ6_OFFSETCTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ7_CTL2_MCMAIN_REG                      0x00000CE8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ7_CTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ7_OFFSETCTL2_MCMAIN_REG                0x00000CEC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ7_OFFSETCTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ8_CTL2_MCMAIN_REG                      0x00000CF0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ8_CTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ8_OFFSETCTL2_MCMAIN_REG                0x00000CF4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ8_OFFSETCTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ9_CTL2_MCMAIN_REG                      0x00000CF8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ9_CTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ9_OFFSETCTL2_MCMAIN_REG                0x00000CFC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ9_OFFSETCTL2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ0_CTL3_MCMAIN_REG                      0x00000D00
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ0_CTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ0_OFFSETCTL3_MCMAIN_REG                0x00000D04
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ0_OFFSETCTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ1_CTL3_MCMAIN_REG                      0x00000D08
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ1_CTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ1_OFFSETCTL3_MCMAIN_REG                0x00000D0C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ1_OFFSETCTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ2_CTL3_MCMAIN_REG                      0x00000D10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ2_CTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ2_OFFSETCTL3_MCMAIN_REG                0x00000D14
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ2_OFFSETCTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ3_CTL3_MCMAIN_REG                      0x00000D18
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ3_CTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ3_OFFSETCTL3_MCMAIN_REG                0x00000D1C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ3_OFFSETCTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ4_CTL3_MCMAIN_REG                      0x00000D20
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ4_CTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ4_OFFSETCTL3_MCMAIN_REG                0x00000D24
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ4_OFFSETCTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ5_CTL3_MCMAIN_REG                      0x00000D28
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ5_CTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ5_OFFSETCTL3_MCMAIN_REG                0x00000D2C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ5_OFFSETCTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ6_CTL3_MCMAIN_REG                      0x00000D30
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ6_CTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ6_OFFSETCTL3_MCMAIN_REG                0x00000D34
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ6_OFFSETCTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ7_CTL3_MCMAIN_REG                      0x00000D38
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ7_CTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ7_OFFSETCTL3_MCMAIN_REG                0x00000D3C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ7_OFFSETCTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ8_CTL3_MCMAIN_REG                      0x00000D40
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ8_CTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ8_OFFSETCTL3_MCMAIN_REG                0x00000D44
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ8_OFFSETCTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ9_CTL3_MCMAIN_REG                      0x00000D48
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number_ of_Cachelines defines how many cachelines must be transmitted before a
    // base subsequence or a particular offset direction 
    // (row and/or column) is considered completed.
    // 
    // Bits[6:0], RW_LB, default = 0x0
    //
    UINTX num_cachelines : 7;
    //
    // Number_of_Cachelines operates as a linear or exponential counter based on the
    // value of Number_Of_Cachelines_Scale 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX num_cachelines_scale : 1;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[19:8], RW_LB, default = 0x0
    //
    UINTX subseq_wait : 12;
    //
    // Defines what type of operation a particular Subsequence will be:
    // 0000: Base Read
    // 0001: Base Write
    // 0010: Base Read Write
    // 0011: Base Write Read
    // 0100: Offset Read
    // 0101: Offset Write
    // 
    // Bits[23:20], RW_LB, default = 0x0
    //
    UINTX subseq_type : 4;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit12 : 1;
    //
    // Upon the entry to a subsequence where Save_Current_Base_Address_To_Start = 1 the
    // following actions must occur: 
    // 1) All the fields in Base Current Address (REUT_CH#_SEQ_BASE_ADDR_CURRENT) must
    // be written into the corresponding 
    // fields in Base Starting Address (REUT#_CH#_SEQ_BASE_ADDR_START).
    // 2) In the case where both Save_Current_Base_Address_To_Start = 1 and Reset_Current_Base_Address_To_Start
    // = 1 then only 
    // Save_Current_Base_Address_To_Start = 1 will take effect and Reset_Current_Base_Address_To_Start
    // = 1 will be ignored. 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX savecurr_ba_start : 1;
    //
    // Upon entry to a subsequence where Reset_Current Base_Address_To_Start is set the
    // following actions must occur:Base 
    // Current Address (CPGC_CH#_SEQ_BASE_ADDR_CURRENT) gets immediately re initialized
    // to the Base Starting Address 
    // (CPGC#_CH#_SEQ_BASE_ADDR_START).
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX rstcurr_ba_start : 1;
    //
    // Data_and_ECC_Address_Inversion allows for data backgrounds based on the LSB of
    // the Column and Row Base address fields. 
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX dataecc_addrinv : 2;
    //
    // # of DCLK cycles between completion of the current sub-sequence and beginning
    // the next sub-sequence. 
    // The wait period is considered to be part of this subsequence for
    // considering any logical action. Subsequence wait is 14 bits wide and
    // is a concatenation of fields subseq_wait_bit13, subseq_wait_bit12, subseq_wait
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX subseq_wait_bit13 : 1;
    //
    // Invert_Data_and_ECC is used to toggle the polarity of the data and ECC for the
    // given subsequence which is then applied 
    // to the logical output of any Address_Invesion to determine the final polarity
    // for the current write or read. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX inv_dataecc : 1;
    //
    // If Stop_Base_Subsequence_On_Wrap_Trigger is set then any Base Address Wrap Trigger
    // that occurs will immediately force 
    // a transition to the next Subsequence after the Subsequence_Wait.
    // Please note the difference between CPGC#_CH#_SUBSEQ#_CTL.Stop_OnWrap_Trigger and
    // CPGC#_CH#_SEQ_CTL.Stop_OnWrap_Trigger as the 
    // former causes the subsequence to end and the latter causes the sequence to end.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX stop_baseseq_wrptrig : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ9_CTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SUBSEQ9_OFFSETCTL3_MCMAIN_REG                0x00000D4C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset_Address_Update_Rate determines the rate that the Current Offset Address
    // is updated. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX offadd_updrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // When the Subsequence_Type is set to an offset operation then Base_Subsequence_Repeat_Rate
    // determines how often 
    // the Base_Subsequence_Type operation occurs for 1 cacheline.
    // 
    // Bits[12:8], RW_LB, default = 0x0
    //
    UINTX base_subseq_rptrate : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX coloff_wrptrig_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX rowoff_wrptrig_enb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // Everytime the Base_Subsequence_Repeat_Rate is reached a Read or Write is performed
    // for one command based on other fields. 
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX base_subseq_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX col_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX col_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX row_inc_order : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX row_inc_enb : 1;
    //
    // Refer CPGC register spread-sheet for details
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX base_inv_dataecc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
  } Bits;
  UINTX Data;
} CPGC_SUBSEQ9_OFFSETCTL3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_LRRANKLG2PHYMAP0_MCMAIN_REG              0x00000D50
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ddr3_lrdim/ddr4 subrank-0 mapping
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX lr0_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-1 mapping
    // 
    // Bits[5:3], RW_LB, default = 0x0
    //
    UINTX lr1_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-2 mapping
    // 
    // Bits[8:6], RW_LB, default = 0x0
    //
    UINTX lr2_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-3 mapping
    // 
    // Bits[11:9], RW_LB, default = 0x0
    //
    UINTX lr3_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-4 mapping
    // 
    // Bits[14:12], RW_LB, default = 0x0
    //
    UINTX lr4_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-5 mapping
    // 
    // Bits[17:15], RW_LB, default = 0x0
    //
    UINTX lr5_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-6 mapping
    // 
    // Bits[20:18], RW_LB, default = 0x0
    //
    UINTX lr6_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-7 mapping
    // 
    // Bits[23:21], RW_LB, default = 0x0
    //
    UINTX lr7_mapping : 3;
    //
    // lrdimm_rank_mapping is a 3-bit field that maps which type of LRDIMM/3ds devices
    // have been populated in the system. 
    // 3'b000: No subranks. ddr3 will use row_addr[15:0], ddr4 will use row_addr[17:0]
    // 3'b001: subranks appended after A[14]
    // 3'b010: subranks appended after A[15]
    // 3'b011: subranks appended after A[13]; for ddr4 only
    // 3'b100: subranks appended after A[16]; for ddr4 only
    // 3'b101: subranks appended after A[17]; for ddr4 only
    // 3'b110-3'b111: Reserved
    // Note: Subrank information is obtained from lr*_mapping fields in this register.
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX lrdimm_rank_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_LRRANKLG2PHYMAP0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_LRRANKLG2PHYMAP1_MCMAIN_REG              0x00000D54
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ddr3_lrdim/ddr4 subrank-0 mapping
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX lr0_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-1 mapping
    // 
    // Bits[5:3], RW_LB, default = 0x0
    //
    UINTX lr1_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-2 mapping
    // 
    // Bits[8:6], RW_LB, default = 0x0
    //
    UINTX lr2_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-3 mapping
    // 
    // Bits[11:9], RW_LB, default = 0x0
    //
    UINTX lr3_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-4 mapping
    // 
    // Bits[14:12], RW_LB, default = 0x0
    //
    UINTX lr4_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-5 mapping
    // 
    // Bits[17:15], RW_LB, default = 0x0
    //
    UINTX lr5_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-6 mapping
    // 
    // Bits[20:18], RW_LB, default = 0x0
    //
    UINTX lr6_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-7 mapping
    // 
    // Bits[23:21], RW_LB, default = 0x0
    //
    UINTX lr7_mapping : 3;
    //
    // lrdimm_rank_mapping is a 3-bit field that maps which type of LRDIMM/3ds devices
    // have been populated in the system. 
    // 3'b000: No subranks. ddr3 will use row_addr[15:0], ddr4 will use row_addr[17:0]
    // 3'b001: subranks appended after A[14]
    // 3'b010: subranks appended after A[15]
    // 3'b011: subranks appended after A[13]; for ddr4 only
    // 3'b100: subranks appended after A[16]; for ddr4 only
    // 3'b101: subranks appended after A[17]; for ddr4 only
    // 3'b110-3'b111: Reserved
    // Note: Subrank information is obtained from lr*_mapping fields in this register.
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX lrdimm_rank_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_LRRANKLG2PHYMAP1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_LRRANKLG2PHYMAP2_MCMAIN_REG              0x00000D58
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ddr3_lrdim/ddr4 subrank-0 mapping
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX lr0_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-1 mapping
    // 
    // Bits[5:3], RW_LB, default = 0x0
    //
    UINTX lr1_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-2 mapping
    // 
    // Bits[8:6], RW_LB, default = 0x0
    //
    UINTX lr2_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-3 mapping
    // 
    // Bits[11:9], RW_LB, default = 0x0
    //
    UINTX lr3_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-4 mapping
    // 
    // Bits[14:12], RW_LB, default = 0x0
    //
    UINTX lr4_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-5 mapping
    // 
    // Bits[17:15], RW_LB, default = 0x0
    //
    UINTX lr5_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-6 mapping
    // 
    // Bits[20:18], RW_LB, default = 0x0
    //
    UINTX lr6_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-7 mapping
    // 
    // Bits[23:21], RW_LB, default = 0x0
    //
    UINTX lr7_mapping : 3;
    //
    // lrdimm_rank_mapping is a 3-bit field that maps which type of LRDIMM/3ds devices
    // have been populated in the system. 
    // 3'b000: No subranks. ddr3 will use row_addr[15:0], ddr4 will use row_addr[17:0]
    // 3'b001: subranks appended after A[14]
    // 3'b010: subranks appended after A[15]
    // 3'b011: subranks appended after A[13]; for ddr4 only
    // 3'b100: subranks appended after A[16]; for ddr4 only
    // 3'b101: subranks appended after A[17]; for ddr4 only
    // 3'b110-3'b111: Reserved
    // Note: Subrank information is obtained from lr*_mapping fields in this register.
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX lrdimm_rank_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_LRRANKLG2PHYMAP2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_LRRANKLG2PHYMAP3_MCMAIN_REG              0x00000D5C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ddr3_lrdim/ddr4 subrank-0 mapping
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX lr0_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-1 mapping
    // 
    // Bits[5:3], RW_LB, default = 0x0
    //
    UINTX lr1_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-2 mapping
    // 
    // Bits[8:6], RW_LB, default = 0x0
    //
    UINTX lr2_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-3 mapping
    // 
    // Bits[11:9], RW_LB, default = 0x0
    //
    UINTX lr3_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-4 mapping
    // 
    // Bits[14:12], RW_LB, default = 0x0
    //
    UINTX lr4_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-5 mapping
    // 
    // Bits[17:15], RW_LB, default = 0x0
    //
    UINTX lr5_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-6 mapping
    // 
    // Bits[20:18], RW_LB, default = 0x0
    //
    UINTX lr6_mapping : 3;
    //
    // ddr3_lrdim/ddr4 subrank-7 mapping
    // 
    // Bits[23:21], RW_LB, default = 0x0
    //
    UINTX lr7_mapping : 3;
    //
    // lrdimm_rank_mapping is a 3-bit field that maps which type of LRDIMM/3ds devices
    // have been populated in the system. 
    // 3'b000: No subranks. ddr3 will use row_addr[15:0], ddr4 will use row_addr[17:0]
    // 3'b001: subranks appended after A[14]
    // 3'b010: subranks appended after A[15]
    // 3'b011: subranks appended after A[13]; for ddr4 only
    // 3'b100: subranks appended after A[16]; for ddr4 only
    // 3'b101: subranks appended after A[17]; for ddr4 only
    // 3'b110-3'b111: Reserved
    // Note: Subrank information is obtained from lr*_mapping fields in this register.
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX lrdimm_rank_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_LRRANKLG2PHYMAP3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_TRIGCTL_MCMAIN_REG                       0x00000D60
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Setting Trigger_In_Global_Start enables a test to start based on a uBP trigger.
    // This capability enables a test to start in a synchronous fashion with respect
    // to an external event. 
    // This is required to allow synchronous CPGC operation with external test hardware
    // (HVM Tester, BERT, etc.). 
    // When Trigger_In_Global_Start is set the uBP used to start a CPGC test will set
    // REUT#_GLOBAL_CTL.Global_Start_Test on a deterministic boundary. 
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX trigger_in_global_start : 1;
    //
    // Setting Trigger_Out_Global_Start will generate a deterministic external uBP trigger
    // that is based on Global_Start_Test being set. 
    // This capability enables a test to start in a synchronous fashion with respect
    // to an external event. 
    // This is required to allow synchronous CPGC operation with external test hardware
    // (HVM Tester, BERT, etc.). 
    // When Trigger_OUT_Global_Start is set a deterministic uBP trigger is generated
    // each time REUT#_GLOBAL_CTL.Global_Start_Test is set. 
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX trigger_out_global_start : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // Setting Trigger_Out_On_Error_0 enables external equipment to be synced deterministically
    // to when any bit in Data_Error_Status or ECC_Error_Status on channel 0 is set.
    // Once any bit in Data_Error_Status or ECC_Error_Status on channel 0 is set no additional
    // triggers will be generated. 
    // This capability enables external test equipment to be synched to an error event
    // within CPGC on channel 0. 
    // This is required to allow synchronous CPGC operation with external test hardware
    // (HVM Tester, BERT, etc.). 
    // When Trigger_Out_On_Error_0 is set a deterministic uBP trigger is generated in
    // relation to when REUT_CH#_ERR_DATA_STATUS.REUT_CH#_ERR_CTL.Data_Error_Status or
    // REUT_CH#_ERR_ECC_CHUNK_RANK_BYTE_NTH_STATUS.ECC_Error_Status becomes non zero
    // on channel 0. 
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX trigger_out_on_err_0 : 1;
    //
    // Setting Trigger_Out_On_Error_1 enables external equipment to be synced deterministically
    // to when any bit in Data_Error_Status or ECC_Error_Status on channel 1 is set.
    // Once any bit in Data_Error_Status or ECC_Error_Status on channel 1 is set no additional
    // triggers will be generated. 
    // This capability enables external test equipment to be synched to an error event
    // within CPGC on channel 1. 
    // This is required to allow synchronous CPGC operation with external test hardware
    // (HVM Tester, BERT, etc.). 
    // When Trigger_Out_On_Error_1 is set a deterministic uBP trigger is generated in
    // relation to when REUT_CH#_ERR_DATA_STATUS.REUT_CH#_ERR_CTL.Data_Error_Status or
    // REUT_CH#_ERR_ECC_CHUNK_RANK_BYTE_NTH_STATUS.ECC_Error_Status becomes non zero
    // on channel 1. 
    // 
    // Bits[8:8], RW_LB, default = 0x0
    //
    UINTX trigger_out_on_err_1 : 1;
    //
    // Setting Trigger_Out_On_Error_2 enables external equipment to be synced deterministically
    // to when any bit in Data_Error_Status or ECC_Error_Status on channel 2 is set.
    // Once any bit in Data_Error_Status or ECC_Error_Status on channel 2 is set no additional
    // triggers will be generated. 
    // This capability enables external test equipment to be synched to an error event
    // within CPGC on channel 2. 
    // This is required to allow synchronous CPGC operation with external test hardware
    // (HVM Tester, BERT, etc.). 
    // When Trigger_Out_On_Error_2 is set a deterministic uBP trigger is generated in
    // relation to when REUT_CH#_ERR_DATA_STATUS.REUT_CH#_ERR_CTL.Data_Error_Status or
    // REUT_CH#_ERR_ECC_CHUNK_RANK_BYTE_NTH_STATUS.ECC_Error_Status becomes non zero
    // on channel 2. 
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX trigger_out_on_err_2 : 1;
    //
    // Setting Trigger_Out_On_Error_3 enables external equipment to be synced deterministically
    // to when any bit in Data_Error_Status or ECC_Error_Status on channel 3 is set.
    // Once any bit in Data_Error_Status or ECC_Error_Status on channel 3 is set no additional
    // triggers will be generated. 
    // This capability enables external test equipment to be synched to an error event
    // within CPGC on channel 3. 
    // This is required to allow synchronous CPGC operation with external test hardware
    // (HVM Tester, BERT, etc.). 
    // When Trigger_Out_On_Error_3 is set a deterministic uBP trigger is generated in
    // relation to when REUT_CH#_ERR_DATA_STATUS.REUT_CH#_ERR_CTL.Data_Error_Status or
    // REUT_CH#_ERR_ECC_CHUNK_RANK_BYTE_NTH_STATUS.ECC_Error_Status becomes non zero
    // on channel 3. 
    // 
    // Bits[10:10], RW_LB, default = 0x0
    //
    UINTX trigger_out_on_err_3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
    //
    // Setting trigout_on_ch_testdone_sts_0 enables external equipment to be synced deterministically
    // to the exact moment when trigout_on_ch_testdone_sts_0 is set. 
    // This capability enables external test equipment to be deterministically synched
    // to when Channel 0 CPGC test is completed. 
    // This is required to allow synchronous CPGC operation with external test hardware
    // (HVM Tester, BERT, etc.). 
    // When trigout_on_ch_testdone_sts_0 is set a deterministic externally viewable uBP
    // trigger is generated each time REUT#_GLOBAL_ERR.Channel_Test_Done_Status_0 is
    // set to 1. 
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX trigout_on_ch_testdone_sts_0 : 1;
    //
    // Setting trigout_on_ch_testdone_sts_1 enables external equipment to be synced deterministically
    // to the exact moment when trigout_on_ch_testdone_sts_1 is set. 
    // This capability enables external test equipment to be deterministically synched
    // to when Channel 1 CPGC test is completed. 
    // This is required to allow synchronous CPGC operation with external test hardware
    // (HVM Tester, BERT, etc.). 
    // When trigout_on_ch_testdone_sts_1 is set a deterministic externally viewable uBP
    // trigger is generated each time REUT#_GLOBAL_ERR.Channel_Test_Done_Status_1 is
    // set to 1. 
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX trigout_on_ch_testdone_sts_1 : 1;
    //
    // Setting trigout_on_ch_testdone_sts_2 enables external equipment to be synced deterministically
    // to the exact moment when trigout_on_ch_testdone_sts_2 is set. 
    // This capability enables external test equipment to be deterministically synched
    // to when Channel 2 CPGC test is completed. 
    // This is required to allow synchronous CPGC operation with external test hardware
    // (HVM Tester, BERT, etc.). 
    // When trigout_on_ch_testdone_sts_2 is set a deterministic externally viewable uBP
    // trigger is generated each time REUT#_GLOBAL_ERR.Channel_Test_Done_Status_2 is
    // set to 1. 
    // 
    // Bits[17:17], RW_LB, default = 0x0
    //
    UINTX trigout_on_ch_testdone_sts_2 : 1;
    //
    // Setting trigout_on_ch_testdone_sts_3 enables external equipment to be synced deterministically
    // to the exact moment when trigout_on_ch_testdone_sts_3 is set. 
    // This capability enables external test equipment to be deterministically synched
    // to when Channel 3 CPGC test is completed. 
    // This is required to allow synchronous CPGC operation with external test hardware
    // (HVM Tester, BERT, etc.). 
    // When trigout_on_ch_testdone_sts_3 is set a deterministic externally viewable uBP
    // trigger is generated each time REUT#_GLOBAL_ERR.Channel_Test_Done_Status_3 is
    // set to 1. 
    // 
    // Bits[18:18], RW_LB, default = 0x0
    //
    UINTX trigout_on_ch_testdone_sts_3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 13;
  } Bits;
  UINTX Data;
} CPGC_ERR_TRIGCTL_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_DMYRDADDR_HI_MCMAIN_REG                  0x00000D64
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Refer to Bank_Mask0 for details
    // 
    // Bits[15:0], RW_LB, default = 0x0
    //
    UINTX bank_mask2 : 16;
    //
    // Refer to Bank_Mask0 for details
    // 
    // Bits[31:16], RW_LB, default = 0x0
    //
    UINTX bank_mask3 : 16;
  } Bits;
  UINTX Data;
} CPGC_SEQ_DMYRDADDR_HI_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRSTART_HI0_MCMAIN_REG             0x00000D68
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Starting Row Address
    // 
    // Bits[17:0], RW_LB, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Starting Logical Rank Address
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX rank_addr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRSTART_HI0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRSTART_HI1_MCMAIN_REG             0x00000D6C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Starting Row Address
    // 
    // Bits[17:0], RW_LB, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Starting Logical Rank Address
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX rank_addr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRSTART_HI1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRSTART_HI2_MCMAIN_REG             0x00000D70
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Starting Row Address
    // 
    // Bits[17:0], RW_LB, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Starting Logical Rank Address
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX rank_addr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRSTART_HI2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRSTART_HI3_MCMAIN_REG             0x00000D74
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Starting Row Address
    // 
    // Bits[17:0], RW_LB, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Starting Logical Rank Address
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX rank_addr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRSTART_HI3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRWRAP_HI0_MCMAIN_REG              0x00000D78
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Same as field [6:0] for Row-Addr
    // 
    // Bits[17:0], RW_LB, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Same as field [6:0] for Rank-Addr
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX rank_addr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRWRAP_HI0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRWRAP_HI1_MCMAIN_REG              0x00000D7C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Same as field [6:0] for Row-Addr
    // 
    // Bits[17:0], RW_LB, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Same as field [6:0] for Rank-Addr
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX rank_addr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRWRAP_HI1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRWRAP_HI2_MCMAIN_REG              0x00000D80
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Same as field [6:0] for Row-Addr
    // 
    // Bits[17:0], RW_LB, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Same as field [6:0] for Rank-Addr
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX rank_addr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRWRAP_HI2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRWRAP_HI3_MCMAIN_REG              0x00000D84
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Same as field [6:0] for Row-Addr
    // 
    // Bits[17:0], RW_LB, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Same as field [6:0] for Rank-Addr
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX rank_addr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRWRAP_HI3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRCURR_HI0_MCMAIN_REG              0x00000D88
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current Base Row Address
    // 
    // Bits[17:0], RO_V, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Current Base Logical Rank Address
    // 
    // Bits[26:24], RO_V, default = 0x0
    //
    UINTX rank_addr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRCURR_HI0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRCURR_HI1_MCMAIN_REG              0x00000D8C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current Base Row Address
    // 
    // Bits[17:0], RO_V, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Current Base Logical Rank Address
    // 
    // Bits[26:24], RO_V, default = 0x0
    //
    UINTX rank_addr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRCURR_HI1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRCURR_HI2_MCMAIN_REG              0x00000D90
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current Base Row Address
    // 
    // Bits[17:0], RO_V, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Current Base Logical Rank Address
    // 
    // Bits[26:24], RO_V, default = 0x0
    //
    UINTX rank_addr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRCURR_HI2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRCURR_HI3_MCMAIN_REG              0x00000D94
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current Base Row Address
    // 
    // Bits[17:0], RO_V, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // Current Base Logical Rank Address
    // 
    // Bits[26:24], RO_V, default = 0x0
    //
    UINTX rank_addr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRCURR_HI3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRSAVE_LO0_MCMAIN_REG              0x00000D98
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Bits 20:13 are used only for DDRT addresses.
    // 
    // Bits[20:3], RW_LBV, default = 0x0
    //
    UINTX column_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // N/A
    // 
    // Bits[27:24], RW_LBV, default = 0x0
    //
    UINTX bank_addr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRSAVE_LO0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRSAVE_LO1_MCMAIN_REG              0x00000D9C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Bits 20:13 are used only for DDRT addresses. 
    // 
    // Bits[20:3], RW_LBV, default = 0x0
    //
    UINTX column_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // N/A
    // 
    // Bits[27:24], RW_LBV, default = 0x0
    //
    UINTX bank_addr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRSAVE_LO1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRSAVE_LO2_MCMAIN_REG              0x00000DA0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Bits 20:13 are used only for DDRT addresses. 
    // 
    // Bits[20:3], RW_LBV, default = 0x0
    //
    UINTX column_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // N/A
    // 
    // Bits[27:24], RW_LBV, default = 0x0
    //
    UINTX bank_addr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRSAVE_LO2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRSAVE_LO3_MCMAIN_REG              0x00000DA4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Bits 20:13 are used only for DDRT addresses. 
    // 
    // Bits[20:3], RW_LBV, default = 0x0
    //
    UINTX column_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // N/A
    // 
    // Bits[27:24], RW_LBV, default = 0x0
    //
    UINTX bank_addr : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRSAVE_LO3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRSAVE_HI0_MCMAIN_REG              0x00000DA8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[17:0], RW_LBV, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // N/A
    // 
    // Bits[26:24], RW_LBV, default = 0x0
    //
    UINTX rank_addr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRSAVE_HI0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRSAVE_HI1_MCMAIN_REG              0x00000DAC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[17:0], RW_LBV, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // N/A
    // 
    // Bits[26:24], RW_LBV, default = 0x0
    //
    UINTX rank_addr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRSAVE_HI1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRSAVE_HI2_MCMAIN_REG              0x00000DB0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[17:0], RW_LBV, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // N/A
    // 
    // Bits[26:24], RW_LBV, default = 0x0
    //
    UINTX rank_addr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRSAVE_HI2_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_BASEADDRSAVE_HI3_MCMAIN_REG              0x00000DB4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[17:0], RW_LBV, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // N/A
    // 
    // Bits[26:24], RW_LBV, default = 0x0
    //
    UINTX rank_addr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} CPGC_SEQ_BASEADDRSAVE_HI3_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_OFFADDRCUR0_ROW_MCMAIN_REG               0x00000DB8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 12;
    //
    // Current Row Offset Address
    // 
    // Bits[29:12], RO_V, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
  } Bits;
  UINTX Data;
} CPGC_SEQ_OFFADDRCUR0_ROW_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_OFFADDRCUR1_ROW_MCMAIN_REG               0x00000DBC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 12;
    //
    // Current Row Offset Address
    // 
    // Bits[29:12], RO_V, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
  } Bits;
  UINTX Data;
} CPGC_SEQ_OFFADDRCUR1_ROW_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_OFFADDRCUR2_ROW_MCMAIN_REG               0x00000DC0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 12;
    //
    // Current Row Offset Address
    // 
    // Bits[29:12], RO_V, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
  } Bits;
  UINTX Data;
} CPGC_SEQ_OFFADDRCUR2_ROW_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_OFFADDRCUR3_ROW_MCMAIN_REG               0x00000DC4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 12;
    //
    // Current Row Offset Address
    // 
    // Bits[29:12], RO_V, default = 0x0
    //
    UINTX row_addr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
  } Bits;
  UINTX Data;
} CPGC_SEQ_OFFADDRCUR3_ROW_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_X8VLRANKLG2PHYMAP0_MCMAIN_REG            0x00000DD0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // x8 virtual lockstep mode buddy rank 0 mapping
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX br0_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // x8 virtual lockstep mode buddy rank 1 mapping
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX br1_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // x8 virtual lockstep mode buddy rank 2 mapping
    // 
    // Bits[10:8], RW_LB, default = 0x0
    //
    UINTX br2_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // x8 virtual lockstep mode buddy rank 3 mapping
    // 
    // Bits[14:12], RW_LB, default = 0x0
    //
    UINTX br3_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // x8 virtual lockstep mode buddy rank 4 mapping
    // 
    // Bits[18:16], RW_LB, default = 0x0
    //
    UINTX br4_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // x8 virtual lockstep mode buddy rank 5 mapping
    // 
    // Bits[22:20], RW_LB, default = 0x0
    //
    UINTX br5_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // x8 virtual lockstep mode buddy rank 6 mapping
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX br6_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
    //
    // x8 virtual lockstep mode buddy rank 7 mapping
    // 
    // Bits[30:28], RW_LB, default = 0x0
    //
    UINTX br7_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_7 : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQ_X8VLRANKLG2PHYMAP0_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_X8VLRANKLG2PHYMAP1_MCMAIN_REG            0x00000DD4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // x8 virtual lockstep mode buddy rank 0 mapping
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX br0_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // x8 virtual lockstep mode buddy rank 1 mapping
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX br1_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // x8 virtual lockstep mode buddy rank 2 mapping
    // 
    // Bits[10:8], RW_LB, default = 0x0
    //
    UINTX br2_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // x8 virtual lockstep mode buddy rank 3 mapping
    // 
    // Bits[14:12], RW_LB, default = 0x0
    //
    UINTX br3_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // x8 virtual lockstep mode buddy rank 4 mapping
    // 
    // Bits[18:16], RW_LB, default = 0x0
    //
    UINTX br4_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // x8 virtual lockstep mode buddy rank 5 mapping
    // 
    // Bits[22:20], RW_LB, default = 0x0
    //
    UINTX br5_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // x8 virtual lockstep mode buddy rank 6 mapping
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX br6_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
    //
    // x8 virtual lockstep mode buddy rank 7 mapping
    // 
    // Bits[30:28], RW_LB, default = 0x0
    //
    UINTX br7_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_7 : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQ_X8VLRANKLG2PHYMAP1_MCMAIN_STRUCT;
#endif // ASM_INC

#define CPGC_SEQ_X8VLRANKLG2PHYMAP2_MCMAIN_REG            0x00000DD8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // x8 virtual lockstep mode buddy rank 0 mapping
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX br0_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // x8 virtual lockstep mode buddy rank 1 mapping
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX br1_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // x8 virtual lockstep mode buddy rank 2 mapping
    // 
    // Bits[10:8], RW_LB, default = 0x0
    //
    UINTX br2_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // x8 virtual lockstep mode buddy rank 3 mapping
    // 
    // Bits[14:12], RW_LB, default = 0x0
    //
    UINTX br3_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // x8 virtual lockstep mode buddy rank 4 mapping
    // 
    // Bits[18:16], RW_LB, default = 0x0
    //
    UINTX br4_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // x8 virtual lockstep mode buddy rank 5 mapping
    // 
    // Bits[22:20], RW_LB, default = 0x0
    //
    UINTX br5_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // x8 virtual lockstep mode buddy rank 6 mapping
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX br6_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 1;
    //
    // x8 virtual lockstep mode buddy rank 7 mapping
    // 
    // Bits[30:28], RW_LB, default = 0x0
    //
    UINTX br7_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_7 : 1;
  } Bits;
  UINTX Data;
} CPGC_SEQ_X8VLRANKLG2PHYMAP2_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCDFXBGFCONTROL_MCMAIN_REG                        0x00000E00
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             BGF Stop Override (BgfStopOvrd):
    //             The DFx BGF is primarily controlled by the BgfRun signal of primary,
    // functional BGFs in 
    //             DFx BGF's neighborhood. Setting this field to 1, however, forces the
    // DFx BGF to stop. While the BGF is stopped,  
    //             the pattern generator, pattern checker and error counter are not running.
    // When the BGF is restarted  
    //             (i.e. when this field is cleared to 0), the error counter (i.e. the
    // ErrorCount field) is reset. 
    //             
    //             If the BGF's configuration is changed while it is running, spurious
    // errors will be logged.  
    //             To change configuration (pattern mode, read delay, read back borrow,
    // pointer separation offset), the standard procedure  
    //             is to stop the BGF (i.e. set this field 1), change the configuration,
    // and restart the BGF (set this field back to 0). 
    //             All the other writable fields should be sticky through reset. This
    // field is the exception; it should clear during reset. 
    //         
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX bgfstopovrd : 1;
    //
    // 
    //             Pattern Mode (PatternMode):
    //             This field controls the type of test pattern that runs through the
    // DFx FIFO:  
    //               0 = toggle pattern, 
    //               1 = pseudo-random bit sequence. 
    //             (This setting should not be changed while the BGF is running. See
    // Bgf StopOvrd.)  
    //             Path from register to pattern generator and checker may be multi-cycle.
    //         
    // 
    // Bits[1:1], RWS, default = 0x1
    //
    UINTX patternmode : 1;
    //
    // 
    //             Enable Read Delay (EnRdDelay):
    //             While this field (and EnRdBkBrw) is set to 0, BGF read timing follows
    // standard BGF behavior. If this field is set to 1,  
    //             all reads are delayed by one cycle. This setting may be combined with
    // EnRdBkBrw.   
    //             (This setting should not be changed while the BGF is running. See
    // BgfStopOvrd.)        
    //             Path from register to pattern checker may be multi-cycle.
    //         
    // 
    // Bits[2:2], RWS, default = 0x0
    //
    UINTX enrddelay : 1;
    //
    // 
    //             Pointer Separation Offset (EnRdBkBrw):
    //             While this field (and EnRdDelay) is set to 0, BGF read timing follows
    // standard BGF behavior.  
    //             If this field is set to 1, read data is sampled half a read clock
    // earlier. This setting may be combined 
    //             with EnRdDelay. (This setting should not be changed while the BGF
    // is running. See BgfStopOvrd.)     
    //             Path from register to pattern checker may be multi-cycle.
    //         
    // 
    // Bits[3:3], RWS, default = 0x0
    //
    UINTX enrdbkbrw : 1;
    //
    // 
    //             Pointer Separation Offset (PtrSepOffset):
    //             This field specifies the offset between the pointer separation of
    // nearby primary, functional BGFs to the pointer  
    //             separation of the DFx BGF. The DFx BGF's pointer separation is the
    // primary BGFs pointer separation minus this offset.  
    //             (This setting should not be changed while the BGF is running. See
    // bgfstopovrd.)   
    //             Path from register to DFx BGF's pointer separation calculation logic
    // may be multi-cycle. 
    //         
    // 
    // Bits[6:4], RWS, default = 0x1
    //
    UINTX ptrsepoffset : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //             Effective Pointer Separation (PtrSepEff):
    //             This field shows the effective pointer separation applied to the DFx
    // BGF (i.e. it is the primary BGF  
    //             pointer separation minus PtrSepOffset). Note that this value is actually
    // the program value; the 
    //             conceptual pointer separation is the program value plus two.  Shouldn't
    // need any flip-flops at register. 
    //             Value may flow through from logic that computes the effective pointer
    // separation. Path to register may be multi-cycle. 
    //         
    // 
    // Bits[10:8], RO_V, default = 0x0
    //
    UINTX ptrsepeff : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //             This field shows the number of errors accumulated since the DFx BGF
    // was last started. The error count  
    //             saturates at its maximum value. It may be cleared (write 1 to clear)
    // while the BGF is running. 
    //             (Clearing this field does not reset the pattern generator, BGF or
    // pattern checker; they keep running.)      
    //             Shouldn't need any flip-flops at register. Value may flow through
    // from error counter.  
    //             Path from error counter to register may be multi-cycle. 
    //             If path is multi-cycle, then BGF should be stopped (see BgfStopOvrd)
    // to read a, reliable, stable error count value. 
    //             When a 1 is written to this field, send a two-cycle long clear signal
    // to the error counter logic.  
    //             The clear signal may be multi-cycle.
    //         
    // 
    // Bits[31:12], RW1CS, default = 0x0
    //
    UINTX errorcount : 20;
  } Bits;
  UINTX Data;
} MCDFXBGFCONTROL_MCMAIN_STRUCT;
#endif // ASM_INC

#define MH_MAINCNTL_MCMAIN_REG                            0x00000E04
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MEMHOT base temperature. The base temp is subtracted from the hottest DIMM temp
    // to obtain a relative temperature (substituted to zero if negative). The delta
    // temperature is used to generate the MEM_HOT#. 
    // 
    // Bits[7:0], RW, default = 0x1F
    //
    UINTX mh_base_temp : 8;
    //
    // MEMHOT decrement counter rate control field. Every MH_DUTY_CYC_PRD/(2**MH_DUTY_CYC_RATE_CNTL)
    // (i.e. shift right by MH_DUTY_CYC_RATE_CNTL) in 500ns per CNFG_500NANOSEC definition,
    // the delta temperature is subtracted by MH_DUTY_CYC_RATE. If the subtraction result
    // is greater than zero, the corresponding MEM_HOT# is asserted; otherwise, the MEM_HOT#
    // is de-asserted. By setting this field to zero, the MEM_HOT becomes level mode.
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX mh_duty_cyc_rate : 4;
    //
    // Controlling the MEMHOT decrement counter rate. This field defines the number of
    // bits to be right-shifted from the MH_DUTY_CYCLE_PRD value. 
    // When MH_DUTY_CYC_RATE_CNTL
    // = 0, the MH_DUTY_CYC_RATE=MH_DUTY_CYC_PRD/1
    // = 1, the MH_DUTY_CYC_RATE=MH_DUTY_CYC_PRD/2
    // = 2, the MH_DUTY_CYC_RATE=MH_DUTY_CYC_PRD/4
    // = 3, the MH_DUTY_CYC_RATE=MH_DUTY_CYC_PRD/8
    // = 4, the MH_DUTY_CYC_RATE=MH_DUTY_CYC_PRD/16
    // = 5, the MH_DUTY_CYC_RATE=MH_DUTY_CYC_PRD/32
    // = 6, the MH_DUTY_CYC_RATE=MH_DUTY_CYC_PRD/64
    // = 7, the MH_DUTY_CYC_RATE=MH_DUTY_CYC_PRD/128
    // 
    // Bits[14:12], RW, default = 0x6
    //
    UINTX mh_duty_cyc_rate_cntl : 3;
    //
    // MEM_HOT output generation logic enable control.
    // When 0, the MEM_HOT output generation logic is disabled, i.e. MEM_HOT[1:0]# outputs
    // are in de-asserted state, no assertion regardless of the memory temperature. Sensing
    // of externally asserted MEM_HOT[1:0]# is not affected by this bit. IMC will always
    // reset the MH1_DIMM_VAL and MH0_DIMM_VAL bits in the next DCLK so there is no impact
    // to the PCODE update to the MH_TEMP_STAT registers. 
    // When 1, the MEM_HOT output generation logic is enabled.
    // 
    // Bits[15:15], RW_LB, default = 0x1
    //
    UINTX mh_output_en : 1;
    //
    // Externally asserted MEM_HOTsense control enable bit.
    // When set, the MEM_HOT sense logic is enabled.
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX mh_sense_en : 1;
    //
    // this bit enables the MHOT_SMI_EXT_EN, i.e.
    // Generate SMI when either MEMHOT[1:0]# is EXTERNALLY asserted.
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX mhot_smi_en : 1;
    //
    // this bit enables the MHOT_SMI_EN, i.e.
    // Generate SMI during INTERNAL MEMHOT# event assertion.
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINTX mhot_ext_smi_en : 1;
    //
    // When set to one selects SMBus source input 0 for channels 0/1. When zero
    // selects SMBus source input 1A.
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINTX smbus_01src_sel_0 : 1;
    //
    // When set to one selects SMBus source input 1A for channels 2/3. When zero
    // selects SMBus source input 1B.
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX smbus_23src_sel_1a : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 11;
  } Bits;
  UINTX Data;
} MH_MAINCNTL_MCMAIN_STRUCT;
#endif // ASM_INC

#define MH_DUTYCYC_MIN_ASRT_CFG_MCMAIN_REG                0x00000E08
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MEMHOT DUTY Cycle Period Time in number of CNTR_500_NANOSEC. BIOS calculate number
    // of CNTR_500_NANOSEC for 128/256ms. 
    // 
    // Bits[19:0], RW, default = 0x3E800
    //
    UINTX mh_duty_cyc_prd : 20;
    //
    // MEMHOT Minimum Assertion Time in number of CNTR_500_NANOSEC. BIOS calculate number
    // of CNTR_500_NANOSEC for 500usec. 
    // 
    // Bits[31:20], RW, default = 0x1
    //
    UINTX mh_min_asrtn : 12;
  } Bits;
  UINTX Data;
} MH_DUTYCYC_MIN_ASRT_CFG_MCMAIN_STRUCT;
#endif // ASM_INC

#define MH_SENSE_500NS_CFG_MCMAIN_REG                     0x00000E0C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 500ns equivalent in DCLK. BIOS calculate number of DCLK to be equvalent to 500
    // nanoseconds. This value is loaded into CNTR_500_NANOSEC when it is decremented
    // to zero. 
    // The following are the recommended CNFG_500_NANOSEC values based from each DCLK
    // frequency: 
    // DCLK=400MHz, CNFG_500_NANOSEC=0C8h
    // DCLK=533MHz, CNFG_500_NANOSEC=10Ah
    // DCLK=667MHz, CNFG_500_NANOSEC=14Dh
    // DCLK=800MHz, CNFG_500_NANOSEC=190h
    // DCLK=933MHz, CNFG_500_NANOSEC=1D2h
    // 
    // Bits[9:0], RWS_LB, default = 0x190
    //
    UINTX cnfg_500_nanosec : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // MEMHOT Input Sense Assertion Time in number of CNTR_500_NANOSEC. BIOS calculate
    // number of CNFG_500_NANOSEC for 1usec/2usec input_sense duration 
    // Here is MH_IN_SENSE_ASSERT ranges:
    // 0 or 1 Reserved
    // 2 - 7 1usec - 3.5usec sense assertion time in 500nsec increment
    // 
    // Bits[15:13], RW, default = 0x2
    //
    UINTX mh_in_sense_assert : 3;
    //
    // MEMHOT Input Sense Period in number of CNTR_500_NANOSEC. BIOS calculate number
    // of CNTR_500_NANOSEC for 50usec/100usec/200usec/400usec. 
    // 
    // Bits[25:16], RW, default = 0xC8
    //
    UINTX mh_sense_period : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 6;
  } Bits;
  UINTX Data;
} MH_SENSE_500NS_CFG_MCMAIN_STRUCT;
#endif // ASM_INC

#define MH_DTYCYC_MIN_ASRT_CNTR_0_MCMAIN_REG              0x00000E10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MEM_HOT[1:0]# DUTY Cycle Period Current Count in number of CNTR_500_NANOSEC (decrement
    // by 1 every CNTR_500_NANOSEC). When the counter is zero, the next cycle is loaded
    // with MH_DUTY_CYC_PRD. PMSI pause (at quiencense) and resume (at wipe) 
    // 
    // 
    // Bits[19:0], RW_LV, default = 0x0
    //
    UINTX mh_duty_cyc_prd_cntr : 20;
    //
    // MEM_HOT[1:0]# Minimum Assertion Time Current Count in number of CNTR_500_NANOSEC
    // (decrement by 1 every CNTR_500_NANOSEC). When the counter is zero, the counter
    // is remain at zero and it is only loaded with MH_MIN_ASRTN only when MH_DUTY_CYC_PRD_CNTR
    // is reloaded. Not affected by the PSMI quiecense. PSMI quiecense must wait until
    // MH_MIN_ASRTN_CNTR has decremented to zero. 
    // 
    // Bits[31:20], RO_V, default = 0x0
    //
    UINTX mh_min_asrtn_cntr : 12;
  } Bits;
  UINTX Data;
} MH_DTYCYC_MIN_ASRT_CNTR_0_MCMAIN_STRUCT;
#endif // ASM_INC

#define MH_DTYCYC_MIN_ASRT_CNTR_1_MCMAIN_REG              0x00000E14
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MEM_HOT[1:0]# DUTY Cycle Period Current Count in number of CNTR_500_NANOSEC (decrement
    // by 1 every CNTR_500_NANOSEC). When the counter is zero, the next cycle is loaded
    // with MH_DUTY_CYC_PRD. PMSI pause (at quiencense) and resume (at wipe) 
    // 
    // 
    // Bits[19:0], RW_LV, default = 0x0
    //
    UINTX mh_duty_cyc_prd_cntr : 20;
    //
    // MEM_HOT[1:0]# Minimum Assertion Time Current Count in number of CNTR_500_NANOSEC
    // (decrement by 1 every CNTR_500_NANOSEC). When the counter is zero, the counter
    // is remain at zero and it is only loaded with MH_MIN_ASRTN only when MH_DUTY_CYC_PRD_CNTR
    // is reloaded. Not affected by the PSMI quiecense. PSMI quiecense must wait until
    // MH_MIN_ASRTN_CNTR has decremented to zero. 
    // 
    // Bits[31:20], RO_V, default = 0x0
    //
    UINTX mh_min_asrtn_cntr : 12;
  } Bits;
  UINTX Data;
} MH_DTYCYC_MIN_ASRT_CNTR_1_MCMAIN_STRUCT;
#endif // ASM_INC

#define MH_IO_500NS_CNTR_MCMAIN_REG                       0x00000E18
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 500ns base counters used for the MEM_HOT counters and the SMBus counters. BIOS
    // calculate number of DCLK to be equvalent to 500 nanoseconds. CNTR_500_NANOSEC
    // (hardware will decrement this register by 1 every CNTR_500_NANOSEC). When the
    // counter is zero, the next CNTR_500_NANOSEC count is loaded with CNFG_500_NANOSEC.
    // This counter is subject to PMSI pause (at quiencense) and resume (at wipe). 
    // 
    // 
    // Bits[9:0], RW_LV, default = 0x0
    //
    UINTX cntr_500_nanosec : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // MEM_HOT[1:0]# Input Output Counter in number of CNTR_500_NANOSEC. When MH_IO_CNTR
    // is zero, the counter is loaded with MH_SENSE_PERIOD in the next CNTR_500_NANOSEC.
    // When count is greater than MH_IN_SENSE_ASSERT, the MEM_HOT[1:0]# output driver
    // may be turn on if the corresponding MEM_HOT#event is asserted. The receiver is
    // turned off during this time. When count is equal or less than MH_IN_SENSE_ASSERT,
    // MEM_HOT[1:0]# output is disabled and receiver is turned on. BIOS calculate number
    // of CNTR_500_NANOSEC (hardware will decrement this register by 1 every CNTR_500_NANOSEC).
    // When the counter is zero, the next CNTR_500_NANOSEC count is loaded with MH_IN_SENSE_ASSERT.
    // This counter is subject to PMSI pause (at quiencense) and resume (at wipe). 
    // 
    // 
    // Bits[21:12], RW_LV, default = 0x0
    //
    UINTX mh0_io_cntr : 10;
    //
    // MEM_HOT[1:0]# Input Output Counter in number of CNTR_500_NANOSEC. When MH0_IO_CNTR
    // is zero, the counter is loaded with MH_SENSE_PERIOD in the next CNTR_500_NANOSEC.
    // When count is greater than MH_IN_SENSE_ASSERT, the MEM_HOT[1]# output driver may
    // be turn on if the corresponding MEM_HOT#event is asserted. The receiver is turned
    // off during this time. When count is equal or less than MH_IN_SENSE_ASSERT, MEM_HOT[1:0]#
    // output is disabled and receiver is turned on. Hardware will decrement this counter
    // by 1 every time CNTR_500_NANOSEC is decremented to zero. When the counter is zero,
    // the next CNFG_500_NANOSEC count is loaded with MH_IN_SENSE_ASSERT. This counter
    // is subject to PMSI pause (at quiencense) and resume (at wipe). 
    // 
    // 
    // Bits[31:22], RW_LV, default = 0x0
    //
    UINTX mh1_io_cntr : 10;
  } Bits;
  UINTX Data;
} MH_IO_500NS_CNTR_MCMAIN_STRUCT;
#endif // ASM_INC

#define MH_CHN_ASTN_MCMAIN_REG                            0x00000E1C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MemHot[0]# 1st Channel Associationbit 3: is valid bit. Note: Valid bit means the
    // association is valid and it does not implies the channel is populated or exist.
    // bit 2-0: 1st channel ID within this MEMHOT domain
    // 
    // Bits[3:0], RO, default = 0x8
    //
    UINTX mh0_1st_chn_astn : 4;
    //
    // MemHot[0]# 2nd Channel Associationbit 7: is valid bit. Note: Valid bit means the
    // association is valid and it does not implies the channel is populated. 
    // bit 6-4: 2nd channel ID within this MEMHOT domain
    // 
    // Bits[7:4], RO, default = 0x9
    //
    UINTX mh0_2nd_chn_astn : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
    //
    // MemHot[1]# 1st Channel Associationbit 19: is valid bit. Note: Valid bit means
    // the association is valid and it does not implies the channel is populated. 
    // bit 18-16: 1st channel ID within this MEMHOT domain
    // 
    // Bits[19:16], RO, default = 0xA
    //
    UINTX mh1_1st_chn_astn : 4;
    //
    // MemHot[1]# 2nd Channel Associationbit 23: is valid bit. Note: Valid bit means
    // the association is valid and it does not implies the channel is populated. 
    // bit 22-20: 2nd channel ID within this MEMHOT domain.
    // 
    // Bits[23:20], RO, default = 0xB
    //
    UINTX mh1_2nd_chn_astn : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 8;
  } Bits;
  UINTX Data;
} MH_CHN_ASTN_MCMAIN_STRUCT;
#endif // ASM_INC

#define MH_TEMP_STAT_MCMAIN_REG                           0x00000E20
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Hottest DIMM Sensor Reading for MEM_HOT[0]# - This reading represents the temperature
    // of the hottest DIMM. PCODE search the hottest DIMM temperature and write the hottest
    // temperature and the corresponding Hottest DIMM CID/ID. Note: IMC hardware load
    // this value into the MEM_HOT duty cycle generator counter since PCode may update
    // this field at different rate/time. This field is ranged from 0 to 127, i.e. the
    // most significant bit is always zero. 
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX mh0_temp : 8;
    //
    // Hottest DIMM ID for MEM_HOT[0]#. PCODE search the hottest DIMM temperature and
    // write the hottest temperature and the corresponding Hottest DIMM CID/ID. 
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX mh0_dimm_id : 4;
    //
    // Hottest DIMM Channel ID for MEM_HOT[0]#. PCODE search the hottest DIMM temperature
    // and write the hottest temperature and the corresponding Hottest DIMM CID/ID. 
    // 
    // Bits[14:12], RW, default = 0x0
    //
    UINTX mh0_dimm_cid : 3;
    //
    // Valid if set. PCODE search the hottest DIMM temperature and write the hottest
    // temperature and the corresponding Hottest DIMM CID/ID and set the valid bit. MEMHOT
    // hardware logic process the corresponding MEMHOT data when there is a MEMHOT event.
    // Upon processing, the valid bit is reset. PCODE can write over existing valid temparature
    // since a valid temperature may not occur during a MEMHOT event. If PCODE set the
    // valid bit occur at the same cycle that the MEMHOT logic processing and try to
    // clear, the PCODE set will dominate since it is a new temperature is updated while
    // processing logic tries to clear an existing temperature. 
    // 
    // Bits[15:15], RW_V, default = 0x0
    //
    UINTX mh0_dimm_val : 1;
    //
    // Hottest DIMM Sensor Reading for MEM_HOT[1]# - This reading represents the temperature
    // of the hottest DIMM. PCODE search the hottest DIMM temperature and write the hottest
    // temperature and the corresponding Hottest DIMM CID/ID. Note: IMC hardware load
    // this value into the MEM_HOT duty cycle generator counter since PCode may update
    // this field at different rate/time. This field is ranged from 0 to 127, i.e. the
    // most significant bit is always zero. 
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX mh1_temp : 8;
    //
    // Hottest DIMM ID for MEM_HOT[1]#. PCODE search the hottest DIMM temperature and
    // write the hottest temperature and the corresponding Hottest DIMM CID/ID. 
    // 
    // Bits[27:24], RW, default = 0x0
    //
    UINTX mh1_dimm_id : 4;
    //
    // Hottest DIMM Channel ID for MEM_HOT[1]#. PCODE search the hottest DIMM temperature
    // and write the hottest temperature and the corresponding Hottest DIMM CID/ID. 
    // 
    // Bits[30:28], RW, default = 0x0
    //
    UINTX mh1_dimm_cid : 3;
    //
    // Valid if set. PCODE search the hottest DIMM temperature and write the hottest
    // temperature and the corresponding Hottest DIMM CID/ID and set the valid bit. MEMHOT
    // hardware logic process the corresponding MEMHOT data when there is a MEMHOT event.
    // Upon processing, the valid bit is reset. PCODE can write over existing valid temparature
    // since a valid temperature may not occur during a MEMHOT event. If PCODE set the
    // valid bit occur at the same cycle that the MEMHOT logic processing and try to
    // clear, the PCODE set will dominate since it is a new temperature is updated while
    // processing logic tries to clear an existing temperature. 
    // 
    // Bits[31:31], RW_V, default = 0x0
    //
    UINTX mh1_dimm_val : 1;
  } Bits;
  UINTX Data;
} MH_TEMP_STAT_MCMAIN_STRUCT;
#endif // ASM_INC

#define MH_EXT_STAT_MCMAIN_REG                            0x00000E24
#ifndef ASM_INC
typedef union {
  struct {
    //
    // MEM_HOT[0]# assertion status at this sense period.
    // Set if MEM_HOT[0]# is asserted externally for this sense period, this running
    // status bit will automatically updated with the next sensed value in the next MEM_HOT
    // input sense phase. 
    // 
    // Bits[0:0], RW1C, default = 0x0
    //
    UINTX mh_ext_stat_0 : 1;
    //
    // MEM_HOT[1]# assertion status at this sense period.
    // Set if MEM_HOT[1]# is asserted externally for this sense period, this running
    // status bit will automatically updated with the next sensed value in the next MEM_HOT
    // input sense phase. 
    // 
    // Bits[1:1], RW1C, default = 0x0
    //
    UINTX mh_ext_stat_1 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 30;
  } Bits;
  UINTX Data;
} MH_EXT_STAT_MCMAIN_STRUCT;
#endif // ASM_INC

#define SMB0_TLOW_TIMEOUT_CNTR_MCMAIN_REG                 0x00000E70
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SMBus 0 Time-out Timer Counter (18b)
    // 
    // Bits[17:0], RO_V, default = 0x0
    //
    UINTX smb0_tlow_timeout_cntr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
  } Bits;
  UINTX Data;
} SMB0_TLOW_TIMEOUT_CNTR_MCMAIN_STRUCT;
#endif // ASM_INC

#define SMB1_TLOW_TIMEOUT_CNTR_MCMAIN_REG                 0x00000E74
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SMBus 0 Time-out Timer Counter (18b)
    // 
    // Bits[17:0], RO_V, default = 0x0
    //
    UINTX smb1_tlow_timeout_cntr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
  } Bits;
  UINTX Data;
} SMB1_TLOW_TIMEOUT_CNTR_MCMAIN_STRUCT;
#endif // ASM_INC

#define SMB_STAT_0_MCMAIN_REG                             0x00000E80
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read DataHolds data read from SMBus Read commands.
    // Since TSOD/EEPROM are I2C devices and the byte order is MSByte first in a word
    // read, reading of I2C using word read should return SMB_RDATA[15:8]=I2C_MSB and
    // SMB_RDATA[7:0]=I2C_LSB. If reading of I2C using byte read, the SMB_RDATA[15:8]=dont
    // care; SMB_RDATA[7:0]=read_byte. 
    // If we have a SMB slave connected on the bus , reading of the SMBus slave using
    // word read should return SMB_RDATA[15:8]=SMB_LSB and SMB_RDATA[7:0]=SMB_MSB. 
    // If the software is not sure whether the target is I2C or SMBus slave, please use
    // byte access. 
    // 
    // Bits[15:0], RO_V, default = 0x0
    //
    UINTX smb_rdata : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
    //
    // This field captures the last issued TSOD slave address. Here is the slave address
    // and the DDR CHN and DIMM slot mapping: 
    // Slave Address: 0 -- Channel: Even Chn; Slot #: 0
    // Slave Address: 1 -- Channel: Even Chn; Slot #: 1
    // Slave Address: 2 -- Channel: Even Chn; Slot #: 2
    // Slave Address: 3 -- Channel: Even Chn; Slot #: 3 (reserved for future use)
    // Slave Address: 4 -- Channel: Odd Chn; Slot #: 0
    // Slave Address: 5 -- Channel: Odd Chn; Slot #: 1
    // Slave Address: 6 -- Channel: Odd Chn; Slot #: 2
    // Slave Address: 7 -- Channel: Odd Chn; Slot #: 3 (reserved for future use)
    // A value of 8 in this register indicates to poll scalable memory buffer temperature
    // rather than a DIMM temperature, values above 0x8 are invalid. 
    // Since this field only captures the TSOD polling slave address. During SMB error
    // handling, software should check the hung SMB_TSOD_POLL_EN state before disabling
    // the SMB_TSOD_POLL_EN in order to qualify whether this field is valid. 
    // 
    // Bits[27:24], RO_V, default = 0x7
    //
    UINTX tsod_sa : 4;
    //
    // SMBus Busy state. This bit is set by IMC while an SMBus/I2C command (including
    // TSOD command issued from IMC hardware) is executing. Any transaction that is completed
    // normally or gracefully will clear this bit automatically. By setting the SMB_SOFT_RST
    // will also clear this bit. 
    // This register bit is sticky across reset so any surprise reset during pending
    // SMBus operation will sustain the bit assertion across surprised warm-reset. BIOS
    // reset handler can read this bit before issuing any SMBus transaction to determine
    // whether a slave device may need special care to force the slave to idle state
    // (e.g. via clock override toggling (SMB_CKOVRD) and/or via induced time-out by
    // asserting SMB_CKOVRD for 25-35ms). 
    // 
    // Bits[28:28], ROS_V, default = 0x0
    //
    UINTX smb_busy : 1;
    //
    // SMBus Error
    // This bit is set by IMC if an SMBus transaction (including the TSOD polling or
    // message channel initiated SMBus access) that does not complete successfully (non-Ack
    // has been received from slave at expected Ack slot of the transfer). If a slave
    // device is asserting clock stretching, IMC does not have logic to detect this condition
    // to set the SBE bit directly; however, the SMBus master will detect the error at
    // the corresponding transaction's expected ACK slot. 
    // // New in JKT B0:
    // Once SMBUS_SBE bit is set, IMC stops issuing hardware initiated TSOD polling SMBUS
    // transactions until the SMB_SBE is cleared. IMC will not increment the SMB_STAT_x.TSOD_SA
    // until the SMB_SBE is cleared. Manual SMBus command interface is not affected,
    // i.e. new command issue will clear the SMB_SBE. 
    // 
    // Bits[29:29], RO_V, default = 0x0
    //
    UINTX smb_sbe : 1;
    //
    // Write Operation Done
    // This bit is set by IMC when a SMBus Write command has been completed on the SMBus.
    // It is cleared by IMC when a subsequent SMBus Write command is issued. 
    // 
    // Bits[30:30], RO_V, default = 0x0
    //
    UINTX smb_wod : 1;
    //
    // Read Data Valid
    // This bit is set by IMC when the Data field of this register receives read data
    // from the SPD/TSOD after completion of an SMBus read command. It is cleared by
    // IMC when a subsequent SMBus read command is issued. 
    // 
    // Bits[31:31], RO_V, default = 0x0
    //
    UINTX smb_rdo : 1;
  } Bits;
  UINTX Data;
} SMB_STAT_0_MCMAIN_STRUCT;
#endif // ASM_INC

#define SMBCMD_0_MCMAIN_REG                               0x00000E84
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write Data: Holds data to be written by SPDW commands.
    // Since TSOD/EEPROM are I2C devices and the byte order is MSByte first in a word
    // write, writing of I2C using word write should use SMB_WDATA[15:8]=I2C_MSB and
    // SMB_WDATA[7:0]=I2C_LSB. If writing of I2C using byte write, the SMB_WDATA[15:8]=dont
    // care; SMB_WDATA[7:0]=write_byte. 
    // If we have a SMB slave connected on the bus , writing of the SMBus slave using
    // word write should use SMB_WDATA[15:8]=SMB_LSB and SMB_WDATA[7:0]=SMB_MSB. 
    // It is software responsibility to figure out the byte order of the slave access.
    // 
    // Bits[15:0], RWS, default = 0x0
    //
    UINTX smb_wdata : 16;
    //
    // Bus Txn Address: This field identifies the bus transaction address to be accessed.
    // Note: in WORD access, 23:16 specifies 2B access address. In Byte access, 23:16
    // specified 1B access address. 
    // 
    // Bits[23:16], RWS, default = 0x0
    //
    UINTX smb_ba : 8;
    //
    // Slave Address: This field identifies the DIMM SPD/TSOD to be accessed.
    // 
    // Bits[26:24], RWS, default = 0x0
    //
    UINTX smb_sa : 3;
    //
    // When '0', it's a read command
    // When '1', it's a write command
    // 
    // Bits[27:27], RWS, default = 0x0
    //
    UINTX smb_wrt_cmd : 1;
    //
    // Bit[28:27]=00: SMBus Read
    // Bit[28:27]=01: SMBus Write
    // Bit[28:27]=10: illegal combination
    // Bit[28:27]=11: Write to pointer registerSMBus/I2C pointer update (byte). bit 30,
    // and 29 are ignored. Note: SMBCntl_[0:1][26] will NOT disable WrtPntr update command.
    // 
    // Bits[28:28], RWS, default = 0x0
    //
    UINTX smb_wrt_pntr : 1;
    //
    // word access: SMBus/I2C word (2B) access when set; otherwise, it is a byte access.
    // 
    // Bits[29:29], RWS, default = 0x0
    //
    UINTX smb_word_access : 1;
    //
    // Pointer Selection: SMBus/I2C present pointer based access enable when set; otherwise,
    // use random access protocol. Hardware based TSOD polling will also use this bit
    // to enable the pointer word read. 
    // Important Note: the processor hardware based TSOD polling can be configured with
    // pointer based access. If software manually issue SMBus transaction to other address,
    // i.e. changing the pointer in the slave device, it is software's responsibility
    // to restore the pointer in each TSOD before returning to hardware based TSOD polling
    // while keeping the SMB_PNTR_SEL=1. 
    // 
    // Bits[30:30], RWS, default = 0x0
    //
    UINTX smb_pntr_sel : 1;
    //
    // CMD trigger: After setting this bit to 1, the SMBus master will issue the SMBus
    // command using the other fields written in SMBCMD_[0:1] and SMBCntl_[0:1]. Note:
    // the '-V' in the attribute implies the hardware will reset this bit when the SMBus
    // command is being started. 
    // 
    // Bits[31:31], RW_V, default = 0x0
    //
    UINTX smb_cmd_trigger : 1;
  } Bits;
  UINTX Data;
} SMBCMD_0_MCMAIN_STRUCT;
#endif // ASM_INC

#define SMBCNTL_0_MCMAIN_REG                              0x00000E88
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DIMM slot mask to indicate whether the DIMM is equipped with TSOD sensor.
    // Bit 7: must be programmed to zero. Upper channel slot #3 is not supported
    // Bit 6: TSOD PRESENT at upper channel (ch 1 or ch 3) slot #2
    // Bit 5: TSOD PRESENT at upper channel (ch 1 or ch 3) slot #1
    // Bit 4: TSOD PRESENT at upper channel (ch 1 or ch 3) slot #0
    // Bit 3: must be programmed to zero. Lower channel slot #3 is not supported
    // Bit 2: TSOD PRESENT at lower channel (ch 0 or ch 2) slot #2
    // Bit 1: TSOD PRESENT at lower channel (ch 0 or ch 2) slot #1
    // Bit 0: TSOD PRESENT at lower channel (ch 0 or ch 2) slot #0
    // 
    // Bits[7:0], RW_LB, default = 0x0
    //
    UINTX tsod_present : 8;
    //
    // TSOD polling enable
    // '0': disable TSOD polling and enable SPDCMD accesses.
    // '1': disable SPDCMD access and enable TSOD polling.
    // It is important to make sure no pending SMBus transaction and the TSOD polling
    // must be disabled (and pending TSOD polling must be drained) before changing the
    // TSODPOLLEN. 
    // 
    // Bits[8:8], RW_LB, default = 0x0
    //
    UINTX smb_tsod_poll_en : 1;
    //
    // This bit wil start the reading of all enabled devices
    // Note that the hardware will reset this bit when the SMBus polling has started.
    // 
    // Bits[9:9], RW_V, default = 0x0
    //
    UINTX start_tsod_poll : 1;
    //
    // SMBus software reset strobe to graceful terminate pending transaction (after ACK)
    // and keep the SMB from issuing any transaction until this bit is cleared. If slave
    // device is hung, software can write this bit to 1 and the SMB_CKOVRD to 0 (for
    // more than 35ms) to force hung the SMB slaves to time-out and put it in idle state
    // without using power good reset or warm reset. 
    // Note: software need to set the SMB_CKOVRD back to 1 after 35ms in order to force
    // slave devices to time-out in case there is any pending transaction. The corresponding
    // SMB_STAT_x.SMB_SBE error status bit may be set if there was such pending transaction
    // time-out (non-graceful termination). If the pending transaction was a write operation,
    // the slave device content may be corrupted by this clock overide operation. A subsequent
    // SMB command will automatically cleared the SMB_SBE. 
    // // Note for JKT bug #3245558: If this bug fix is approved for B0,
    // The IMC H/W will perform SMB time-out (if the SMB_SBE_EN=1). Software should simply
    // clear the SMB_SBE and SMB_SOFT_RST sequentially after writing the SMB_CKOVRD=0
    // and SMB_SOFT_RST=1 (asserting clock override and perform graceful txn termination).
    // Hardware will automatically de-assert the SMB_CKOVRD (update to 1) after the pre-configured
    // 35ms/65ms time-out. 
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX smb_soft_rst : 1;
    //
    // This bit is used to control how force self refresh enter affects the SMBus controller
    // '0': force_sr_enter does not affect SMBus actions
    // '1': force_sr_enter will reset SMBus controller
    // 
    // Bits[11:11], RW_LB, default = 0x0
    //
    UINTX spd_rst_on_forcesr : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
    //
    // // New in JKT B0:
    // Enable ERR0 assertion when SMB_SBE is 0 --> 1.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX smb_sbe_err0_en : 1;
    //
    // // New in JKT B0:
    // Enable SMI generation when SMB_SBE is 0 --> 1.
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX smb_sbe_smi_en : 1;
    //
    // // New in JKT B0:
    // SMBus errer recovery enable if set.
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX smb_sbe_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Disable SMBus Write
    // Writing a '0' to this bit enables CMD to be set to 1; Writing a 1 to force CMD
    // bit to be always 0, i.e. disabling SMBus write. This bit can only be written in
    // SMMode. SMBus Read is not affected. I2C Write Pointer Update Command is not affected.
    // Important Note to BIOS: Since BIOS is the source to update SMBCNTL_x register
    // initially after reset, it is important to determine wheter the SMBus can have
    // write capabilty before writing any upper bits (bit24-31) via byte-enable config
    // write (or writing any bit within this register via 32b config write) within the
    // SMBCNTL register. 
    // 
    // Bits[26:26], RW_LB, default = 0x1
    //
    UINTX smb_dis_wrt : 1;
    //
    // Clock Override
    // '0' = Clock signal is driven low, overriding writing a '1' to CMD.
    // '1' = Clock signal is released high, allowing normal operation of CMD.
    // Toggling this bit can be used to 'budge' the port out of a 'stuck' state.
    // Software can write this bit to 0 and the SMB_SOFT_RST to 1 to force hung SMBus
    // controller and the SMB slaves to idle state without using power good reset or
    // warm reset. 
    // Note: software need to set the SMB_CKOVRD back to 1 after 35ms in order to force
    // slave devices to time-out in case there is any pending transaction. The corresponding
    // SMB_STAT_x.SMB_SBE error status bit may be set if there was such pending transaction
    // time-out (non-graceful termination). If the pending transaction was a write operation,
    // the slave device content may be corrupted by this clock overide operation. A subsequent
    // SMB command will automatically cleared the SMB_SBE. 
    // // New in JKT B0:
    // IMC added SMBus time-out control timer. When the time-out control timer expired,
    // the SMB_CKOVRD# will "de-assert", i.e. return to 1 value. 
    // 
    // Bits[27:27], RWS_V, default = 0x1
    //
    UINTX smb_ckovrd : 1;
    //
    // Device Type Identifier: This field specifies the device type identifier. Only
    // devices with this device-type will respond to commands. 
    // '0011' specifies TSOD.
    // '1010' specifies EEPROM's.
    // '0110' specifies a write-protect operation for an EEPROM.
    // Other identifiers can be specified to target non-EEPROM devices on the SMBus.
    // 
    // 
    // Bits[31:28], RWS, default = 0xA
    //
    UINTX smb_dti : 4;
  } Bits;
  UINTX Data;
} SMBCNTL_0_MCMAIN_STRUCT;
#endif // ASM_INC

#define SMB_TSOD_POLL_RATE_CNTR_0_MCMAIN_REG              0x00000E8C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // TSOD poll rate counter. When it is decremented to zero, reset to zero or written
    // to zero, SMB_TSOD_POLL_RATE value is loaded into this counter and appear the updated
    // value in the next DCLK. PSMI SMBus Quiecense will freeze the counter for PSMI
    // handler to read. PSMI wipe or the clearing the Quiecense bit will resume the counter.
    // 
    // 
    // Bits[17:0], RW_LV, default = 0x0
    //
    UINTX smb_tsod_poll_rate_cntr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
  } Bits;
  UINTX Data;
} SMB_TSOD_POLL_RATE_CNTR_0_MCMAIN_STRUCT;
#endif // ASM_INC

#define SMB_STAT_1_MCMAIN_REG                             0x00000E90
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read DataHolds data read from SMBus Read commands.
    // Since TSOD/EEPROM are I2C devices and the byte order is MSByte first in a word
    // read, reading of I2C using word read should return SMB_RDATA[15:8]=I2C_MSB and
    // SMB_RDATA[7:0]=I2C_LSB. If reading of I2C using byte read, the SMB_RDATA[15:8]=dont
    // care; SMB_RDATA[7:0]=read_byte. 
    // If we have a SMB slave connected on the bus , reading of the SMBus slave using
    // word read should return SMB_RDATA[15:8]=SMB_LSB and SMB_RDATA[7:0]=SMB_MSB. 
    // If the software is not sure whether the target is I2C or SMBus slave, please use
    // byte access. 
    // 
    // Bits[15:0], RO_V, default = 0x0
    //
    UINTX smb_rdata : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
    //
    // This field captures the last issued TSOD slave address. Here is the slave address
    // and the DDR CHN and DIMM slot mapping: 
    // Slave Address: 0 -- Channel: Even Chn; Slot #: 0
    // Slave Address: 1 -- Channel: Even Chn; Slot #: 1
    // Slave Address: 2 -- Channel: Even Chn; Slot #: 2
    // Slave Address: 3 -- Channel: Even Chn; Slot #: 3 (reserved for future use)
    // Slave Address: 4 -- Channel: Odd Chn; Slot #: 0
    // Slave Address: 5 -- Channel: Odd Chn; Slot #: 1
    // Slave Address: 6 -- Channel: Odd Chn; Slot #: 2
    // Slave Address: 7 -- Channel: Odd Chn; Slot #: 3 (reserved for future use)
    // A value of 8 in this register indicates to poll scalable memory buffer temperature
    // rather than a DIMM temperature, values above 0x8 are invalid. 
    // Since this field only captures the TSOD polling slave address. During SMB error
    // handling, software should check the hung SMB_TSOD_POLL_EN state before disabling
    // the SMB_TSOD_POLL_EN in order to qualify whether this field is valid. 
    // 
    // Bits[27:24], RO_V, default = 0x7
    //
    UINTX tsod_sa : 4;
    //
    // SMBus Busy state. This bit is set by IMC while an SMBus/I2C command (including
    // TSOD command issued from IMC hardware) is executing. Any transaction that is completed
    // normally or gracefully will clear this bit automatically. By setting the SMB_SOFT_RST
    // will also clear this bit. 
    // This register bit is sticky across reset so any surprise reset during pending
    // SMBus operation will sustain the bit assertion across surprised warm-reset. BIOS
    // reset handler can read this bit before issuing any SMBus transaction to determine
    // whether a slave device may need special care to force the slave to idle state
    // (e.g. via clock override toggling (SMB_CKOVRD) and/or via induced time-out by
    // asserting SMB_CKOVRD for 25-35ms). 
    // 
    // Bits[28:28], ROS_V, default = 0x0
    //
    UINTX smb_busy : 1;
    //
    // SMBus Error
    // This bit is set by IMC if an SMBus transaction (including the TSOD polling or
    // message channel initiated SMBus access) that does not complete successfully (non-Ack
    // has been received from slave at expected Ack slot of the transfer). If a slave
    // device is asserting clock stretching, IMC does not have logic to detect this condition
    // to set the SBE bit directly; however, the SMBus master will detect the error at
    // the corresponding transaction's expected ACK slot. 
    // // New in JKT B0:
    // Once SMBUS_SBE bit is set, IMC stops issuing hardware initiated TSOD polling SMBUS
    // transactions until the SMB_SBE is cleared. IMC will not increment the SMB_STAT_x.TSOD_SA
    // until the SMB_SBE is cleared. Manual SMBus command interface is not affected,
    // i.e. new command issue will clear the SMB_SBE. 
    // 
    // Bits[29:29], RO_V, default = 0x0
    //
    UINTX smb_sbe : 1;
    //
    // Write Operation Done
    // This bit is set by IMC when a SMBus Write command has been completed on the SMBus.
    // It is cleared by IMC when a subsequent SMBus Write command is issued. 
    // 
    // Bits[30:30], RO_V, default = 0x0
    //
    UINTX smb_wod : 1;
    //
    // Read Data Valid
    // This bit is set by IMC when the Data field of this register receives read data
    // from the SPD/TSOD after completion of an SMBus read command. It is cleared by
    // IMC when a subsequent SMBus read command is issued. 
    // 
    // Bits[31:31], RO_V, default = 0x0
    //
    UINTX smb_rdo : 1;
  } Bits;
  UINTX Data;
} SMB_STAT_1_MCMAIN_STRUCT;
#endif // ASM_INC

#define SMBCMD_1_MCMAIN_REG                               0x00000E94
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write Data: Holds data to be written by SPDW commands.
    // Since TSOD/EEPROM are I2C devices and the byte order is MSByte first in a word
    // write, writing of I2C using word write should use SMB_WDATA[15:8]=I2C_MSB and
    // SMB_WDATA[7:0]=I2C_LSB. If writing of I2C using byte write, the SMB_WDATA[15:8]=dont
    // care; SMB_WDATA[7:0]=write_byte. 
    // If we have a SMB slave connected on the bus , writing of the SMBus slave using
    // word write should use SMB_WDATA[15:8]=SMB_LSB and SMB_WDATA[7:0]=SMB_MSB. 
    // It is software responsibility to figure out the byte order of the slave access.
    // 
    // Bits[15:0], RWS, default = 0x0
    //
    UINTX smb_wdata : 16;
    //
    // Bus Txn Address: This field identifies the bus transaction address to be accessed.
    // Note: in WORD access, 23:16 specifies 2B access address. In Byte access, 23:16
    // specified 1B access address. 
    // 
    // Bits[23:16], RWS, default = 0x0
    //
    UINTX smb_ba : 8;
    //
    // Slave Address: This field identifies the DIMM SPD/TSOD to be accessed.
    // 
    // Bits[26:24], RWS, default = 0x0
    //
    UINTX smb_sa : 3;
    //
    // When '0', it's a read command
    // When '1', it's a write command
    // 
    // Bits[27:27], RWS, default = 0x0
    //
    UINTX smb_wrt_cmd : 1;
    //
    // Bit[28:27]=00: SMBus Read
    // Bit[28:27]=01: SMBus Write
    // Bit[28:27]=10: illegal combination
    // Bit[28:27]=11: Write to pointer registerSMBus/I2C pointer update (byte). bit 30,
    // and 29 are ignored. Note: SMBCntl_[0:1][26] will NOT disable WrtPntr update command.
    // 
    // Bits[28:28], RWS, default = 0x0
    //
    UINTX smb_wrt_pntr : 1;
    //
    // word access: SMBus/I2C word (2B) access when set; otherwise, it is a byte access.
    // 
    // Bits[29:29], RWS, default = 0x0
    //
    UINTX smb_word_access : 1;
    //
    // Pointer Selection: SMBus/I2C present pointer based access enable when set; otherwise,
    // use random access protocol. Hardware based TSOD polling will also use this bit
    // to enable the pointer word read. 
    // Important Note: the processor hardware based TSOD polling can be configured with
    // pointer based access. If software manually issue SMBus transaction to other address,
    // i.e. changing the pointer in the slave device, it is software's responsibility
    // to restore the pointer in each TSOD before returning to hardware based TSOD polling
    // while keeping the SMB_PNTR_SEL=1. 
    // 
    // Bits[30:30], RWS, default = 0x0
    //
    UINTX smb_pntr_sel : 1;
    //
    // CMD trigger: After setting this bit to 1, the SMBus master will issue the SMBus
    // command using the other fields written in SMBCMD_[0:1] and SMBCntl_[0:1]. Note:
    // the '-V' in the attribute implies the hardware will reset this bit when the SMBus
    // command is being started. 
    // 
    // Bits[31:31], RW_V, default = 0x0
    //
    UINTX smb_cmd_trigger : 1;
  } Bits;
  UINTX Data;
} SMBCMD_1_MCMAIN_STRUCT;
#endif // ASM_INC

#define SMBCNTL_1_MCMAIN_REG                              0x00000E98
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DIMM slot mask to indicate whether the DIMM is equipped with TSOD sensor.
    // Bit 7: must be programmed to zero. Upper channel slot #3 is not supported
    // Bit 6: TSOD PRESENT at upper channel (ch 1 or ch 3) slot #2
    // Bit 5: TSOD PRESENT at upper channel (ch 1 or ch 3) slot #1
    // Bit 4: TSOD PRESENT at upper channel (ch 1 or ch 3) slot #0
    // Bit 3: must be programmed to zero. Lower channel slot #3 is not supported
    // Bit 2: TSOD PRESENT at lower channel (ch 0 or ch 2) slot #2
    // Bit 1: TSOD PRESENT at lower channel (ch 0 or ch 2) slot #1
    // Bit 0: TSOD PRESENT at lower channel (ch 0 or ch 2) slot #0
    // 
    // Bits[7:0], RW_LB, default = 0x0
    //
    UINTX tsod_present : 8;
    //
    // TSOD polling enable
    // '0': disable TSOD polling and enable SPDCMD accesses.
    // '1': disable SPDCMD access and enable TSOD polling.
    // It is important to make sure no pending SMBus transaction and the TSOD polling
    // must be disabled (and pending TSOD polling must be drained) before changing the
    // TSODPOLLEN. 
    // 
    // Bits[8:8], RW_LB, default = 0x0
    //
    UINTX smb_tsod_poll_en : 1;
    //
    // This bit wil start the reading of all enabled devices
    // Note that the hardware will reset this bit when the SMBus polling has started.
    // 
    // Bits[9:9], RW_V, default = 0x0
    //
    UINTX start_tsod_poll : 1;
    //
    // SMBus software reset strobe to graceful terminate pending transaction (after ACK)
    // and keep the SMB from issuing any transaction until this bit is cleared. If slave
    // device is hung, software can write this bit to 1 and the SMB_CKOVRD to 0 (for
    // more than 35ms) to force hung the SMB slaves to time-out and put it in idle state
    // without using power good reset or warm reset. 
    // Note: software need to set the SMB_CKOVRD back to 1 after 35ms in order to force
    // slave devices to time-out in case there is any pending transaction. The corresponding
    // SMB_STAT_x.SMB_SBE error status bit may be set if there was such pending transaction
    // time-out (non-graceful termination). If the pending transaction was a write operation,
    // the slave device content may be corrupted by this clock overide operation. A subsequent
    // SMB command will automatically cleared the SMB_SBE. 
    // // Note for JKT bug #3245558: If this bug fix is approved for B0
    // The IMC H/W will perform SMB time-out (if the SMB_SBE_EN=1). Software should simply
    // clear the SMB_SBE and SMB_SOFT_RST sequentially after writing the SMB_CKOVRD=0
    // and SMB_SOFT_RST=1 (asserting clock override and perform graceful txn termination).
    // Hardware will automatically de-assert the SMB_CKOVRD (update to 1) after the pre-configured
    // 35ms/65ms time-out. 
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINTX smb_soft_rst : 1;
    //
    // This bit is used to control how force self refresh enter affects the SMBus controller
    // '0': force_sr_enter does not affect SMBus actions
    // '1': force_sr_enter will reset SMBus controller
    // 
    // Bits[11:11], RW_LB, default = 0x0
    //
    UINTX spd_rst_on_forcesr : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
    //
    // // New in JKT B0:
    // Enable ERR0 assertion when SMB_SBE is 0 --> 1.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINTX smb_sbe_err0_en : 1;
    //
    // // New in JKT B0:
    // Enable SMI generation when SMB_SBE is 0 --> 1.
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX smb_sbe_smi_en : 1;
    //
    // // New in JKT B0:
    // SMBus errer recovery enable if set.
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX smb_sbe_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Disable SMBus Write
    // Writing a '0' to this bit enables CMD to be set to 1; Writing a 1 to force CMD
    // bit to be always 0, i.e. disabling SMBus write. This bit can only be written 0/1
    // once to enable SMB write disable feature. SMBus Read is not affected. I2C Write
    // Pointer Update Command is not affected. 
    // Either SMB_DIS_WRT=1 or the FUSE_SHADOW_DIS_SMBUS_WRT=1 will disable the SMBus
    // Write Capability. 
    // Important Note to BIOS: Since BIOS is the source to update SMBCNTL_x register
    // initially after reset, it is important to determine wheter the SMBus can have
    // write capabilty before writing any upper bits (bit24-31) via byte-enable config
    // write (or writing any bit within this register via 32b config write) within the
    // SMBCNTL register. 
    // 
    // Bits[26:26], RW_LB, default = 0x1
    //
    UINTX smb_dis_wrt : 1;
    //
    // Clock Override
    // '0' = Clock signal is driven low, overriding writing a '1' to CMD.
    // '1' = Clock signal is released high, allowing normal operation of CMD.
    // Toggling this bit can be used to 'budge' the port out of a 'stuck' state.
    // Software can write this bit to 0 and the SMB_SOFT_RST to 1 to force hung SMBus
    // controller and the SMB slaves to idle state without using power good reset or
    // warm reset. 
    // Note: software need to set the SMB_CKOVRD back to 1 after 35ms in order to force
    // slave devices to time-out in case there is any pending transaction. The corresponding
    // SMB_STAT_x.SMB_SBE error status bit may be set if there was such pending transaction
    // time-out (non-graceful termination). If the pending transaction was a write operation,
    // the slave device content may be corrupted by this clock overide operation. A subsequent
    // SMB command will automatically cleared the SMB_SBE. 
    // // New in JKT B0:
    // IMC added SMBus time-out control timer. When the time-out control timer expired,
    // the SMB_CKOVRD# will "de-assert", i.e. return to 1 value and clear the SMB_SBE=0.
    // 
    // Bits[27:27], RWS_V, default = 0x1
    //
    UINTX smb_ckovrd : 1;
    //
    // Device Type Identifier: This field specifies the device type identifier. Only
    // devices with this device-type will respond to commands. 
    // '0011' specifies TSOD.
    // '1010' specifies EEPROM's.
    // '0110' specifies a write-protect operation for an EEPROM.
    // Other identifiers can be specified to target non-EEPROM devices on the SMBus.
    // 
    // 
    // Bits[31:28], RWS, default = 0xA
    //
    UINTX smb_dti : 4;
  } Bits;
  UINTX Data;
} SMBCNTL_1_MCMAIN_STRUCT;
#endif // ASM_INC

#define SMB_TSOD_POLL_RATE_CNTR_1_MCMAIN_REG              0x00000E9C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // TSOD poll rate counter. When it is decremented to zero, reset to zero or written
    // to zero, SMB_TSOD_POLL_RATE value is loaded into this counter and appear the updated
    // value in the next DCLK. PSMI SMBus Quiecense will freeze the counter for PSMI
    // handler to read. PSMI wipe or the clearing the Quiecense bit will resume the counter.
    // 
    // 
    // Bits[17:0], RW_LV, default = 0x0
    //
    UINTX smb_tsod_poll_rate_cntr : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
  } Bits;
  UINTX Data;
} SMB_TSOD_POLL_RATE_CNTR_1_MCMAIN_STRUCT;
#endif // ASM_INC

#define SMB_PERIOD_CFG_MCMAIN_REG                         0x00000EA0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field specifies both SMBus Clock in number of DCLK. Note: In order to generate
    // a 50% duty cycle SCL, half of the SMB_CLK_PRD is used to generate SCL high. SCL
    // must stay low for at least another half of the SMB_CLK_PRD before pulling high.
    // It is recommend to program an even value in this field since the hardware is simply
    // doing a right shift for the divided by 2 operation. 
    // Note the 100KHz SMB_CLK_PRD default value is calculated based on 800MT/s (400MHz)
    // DCLK. 
    // 
    // Bits[15:0], RWS, default = 0xFA0
    //
    UINTX smb_clk_prd : 16;
    //
    // // New in JKT B0:
    // Upper 16b of the 18b SMBus Time-Out Timer Configuration in unit of MH_SERSE_500NS_CFG.CNFG_500_NANOSEC.
    // The lower 2b of the 18b counter config is always 00. 
    // Assuming the CNFG_500_NANOSEC is set at 500ns:
    // For 35ms time out, please configure this register to 445C
    // For 65ms time out, please configure this register to 7EF4
    // 
    // Bits[31:16], RWS, default = 0x445C
    //
    UINTX smb_tlow_timeout : 16;
  } Bits;
  UINTX Data;
} SMB_PERIOD_CFG_MCMAIN_STRUCT;
#endif // ASM_INC

#define SMB_PERIOD_CNTR_MCMAIN_REG                        0x00000EA4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SMBus #0 Clock Period Counter for Ch 01This field is the current SMBus Clock Period
    // Counter Value. PSMI wipe will clear the counter. 
    // 
    // Bits[15:0], RO_V, default = 0x0
    //
    UINTX smb0_clk_prd_cntr : 16;
    //
    // SMBus #1 Clock Period Counter for Ch 23This field is the current SMBus Clock Period
    // Counter Value. PSMI wipe will clear the counter. 
    // 
    // Bits[31:16], RO_V, default = 0x0
    //
    UINTX smb1_clk_prd_cntr : 16;
  } Bits;
  UINTX Data;
} SMB_PERIOD_CNTR_MCMAIN_STRUCT;
#endif // ASM_INC

#define SMB_TSOD_POLL_RATE_MCMAIN_REG                     0x00000EA8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // TSOD poll rate configuration between consecutive TSOD accesses to the TSOD devices
    // on the same SMBus segment. This field specifies the TSOD poll rate in number of
    // 500ns per CNFG_500_NANOSEC register field definition.For pre-Si validation, minimum
    // TBD can be set (along with the CNFG_500_NANOSEC set to 8) to speed up the simulation.
    // 
    // Bits[17:0], RWS, default = 0x3E800
    //
    UINTX smb_tsod_poll_rate : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
  } Bits;
  UINTX Data;
} SMB_TSOD_POLL_RATE_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCCOMVISACFG_MCMAIN_REG                           0x00000ED4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RW_LB, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RW_LB, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RW_LB, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCCOMVISACFG_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCSPDTOPVISACFG_MCMAIN_REG                        0x00000ED8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RW_LB, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RW_LB, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RW_LB, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCSPDTOPVISACFG_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCSPRVISACFG_MCMAIN_REG                           0x00000EDC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RW_LB, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RW_LB, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RW_LB, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCSPRVISACFG_MCMAIN_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_MH_EXT_MCMAIN_REG                        0x00000EF0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 00 - External MH0EXT Pin
    // 01 - Use Trigger-0 from MCGLBRSPCNTL.GlbRsp0
    // 10 - Use Trigger-1 from MCGLBRSPCNTL.GlbRsp1
    // 11 - Use Trigger-2 from MCGLBRSPCNTL.GlbRsp2
    // Please refer to the processor's DFx related MAS document for further detail.
    // 
    // Bits[1:0], RWS_L, default = 0x0
    //
    UINTX mh0ext_sel : 2;
    //
    // 00 - External MH1EXT Pin
    // 01 - Use Trigger-0 from MCGLBRSPCNTL.GlbRsp0
    // 10 - Use Trigger-1 from MCGLBRSPCNTL.GlbRsp1
    // 11 - Use Trigger-2 from MCGLBRSPCNTL.GlbRsp2
    // Please refer to the processor DFx related MAS document for further detail.
    // 
    // Bits[3:2], RWS_L, default = 0x0
    //
    UINTX mh1ext_sel : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 28;
  } Bits;
  UINTX Data;
} RSP_FUNC_MH_EXT_MCMAIN_STRUCT;
#endif // ASM_INC

#define MXB_SMB_ACCESS_MCMAIN_REG                         0x00000EF4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Slave address, may be a don't care.
    // 
    // Bits[2:0], RWS, default = 0x0
    //
    UINTX sa : 3;
    //
    // Device type identifier, current default value 0xC.
    // 
    // Bits[6:3], RWS, default = 0xC
    //
    UINTX dti : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} MXB_SMB_ACCESS_MCMAIN_STRUCT;
#endif // ASM_INC

#define SVID_MCMAIN_REG                                   0x0000002C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The default value specifies Intel but can be set to any value once after reset.
    // 
    // Bits[15:0], RW_O, default = 0x8086
    //
    UINTX subsystem_vendor_identification_number : 16;
  } Bits;
  UINTX Data;
} SVID_MCMAIN_STRUCT;
#endif // ASM_INC

#define SDID_MCMAIN_REG                                   0x0000002E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Assigned by the subsystem vendor to uniquely identify the subsystem
    // 
    // Bits[15:0], RW_O, default = 0x0
    //
    UINTX subsystem_device_identification_number : 16;
  } Bits;
  UINTX Data;
} SDID_MCMAIN_STRUCT;
#endif // ASM_INC

#define PXPCAP_MCMAIN_REG                                 0x00000040
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Provides the PCI Express capability ID assigned by PCI-SIG.
    // 
    // Bits[7:0], RO, default = 0x10
    //
    UINTX capability_id : 8;
    //
    // Pointer to the next capability. Set to 0 to indicate there are no more capability
    // structures. 
    // 
    // Bits[15:8], RO, default = 0x0
    //
    UINTX next_ptr : 8;
    //
    // PCI Express Capability is Compliant with Version 1.0 of the PCI Express Spec.
    // Note:
    // This capability structure is not compliant with Versions beyond 1.0, since they
    // require additional capability registers to be reserved. The only purpose for this
    // capability structure is to make enhanced configuration space available. Minimizing
    // the size of this structure is accomplished by reporting version 1.0 compliancy
    // and reporting that this is an integrated root port device. As such, only three
    // Dwords of configuration space are required for this structure. 
    // 
    // Bits[19:16], RO, default = 0x1
    //
    UINTX capability_version : 4;
    //
    // Device type is Root Complex Integrated Endpoint
    // 
    // Bits[23:20], RO, default = 0x9
    //
    UINTX device_port_type : 4;
    //
    // N/A for integrated endpoints
    // 
    // Bits[24:24], RO, default = 0x0
    //
    UINTX slot_implemented : 1;
    //
    // N/A for this device
    // 
    // Bits[29:25], RO, default = 0x0
    //
    UINTX interrupt_message_number : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} PXPCAP_MCMAIN_STRUCT;
#endif // ASM_INC

#define DIMMMTR_0_MCMAIN_REG                              0x00000080
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 00 - 10 bits
    // 01 - 11 bits
    // 10 - 12 bits
    // 11 - reserved
    // 
    // Bits[1:0], RWS_LB, default = 0x0
    //
    UINTX ca_width : 2;
    //
    // 000 - reserved 
    // 001 - 13 bits
    // 010 - 14 bits
    // 011 - 15 bits
    // 100 - 16 bits
    // 101 - 17 bits
    // 110 - 18 bits
    // 111: reserved
    // 
    // Bits[4:2], RWS_LB, default = 0x3
    //
    UINTX ra_width : 3;
    //
    // 000 - Reserved
    // 001 - 2Gb
    // 010 - 4Gb
    // 011 - 8Gb
    // 100 - 16Gb
    // 101 - 12Gb
    // 
    // 
    // Bits[7:5], RWS_LB, default = 0x0
    //
    UINTX ddr3_dnsty : 3;
    //
    // 00 - x4
    // 01 - x8
    // 10 - x16
    // 11 - reserved
    // 
    // 
    // Bits[9:8], RWS_LB, default = 0x0
    //
    UINTX ddr3_width : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 
    // 00 - SR
    // 01 - DR
    // 10 - QR
    // 11 - reserved
    // 
    // 
    // Bits[13:12], RWS_LB, default = 0x0
    //
    UINTX rank_cnt : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //             DDR4 DIMM populated if set; otherwise, unpopulated.
    //             Should be set to 0 when this slot is populated with a DDR-T DIMM.
    //         
    // 
    // Bits[15:15], RWS_LB, default = 0x0
    //
    UINTX dimm_pop : 1;
    //
    // RANK Disable Control to disable refresh and ZQCAL operation. This bit setting
    // must be set consistently with TERM_RNK_MSK, i.e. both corresponding bits cannot
    // be set at the same time. In the other word, a disabled rank must not be selected
    // for the terminaton rank. 
    // RANK_DISABLE[3], i.e. bit 19: rank 3 disable. Note DIMMMTR_2.RANK_DISABLE[3] is
    // don't care since DIMM 2 must not be quad-rank 
    // RANK_DISABLE[2], i.e. bit 18: rank 2 disable. Note DIMMMTR_2.RANK_DISABLE[2] is
    // don't care since DIMM 2 must not be quad-rank 
    // RANK_DISABLE[1], i.e. bit 17: rank 1 disable
    // RANK_DISABLE[0], i.e. bit 16: rank 0 disable
    // when set, no refresh will be perform on this rank. ODT termination is not affected
    // by this bit. 
    // Note that patrols are disabled by dimm*_pat_rank_disable of amap register now
    // and not affected by this bit field. 
    // 
    // Bits[19:16], RWS_LB, default = 0x0
    //
    UINTX rank_disable : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // When set, will enable High Density Reduced Load mode which will transmit Row address
    // bits 17:16 on chip select lines 
    // 7:6 and 3:2.
    // 
    // Bits[21:21], RWS_LB, default = 0x0
    //
    UINTX hdrl : 1;
    //
    // When set, will enable parity calculation to include address bits 17:16 which are
    // sent on chip select lines 
    // 7:6 and 3:2.
    // 
    // Bits[22:22], RWS_LB, default = 0x0
    //
    UINTX hdrl_parity : 1;
    //
    // Number of sub ranks per chip select per dimm of DDR4 3DS and non3ds_lrdimm (this
    // is a dimm 
    // specific field. There are restriction on rank_cnt field if this field is nonzero
    // fro 3ds devices. 
    // Can not mix 2 chip_select parts and 1 chip_select part on the same channel)
    // 00- 3ds/non3ds_lrdimm ddr4 multiple ranks/chip select disabled
    // 01- 2 ranks per chip select
    // 10- 4 ranks per chip select
    // 11- 8 ranks per chip select
    // 
    // Bits[24:23], RWS_LB, default = 0x0
    //
    UINTX ddr4_3dsnumranks_cs : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 7;
  } Bits;
  UINTX Data;
} DIMMMTR_0_MCMAIN_STRUCT;
#endif // ASM_INC

#define DIMMMTR_1_MCMAIN_REG                              0x00000084
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 00 - 10 bits
    // 01 - 11 bits
    // 10 - 12 bits
    // 11 - reserved
    // 
    // Bits[1:0], RWS_LB, default = 0x0
    //
    UINTX ca_width : 2;
    //
    // 000 - reserved 
    // 001 - 13 bits
    // 010 - 14 bits
    // 011 - 15 bits
    // 100 - 16 bits
    // 101 - 17 bits
    // 110 - 18 bits
    // 111: reserved
    // 
    // Bits[4:2], RWS_LB, default = 0x3
    //
    UINTX ra_width : 3;
    //
    // 000 - Reserved
    // 001 - 2Gb
    // 010 - 4Gb
    // 011 - 8Gb
    // 100 - 16Gb
    // 101 - 12Gb
    // 
    // 
    // Bits[7:5], RWS_LB, default = 0x0
    //
    UINTX ddr3_dnsty : 3;
    //
    // 00 - x4
    // 01 - x8
    // 10 - x16
    // 11 - reserved
    // 
    // 
    // Bits[9:8], RWS_LB, default = 0x0
    //
    UINTX ddr3_width : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 
    // 00 - SR
    // 01 - DR
    // 10 - QR
    // 11 - reserved
    // 
    // 
    // Bits[13:12], RWS_LB, default = 0x0
    //
    UINTX rank_cnt : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //             DDR4 DIMM populated if set; otherwise, unpopulated.
    //             Should be set to 0 when this slot is populated with a DDR-T DIMM.
    //         
    // 
    // Bits[15:15], RWS_LB, default = 0x0
    //
    UINTX dimm_pop : 1;
    //
    // RANK Disable Control to disable refresh and ZQCAL operation. This bit setting
    // must be set consistently with TERM_RNK_MSK, i.e. both corresponding bits cannot
    // be set at the same time. In the other word, a disabled rank must not be selected
    // for the terminaton rank. 
    // RANK_DISABLE[3], i.e. bit 19: rank 3 disable. Note DIMMMTR_2.RANK_DISABLE[3] is
    // don't care since DIMM 2 must not be quad-rank 
    // RANK_DISABLE[2], i.e. bit 18: rank 2 disable. Note DIMMMTR_2.RANK_DISABLE[2] is
    // don't care since DIMM 2 must not be quad-rank 
    // RANK_DISABLE[1], i.e. bit 17: rank 1 disable
    // RANK_DISABLE[0], i.e. bit 16: rank 0 disable
    // when set, no refresh will be perform on this rank. ODT termination is not affected
    // by this bit. 
    // Note that patrols are disabled by dimm*_pat_rank_disable of amap register now
    // and not affected by this bit field. 
    // 
    // Bits[19:16], RWS_LB, default = 0x0
    //
    UINTX rank_disable : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[22:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // N/A
    // 
    // Bits[24:23], RWS_LB, default = 0x0
    //
    UINTX ddr4_3dsnumranks_cs : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 7;
  } Bits;
  UINTX Data;
} DIMMMTR_1_MCMAIN_STRUCT;
#endif // ASM_INC

#define DIMMMTR_2_MCMAIN_REG                              0x00000088
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 00 - 10 bits
    // 01 - 11 bits
    // 10 - 12 bits
    // 11 - reserved
    // 
    // Bits[1:0], RWS_LB, default = 0x0
    //
    UINTX ca_width : 2;
    //
    // 000 - reserved 
    // 001 - 13 bits
    // 010 - 14 bits
    // 011 - 15 bits
    // 100 - 16 bits
    // 101 - 17 bits
    // 110 - 18 bits
    // 111: reserved
    // 
    // Bits[4:2], RWS_LB, default = 0x3
    //
    UINTX ra_width : 3;
    //
    // 000 - Reserved
    // 001 - 2Gb
    // 010 - 4Gb
    // 011 - 8Gb
    // 100 - 16Gb
    // 101 - 12Gb
    // 
    // 
    // Bits[7:5], RWS_LB, default = 0x0
    //
    UINTX ddr3_dnsty : 3;
    //
    // 00 - x4
    // 01 - x8
    // 10 - x16
    // 11 - reserved
    // 
    // 
    // Bits[9:8], RWS_LB, default = 0x0
    //
    UINTX ddr3_width : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 
    // 00 - SR
    // 01 - DR
    // 10 - QR
    // 11 - reserved
    // 
    // 
    // Bits[13:12], RWS_LB, default = 0x0
    //
    UINTX rank_cnt : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //             DDR4 DIMM populated if set; otherwise, unpopulated.
    //             Should be set to 0 when this slot is populated with a DDR-T DIMM.
    //         
    // 
    // Bits[15:15], RWS_LB, default = 0x0
    //
    UINTX dimm_pop : 1;
    //
    // RANK Disable Control to disable refresh and ZQCAL operation. This bit setting
    // must be set consistently with TERM_RNK_MSK, i.e. both corresponding bits cannot
    // be set at the same time. In the other word, a disabled rank must not be selected
    // for the terminaton rank. 
    // RANK_DISABLE[3], i.e. bit 19: rank 3 disable. Note DIMMMTR_2.RANK_DISABLE[3] is
    // don't care since DIMM 2 must not be quad-rank 
    // RANK_DISABLE[2], i.e. bit 18: rank 2 disable. Note DIMMMTR_2.RANK_DISABLE[2] is
    // don't care since DIMM 2 must not be quad-rank 
    // RANK_DISABLE[1], i.e. bit 17: rank 1 disable
    // RANK_DISABLE[0], i.e. bit 16: rank 0 disable
    // when set, no refresh will be perform on this rank. ODT termination is not affected
    // by this bit. 
    // Note that patrols are disabled by dimm*_pat_rank_disable of amap register now
    // and not affected by this bit field. 
    // 
    // Bits[19:16], RWS_LB, default = 0x0
    //
    UINTX rank_disable : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[22:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // N/A
    // 
    // Bits[24:23], RWS_LB, default = 0x0
    //
    UINTX ddr4_3dsnumranks_cs : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 7;
  } Bits;
  UINTX Data;
} DIMMMTR_2_MCMAIN_STRUCT;
#endif // ASM_INC

#define AMAP_MCMAIN_REG                                   0x0000008C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable DDR4 fine grain bank interleaving. 
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX fine_grain_bank_interleaving : 1;
    //
    // When setting to 1, force additional 1 cycle latency in decoding logic (same latency
    // as 3 channel mode); expected to set to 1 when channel mirroring is enabled. 
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX force_lat : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 13;
    //
    // This field is similar to dimmmtr_*.rank_disable; but it affects only patrol operations.
    // Each bit controls 1 Chip_select's patrol in a given dimm. If 1, patrol engine
    // will skip that 
    // ChipSelect; other wise it will patrol it if dimm is populted and all other patrol
    // conditions are 
    // true. This is intended to be used after rank_sparing to skip patrol of the spared
    // rank. 
    // 
    // Bits[18:15], RW_LB, default = 0x0
    //
    UINTX dimm0_pat_rank_disable : 4;
    //
    // This field is similar to dimmmtr_*.rank_disable; but it affects only patrol operations.
    // Each bit controls 1 Chip_select's patrol in a given dimm. If 1, patrol engine
    // will skip that 
    // ChipSelect; other wise it will patrol it if dimm is populted and all other patrol
    // conditions are 
    // true. This is intended to be used after rank_sparing to skip patrol of the spared
    // rank. 
    // 
    // Bits[22:19], RW_LB, default = 0x0
    //
    UINTX dimm1_pat_rank_disable : 4;
    //
    // This field is similar to dimmmtr_*.rank_disable; but it affects only patrol operations.
    // Each bit controls 1 Chip_select's patrol in a given dimm. If 1, patrol engine
    // will skip that 
    // ChipSelect; other wise it will patrol it if dimm is populted and all other patrol
    // conditions are 
    // true. This is intended to be used after rank_sparing to skip patrol of the spared
    // rank. 
    // 
    // Bits[26:23], RW_LB, default = 0x0
    //
    UINTX dimm2_pat_rank_disable : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} AMAP_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADCHNILVOFFSET_0_MCMAIN_REG                      0x00000090
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  socket interleave wayness
    //                         00 = 1 way,
    //                         01 = 2 way,
    //                         10 = 4 way,
    //                         11 = 8 way.
    //           
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    //  Channel interleave wayness
    //                         00 = 1 way
    //                         01 = 2 way
    //                         10 = 3 way
    //           
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // when set, the skt_wayness will be treated as skt_way*3, with the div3 that thsi
    // implies on the system address at the granularity specified by imc_granularity
    // (used for EX only) 
    //           
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the ch_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM,
    // DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
    //               b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT
    // PMem) 
    //               b'11   reserved
    //               Note:  using the same ch_granularity encoding for both DDRT and
    // DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //           
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} TADCHNILVOFFSET_0_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADCHNILVOFFSET_1_MCMAIN_REG                      0x00000094
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  socket interleave wayness
    //                         00 = 1 way,
    //                         01 = 2 way,
    //                         10 = 4 way,
    //                         11 = 8 way.
    //           
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    //  Channel interleave wayness
    //                         00 = 1 way
    //                         01 = 2 way
    //                         10 = 3 way
    //           
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the ch_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM,
    // DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
    //               b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT
    // PMem) 
    //               b'11   reserved
    //               Note:  using the same ch_granularity encoding for both DDRT and
    // DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //           
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} TADCHNILVOFFSET_1_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADCHNILVOFFSET_2_MCMAIN_REG                      0x00000098
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  socket interleave wayness
    //                         00 = 1 way,
    //                         01 = 2 way,
    //                         10 = 4 way,
    //                         11 = 8 way.
    //           
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    //  Channel interleave wayness
    //                         00 = 1 way
    //                         01 = 2 way
    //                         10 = 3 way
    //           
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the ch_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM,
    // DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
    //               b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT
    // PMem) 
    //               b'11   reserved
    //               Note:  using the same ch_granularity encoding for both DDRT and
    // DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //           
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} TADCHNILVOFFSET_2_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADCHNILVOFFSET_3_MCMAIN_REG                      0x0000009C
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  socket interleave wayness
    //                         00 = 1 way,
    //                         01 = 2 way,
    //                         10 = 4 way,
    //                         11 = 8 way.
    //           
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    //  Channel interleave wayness
    //                         00 = 1 way
    //                         01 = 2 way
    //                         10 = 3 way
    //           
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the ch_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM,
    // DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
    //               b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT
    // PMem) 
    //               b'11   reserved
    //               Note:  using the same ch_granularity encoding for both DDRT and
    // DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //           
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} TADCHNILVOFFSET_3_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADCHNILVOFFSET_4_MCMAIN_REG                      0x000000A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  socket interleave wayness
    //                         00 = 1 way,
    //                         01 = 2 way,
    //                         10 = 4 way,
    //                         11 = 8 way.
    //           
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    //  Channel interleave wayness
    //                         00 = 1 way
    //                         01 = 2 way
    //                         10 = 3 way
    //           
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the ch_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM,
    // DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
    //               b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT
    // PMem) 
    //               b'11   reserved
    //               Note:  using the same ch_granularity encoding for both DDRT and
    // DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //           
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} TADCHNILVOFFSET_4_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADCHNILVOFFSET_5_MCMAIN_REG                      0x000000A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  socket interleave wayness
    //                         00 = 1 way,
    //                         01 = 2 way,
    //                         10 = 4 way,
    //                         11 = 8 way.
    //           
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    //  Channel interleave wayness
    //                         00 = 1 way
    //                         01 = 2 way
    //                         10 = 3 way
    //           
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the ch_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM,
    // DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
    //               b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT
    // PMem) 
    //               b'11   reserved
    //               Note:  using the same ch_granularity encoding for both DDRT and
    // DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //           
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} TADCHNILVOFFSET_5_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADCHNILVOFFSET_6_MCMAIN_REG                      0x000000A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  socket interleave wayness
    //                         00 = 1 way,
    //                         01 = 2 way,
    //                         10 = 4 way,
    //                         11 = 8 way.
    //           
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    //  Channel interleave wayness
    //                         00 = 1 way
    //                         01 = 2 way
    //                         10 = 3 way
    //           
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the ch_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM,
    // DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
    //               b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT
    // PMem) 
    //               b'11   reserved
    //               Note:  using the same ch_granularity encoding for both DDRT and
    // DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //           
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} TADCHNILVOFFSET_6_MCMAIN_STRUCT;
#endif // ASM_INC

#define TADCHNILVOFFSET_7_MCMAIN_REG                      0x000000AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  socket interleave wayness
    //                         00 = 1 way,
    //                         01 = 2 way,
    //                         10 = 4 way,
    //                         11 = 8 way.
    //           
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    //  Channel interleave wayness
    //                         00 = 1 way
    //                         01 = 2 way
    //                         10 = 3 way
    //           
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the ch_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM,
    // DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
    //               b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT
    // PMem) 
    //               b'11   reserved
    //               Note:  using the same ch_granularity encoding for both DDRT and
    // DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //           
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} TADCHNILVOFFSET_7_MCMAIN_STRUCT;
#endif // ASM_INC

#define MEM_SIZE_CONTROL_MCMAIN_REG                       0x000000C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable address crop for fast div-3
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX enable : 1;
    //
    // Per Channel Near Memory Capacity.
    // 4'h0 - 4GB
    // 4'h1 - 8GB
    // 4'h2 - 16GB
    // 4'h3 - 32GB
    // 4'h4 - 64GB
    // 4'h5 - 128GB
    // 4'h6 - 256GB
    // 4'h7 - 512GB
    // 4'b1xxx - Reserved
    // This field can be programmed on the per-channel basis.
    // 
    // 
    // Bits[4:1], RW_LB, default = 0x0
    //
    UINTX nm_chn_cap : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 27;
  } Bits;
  UINTX Data;
} MEM_SIZE_CONTROL_MCMAIN_STRUCT;
#endif // ASM_INC

#define PXPENHCAP_MCMAIN_REG                              0x00000100
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Indicates there are no capability structures in the enhanced configuration space.
    // 
    // Bits[15:0], RO, default = 0x0
    //
    UINTX capability_id : 16;
    //
    // Indicates there are no capability structures in the enhanced configuration space.
    // 
    // Bits[19:16], RO, default = 0x0
    //
    UINTX capability_version : 4;
    //
    // N/A
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX next_capability_offset : 12;
  } Bits;
  UINTX Data;
} PXPENHCAP_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRWAYNESSLIMIT_0_MCMAIN_REG                      0x00000108
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[0:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // RIR[4:0].LIMIT[39:29] == highest address of the range in channel address space,
    // 384GB in lock-step/192GB in independent channel, 512MB granularity.  
    // 
    // Bits[11:1], RW_LB, default = 0x0
    //
    UINTX rir_limit : 11;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 16;
    //
    // rank interleave wayness00 = 1 way,
    //            01 = 2 way,
    //            10 = 4 way,
    //            11 = 8 way.
    // 
    // Bits[29:28], RW_LB, default = 0x0
    //
    UINTX rir_way : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Range Valid when set; otherwise, invalid
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX rir_val : 1;
  } Bits;
  UINTX Data;
} RIRWAYNESSLIMIT_0_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRWAYNESSLIMIT_1_MCMAIN_REG                      0x0000010C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[0:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // RIR[4:0].LIMIT[39:29] == highest address of the range in channel address space,
    // 384GB in lock-step/192GB in independent channel, 512MB granularity.  
    // 
    // Bits[11:1], RW_LB, default = 0x0
    //
    UINTX rir_limit : 11;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 16;
    //
    // rank interleave wayness00 = 1 way,
    //            01 = 2 way,
    //            10 = 4 way,
    //            11 = 8 way.
    // 
    // Bits[29:28], RW_LB, default = 0x0
    //
    UINTX rir_way : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Range Valid when set; otherwise, invalid
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX rir_val : 1;
  } Bits;
  UINTX Data;
} RIRWAYNESSLIMIT_1_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRWAYNESSLIMIT_2_MCMAIN_REG                      0x00000110
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[0:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // RIR[4:0].LIMIT[39:29] == highest address of the range in channel address space,
    // 384GB in lock-step/192GB in independent channel, 512MB granularity.  
    // 
    // Bits[11:1], RW_LB, default = 0x0
    //
    UINTX rir_limit : 11;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 16;
    //
    // rank interleave wayness00 = 1 way,
    //            01 = 2 way,
    //            10 = 4 way,
    //            11 = 8 way.
    // 
    // Bits[29:28], RW_LB, default = 0x0
    //
    UINTX rir_way : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Range Valid when set; otherwise, invalid
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX rir_val : 1;
  } Bits;
  UINTX Data;
} RIRWAYNESSLIMIT_2_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRWAYNESSLIMIT_3_MCMAIN_REG                      0x00000114
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[0:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // RIR[4:0].LIMIT[39:29] == highest address of the range in channel address space,
    // 384GB in lock-step/192GB in independent channel, 512MB granularity.  
    // 
    // Bits[11:1], RW_LB, default = 0x0
    //
    UINTX rir_limit : 11;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 16;
    //
    // rank interleave wayness00 = 1 way,
    //            01 = 2 way,
    //            10 = 4 way,
    //            11 = 8 way.
    // 
    // Bits[29:28], RW_LB, default = 0x0
    //
    UINTX rir_way : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Range Valid when set; otherwise, invalid
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX rir_val : 1;
  } Bits;
  UINTX Data;
} RIRWAYNESSLIMIT_3_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV0OFFSET_0_MCMAIN_REG                        0x00000120
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET0[39:26] == rank interleave 0 offset, 64MB granularity 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset0 : 14;
    //
    // target rank ID for rank interleave 0 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt0 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV0OFFSET_0_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV0OFFSET_1_MCMAIN_REG                        0x00000124
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET0[39:26] == rank interleave 0 offset, 64MB granularity 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset0 : 14;
    //
    // target rank ID for rank interleave 0 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt0 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV0OFFSET_1_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV0OFFSET_2_MCMAIN_REG                        0x00000128
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET0[39:26] == rank interleave 0 offset, 64MB granularity 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset0 : 14;
    //
    // target rank ID for rank interleave 0 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt0 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV0OFFSET_2_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV0OFFSET_3_MCMAIN_REG                        0x0000012C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET0[39:26] == rank interleave 0 offset, 64MB granularity 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset0 : 14;
    //
    // target rank ID for rank interleave 0 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt0 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV0OFFSET_3_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV1OFFSET_0_MCMAIN_REG                        0x00000130
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET1[39:26] == rank interleave 1 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    //         
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset1 : 14;
    //
    // target rank ID for rank interleave 1 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt1 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV1OFFSET_0_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV1OFFSET_1_MCMAIN_REG                        0x00000134
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET1[39:26] == rank interleave 1 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    //         
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset1 : 14;
    //
    // target rank ID for rank interleave 1 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt1 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV1OFFSET_1_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV1OFFSET_2_MCMAIN_REG                        0x00000138
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET1[39:26] == rank interleave 1 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    //         
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset1 : 14;
    //
    // target rank ID for rank interleave 1 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt1 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV1OFFSET_2_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV1OFFSET_3_MCMAIN_REG                        0x0000013C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET1[39:26] == rank interleave 1 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    //         
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset1 : 14;
    //
    // target rank ID for rank interleave 1 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt1 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV1OFFSET_3_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV2OFFSET_0_MCMAIN_REG                        0x00000140
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET2[39:26] == rank interleave 2 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset2 : 14;
    //
    // target rank ID for rank interleave 2 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt2 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV2OFFSET_0_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV2OFFSET_1_MCMAIN_REG                        0x00000144
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET2[39:26] == rank interleave 2 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset2 : 14;
    //
    // target rank ID for rank interleave 2 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt2 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV2OFFSET_1_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV2OFFSET_2_MCMAIN_REG                        0x00000148
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET2[39:26] == rank interleave 2 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset2 : 14;
    //
    // target rank ID for rank interleave 2 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt2 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV2OFFSET_2_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV2OFFSET_3_MCMAIN_REG                        0x0000014C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET2[39:26] == rank interleave 2 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset2 : 14;
    //
    // target rank ID for rank interleave 2 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt2 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV2OFFSET_3_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV3OFFSET_0_MCMAIN_REG                        0x00000150
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET3[39:26] == rank interleave 3 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset3 : 14;
    //
    // target rank ID for rank interleave 3 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV3OFFSET_0_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV3OFFSET_1_MCMAIN_REG                        0x00000154
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET3[39:26] == rank interleave 3 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset3 : 14;
    //
    // target rank ID for rank interleave 3 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV3OFFSET_1_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV3OFFSET_2_MCMAIN_REG                        0x00000158
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET3[39:26] == rank interleave 3 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset3 : 14;
    //
    // target rank ID for rank interleave 3 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV3OFFSET_2_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV3OFFSET_3_MCMAIN_REG                        0x0000015C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET3[39:26] == rank interleave 3 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset3 : 14;
    //
    // target rank ID for rank interleave 3 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV3OFFSET_3_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV4OFFSET_0_MCMAIN_REG                        0x00000160
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET4[39:26] == rank interleave 4 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset4 : 14;
    //
    // target rank ID for rank interleave 4 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt4 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV4OFFSET_0_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV4OFFSET_1_MCMAIN_REG                        0x00000164
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET4[39:26] == rank interleave 4 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset4 : 14;
    //
    // target rank ID for rank interleave 4 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt4 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV4OFFSET_1_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV4OFFSET_2_MCMAIN_REG                        0x00000168
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET4[39:26] == rank interleave 4 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset4 : 14;
    //
    // target rank ID for rank interleave 4 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt4 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV4OFFSET_2_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV4OFFSET_3_MCMAIN_REG                        0x0000016C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET4[39:26] == rank interleave 4 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset4 : 14;
    //
    // target rank ID for rank interleave 4 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt4 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV4OFFSET_3_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV5OFFSET_0_MCMAIN_REG                        0x00000170
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET5[39:26] == rank interleave 5 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset5 : 14;
    //
    // target rank ID for rank interleave 5 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt5 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV5OFFSET_0_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV5OFFSET_1_MCMAIN_REG                        0x00000174
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET5[39:26] == rank interleave 5 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset5 : 14;
    //
    // target rank ID for rank interleave 5 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt5 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV5OFFSET_1_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV5OFFSET_2_MCMAIN_REG                        0x00000178
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET5[39:26] == rank interleave 5 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset5 : 14;
    //
    // target rank ID for rank interleave 5 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt5 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV5OFFSET_2_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV5OFFSET_3_MCMAIN_REG                        0x0000017C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET5[39:26] == rank interleave 5 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset5 : 14;
    //
    // target rank ID for rank interleave 5 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt5 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV5OFFSET_3_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV6OFFSET_0_MCMAIN_REG                        0x00000180
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET6[39:26] == rank interleave 6 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset6 : 14;
    //
    // target rank ID for rank interleave 6 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt6 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV6OFFSET_0_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV6OFFSET_1_MCMAIN_REG                        0x00000184
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET6[39:26] == rank interleave 6 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset6 : 14;
    //
    // target rank ID for rank interleave 6 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt6 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV6OFFSET_1_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV6OFFSET_2_MCMAIN_REG                        0x00000188
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET6[39:26] == rank interleave 6 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset6 : 14;
    //
    // target rank ID for rank interleave 6 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt6 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV6OFFSET_2_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV6OFFSET_3_MCMAIN_REG                        0x0000018C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET6[39:26] == rank interleave 6 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset6 : 14;
    //
    // target rank ID for rank interleave 6 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt6 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV6OFFSET_3_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV7OFFSET_0_MCMAIN_REG                        0x00000190
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET7[39:26] == rank interleave 0 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset7 : 14;
    //
    // target rank ID for rank interleave 7 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt7 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV7OFFSET_0_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV7OFFSET_1_MCMAIN_REG                        0x00000194
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET7[39:26] == rank interleave 0 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset7 : 14;
    //
    // target rank ID for rank interleave 7 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt7 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV7OFFSET_1_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV7OFFSET_2_MCMAIN_REG                        0x00000198
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET7[39:26] == rank interleave 0 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset7 : 14;
    //
    // target rank ID for rank interleave 7 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt7 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV7OFFSET_2_MCMAIN_STRUCT;
#endif // ASM_INC

#define RIRILV7OFFSET_3_MCMAIN_REG                        0x0000019C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET7[39:26] == rank interleave 0 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset7 : 14;
    //
    // target rank ID for rank interleave 7 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt7 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV7OFFSET_3_MCMAIN_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_ADDR_MATCH_LO_MCMAIN_REG                 0x000001C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Addr Match Lower: 32-bits (Match Addr[34:3])
    // 
    // Bits[31:0], RWS, default = 0x0
    //
    UINTX addr_match_lower : 32;
  } Bits;
  UINTX Data;
} RSP_FUNC_ADDR_MATCH_LO_MCMAIN_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_ADDR_MATCH_HI_MCMAIN_REG                 0x000001C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Addr Match Higher : 11-Bits (Match Addr[45:35])
    // 
    // Bits[10:0], RWS, default = 0x0
    //
    UINTX addr_match_higher : 11;
    //
    // Enabling the Address Match Response Function when set.
    // 
    // Bits[11:11], RWS_LV, default = 0x0
    //
    UINTX rsp_func_addr_match_en : 1;
    //
    // The enable bit RSP_FUNC_ADDR_MATCH_EN will not be self cleared after match if
    // this field is set. Continuous address matching. 
    // 
    // Bits[12:12], RWS, default = 0x0
    //
    UINTX rsp_func_addr_match_always : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // HTID comparison value for array dump. Note array dump function is only enabled
    // when the WPQ_DUMP_CFG2.VALID or the RPQ_DUMP_CFG2.VALID are enabled. 
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX htid_match : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Additional match configuration: Bit 0 matches with Mirror field; Bit 1 matches
    // with mirr_pri (primary channel); Bit 2 matches with demand scrub request 
    // 
    // Bits[27:25], RWS, default = 0x0
    //
    UINTX mirror_match : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} RSP_FUNC_ADDR_MATCH_HI_MCMAIN_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_ADDR_MASK_LO_MCMAIN_REG                  0x000001C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Address Mask to deselect (when set) the corresponding Addr[34:3] for the address
    // match. 
    // 
    // Bits[31:0], RWS, default = 0xFFFFFFFF
    //
    UINTX addr_mask_lower : 32;
  } Bits;
  UINTX Data;
} RSP_FUNC_ADDR_MASK_LO_MCMAIN_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_ADDR_MASK_HI_MCMAIN_REG                  0x000001CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Address Mask to deselect (when set) the corresponding Addr[45:35] for the address
    // match. 
    // 
    // Bits[10:0], RWS, default = 0x7FF
    //
    UINTX addr_mask_higher : 11;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // HTID mask comparison value for array dump
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX htid_mask : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Additional mask to deselect (when set) the corresponding bits in mirror_mask field.
    // Bit 0 is mask for Mirror field; Bit 1 is mask for mirr_pri (primary channel);
    // Bit 2 is mask for demand scrub request 
    // 
    // Bits[27:25], RWS, default = 0x7
    //
    UINTX mirror_mask : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} RSP_FUNC_ADDR_MASK_HI_MCMAIN_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_RANK_BANK_MATCH_MCMAIN_REG               0x000001D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bank to match
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX bank : 4;
    //
    // Rank to match
    // 
    // Bits[6:4], RW, default = 0x0
    //
    UINTX rank : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
    //
    // Disable any injection matching on Patrol or Spare transactions. This applies to
    // rank/bank match and system address match. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX dis_patspr : 1;
    //
    // Enable rank and bank matching
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} RSP_FUNC_RANK_BANK_MATCH_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCDECSVISACFG_MCMAIN_REG                          0x000001E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RWS_L, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RWS_L, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RWS_L, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RWS_L, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RWS_L, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCDECSVISACFG_MCMAIN_STRUCT;
#endif // ASM_INC

#define ECC_MODE_RANK0_MCMAIN_REG                         0x00000210
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This field specifies the ECC in use for this rank, for portions of
    // the rank not participating in an ADDDC region. 
    //             0 = No failure
    //             1 = Parity substitution.  EP:  Detect only, EX:  Single bit correction
    //             This field is set by software at the beginning of a sparing flow.
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} ECC_MODE_RANK0_MCMAIN_STRUCT;
#endif // ASM_INC

#define ECC_MODE_RANK1_MCMAIN_REG                         0x00000211
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This field specifies the ECC in use for this rank, for portions of
    // the rank not participating in an ADDDC region. 
    //             0 = No failure
    //             1 = Parity substitution.  EP:  Detect only, EX:  Single bit correction
    //             This field is set by software at the beginning of a sparing flow.
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} ECC_MODE_RANK1_MCMAIN_STRUCT;
#endif // ASM_INC

#define ECC_MODE_RANK2_MCMAIN_REG                         0x00000212
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This field specifies the ECC in use for this rank, for portions of
    // the rank not participating in an ADDDC region. 
    //             0 = No failure
    //             1 = Parity substitution.  EP:  Detect only, EX:  Single bit correction
    //             This field is set by software at the beginning of a sparing flow.
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} ECC_MODE_RANK2_MCMAIN_STRUCT;
#endif // ASM_INC

#define ECC_MODE_RANK3_MCMAIN_REG                         0x00000213
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This field specifies the ECC in use for this rank, for portions of
    // the rank not participating in an ADDDC region. 
    //             0 = No failure
    //             1 = Parity substitution.  EP:  Detect only, EX:  Single bit correction
    //             This field is set by software at the beginning of a sparing flow.
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} ECC_MODE_RANK3_MCMAIN_STRUCT;
#endif // ASM_INC

#define ECC_MODE_RANK4_MCMAIN_REG                         0x00000214
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This field specifies the ECC in use for this rank, for portions of
    // the rank not participating in an ADDDC region. 
    //             0 = No failure
    //             1 = Parity substitution.  EP:  Detect only, EX:  Single bit correction
    //             This field is set by software at the beginning of a sparing flow.
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} ECC_MODE_RANK4_MCMAIN_STRUCT;
#endif // ASM_INC

#define ECC_MODE_RANK5_MCMAIN_REG                         0x00000215
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This field specifies the ECC in use for this rank, for portions of
    // the rank not participating in an ADDDC region. 
    //             0 = No failure
    //             1 = Parity substitution.  EP:  Detect only, EX:  Single bit correction
    //             This field is set by software at the beginning of a sparing flow.
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} ECC_MODE_RANK5_MCMAIN_STRUCT;
#endif // ASM_INC

#define ECC_MODE_RANK6_MCMAIN_REG                         0x00000216
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This field specifies the ECC in use for this rank, for portions of
    // the rank not participating in an ADDDC region. 
    //             0 = No failure
    //             1 = Parity substitution.  EP:  Detect only, EX:  Single bit correction
    //             This field is set by software at the beginning of a sparing flow.
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} ECC_MODE_RANK6_MCMAIN_STRUCT;
#endif // ASM_INC

#define ECC_MODE_RANK7_MCMAIN_REG                         0x00000217
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This field specifies the ECC in use for this rank, for portions of
    // the rank not participating in an ADDDC region. 
    //             0 = No failure
    //             1 = Parity substitution.  EP:  Detect only, EX:  Single bit correction
    //             This field is set by software at the beginning of a sparing flow.
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} ECC_MODE_RANK7_MCMAIN_STRUCT;
#endif // ASM_INC

#define ADDDC_REGION0_CONTROL_MCMAIN_REG                  0x00000230
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This bit specifies whether the ADDDC region is in use.
    //             0=ADDDC not enabled for this region
    //             1=ADDDC enabled for this region
    //             This bit should be set by software before the beginning of the ADDDC
    // sparing copy flow. 
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX region_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //             Granularity for this ADDDC region:
    //             00=bank
    //             01=rank
    //             10=reserved 
    //             11=reserved
    //         
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX region_size : 2;
    //
    // 
    //             This field specifies the Chip Select (rank) to match when determining
    // if this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  The value in this field is encoded (Chip Selects are normally 1-hot), corresponding
    // to CS0-CS7.  When the failed region is a DIMM, two region registers should be
    // programmed corresponding to both Chip Selects of the failed DIMM. 
    //         
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX failed_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //             This field specifies the subrank to match when determining if this
    // is the failed region participating in ADDDC.  Only used when region_size=bank.
    //         
    // 
    // Bits[10:8], RW_LB, default = 0x0
    //
    UINTX failed_c : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // 
    //             This field specifies the bank address to match when determining if
    // this is the failed region participating in ADDDC.  Only used when region_size=bank.
    //         
    // 
    // Bits[13:12], RW_LB, default = 0x0
    //
    UINTX failed_ba : 2;
    //
    // 
    //             This field specifies the bank group to match when determining if this
    // is the failed region participating in ADDDC.  Only used when region_size=bank.
    //         
    // 
    // Bits[15:14], RW_LB, default = 0x0
    //
    UINTX failed_bg : 2;
    //
    // 
    //             This field specifies the Chip Select (rank) to match when determining
    // if this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  The value in this field is encoded (Chip Selects are normally 1-hot), corresponding
    // to CS0-CS7.  When the failed region is a DIMM, two region registers should be
    // programmed corresponding to both Chip Selects of the failed DIMM. 
    //         
    // 
    // Bits[18:16], RW_LB, default = 0x0
    //
    UINTX nonfailed_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // 
    //             This field specifies the subrank to match when determining if this
    // is the failed region participating in ADDDC.  Only used when region_size=bank.
    //         
    // 
    // Bits[22:20], RW_LB, default = 0x0
    //
    UINTX nonfailed_c : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // 
    //             This field specifies the bank address to match when determining if
    // this is the failed region participating in ADDDC.  Only used when region_size=bank.
    //         
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX nonfailed_ba : 2;
    //
    // 
    //             This field specifies the bank group to match when determining if this
    // is the failed region participating in ADDDC.  Only used when region_size=bank.
    //         
    // 
    // Bits[27:26], RW_LB, default = 0x0
    //
    UINTX nonfailed_bg : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // 
    //             This field specifies that ADDDC spare copy is on-going for this region.
    //             This bit should be set by BIOS before starting the ADDDC sparing copy
    // flow. 
    //             This bit should be cleared by hardware at the end of the sparing copy
    // flow. 
    //         
    // 
    // Bits[29:29], RW_LBV, default = 0x0
    //
    UINTX copy_in_progress : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 2;
  } Bits;
  UINTX Data;
} ADDDC_REGION0_CONTROL_MCMAIN_STRUCT;
#endif // ASM_INC

#define ADDDC_REGION1_CONTROL_MCMAIN_REG                  0x00000234
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This bit specifies whether the ADDDC region is in use.
    //             0=ADDDC not enabled for this region
    //             1=ADDDC enabled for this region
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX region_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //             Granularity for this ADDDC region:
    //             00=bank
    //             01=rank
    //             10=reserved 
    //             11=reserved
    //         
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX region_size : 2;
    //
    // 
    //             This field specifies the Chip Select (rank) to match when determining
    // if this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  The value in this field is encoded (Chip Selects are normally 1-hot), corresponding
    // to CS0-CS7.  When the failed region is a DIMM, two region registers should be
    // programmed corresponding to both Chip Selects of the failed DIMM. 
    //         
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX failed_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //             This field specifies the subrank to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[10:8], RW_LB, default = 0x0
    //
    UINTX failed_c : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // 
    //             This field specifies the bank address to match when determining if
    // this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[13:12], RW_LB, default = 0x0
    //
    UINTX failed_ba : 2;
    //
    // 
    //             This field specifies the bank group to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[15:14], RW_LB, default = 0x0
    //
    UINTX failed_bg : 2;
    //
    // 
    //             This field specifies the Chip Select (rank) to match when determining
    // if this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  The value in this field is encoded (Chip Selects are normally 1-hot), corresponding
    // to CS0-CS7.  When the failed region is a DIMM, two region registers should be
    // programmed corresponding to both Chip Selects of the failed DIMM. 
    //         
    // 
    // Bits[18:16], RW_LB, default = 0x0
    //
    UINTX nonfailed_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // 
    //             This field specifies the subrank to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[22:20], RW_LB, default = 0x0
    //
    UINTX nonfailed_c : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // 
    //             This field specifies the bank address to match when determining if
    // this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX nonfailed_ba : 2;
    //
    // 
    //             This field specifies the bank group to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[27:26], RW_LB, default = 0x0
    //
    UINTX nonfailed_bg : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // 
    //           This field specifies that ADDDC spare copy is on-going for this region
    //         
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX copy_in_progress : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 2;
  } Bits;
  UINTX Data;
} ADDDC_REGION1_CONTROL_MCMAIN_STRUCT;
#endif // ASM_INC

#define ADDDC_REGION2_CONTROL_MCMAIN_REG                  0x00000238
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This bit specifies whether the ADDDC region is in use.
    //             0=ADDDC not enabled for this region
    //             1=ADDDC enabled for this region
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX region_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //             Granularity for this ADDDC region:
    //             00=bank
    //             01=rank
    //             10=reserved 
    //             11=reserved
    //         
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX region_size : 2;
    //
    // 
    //             This field specifies the Chip Select (rank) to match when determining
    // if this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  The value in this field is encoded (Chip Selects are normally 1-hot), corresponding
    // to CS0-CS7.  When the failed region is a DIMM, two region registers should be
    // programmed corresponding to both Chip Selects of the failed DIMM. 
    //         
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX failed_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //             This field specifies the subrank to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[10:8], RW_LB, default = 0x0
    //
    UINTX failed_c : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // 
    //             This field specifies the bank address to match when determining if
    // this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[13:12], RW_LB, default = 0x0
    //
    UINTX failed_ba : 2;
    //
    // 
    //             This field specifies the bank group to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[15:14], RW_LB, default = 0x0
    //
    UINTX failed_bg : 2;
    //
    // 
    //             This field specifies the Chip Select (rank) to match when determining
    // if this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  The value in this field is encoded (Chip Selects are normally 1-hot), corresponding
    // to CS0-CS7.  When the failed region is a DIMM, two region registers should be
    // programmed corresponding to both Chip Selects of the failed DIMM. 
    //         
    // 
    // Bits[18:16], RW_LB, default = 0x0
    //
    UINTX nonfailed_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // 
    //             This field specifies the subrank to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[22:20], RW_LB, default = 0x0
    //
    UINTX nonfailed_c : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // 
    //             This field specifies the bank address to match when determining if
    // this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX nonfailed_ba : 2;
    //
    // 
    //             This field specifies the bank group to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[27:26], RW_LB, default = 0x0
    //
    UINTX nonfailed_bg : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // 
    //           This field specifies that ADDDC spare copy is on-going for this region
    //         
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX copy_in_progress : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 2;
  } Bits;
  UINTX Data;
} ADDDC_REGION2_CONTROL_MCMAIN_STRUCT;
#endif // ASM_INC

#define ADDDC_REGION3_CONTROL_MCMAIN_REG                  0x0000023C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This bit specifies whether the ADDDC region is in use.
    //             0=ADDDC not enabled for this region
    //             1=ADDDC enabled for this region
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX region_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //             Granularity for this ADDDC region:
    //             00=bank
    //             01=rank
    //             10=reserved 
    //             11=reserved
    //         
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX region_size : 2;
    //
    // 
    //             This field specifies the Chip Select (rank) to match when determining
    // if this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  The value in this field is encoded (Chip Selects are normally 1-hot), corresponding
    // to CS0-CS7.  When the failed region is a DIMM, two region registers should be
    // programmed corresponding to both Chip Selects of the failed DIMM. 
    //         
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX failed_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //             This field specifies the subrank to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[10:8], RW_LB, default = 0x0
    //
    UINTX failed_c : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // 
    //             This field specifies the bank address to match when determining if
    // this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[13:12], RW_LB, default = 0x0
    //
    UINTX failed_ba : 2;
    //
    // 
    //             This field specifies the bank group to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[15:14], RW_LB, default = 0x0
    //
    UINTX failed_bg : 2;
    //
    // 
    //             This field specifies the Chip Select (rank) to match when determining
    // if this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  The value in this field is encoded (Chip Selects are normally 1-hot), corresponding
    // to CS0-CS7.  When the failed region is a DIMM, two region registers should be
    // programmed corresponding to both Chip Selects of the failed DIMM. 
    //         
    // 
    // Bits[18:16], RW_LB, default = 0x0
    //
    UINTX nonfailed_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // 
    //             This field specifies the subrank to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[22:20], RW_LB, default = 0x0
    //
    UINTX nonfailed_c : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // 
    //             This field specifies the bank address to match when determining if
    // this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX nonfailed_ba : 2;
    //
    // 
    //             This field specifies the bank group to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[27:26], RW_LB, default = 0x0
    //
    UINTX nonfailed_bg : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // 
    //           This field specifies that ADDDC spare copy is on-going for this region
    //         
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX copy_in_progress : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 2;
  } Bits;
  UINTX Data;
} ADDDC_REGION3_CONTROL_MCMAIN_STRUCT;
#endif // ASM_INC

#define SCRATCHPAD2_MCMAIN_REG                            0x00000240
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SCRATCHPAD2
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX scratchpad2 : 32;
  } Bits;
  UINTX Data;
} SCRATCHPAD2_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCDECS_CHKN_BIT_MCMAIN_REG                        0x00000244
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Disable RCB Clock Gate in DECS
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX dis_mcdecs_pri_rcb_gate : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 31;
  } Bits;
  UINTX Data;
} MCDECS_CHKN_BIT_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCDECS_RCB_GATE_CTL_MCMAIN_REG                    0x00000248
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Time clock keeps running after triggering events
    // 
    // Bits[9:0], RW_LB, default = 0x40
    //
    UINTX rcb_gate_mcdecs_timer : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 22;
  } Bits;
  UINTX Data;
} MCDECS_RCB_GATE_CTL_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCDECS_ERR_LOG_MCMAIN_REG                         0x0000024C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Error indication when critical chunk bit is set for ADDDC or PlusOne transaction
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX critical_chunk_err : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 31;
  } Bits;
  UINTX Data;
} MCDECS_ERR_LOG_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCDECS_CHICKEN_BITS_MCMAIN_REG                    0x00000300
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Disable clock gating addr_decode
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX dis_ck_gate_addr_dec : 1;
    //
    // Converts isoch writes to non isoch in decoder
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX dis_isoch_wr : 1;
    //
    // Converts isoch reads to non isoch in decoder
    // 
    // Bits[2:2], RW_LB, default = 0x0
    //
    UINTX dis_isoch_rd : 1;
    //
    // Reserved Unused
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX defeature_2 : 1;
    //
    // Reserved Unused
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX defeature_3 : 1;
    //
    // Enable ADDDC format for CPGC transactions. Use for x8 virtual lockstep mode only.
    // 
    // Bits[5:5], RW_LB, default = 0x0
    //
    UINTX en_cpgc_adddc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} MCDECS_CHICKEN_BITS_MCMAIN_STRUCT;
#endif // ASM_INC

#define MCDDRTCFG_MCMAIN_REG                              0x00000400
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             DDR-T DIMM populated if set; otherwise, unpopulated.
    //             Should be set to 0 when this slot is populated with a DDR4 DIMM.
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX slot0 : 1;
    //
    // 
    //             DDR-T DIMM populated if set; otherwise, unpopulated.
    //             Should be set to 0 when this slot is populated with a DDR4 DIMM.
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX slot1 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 30;
  } Bits;
  UINTX Data;
} MCDDRTCFG_MCMAIN_STRUCT;
#endif // ASM_INC


#endif // _MCMAIN_H_
