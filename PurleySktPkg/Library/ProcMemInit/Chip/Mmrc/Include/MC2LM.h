/*++

Copyright (c) 2005-2015 Intel Corporation. All rights reserved
This software and associated documentation (if any) is furnished
under a license and may only be used or copied in accordance
with the terms of the license. Except as permitted by such
license, no part of this software or documentation may be
reproduced, stored in a retrieval system, or transmitted in any
form or by any means without the express written consent of
Intel Corporation.

Module Name:

    File name:    MC2LM.h
    Input File:   SKX_MRC_for CTE updt-2015ww15.3.xlsx

Abstract:

    THIS FILE IS AUTO-GENERATED BY THE MMRC TOOL. DO NOT CHANGE THIS CODE.

    If edits are needed in this file, they must be done via the MMRC tool.

    If there is additional project-specific data required by the MMRC, it
    can be placed in MC2LM.h, which is used for non-tool-generated
    data

    Includes register defines specific to a project.

--*/
#ifndef _MC2LM_H_
#define _MC2LM_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define VID_MC2LM_REG                                     0x00000000
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The value is assigned by PCI-SIG to Intel.
    // 
    // Bits[15:0], RO, default = 0x8086
    //
    UINTX vendor_identification_number : 16;
  } Bits;
  UINTX Data;
} VID_MC2LM_STRUCT;
#endif // ASM_INC

#define DID_MC2LM_REG                                     0x00000002
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  
    // Start (h)	End (h)	Device
    // 0x203F		0x203F	
    // 0x2040		0x204B	MC
    // 0x204C		0x204F	M3KTI
    // 0x2054		0x2054	CHASADALL
    // 0x2055		0x2055	CHAUTILALL
    // 0x2056		0x2056	CHAUTILALL1
    // 0x2057		0x2057	CHAPMAALL
    // 0x2058		0x205B	KTI
    // 0x2066		0x2067	M2MEM
    // 0x2068		0x206F	MC DDRIO
    // 0x2078		0x207F	VCU
    // 0x2080		0x2087	PCU
    // 0x2088		0x2088	
    // 0x2089		0x2089	
    // 0x208A		0x208A	
    // 0x208B		0x208B	
    // 0x208C		0x208C	
    // 0x208D		0x208D	CHAUTIL
    // 0x208E		0x208E	CHASAD
    // 0x208F		0x208F	CMSCHA
    // 0x2090		0x209F	RSVD FOR PCU FUNCTION 3
    // 	
    // 
    // Bits[15:0], RO, default = 0x2041
    //
    UINTX device_identification_number : 16;
  } Bits;
  UINTX Data;
} DID_MC2LM_STRUCT;
#endif // ASM_INC

#define PCICMD_MC2LM_REG                                  0x00000004
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Hardwired to 0 since these devices don't decode any IO BARs
    // 
    // Bits[0:0], RO, default = 0x0
    //
    UINTX io_space_enable : 1;
    //
    // Hardwired to 0 since these devices don't decode any memory BARs
    // 
    // Bits[1:1], RO, default = 0x0
    //
    UINTX memory_space_enable : 1;
    //
    // Hardwired to 0 since these devices don't generate any transactions
    // 
    // Bits[2:2], RO, default = 0x0
    //
    UINTX bus_master_enable : 1;
    //
    // Not applicable. Hardwired to 0.
    // 
    // Bits[3:3], RO, default = 0x0
    //
    UINTX special_cycle_enable : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[4:4], RO, default = 0x0
    //
    UINTX memory_write_and_invalidate_enable : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[5:5], RO, default = 0x0
    //
    UINTX vga_palette_snoop_enable : 1;
    //
    // This bit has no impact on error reporting from these devices
    // 
    // Bits[6:6], RO, default = 0x0
    //
    UINTX parity_error_response : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX idsel_stepping_wait_cycle_control : 1;
    //
    // This bit has no impact on error reporting from these devices
    // 
    // Bits[8:8], RO, default = 0x0
    //
    UINTX serr_enable : 1;
    //
    // Not applicable to PCI Express and is hardwired to 0
    // 
    // Bits[9:9], RO, default = 0x0
    //
    UINTX fast_back_to_back_enable : 1;
    //
    // N/A for these devices
    // 
    // Bits[10:10], RO, default = 0x0
    //
    UINTX intx_disable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
  } Bits;
  UINTX Data;
} PCICMD_MC2LM_STRUCT;
#endif // ASM_INC

#define PCISTS_MC2LM_REG                                  0x00000006
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Reflects the state of the INTA# signal at the input of the enable/disable circuit.
    //  This bit is set by HW to 1 when the INTA# is asserted.  This bit is reset by
    // HW to 0 after the interrupt is cleared (independent of the state of the Interrupt
    // Disable bit in the 0.4.0.PCICMD register). 
    // Hardwired to 0 on the processor
    // 
    // Bits[3:3], RO, default = 0x0
    //
    UINTX intx_status : 1;
    //
    // This bit indicates the presence of a capabilities list structure. When set to
    // 1, indicates the register at 34h provides an offset into the function. 
    // 
    // Bits[4:4], RO, default = 0x1
    //
    UINTX capabilities_list : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[5:5], RO, default = 0x0
    //
    UINTX x66mhz_capable : 1;
    //
    // Reserved
    // 
    // Bits[6:6], RO, default = 0x0
    //
    UINTX reserved : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX fast_back_to_back : 1;
    //
    // Hardwired to 0
    // 
    // Bits[8:8], RO, default = 0x0
    //
    UINTX master_data_parity_error : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[10:9], RO, default = 0x0
    //
    UINTX devsel_timing : 2;
    //
    // Hardwired to 0
    // 
    // Bits[11:11], RO, default = 0x0
    //
    UINTX signaled_target_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[12:12], RO, default = 0x0
    //
    UINTX received_target_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[13:13], RO, default = 0x0
    //
    UINTX received_master_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[14:14], RO, default = 0x0
    //
    UINTX signaled_system_error : 1;
    //
    // This bit is set when the device receives a packet on the primary side with an
    // uncorrectable data error (including a packet with poison bit set) or an uncorrectable
    // address/control parity error. The setting of this bit is regardless of the Parity
    // Error Response bit (PERRE) in the PCICMD register. 
    // 
    // Bits[15:15], RO_V, default = 0x0
    //
    UINTX detected_parity_error : 1;
  } Bits;
  UINTX Data;
} PCISTS_MC2LM_STRUCT;
#endif // ASM_INC

#define RID_MC2LM_REG                                     0x00000008
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reflects the Uncore Revision ID after reset.
    // Reflects the Compatibility Revision ID after BIOS writes 0x69 to any RID register
    // in the processor uncore. 
    //         
    // 
    // Bits[7:0], RO_V, default = 0x0
    //
    UINTX revision_id : 8;
  } Bits;
  UINTX Data;
} RID_MC2LM_STRUCT;
#endif // ASM_INC

#define CCR_MC2LM_REG                                     0x00000009
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[7:0], RO_V, default = 0x0
    //
    UINTX register_level_programming_interface : 8;
    //
    // The value changes dependent upon the dev/func accessed. A table of the values
    // can be found in the Class-code tab of the msgch spread-sheet  
    // 	  Most dev-func will return 8'h80 for this field except for the following dev-func0,func1,...
    // combinations. The following exceptions will return 8'h01. Please refer to /src/uncore/ncu/f_ccr_reg.vh
    // for the full lookingup table. 
    //           bus-0, dev-8 func-1 
    //           bus-3, dev-14 to 16, func-0
    //           bus-3, dev-18, func-0, 1, 4, 5
    //         
    // 
    // Bits[15:8], RO_V, default = 0x80
    //
    UINTX sub_class : 8;
    //
    // The value changes dependent upon the dev-func accessed. A table of the values
    // can be found in the Class-code tab of the msgch spread-sheet  
    // 	  Most bus-dev-func will return 8'h08 for this field except for the following
    // bus-dev-func0,func1,... combinations. The following exceptions will return 8'h11.
    // Please refer to /src/uncore/ncu/f_ccr_reg.vhfor the full lookingup table. 
    //           bus-0, dev-8 func-1 
    //           bus-3, dev-14 to 16, func-0
    //           bus-3, dev-18, func-0, 1, 4, 5
    //         
    // 
    // Bits[23:16], RO_V, default = 0x8
    //
    UINTX base_class : 8;
  } Bits;
  UINTX Data;
} CCR_MC2LM_STRUCT;
#endif // ASM_INC

#define CLSR_MC2LM_REG                                    0x0000000C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Size of Cacheline
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX cacheline_size : 8;
  } Bits;
  UINTX Data;
} CLSR_MC2LM_STRUCT;
#endif // ASM_INC

#define PLAT_MC2LM_REG                                    0x0000000D
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Not applicable to PCI-Express. Hardwired to 00h.
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX primary_latency_timer : 8;
  } Bits;
  UINTX Data;
} PLAT_MC2LM_STRUCT;
#endif // ASM_INC

#define HDR_MC2LM_REG                                     0x0000000E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Type 0 header
    // 
    // Bits[6:0], RO, default = 0x0
    //
    UINTX configuration_layout : 7;
    //
    // This bit defaults to 1b since all these devices are multi-function
    // 
    // Bits[7:7], RO, default = 0x1
    //
    UINTX multi_function_device : 1;
  } Bits;
  UINTX Data;
} HDR_MC2LM_STRUCT;
#endif // ASM_INC

#define BIST_MC2LM_REG                                    0x0000000F
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Not supported. Hardwired to 00h
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX bist_tests : 8;
  } Bits;
  UINTX Data;
} BIST_MC2LM_STRUCT;
#endif // ASM_INC

#define CAPPTR_MC2LM_REG                                  0x00000034
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Points to the first capability structure for the device which is the PCIe capability.
    // 
    // Bits[7:0], RO, default = 0x40
    //
    UINTX capability_pointer : 8;
  } Bits;
  UINTX Data;
} CAPPTR_MC2LM_STRUCT;
#endif // ASM_INC

#define INTL_MC2LM_REG                                    0x0000003C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A for these devices
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX interrupt_line : 8;
  } Bits;
  UINTX Data;
} INTL_MC2LM_STRUCT;
#endif // ASM_INC

#define INTPIN_MC2LM_REG                                  0x0000003D
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A since these devices do not generate any interrupt on their own
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX interrupt_pin : 8;
  } Bits;
  UINTX Data;
} INTPIN_MC2LM_STRUCT;
#endif // ASM_INC

#define MINGNT_MC2LM_REG                                  0x0000003E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The device does not burst as a PCI compliant master.
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX mgv : 8;
  } Bits;
  UINTX Data;
} MINGNT_MC2LM_STRUCT;
#endif // ASM_INC

#define MAXLAT_MC2LM_REG                                  0x0000003F
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The device has no specific requirements for how often it needs to access the PCI
    // bus. 
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX mlv : 8;
  } Bits;
  UINTX Data;
} MAXLAT_MC2LM_STRUCT;
#endif // ASM_INC

#define SVID_MC2LM_REG                                    0x0000002C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The default value specifies Intel but can be set to any value once after reset.
    // 
    // Bits[15:0], RW_O, default = 0x8086
    //
    UINTX subsystem_vendor_identification_number : 16;
  } Bits;
  UINTX Data;
} SVID_MC2LM_STRUCT;
#endif // ASM_INC

#define SDID_MC2LM_REG                                    0x0000002E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Assigned by the subsystem vendor to uniquely identify the subsystem
    // 
    // Bits[15:0], RW_O, default = 0x0
    //
    UINTX subsystem_device_identification_number : 16;
  } Bits;
  UINTX Data;
} SDID_MC2LM_STRUCT;
#endif // ASM_INC

#define PXPCAP_MC2LM_REG                                  0x00000040
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Provides the PCI Express capability ID assigned by PCI-SIG.
    // 
    // Bits[7:0], RO, default = 0x10
    //
    UINTX capability_id : 8;
    //
    // Pointer to the next capability. Set to 0 to indicate there are no more capability
    // structures. 
    // 
    // Bits[15:8], RO, default = 0x0
    //
    UINTX next_ptr : 8;
    //
    // PCI Express Capability is Compliant with Version 1.0 of the PCI Express Spec.
    // Note:
    // This capability structure is not compliant with Versions beyond 1.0, since they
    // require additional capability registers to be reserved. The only purpose for this
    // capability structure is to make enhanced configuration space available. Minimizing
    // the size of this structure is accomplished by reporting version 1.0 compliancy
    // and reporting that this is an integrated root port device. As such, only three
    // Dwords of configuration space are required for this structure. 
    // 
    // Bits[19:16], RO, default = 0x1
    //
    UINTX capability_version : 4;
    //
    // Device type is Root Complex Integrated Endpoint
    // 
    // Bits[23:20], RO, default = 0x9
    //
    UINTX device_port_type : 4;
    //
    // N/A for integrated endpoints
    // 
    // Bits[24:24], RO, default = 0x0
    //
    UINTX slot_implemented : 1;
    //
    // N/A for this device
    // 
    // Bits[29:25], RO, default = 0x0
    //
    UINTX interrupt_message_number : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} PXPCAP_MC2LM_STRUCT;
#endif // ASM_INC

#define MCNMCACHINGCFG2_MC2LM_REG                         0x00000084
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per Channel Near Memory Capacity. 
    // 4'h0 - 4GB
    // 4'h1 - 8GB
    // 4'h2 - 16GB
    // 4'h3 - 32GB
    // 4'h4 - 64GB
    // 4'h5 - 128GB
    // 4'h6 - 256GB
    // 4'h7 - 512GB
    // 4'b1xxx - Reserved
    // This field can be programmed on the per-channel basis.
    // 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX mcnmcachingnmchncap : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // Enable the reserved meta data bit to be tag offset indication. Set to 0 in SKX,
    // only used for CNX/RG if set. This field is programmed on the per iMC basis, i.e.
    // need to maintain consistency with other populated channels in this iMC. 
    // 
    // Bits[8:8], RW_LB, default = 0x0
    //
    UINTX mcnmcachingtagoffsetenb : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 7;
    //
    // 
    //         This is no longer used in SKX due to the new error flows, which are managed
    // by M2Mem rather than MC. 
    //         Set all writes to NI=1 in response to DUE tag error with clean data when
    // set. This field is programmed on the per iMC basis, i.e. need to maintain consistency
    // with other populated channels in this iMC. 
    //         
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX mcnmcachingforceni : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 15;
  } Bits;
  UINTX Data;
} MCNMCACHINGCFG2_MC2LM_STRUCT;
#endif // ASM_INC

#define MCNMCACHINGINTLV_MC2LM_REG                        0x00000088
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If set, strip out bit 8 for 256b interleaving between near-memory channels in
    // a socket. This is only relevant if there are only 2 channels of NM behind the
    // MC. This field is programmed on the per channel basis, i.e. need to maintain consistency
    // with other populated channels in this iMC. 
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mcnmcaching_tad_il_granular_ximc : 1;
    //
    // The value of bit 8 for this channel. Used for reverse address decode. This field
    // is programmed on the per channel basis. 
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX mcnmcachingchanintlvval : 1;
    //
    // 4kb Socket interleave ways:
    // 2'b00 - no socket interleaving
    // 2'b01 - 2 way interleave: strip out bit 12 from index
    // 2'b10 - 4 way interleave: strip out bits 13:12 from index
    // 2'b11 - 8 way interleave: strip out bits 14:12 from index
    // This field is programmed on the per iMC basis, i.e. need to maintain consistency
    // with other populated channels in this iMC. 
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX mcnmcachingsocketintlv : 2;
    //
    // The value of bits 14:12 for this MC. Used for reverse address decode. This field
    // is programmed on the per iMC basis, i.e. need to maintain consistency with other
    // populated channels in this iMC. 
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX mcnmcachingsocketintlvval : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 25;
  } Bits;
  UINTX Data;
} MCNMCACHINGINTLV_MC2LM_STRUCT;
#endif // ASM_INC

#define SYSFEATURES0_MC2LM_REG                            0x0000008C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // 
    //         Force NM Pmem dir updates to NGN (FrcPmemDirUpdate2NGN):
    //         By default, for multi-socket performance reasons, directory only updates
    // in NM for PMem Write-Through regions are not propagated to NGN. 
    //           0: Dont propagate PMem NM dir-only updates to NGN (default).
    //           1: Force propagation of NM PMem dir updates to NGN (debug).
    //         This bit is only relevant in PMemCaching mode (Mode.PmemCaching==1).
    //         
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX frcpmemdirupdate2ngn : 1;
    //
    // 
    //         Must be set consistently with SysFeatures0.DirWrDisable in M2Mem.
    //         Disable directory writes (DirWrDisable):
    //           0: MC directory writes are enabled (default).
    //           1: MC directory writes are disabled.
    //         Only legal configs where MC directory writes can be disabled are:
    //           - when single socket system, or
    //           - when directory disabled in the system.
    //         BIOS should set this bit to 1 for above configs (for performance).
    //         
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX dirwrdisable : 1;
    //
    // 
    //         Must be set consistently with SysFeatures0.FrcDirI in M2Mem.
    //         Force dirI (FrcDirI):
    //         Force the directory state read from memory to Invalid, for 
    //         new dir calculation (exception: poison/uncorr stays poison) and for 
    //         dir delivery to CHA (here Invalid will override poison).
    //           0: interpret directory from memory as-is.
    //           1: override directory S/A/(P) read from memory with I.
    //         BIOS needs to set this bit to 1 if single socket.
    //         
    // 
    // Bits[5:5], RW_LB, default = 0x0
    //
    UINTX frcdiri : 1;
    //
    // 
    //         Must be set consistently with SysFeatures0.MapDirStoDirA in M2Mem.
    //         Map dirS to dirA (MapDirStoDirA):
    //         Upgrade dirS to memory to dirA. It also prevents DataC_S_CmpO D2K (when
    // dirS no longer present in memory). 
    //           0: don't override dirS with dirA (default).
    //           1: dirS wr to memory gets replaced with dirA wr.
    //         Guideline is to keep at 0 for performance. Note that taking out directory
    // shared state  
    //         might result in less directory writes. Some usage models might prefer
    // less directory writes. 
    //         
    // 
    // Bits[6:6], RW_LB, default = 0x0
    //
    UINTX mapdirstodira : 1;
    //
    // 
    //         Reconstruct the fill/evict address on all read returns, not just on a
    // miss. 
    //           0: only reconstruct the address on a miss
    //           1: reconstruct the address on all read returns (for debug)
    //         
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX reconstructaddronhit : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 24;
  } Bits;
  UINTX Data;
} SYSFEATURES0_MC2LM_STRUCT;
#endif // ASM_INC

#define MCNMCACHINGOFFSET0_MC2LM_REG                      0x00000090
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is the base address of the lower cacheable region from bits 47:32. This field
    // is programmed on the per iMC basis, i.e. need to maintain consistency with other
    // populated channels in this iMC. 
    // 
    // Bits[15:0], RW_LB, default = 0x0
    //
    UINTX mcnmcachingoffset0 : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} MCNMCACHINGOFFSET0_MC2LM_STRUCT;
#endif // ASM_INC

#define MCNMCACHINGOFFSET1_MC2LM_REG                      0x00000094
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is the base address of the upper cacheable region from bits 47:32. Not used
    // in SKX, only for CNX and RG. This field is programmed on the per iMC basis, i.e.
    // need to maintain consistency with other populated channels in this iMC. 
    // 
    // Bits[15:0], RW_LB, default = 0x0
    //
    UINTX mcnmcachingoffset1 : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} MCNMCACHINGOFFSET1_MC2LM_STRUCT;
#endif // ASM_INC

#define SCRATCHPAD_2LMCNTL_MC2LM_REG                      0x000000FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // scratchpad
    // 
    // Bits[31:0], RWS_V, default = 0x0
    //
    UINTX bit_field : 32;
  } Bits;
  UINTX Data;
} SCRATCHPAD_2LMCNTL_MC2LM_STRUCT;
#endif // ASM_INC

#define PXPENHCAP_MC2LM_REG                               0x00000100
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Indicates there are no capability structures in the enhanced configuration space.
    // 
    // Bits[15:0], RO, default = 0x0
    //
    UINTX capability_id : 16;
    //
    // Indicates there are no capability structures in the enhanced configuration space.
    // 
    // Bits[19:16], RO, default = 0x0
    //
    UINTX capability_version : 4;
    //
    // N/A
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX next_capability_offset : 12;
  } Bits;
  UINTX Data;
} PXPENHCAP_MC2LM_STRUCT;
#endif // ASM_INC

#define SBVIRALCTL_MC2LM_REG                              0x00000104
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Disable viral triggering of bad request errors
    // 
    // Bits[0:0], RWS, default = 0x0
    //
    UINTX reqerrdis : 1;
    //
    // Disable viral triggering of read data response miss errors
    // 
    // Bits[1:1], RWS, default = 0x0
    //
    UINTX readrspmisserrdis : 1;
    //
    // Disable viral triggering of DDR4 completion errors
    // 
    // Bits[2:2], RWS, default = 0x0
    //
    UINTX ddr4cmperrdis : 1;
    //
    // Disable viral triggering of DDRt completion errors
    // 
    // Bits[3:3], RWS, default = 0x0
    //
    UINTX ddrtcmperrdis : 1;
    //
    // Disable viral triggering of read data response opcode errors
    // 
    // Bits[4:4], RWS, default = 0x0
    //
    UINTX readrspopcodeerrdis : 1;
    //
    // Disable viral triggering of completion FIFO overflows
    // 
    // Bits[5:5], RWS, default = 0x0
    //
    UINTX cmplfifooferrdis : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 26;
  } Bits;
  UINTX Data;
} SBVIRALCTL_MC2LM_STRUCT;
#endif // ASM_INC

#define SBARRSNAPSHOTCTL_MC2LM_REG                        0x00000108
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read out the entry of the scoreboard programmed in SbArrSnapshotCtl.SbIndex. Once
    // the contents of that entry have 
    // been loaded into SbArrSnapshotData0 and SbArrSnapshotData1, hardware will clear
    // this enable bit to 0. 
    // Locked by mc2lmctl_dfx_lck_cntl.mc_array_dump_lck. When locked, the Enable bit
    // is immediately cleared. 
    // 
    // Bits[0:0], RW_LV, default = 0x0
    //
    UINTX enable : 1;
    //
    // Entry of the scoreboard to read.
    // 
    // Bits[7:1], RW, default = 0x0
    //
    UINTX sbindex : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 24;
  } Bits;
  UINTX Data;
} SBARRSNAPSHOTCTL_MC2LM_STRUCT;
#endif // ASM_INC

#define SBDEFEATURES0_MC2LM_REG                           0x0000010C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number of enabled SB entries. A value of 0 corresponds to all 128 entries being
    // enabled, otherwise entries 0...N-1 are enabled. 
    //         This must not be set to 0 (meaning 128 entries) if address anti-starvation
    // is enabled (SbDefeatures0.AddrAntiStarveDis = 0) or credit 
    //         anti-starvation is enabled (Chicken0.DisCrdtAntiStarve = 0). This must
    // be set to less than 127 if both address and credit anti-starvation 
    //         are enabled.
    // 
    // Bits[6:0], RWS_LB, default = 0x7F
    //
    UINTX numsbentries : 7;
    //
    // Enable throttling the return of scoreboard credits when the DFD response function
    // asserts. 
    // 00 - Dont throttle
    // 01 - Use Trigger-0
    // 10 - Use Trigger-1
    // 11 - Use Trigger-2
    // 
    // Bits[8:7], RWS_LB, default = 0x0
    //
    UINTX sbcrdtthrottleen : 2;
    //
    // Force new requests to be rejected when the DFD response function asserts.
    // 00 - Dont throttle
    // 01 - Use Trigger-0
    // 10 - Use Trigger-1
    // 11 - Use Trigger-2
    // 
    // Bits[10:9], RWS_LB, default = 0x0
    //
    UINTX sbfrcrejecten : 2;
    //
    // Used in conjunction with SbFrcRejectEn. Type of request to force reject when the
    // DFD response function asserts. 
    // 000 - All requests
    // 001 - NM requests
    // 010 - FM requests
    // 011 - Patrol requests
    // 100 - Reads
    // 101 - Writes
    // 110 - Non-patrol requests
    // 
    // Bits[13:11], RWS_LB, default = 0x0
    //
    UINTX sbfrcrejectmode : 3;
    //
    // Disable clock-gating for 2LM scoreboard control
    // 
    // Bits[14:14], RWS_LB, default = 0x0
    //
    UINTX pwrdnovrd : 1;
    //
    // Disable clock-gating for 2LM scoreboard MsgChnl
    // 
    // Bits[15:15], RWS_LB, default = 0x0
    //
    UINTX msgchpwrdnovrd : 1;
    //
    // When set, each scoreboard entry stores the result of the mask/match operation
    // in M2M 
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX maskmatchmodeen : 1;
    //
    // When set, disables the anti-starvation mechanism for address conflicts.
    //         When not disabled, SbDefeatures0.NumSbEntries must be greater than 0
    // 
    // Bits[17:17], RWS_LB, default = 0x1
    //
    UINTX addrantistarvedis : 1;
    //
    // Number of times an entry must be rejected before anti-starvation will kick in.
    // 
    // Bits[22:18], RWS_LB, default = 0x8
    //
    UINTX addrantistarvethresh : 5;
    //
    // When set, disables the anti-starvation mechanism for SB credits.
    //         Must be set the same as M2Mem's Chicken0.DisCrdtAntiStarve.
    //         When not disabled, SbDefeatures0.NumSbEntries must be greater than 0
    // 
    // Bits[23:23], RWS_LB, default = 0x1
    //
    UINTX credantistarvedis : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} SBDEFEATURES0_MC2LM_STRUCT;
#endif // ASM_INC

#define SBMCACTL_MC2LM_REG                                0x00000110
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Disable logging and reporting of bad request errors
    // 
    // Bits[0:0], RWS, default = 0x0
    //
    UINTX reqerrdis : 1;
    //
    // Disable logging and reporting of read data response miss errors
    // 
    // Bits[1:1], RWS, default = 0x0
    //
    UINTX readrspmisserrdis : 1;
    //
    // Disable logging and reporting of DDR4 completion errors
    // 
    // Bits[2:2], RWS, default = 0x0
    //
    UINTX ddr4cmperrdis : 1;
    //
    // Disable logging and reporting of DDRt completion errors
    // 
    // Bits[3:3], RWS, default = 0x0
    //
    UINTX ddrtcmperrdis : 1;
    //
    // Disable logging and reporting of read data response opcode errors
    // 
    // Bits[4:4], RWS, default = 0x0
    //
    UINTX readrspopcodeerrdis : 1;
    //
    // Disable logging and reporting of completion FIFO overflows
    // 
    // Bits[5:5], RWS, default = 0x0
    //
    UINTX cmplfifooferrdis : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 26;
  } Bits;
  UINTX Data;
} SBMCACTL_MC2LM_STRUCT;
#endif // ASM_INC

#define SBARRSNAPSHOTDATA0_MC2LM_REG                      0x00000114
#ifndef ASM_INC
typedef union {
  struct {
    //
    // State of the SB entry specified by SbArrCapture.SbIndex
    // Bits 13:13 - valid
    // Bits 12:12 - NM write pending
    // Bits 11:11 - FM write pending
    // Bits 10:10 - mirror or WT write pending
    // Bits  9: 9 - pmem request
    // Bits  8: 8 - request targets uncacheable DDRT
    // Bits  7: 7 - block region request
    // Bits  6: 6 - write request
    // Bits  5: 0 - original request
    //         
    // 
    // Bits[13:0], RO_V, default = 0x0
    //
    UINTX sbstate : 14;
    //
    // Tag of the SB entry specified by SbArrSnapshotCtl.SbIndex
    // 
    // Bits[25:14], RO_V, default = 0x0
    //
    UINTX sbtag : 12;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
  } Bits;
  UINTX Data;
} SBARRSNAPSHOTDATA0_MC2LM_STRUCT;
#endif // ASM_INC

#define SBARRSNAPSHOTDATA1_MC2LM_REG                      0x00000118
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Index of the SB entry specified by SbArrSnapshotCtl.SbIndex
    // 
    // Bits[31:0], RO_V, default = 0x0
    //
    UINTX sbindex : 32;
  } Bits;
  UINTX Data;
} SBARRSNAPSHOTDATA1_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_TIMING_MC2LM_REG                             0x00000800
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         The slot number to allow GNT for current channel. This feature is only
    // enabled when uclk is slower than dclk, and NGN DIMMs are used. When this feature
    // is enabled (mcmtr.enable_slot_use = 1), early completion for channel 0 should
    // only be sent in slot 0, and channel 1 should only use slot 2, while channel 2
    // should only use slot 4. A value between 0 and 5 should be programmed in this field
    // to allow the above result. This field should be programmed such that (du_slot_number
    // + GNT to early completion delay) mod 6 = (2 * current channel number). 
    //         
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX du_slot_number : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // 
    //             This field controls the delay from when the MC sees RID to the deallocation
    // of the entry in the T-RPQ. 
    //         
    // 
    // Bits[15:8], RW, default = 0x6
    //
    UINTX rid2dealloc : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 16;
  } Bits;
  UINTX Data;
} DDRT_TIMING_MC2LM_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_ADDR_MATCH_LO_DDRT_MC2LM_REG             0x00000880
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Addr Match Lower: 32-bits (Match Addr[34:3])
    // 
    // Bits[31:0], RWS, default = 0x0
    //
    UINTX addr_match_lower : 32;
  } Bits;
  UINTX Data;
} RSP_FUNC_ADDR_MATCH_LO_DDRT_MC2LM_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_ADDR_MATCH_HI_DDRT_MC2LM_REG             0x00000884
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Addr Match Higher : 11-Bits (Match Addr[45:35])
    // 
    // Bits[10:0], RWS, default = 0x0
    //
    UINTX addr_match_higher : 11;
    //
    // Enabling the Address Match Response Function when set.
    // 
    // Bits[11:11], RWS_LV, default = 0x0
    //
    UINTX rsp_func_addr_match_en : 1;
    //
    // The enable bit RSP_FUNC_ADDR_MATCH_EN will not be self cleared after match if
    // this field is set. Continuous address matching. 
    // 
    // Bits[12:12], RWS, default = 0x0
    //
    UINTX rsp_func_addr_match_always : 1;
    //
    // Clear the AddMatch bit in DDRT WPQ on DDRT Retry flow.
    // 
    // Bits[13:13], RW, default = 0x1
    //
    UINTX clear_addmatch_on_retry : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 11;
    //
    // Additional match configuration: Bit 0 matches with Mirror field; Bit 1 matches
    // with mirr_pri (primary channel); Bit 2 matches with demand scrub request 
    // 
    // Bits[27:25], RWS, default = 0x0
    //
    UINTX mirror_match : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
  } Bits;
  UINTX Data;
} RSP_FUNC_ADDR_MATCH_HI_DDRT_MC2LM_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_ADDR_MASK_LO_DDRT_MC2LM_REG              0x00000888
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Address Mask to deselect (when set) the corresponding Addr[34:3] for the address
    // match. 
    // 
    // Bits[31:0], RWS, default = 0xFFFFFFFF
    //
    UINTX addr_mask_lower : 32;
  } Bits;
  UINTX Data;
} RSP_FUNC_ADDR_MASK_LO_DDRT_MC2LM_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_ADDR_MASK_HI_DDRT_MC2LM_REG              0x0000088C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Address Mask to deselect (when set) the corresponding Addr[45:35] for the address
    // match. 
    // 
    // Bits[10:0], RWS, default = 0x7FF
    //
    UINTX addr_mask_higher : 11;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
    //
    // Additional mask to deselect (when set) the corresponding bits in mirror_mask field.
    // Bit 0 is mask for Mirror field; Bit 1 is mask for mirr_pri (primary channel);
    // Bit 2 is mask for demand scrub request 
    // 
    // Bits[27:25], RWS, default = 0x7
    //
    UINTX mirror_mask : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
  } Bits;
  UINTX Data;
} RSP_FUNC_ADDR_MASK_HI_DDRT_MC2LM_STRUCT;
#endif // ASM_INC

#define FMTADCHNILVOFFSET_0_MC2LM_REG                     0x00000890
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    // N/A
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // Reverse Address Translation Channel Index OffsetBIOS programmed this field by
    // calculating: 
    // (TAD[N].BASE / TAD[N].TAD_SKT_WAY) % TAD[N].TAD_CH_WAY
    // where % is the modulo function.
    // CHN_IDX_OFFSET can have a value of 0, 1, or 2
    // In this equation, the BASE is the lowest address in the TAD range. The TAD_SKT_WAY
    // is 1, 2, 4, or 8, and TAD_CH_WAY is 1, 2, 3, or 4. CHN_IDX_OFFSET will always
    // end up being zero if TAD_CH_WAY is not equal to 3. If TAD_CH_WAY is 3, CHN_IDX_OFFSET
    // can be 0, 1, or 2. 
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // when set, the skt_wayness will be treated as skt_way*3, with the div3 that thsi
    // implies on the system address at the granularity specified by imc_granularity
    // (used for EX only) 
    //           
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    // Specifies the granularity of the skt_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //   b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //   b'11   1GB (based off PA[30] and up) {used for PMem only, though the standard
    // PMem mode will be 4KB) 
    //         
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    // Specifies the granularity of the ch_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, DDRT Block,
    // and DDRT 2LM.  the latter only in mirror mode) 
    //   b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT PMem)
    //   b'11   reserved
    // Note:  using the same ch_granularity encoding for both DDRT and DDR4 even though
    // 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //         
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // When 0, the tad_offset is subtracted from the system address. When 1, the tad_offset
    // is added to the system address. 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX tad_offset_sign : 1;
  } Bits;
  UINTX Data;
} FMTADCHNILVOFFSET_0_MC2LM_STRUCT;
#endif // ASM_INC

#define FMTADCHNILVOFFSET_1_MC2LM_REG                     0x00000894
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    // N/A
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // Reverse Address Translation Channel Index OffsetBIOS programmed this field by
    // calculating: 
    // (TAD[N].BASE / TAD[N].TAD_SKT_WAY) % TAD[N].TAD_CH_WAY
    // where % is the modulo function.
    // CHN_IDX_OFFSET can have a value of 0, 1, or 2
    // In this equation, the BASE is the lowest address in the TAD range. The TAD_SKT_WAY
    // is 1, 2, 4, or 8, and TAD_CH_WAY is 1, 2, 3, or 4. CHN_IDX_OFFSET will always
    // end up being zero if TAD_CH_WAY is not equal to 3. If TAD_CH_WAY is 3, CHN_IDX_OFFSET
    // can be 0, 1, or 2. 
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // when set, the skt_wayness will be treated as skt_way*3, with the div3 that thsi
    // implies on the system address at the granularity specified by imc_granularity
    // (used for EX only) 
    //           
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    // Specifies the granularity of the skt_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //   b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //   b'11   1GB (based off PA[30] and up) {used for PMem only, though the standard
    // PMem mode will be 4KB) 
    //         
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    // Specifies the granularity of the ch_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, DDRT Block,
    // and DDRT 2LM.  the latter only in mirror mode) 
    //   b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT PMem)
    //   b'11   reserved
    // Note:  using the same ch_granularity encoding for both DDRT and DDR4 even though
    // 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //         
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // When 0, the tad_offset is subtracted from the system address. When 1, the tad_offset
    // is added to the system address. 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX tad_offset_sign : 1;
  } Bits;
  UINTX Data;
} FMTADCHNILVOFFSET_1_MC2LM_STRUCT;
#endif // ASM_INC

#define FMTADCHNILVOFFSET_2_MC2LM_REG                     0x00000898
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    // N/A
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // Reverse Address Translation Channel Index OffsetBIOS programmed this field by
    // calculating: 
    // (TAD[N].BASE / TAD[N].TAD_SKT_WAY) % TAD[N].TAD_CH_WAY
    // where % is the modulo function.
    // CHN_IDX_OFFSET can have a value of 0, 1, or 2
    // In this equation, the BASE is the lowest address in the TAD range. The TAD_SKT_WAY
    // is 1, 2, 4, or 8, and TAD_CH_WAY is 1, 2, 3, or 4. CHN_IDX_OFFSET will always
    // end up being zero if TAD_CH_WAY is not equal to 3. If TAD_CH_WAY is 3, CHN_IDX_OFFSET
    // can be 0, 1, or 2. 
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // when set, the skt_wayness will be treated as skt_way*3, with the div3 that thsi
    // implies on the system address at the granularity specified by imc_granularity
    // (used for EX only) 
    //           
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    // Specifies the granularity of the skt_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //   b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //   b'11   1GB (based off PA[30] and up) {used for PMem only, though the standard
    // PMem mode will be 4KB) 
    //         
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    // Specifies the granularity of the ch_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, DDRT Block,
    // and DDRT 2LM.  the latter only in mirror mode) 
    //   b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT PMem)
    //   b'11   reserved
    // Note:  using the same ch_granularity encoding for both DDRT and DDR4 even though
    // 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //         
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // When 0, the tad_offset is subtracted from the system address. When 1, the tad_offset
    // is added to the system address. 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX tad_offset_sign : 1;
  } Bits;
  UINTX Data;
} FMTADCHNILVOFFSET_2_MC2LM_STRUCT;
#endif // ASM_INC

#define FMTADCHNILVOFFSET_3_MC2LM_REG                     0x0000089C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    // N/A
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // Reverse Address Translation Channel Index OffsetBIOS programmed this field by
    // calculating: 
    // (TAD[N].BASE / TAD[N].TAD_SKT_WAY) % TAD[N].TAD_CH_WAY
    // where % is the modulo function.
    // CHN_IDX_OFFSET can have a value of 0, 1, or 2
    // In this equation, the BASE is the lowest address in the TAD range. The TAD_SKT_WAY
    // is 1, 2, 4, or 8, and TAD_CH_WAY is 1, 2, 3, or 4. CHN_IDX_OFFSET will always
    // end up being zero if TAD_CH_WAY is not equal to 3. If TAD_CH_WAY is 3, CHN_IDX_OFFSET
    // can be 0, 1, or 2. 
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // when set, the skt_wayness will be treated as skt_way*3, with the div3 that thsi
    // implies on the system address at the granularity specified by imc_granularity
    // (used for EX only) 
    //           
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    // Specifies the granularity of the skt_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //   b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //   b'11   1GB (based off PA[30] and up) {used for PMem only, though the standard
    // PMem mode will be 4KB) 
    //         
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    // Specifies the granularity of the ch_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, DDRT Block,
    // and DDRT 2LM.  the latter only in mirror mode) 
    //   b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT PMem)
    //   b'11   reserved
    // Note:  using the same ch_granularity encoding for both DDRT and DDR4 even though
    // 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //         
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // When 0, the tad_offset is subtracted from the system address. When 1, the tad_offset
    // is added to the system address. 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX tad_offset_sign : 1;
  } Bits;
  UINTX Data;
} FMTADCHNILVOFFSET_3_MC2LM_STRUCT;
#endif // ASM_INC

#define FMTADCHNILVOFFSET_4_MC2LM_REG                     0x000008A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    // N/A
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // Reverse Address Translation Channel Index OffsetBIOS programmed this field by
    // calculating: 
    // (TAD[N].BASE / TAD[N].TAD_SKT_WAY) % TAD[N].TAD_CH_WAY
    // where % is the modulo function.
    // CHN_IDX_OFFSET can have a value of 0, 1, or 2
    // In this equation, the BASE is the lowest address in the TAD range. The TAD_SKT_WAY
    // is 1, 2, 4, or 8, and TAD_CH_WAY is 1, 2, 3, or 4. CHN_IDX_OFFSET will always
    // end up being zero if TAD_CH_WAY is not equal to 3. If TAD_CH_WAY is 3, CHN_IDX_OFFSET
    // can be 0, 1, or 2. 
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // when set, the skt_wayness will be treated as skt_way*3, with the div3 that thsi
    // implies on the system address at the granularity specified by imc_granularity
    // (used for EX only) 
    //           
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    // Specifies the granularity of the skt_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //   b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //   b'11   1GB (based off PA[30] and up) {used for PMem only, though the standard
    // PMem mode will be 4KB) 
    //         
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    // Specifies the granularity of the ch_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, DDRT Block,
    // and DDRT 2LM.  the latter only in mirror mode) 
    //   b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT PMem)
    //   b'11   reserved
    // Note:  using the same ch_granularity encoding for both DDRT and DDR4 even though
    // 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //         
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // When 0, the tad_offset is subtracted from the system address. When 1, the tad_offset
    // is added to the system address. 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX tad_offset_sign : 1;
  } Bits;
  UINTX Data;
} FMTADCHNILVOFFSET_4_MC2LM_STRUCT;
#endif // ASM_INC

#define FMTADCHNILVOFFSET_5_MC2LM_REG                     0x000008A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    // N/A
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // Reverse Address Translation Channel Index OffsetBIOS programmed this field by
    // calculating: 
    // (TAD[N].BASE / TAD[N].TAD_SKT_WAY) % TAD[N].TAD_CH_WAY
    // where % is the modulo function.
    // CHN_IDX_OFFSET can have a value of 0, 1, or 2
    // In this equation, the BASE is the lowest address in the TAD range. The TAD_SKT_WAY
    // is 1, 2, 4, or 8, and TAD_CH_WAY is 1, 2, 3, or 4. CHN_IDX_OFFSET will always
    // end up being zero if TAD_CH_WAY is not equal to 3. If TAD_CH_WAY is 3, CHN_IDX_OFFSET
    // can be 0, 1, or 2. 
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // when set, the skt_wayness will be treated as skt_way*3, with the div3 that thsi
    // implies on the system address at the granularity specified by imc_granularity
    // (used for EX only) 
    //           
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    // Specifies the granularity of the skt_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //   b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //   b'11   1GB (based off PA[30] and up) {used for PMem only, though the standard
    // PMem mode will be 4KB) 
    //         
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    // Specifies the granularity of the ch_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, DDRT Block,
    // and DDRT 2LM.  the latter only in mirror mode) 
    //   b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT PMem)
    //   b'11   reserved
    // Note:  using the same ch_granularity encoding for both DDRT and DDR4 even though
    // 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //         
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // When 0, the tad_offset is subtracted from the system address. When 1, the tad_offset
    // is added to the system address. 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX tad_offset_sign : 1;
  } Bits;
  UINTX Data;
} FMTADCHNILVOFFSET_5_MC2LM_STRUCT;
#endif // ASM_INC

#define FMTADCHNILVOFFSET_6_MC2LM_REG                     0x000008A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    // N/A
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // Reverse Address Translation Channel Index OffsetBIOS programmed this field by
    // calculating: 
    // (TAD[N].BASE / TAD[N].TAD_SKT_WAY) % TAD[N].TAD_CH_WAY
    // where % is the modulo function.
    // CHN_IDX_OFFSET can have a value of 0, 1, or 2
    // In this equation, the BASE is the lowest address in the TAD range. The TAD_SKT_WAY
    // is 1, 2, 4, or 8, and TAD_CH_WAY is 1, 2, 3, or 4. CHN_IDX_OFFSET will always
    // end up being zero if TAD_CH_WAY is not equal to 3. If TAD_CH_WAY is 3, CHN_IDX_OFFSET
    // can be 0, 1, or 2. 
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // when set, the skt_wayness will be treated as skt_way*3, with the div3 that thsi
    // implies on the system address at the granularity specified by imc_granularity
    // (used for EX only) 
    //           
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    // Specifies the granularity of the skt_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //   b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //   b'11   1GB (based off PA[30] and up) {used for PMem only, though the standard
    // PMem mode will be 4KB) 
    //         
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    // Specifies the granularity of the ch_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, DDRT Block,
    // and DDRT 2LM.  the latter only in mirror mode) 
    //   b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT PMem)
    //   b'11   reserved
    // Note:  using the same ch_granularity encoding for both DDRT and DDR4 even though
    // 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //         
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // When 0, the tad_offset is subtracted from the system address. When 1, the tad_offset
    // is added to the system address. 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX tad_offset_sign : 1;
  } Bits;
  UINTX Data;
} FMTADCHNILVOFFSET_6_MC2LM_STRUCT;
#endif // ASM_INC

#define FMTADCHNILVOFFSET_7_MC2LM_REG                     0x000008AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    // N/A
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // Reverse Address Translation Channel Index OffsetBIOS programmed this field by
    // calculating: 
    // (TAD[N].BASE / TAD[N].TAD_SKT_WAY) % TAD[N].TAD_CH_WAY
    // where % is the modulo function.
    // CHN_IDX_OFFSET can have a value of 0, 1, or 2
    // In this equation, the BASE is the lowest address in the TAD range. The TAD_SKT_WAY
    // is 1, 2, 4, or 8, and TAD_CH_WAY is 1, 2, 3, or 4. CHN_IDX_OFFSET will always
    // end up being zero if TAD_CH_WAY is not equal to 3. If TAD_CH_WAY is 3, CHN_IDX_OFFSET
    // can be 0, 1, or 2. 
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // when set, the skt_wayness will be treated as skt_way*3, with the div3 that thsi
    // implies on the system address at the granularity specified by imc_granularity
    // (used for EX only) 
    //           
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    // Specifies the granularity of the skt_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //   b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //   b'11   1GB (based off PA[30] and up) {used for PMem only, though the standard
    // PMem mode will be 4KB) 
    //         
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    // Specifies the granularity of the ch_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, DDRT Block,
    // and DDRT 2LM.  the latter only in mirror mode) 
    //   b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT PMem)
    //   b'11   reserved
    // Note:  using the same ch_granularity encoding for both DDRT and DDR4 even though
    // 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //         
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // When 0, the tad_offset is subtracted from the system address. When 1, the tad_offset
    // is added to the system address. 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX tad_offset_sign : 1;
  } Bits;
  UINTX Data;
} FMTADCHNILVOFFSET_7_MC2LM_STRUCT;
#endif // ASM_INC

#define FMTADCHNILVOFFSET_8_MC2LM_REG                     0x000008B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    // N/A
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // Reverse Address Translation Channel Index OffsetBIOS programmed this field by
    // calculating: 
    // (TAD[N].BASE / TAD[N].TAD_SKT_WAY) % TAD[N].TAD_CH_WAY
    // where % is the modulo function.
    // CHN_IDX_OFFSET can have a value of 0, 1, or 2
    // In this equation, the BASE is the lowest address in the TAD range. The TAD_SKT_WAY
    // is 1, 2, 4, or 8, and TAD_CH_WAY is 1, 2, 3, or 4. CHN_IDX_OFFSET will always
    // end up being zero if TAD_CH_WAY is not equal to 3. If TAD_CH_WAY is 3, CHN_IDX_OFFSET
    // can be 0, 1, or 2. 
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // when set, the skt_wayness will be treated as skt_way*3, with the div3 that thsi
    // implies on the system address at the granularity specified by imc_granularity
    // (used for EX only) 
    //           
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    // Specifies the granularity of the skt_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //   b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //   b'11   1GB (based off PA[30] and up) {used for PMem only, though the standard
    // PMem mode will be 4KB) 
    //         
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    // Specifies the granularity of the ch_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, DDRT Block,
    // and DDRT 2LM.  the latter only in mirror mode) 
    //   b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT PMem)
    //   b'11   reserved
    // Note:  using the same ch_granularity encoding for both DDRT and DDR4 even though
    // 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //         
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // When 0, the tad_offset is subtracted from the system address. When 1, the tad_offset
    // is added to the system address. 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX tad_offset_sign : 1;
  } Bits;
  UINTX Data;
} FMTADCHNILVOFFSET_8_MC2LM_STRUCT;
#endif // ASM_INC

#define FMTADCHNILVOFFSET_9_MC2LM_REG                     0x000008B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    // N/A
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // Reverse Address Translation Channel Index OffsetBIOS programmed this field by
    // calculating: 
    // (TAD[N].BASE / TAD[N].TAD_SKT_WAY) % TAD[N].TAD_CH_WAY
    // where % is the modulo function.
    // CHN_IDX_OFFSET can have a value of 0, 1, or 2
    // In this equation, the BASE is the lowest address in the TAD range. The TAD_SKT_WAY
    // is 1, 2, 4, or 8, and TAD_CH_WAY is 1, 2, 3, or 4. CHN_IDX_OFFSET will always
    // end up being zero if TAD_CH_WAY is not equal to 3. If TAD_CH_WAY is 3, CHN_IDX_OFFSET
    // can be 0, 1, or 2. 
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // when set, the skt_wayness will be treated as skt_way*3, with the div3 that thsi
    // implies on the system address at the granularity specified by imc_granularity
    // (used for EX only) 
    //           
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    // Specifies the granularity of the skt_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //   b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //   b'11   1GB (based off PA[30] and up) {used for PMem only, though the standard
    // PMem mode will be 4KB) 
    //         
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    // Specifies the granularity of the ch_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, DDRT Block,
    // and DDRT 2LM.  the latter only in mirror mode) 
    //   b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT PMem)
    //   b'11   reserved
    // Note:  using the same ch_granularity encoding for both DDRT and DDR4 even though
    // 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //         
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // When 0, the tad_offset is subtracted from the system address. When 1, the tad_offset
    // is added to the system address. 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX tad_offset_sign : 1;
  } Bits;
  UINTX Data;
} FMTADCHNILVOFFSET_9_MC2LM_STRUCT;
#endif // ASM_INC

#define FMTADCHNILVOFFSET_10_MC2LM_REG                    0x000008B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    // N/A
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // Reverse Address Translation Channel Index OffsetBIOS programmed this field by
    // calculating: 
    // (TAD[N].BASE / TAD[N].TAD_SKT_WAY) % TAD[N].TAD_CH_WAY
    // where % is the modulo function.
    // CHN_IDX_OFFSET can have a value of 0, 1, or 2
    // In this equation, the BASE is the lowest address in the TAD range. The TAD_SKT_WAY
    // is 1, 2, 4, or 8, and TAD_CH_WAY is 1, 2, 3, or 4. CHN_IDX_OFFSET will always
    // end up being zero if TAD_CH_WAY is not equal to 3. If TAD_CH_WAY is 3, CHN_IDX_OFFSET
    // can be 0, 1, or 2. 
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // when set, the skt_wayness will be treated as skt_way*3, with the div3 that thsi
    // implies on the system address at the granularity specified by imc_granularity
    // (used for EX only) 
    //           
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    // Specifies the granularity of the skt_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //   b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //   b'11   1GB (based off PA[30] and up) {used for PMem only, though the standard
    // PMem mode will be 4KB) 
    //         
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    // Specifies the granularity of the ch_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, DDRT Block,
    // and DDRT 2LM.  the latter only in mirror mode) 
    //   b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT PMem)
    //   b'11   reserved
    // Note:  using the same ch_granularity encoding for both DDRT and DDR4 even though
    // 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //         
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // When 0, the tad_offset is subtracted from the system address. When 1, the tad_offset
    // is added to the system address. 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX tad_offset_sign : 1;
  } Bits;
  UINTX Data;
} FMTADCHNILVOFFSET_10_MC2LM_STRUCT;
#endif // ASM_INC

#define FMTADCHNILVOFFSET_11_MC2LM_REG                    0x000008BC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    // N/A
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // Reverse Address Translation Channel Index OffsetBIOS programmed this field by
    // calculating: 
    // (TAD[N].BASE / TAD[N].TAD_SKT_WAY) % TAD[N].TAD_CH_WAY
    // where % is the modulo function.
    // CHN_IDX_OFFSET can have a value of 0, 1, or 2
    // In this equation, the BASE is the lowest address in the TAD range. The TAD_SKT_WAY
    // is 1, 2, 4, or 8, and TAD_CH_WAY is 1, 2, 3, or 4. CHN_IDX_OFFSET will always
    // end up being zero if TAD_CH_WAY is not equal to 3. If TAD_CH_WAY is 3, CHN_IDX_OFFSET
    // can be 0, 1, or 2. 
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // when set, the skt_wayness will be treated as skt_way*3, with the div3 that thsi
    // implies on the system address at the granularity specified by imc_granularity
    // (used for EX only) 
    //           
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    // Specifies the granularity of the skt_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //   b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //   b'11   1GB (based off PA[30] and up) {used for PMem only, though the standard
    // PMem mode will be 4KB) 
    //         
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    // Specifies the granularity of the ch_way interleave
    //   b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //   b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM, DDRT Block,
    // and DDRT 2LM.  the latter only in mirror mode) 
    //   b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT PMem)
    //   b'11   reserved
    // Note:  using the same ch_granularity encoding for both DDRT and DDR4 even though
    // 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //         
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // When 0, the tad_offset is subtracted from the system address. When 1, the tad_offset
    // is added to the system address. 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX tad_offset_sign : 1;
  } Bits;
  UINTX Data;
} FMTADCHNILVOFFSET_11_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_SCRATCHPAD_MC2LM_REG                         0x000008FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // scratchpad
    // 
    // Bits[31:0], RWS_V, default = 0x0
    //
    UINTX scratchpad : 32;
  } Bits;
  UINTX Data;
} DDRT_SCRATCHPAD_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_RETRY_FSM_STATE_MC2LM_REG                    0x00000904
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current encoded state of DDRT retry FSM
    // 
    // Bits[4:0], RO_V, default = 0x0
    //
    UINTX current_state : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Previous encoded state of DDRT retry FSM
    // 
    // Bits[12:8], RO_V, default = 0x0
    //
    UINTX previous_state : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 19;
  } Bits;
  UINTX Data;
} DDRT_RETRY_FSM_STATE_MC2LM_STRUCT;
#endif // ASM_INC

#define FMRIRWAYNESSLIMIT_0_MC2LM_REG                     0x00000908
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[0:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // RIR[4:0].LIMIT[41:29] == highest address of the range in channel address space.
    //  Needs to address up to 4TB at a 512MB granularity. 
    // 
    // Bits[13:1], RW_LB, default = 0x0
    //
    UINTX rir_limit : 13;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 14;
    //
    // rank interleave wayness00 = 1 way,
    //             01 = 2 way,
    //             10 = 4 way,
    //             11 = 8 way.
    // 
    // Bits[29:28], RW_LB, default = 0x0
    //
    UINTX rir_way : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Range Valid when set; otherwise, invalid
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX rir_val : 1;
  } Bits;
  UINTX Data;
} FMRIRWAYNESSLIMIT_0_MC2LM_STRUCT;
#endif // ASM_INC

#define FMRIRWAYNESSLIMIT_1_MC2LM_REG                     0x0000090C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[0:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // RIR[4:0].LIMIT[41:29] == highest address of the range in channel address space.
    //  Needs to address up to 4TB at a 512MB granularity. 
    // 
    // Bits[13:1], RW_LB, default = 0x0
    //
    UINTX rir_limit : 13;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 14;
    //
    // rank interleave wayness00 = 1 way,
    //             01 = 2 way,
    //             10 = 4 way,
    //             11 = 8 way.
    // 
    // Bits[29:28], RW_LB, default = 0x0
    //
    UINTX rir_way : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Range Valid when set; otherwise, invalid
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX rir_val : 1;
  } Bits;
  UINTX Data;
} FMRIRWAYNESSLIMIT_1_MC2LM_STRUCT;
#endif // ASM_INC

#define FMRIRWAYNESSLIMIT_2_MC2LM_REG                     0x00000910
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[0:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // RIR[4:0].LIMIT[41:29] == highest address of the range in channel address space.
    //  Needs to address up to 4TB at a 512MB granularity. 
    // 
    // Bits[13:1], RW_LB, default = 0x0
    //
    UINTX rir_limit : 13;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 14;
    //
    // rank interleave wayness00 = 1 way,
    //             01 = 2 way,
    //             10 = 4 way,
    //             11 = 8 way.
    // 
    // Bits[29:28], RW_LB, default = 0x0
    //
    UINTX rir_way : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Range Valid when set; otherwise, invalid
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX rir_val : 1;
  } Bits;
  UINTX Data;
} FMRIRWAYNESSLIMIT_2_MC2LM_STRUCT;
#endif // ASM_INC

#define FMRIRWAYNESSLIMIT_3_MC2LM_REG                     0x00000914
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[0:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // RIR[4:0].LIMIT[41:29] == highest address of the range in channel address space.
    //  Needs to address up to 4TB at a 512MB granularity. 
    // 
    // Bits[13:1], RW_LB, default = 0x0
    //
    UINTX rir_limit : 13;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 14;
    //
    // rank interleave wayness00 = 1 way,
    //             01 = 2 way,
    //             10 = 4 way,
    //             11 = 8 way.
    // 
    // Bits[29:28], RW_LB, default = 0x0
    //
    UINTX rir_way : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Range Valid when set; otherwise, invalid
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX rir_val : 1;
  } Bits;
  UINTX Data;
} FMRIRWAYNESSLIMIT_3_MC2LM_STRUCT;
#endif // ASM_INC

#define FMRIRILV0OFFSET_0_MC2LM_REG                       0x00000920
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[].RANKOFFSET0[41:26] == rank interleave 0 offset
    // 
    // Bits[17:2], RW_LB, default = 0x0
    //
    UINTX rir_offset0 : 16;
    //
    // target rank ID for rank interleave 0 (used for 1/2-way RIR interleaving).
    // 
    // Bits[21:18], RW_LBV, default = 0x0
    //
    UINTX rir_rnk_tgt0 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 10;
  } Bits;
  UINTX Data;
} FMRIRILV0OFFSET_0_MC2LM_STRUCT;
#endif // ASM_INC

#define FMRIRILV1OFFSET_0_MC2LM_REG                       0x00000924
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[].RANKOFFSET1[41:26] == rank interleave 1 offset, 64MB granularity 
    // 
    // Bits[17:2], RW_LB, default = 0x0
    //
    UINTX rir_offset1 : 16;
    //
    // target rank ID for rank interleave 1 (used for 1/2-way RIR interleaving).
    // 
    // Bits[21:18], RW_LBV, default = 0x0
    //
    UINTX rir_rnk_tgt1 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 10;
  } Bits;
  UINTX Data;
} FMRIRILV1OFFSET_0_MC2LM_STRUCT;
#endif // ASM_INC

#define FMRIRILV0OFFSET_1_MC2LM_REG                       0x00000940
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[].RANKOFFSET0[41:26] == rank interleave 0 offset, 64MB granularity 
    // 
    // Bits[17:2], RW_LB, default = 0x0
    //
    UINTX rir_offset0 : 16;
    //
    // target rank ID for rank interleave 0 (used for 1/2-way RIR interleaving).
    // 
    // Bits[21:18], RW_LBV, default = 0x0
    //
    UINTX rir_rnk_tgt0 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 10;
  } Bits;
  UINTX Data;
} FMRIRILV0OFFSET_1_MC2LM_STRUCT;
#endif // ASM_INC

#define FMRIRILV1OFFSET_1_MC2LM_REG                       0x00000944
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[].RANKOFFSET1[41:26] == rank interleave 1 offset, 64MB granularity 
    // 
    // Bits[17:2], RW_LB, default = 0x0
    //
    UINTX rir_offset1 : 16;
    //
    // target rank ID for rank interleave 1 (used for 1/2-way RIR interleaving).
    // 
    // Bits[21:18], RW_LBV, default = 0x0
    //
    UINTX rir_rnk_tgt1 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 10;
  } Bits;
  UINTX Data;
} FMRIRILV1OFFSET_1_MC2LM_STRUCT;
#endif // ASM_INC

#define FMRIRILV0OFFSET_2_MC2LM_REG                       0x00000960
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[].RANKOFFSET0[41:26] == rank interleave 0 offset, 64MB granularity 
    // 
    // Bits[17:2], RW_LB, default = 0x0
    //
    UINTX rir_offset0 : 16;
    //
    // target rank ID for rank interleave 0 (used for 1/2-way RIR interleaving).
    // 
    // Bits[21:18], RW_LBV, default = 0x0
    //
    UINTX rir_rnk_tgt0 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 10;
  } Bits;
  UINTX Data;
} FMRIRILV0OFFSET_2_MC2LM_STRUCT;
#endif // ASM_INC

#define FMRIRILV1OFFSET_2_MC2LM_REG                       0x00000964
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[].RANKOFFSET1[41:26] == rank interleave 1 offset, 64MB granularity 
    // 
    // Bits[17:2], RW_LB, default = 0x0
    //
    UINTX rir_offset1 : 16;
    //
    // target rank ID for rank interleave 1 (used for 1/2-way RIR interleaving).
    // 
    // Bits[21:18], RW_LBV, default = 0x0
    //
    UINTX rir_rnk_tgt1 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 10;
  } Bits;
  UINTX Data;
} FMRIRILV1OFFSET_2_MC2LM_STRUCT;
#endif // ASM_INC

#define FMRIRILV0OFFSET_3_MC2LM_REG                       0x00000980
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[].RANKOFFSET0[41:26] == rank interleave 0 offset, 64MB granularity 
    // 
    // Bits[17:2], RW_LB, default = 0x0
    //
    UINTX rir_offset0 : 16;
    //
    // target rank ID for rank interleave 0 (used for 1/2-way RIR interleaving).
    // 
    // Bits[21:18], RW_LBV, default = 0x0
    //
    UINTX rir_rnk_tgt0 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 10;
  } Bits;
  UINTX Data;
} FMRIRILV0OFFSET_3_MC2LM_STRUCT;
#endif // ASM_INC

#define FMRIRILV1OFFSET_3_MC2LM_REG                       0x00000984
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[].RANKOFFSET1[41:26] == rank interleave 1 offset, 64MB granularity 
    // 
    // Bits[17:2], RW_LB, default = 0x0
    //
    UINTX rir_offset1 : 16;
    //
    // target rank ID for rank interleave 1 (used for 1/2-way RIR interleaving).
    // 
    // Bits[21:18], RW_LBV, default = 0x0
    //
    UINTX rir_rnk_tgt1 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 10;
  } Bits;
  UINTX Data;
} FMRIRILV1OFFSET_3_MC2LM_STRUCT;
#endif // ASM_INC

#define T_DDRT_RD_CNSTRNT_MC2LM_REG                       0x00000A00
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Minimum READ to READ command DCLK separation from same DIMM separation parameter
    // (measured between the clock assertion edges of the two corresponding asserted
    // command CS#). The min:max program range is 2-31. Any value outside of the range
    // is RFU. 
    // 
    // Bits[7:0], RW_LB, default = 0x2
    //
    UINTX t_ngn_rdrd_s : 8;
    //
    // Minimum READ to READ command DCLK separation from different DIMM separation parameter
    // (measured between the clock assertion edges of the two corresponding asserted
    // command CS#). The min:max program range is 5-31.  Any value outside of the range
    // is RFU. 
    // 
    // Bits[15:8], RW_LB, default = 0x6
    //
    UINTX t_ngn_rdrd_dd : 8;
    //
    // Minimum WRITE to READ command DCLK separation from same DIMM separation parameter
    // (measured between the clock assertion edges of the two corresponding asserted
    // command CS#). The min:max program range is 2-31.  Any value outside of the range
    // is RFU. 
    // 
    // Bits[23:16], RW_LB, default = 0x6
    //
    UINTX t_ngn_wrrd_s : 8;
    //
    // Minimum WRITE to READ command DCLK separation from different DIMM separation parameter
    // (measured between the clock assertion edges of the two corresponding asserted
    // command CS#). The min:max program range is 5-31.  Any value outside of the range
    // is RFU. 
    // 
    // Bits[31:24], RW_LB, default = 0x6
    //
    UINTX t_ngn_wrrd_dd : 8;
  } Bits;
  UINTX Data;
} T_DDRT_RD_CNSTRNT_MC2LM_STRUCT;
#endif // ASM_INC

#define T_DDRT_WR_CNSTRNT_MC2LM_REG                       0x00000A04
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Minimum READ to WRITE command DCLK separation from same DIMM separation parameter
    // (measured between the clock assertion edges of the two corresponding asserted
    // command CS#). The min:max program range is 2-31.  Any value outside of the range
    // is RFU. 
    // 
    // Bits[7:0], RW_LB, default = 0x6
    //
    UINTX t_ngn_rdwr_s : 8;
    //
    // Minimum READ to WRITE command DCLK separation from different DIMM separation parameter
    // (measured between the clock assertion edges of the two corresponding asserted
    // command CS#). The min:max program range is 5-31.  Any value outside of the range
    // is RFU. 
    // 
    // Bits[15:8], RW_LB, default = 0x6
    //
    UINTX t_ngn_rdwr_dd : 8;
    //
    // Minimum WRITE to WRITE command DCLK separation from same DIMM separation parameter
    // (measured between the clock assertion edges of the two corresponding asserted
    // command CS#). The min:max program range is 4-31.  Any value outside of the range
    // is RFU. 
    // 
    // Bits[23:16], RW_LB, default = 0x6
    //
    UINTX t_ngn_wrwr_s : 8;
    //
    // Minimum WRITE to WRITE command DCLK separation from different DIMM separation
    // parameter (measured between the clock assertion edges of the two corresponding
    // asserted command CS#). The min:max program range is 5-31.  Any value outside of
    // the range is RFU. 
    // 
    // Bits[31:24], RW_LB, default = 0x6
    //
    UINTX t_ngn_wrwr_dd : 8;
  } Bits;
  UINTX Data;
} T_DDRT_WR_CNSTRNT_MC2LM_STRUCT;
#endif // ASM_INC

#define T_DDRT_GNT2RW_CNSTRNT_MC2LM_REG                   0x00000A08
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Minimum GRANT to READ command DCLK separation from same DIMM separation parameter
    // (measured between the clock assertion edges of the two corresponding asserted
    // command CS#). The min:max program range is 2-31.  Any value outside of the range
    // is RFU. 
    // 
    // Bits[7:0], RW_LB, default = 0x6
    //
    UINTX t_ngn_gntrd_s : 8;
    //
    // Minimum GRANT to READ command DCLK separation from different DIMM separation parameter
    // (measured between the clock assertion edges of the two corresponding asserted
    // command CS#). The min:max program range is 2-31.  Any value outside of the range
    // is RFU. 
    //         
    // 
    // Bits[15:8], RW_LB, default = 0x6
    //
    UINTX t_ngn_gntrd_dd : 8;
    //
    // Minimum GRANT to WRITE command DCLK separation from same DIMM separation parameter
    // (measured between the clock assertion edges of the two corresponding asserted
    // command CS#). The min:max program range is 5-31.  Any value outside of the range
    // is RFU. 
    // 
    // Bits[23:16], RW_LB, default = 0x6
    //
    UINTX t_ngn_gntwr_s : 8;
    //
    // Minimum GRANT to WRITE command DCLK separation from different DIMM separation
    // parameter (measured between the clock assertion edges of the two corresponding
    // asserted command CS#). The min:max program range is 5-31.  Any value outside of
    // the range is RFU. 
    // 
    // Bits[31:24], RW_LB, default = 0x6
    //
    UINTX t_ngn_gntwr_dd : 8;
  } Bits;
  UINTX Data;
} T_DDRT_GNT2RW_CNSTRNT_MC2LM_STRUCT;
#endif // ASM_INC

#define T_DDRT_RW2GNT_CNSTRNT_MC2LM_REG                   0x00000A0C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Minimum READ to GRANT command DCLK separation from same DIMM separation parameter
    // (measured between the clock assertion edges of the two corresponding asserted
    // command CS#). The min:max program range is 2-31.  Any value outside of the range
    // is RFU. 
    // 
    // Bits[7:0], RW_LB, default = 0x6
    //
    UINTX t_ngn_rdgnt_s : 8;
    //
    // Minimum READ to GRANT command DCLK separation from different DIMM separation parameter
    // (measured between the clock assertion edges of the two corresponding asserted
    // command CS#). The min:max program range is 5-31.  Any value outside of the range
    // is RFU. 
    // 
    // Bits[15:8], RW_LB, default = 0x6
    //
    UINTX t_ngn_rdgnt_dd : 8;
    //
    // Minimum WRITE to GRANT command DCLK separation from same DIMM separation parameter
    // (measured between the clock assertion edges of the two corresponding asserted
    // command CS#). The min:max program range is 5-31.  Any value outside of the range
    // is RFU. 
    // 
    // Bits[23:16], RW_LB, default = 0x6
    //
    UINTX t_ngn_wrgnt_s : 8;
    //
    // Minimum WRITE to GRANT command DCLK separation from different DIMM separation
    // parameter (measured between the clock assertion edges of the two corresponding
    // asserted command CS#). The min:max program range is 5-31.  Any value outside of
    // the range is RFU. 
    // 
    // Bits[31:24], RW_LB, default = 0x6
    //
    UINTX t_ngn_wrgnt_dd : 8;
  } Bits;
  UINTX Data;
} T_DDRT_RW2GNT_CNSTRNT_MC2LM_STRUCT;
#endif // ASM_INC

#define T_DDRT_GNT2GNT_CNSTRNT_MC2LM_REG                  0x00000A10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Minimum GRANT to GRANT command DCLK separation from same DIMM separation parameter
    // (measured between the clock assertion edges of the two corresponding asserted
    // command CS#). The min:max program range is 4-31.  Any value outside of the range
    // is RFU. 
    // 
    // Bits[7:0], RW_LB, default = 0x6
    //
    UINTX t_ngn_gntgnt_s : 8;
    //
    // Minimum GRANT to GRANT command DCLK separation from different DIMM separation
    // parameter (measured between the clock assertion edges of the two corresponding
    // asserted command CS#). The min:max program range is 5-31.  Any value outside of
    // the range is RFU. 
    // 
    // Bits[15:8], RW_LB, default = 0x6
    //
    UINTX t_ngn_gntgnt_dd : 8;
  } Bits;
  UINTX Data;
} T_DDRT_GNT2GNT_CNSTRNT_MC2LM_STRUCT;
#endif // ASM_INC

#define T_DDRT_PD_MC2LM_REG                               0x00000A14
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Minimum READ to PD command separation (in DCLK, measured between the clock assertion
    // edges of the two corresponding asserted command CS#). The min:max program range
    // is 2-31.  Any value outside of the range is RFU. 
    //         
    // 
    // Bits[7:0], RW_LB, default = 0xF
    //
    UINTX t_ngn_rdpden : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
    //
    // Minimum WRITE to PD command separation (in DCLK measured between the clock assertion
    // edges of the two corresponding asserted command CS#). The min:max program range
    // is 2-31.  Any value outside of the range is RFU. 
    // 
    // Bits[23:16], RW_LB, default = 0xF
    //
    UINTX t_ngn_wrpden : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 8;
  } Bits;
  UINTX Data;
} T_DDRT_PD_MC2LM_STRUCT;
#endif // ASM_INC

#define T_DDRT_PD2_MC2LM_REG                              0x00000A18
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Minimum GRANT to PD command separation (in DCLK measured between the clock assertion
    // edges of the two corresponding asserted command CS#). The min:max program range
    // is 2-31.  Any value outside of the range is RFU. 
    // 
    // Bits[7:0], RW_LB, default = 0x6
    //
    UINTX t_ngn_gntpden : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 24;
  } Bits;
  UINTX Data;
} T_DDRT_PD2_MC2LM_STRUCT;
#endif // ASM_INC

#define T_DDRT_PWRUP_MC2LM_REG                            0x00000A1C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Minimum Power Down Exit to first command DCLK separation. The min:max program
    // range is TBD.  Any value outside of the range is RFU. 
    // 
    // Bits[7:0], RW_LB, default = 0x8
    //
    UINTX t_ngn_xp : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    //  Not used.  Remove. 
    // 
    // Bits[27:12], RW_LB, default = 0x400
    //
    UINTX t_ngn_xpdll : 16;
    //
    // CKE minimum pulse width.  Should be programmed consistent with CR_TCRAP.t_cke
    //  
    // 
    // Bits[31:28], RW_LB, default = 0x3
    //
    UINTX t_ngn_cke : 4;
  } Bits;
  UINTX Data;
} T_DDRT_PWRUP_MC2LM_STRUCT;
#endif // ASM_INC

#define T_DDRT_DIMM0_BASIC_TIMING_MC2LM_REG               0x00000A20
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay from GRANT to ERID. The min:max program range is TBD.  Any value outside
    // of the range is RFU. 
    //             The value of this field should be programmed during training as part
    // of roundtrip training. 
    //         
    // 
    // Bits[7:0], RW_LB, default = 0x6
    //
    UINTX t_ngn_gnt2erid : 8;
    //
    // Grant to 1st Data Delay. Not used by hardware.
    // 
    // Bits[15:8], RW_LB, default = 0x6
    //
    UINTX t_ngn_tcl : 8;
    //
    // Delay between write command (CS# assertion edge) and 1st burst of write data.
    //  
    //             Offset from programmed value of 9 DCLKs based on pipeline delays.
    //         
    // 
    // Bits[23:16], RW_LB, default = 0x2
    //
    UINTX t_ngn_twl : 8;
    //
    // 
    //          This register defines additional WR data delay per channel in order to
    //          overcome the WR-flyby issue. This change is applied only to DDRT DIMMs
    //          on the channel. 
    //          The total CAS write latency that the DDR sees is the sum of t_NGN_tWL
    // and the t_NGN_tWL_ADJ minus t_NGN_tWL_ADJ_NEG. 
    //          000 - no added latency (default)
    //          001 to 111 - 1 to 7 Dclk of added latency
    //         
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX t_ngn_twl_adj : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //           This register defines reduction of WR data delay per channel in order
    // to overcome the WR-flyby issue. 
    //           The total CAS write latency that the DDR sees is the sum of t_NGN_tWL
    // and the t_NGN_tWL_ADJ minus t_NGN_tWL_ADJ_NEG. 
    //           This change is applied only to DDRT DIMMs on the channel.
    //           00 - no latency reduction (default)
    //           01 - reduce latency by 1 Dclk
    //           10 - reduce latency by 2 Dclk
    //           11 - reduce latency by 3 Dclk
    //           The total t_cwl (t_NGN_tWL + t_NGN_tWL_ADJ - t_NGN_tWL_ADJ_NEG) should
    // not be less than 2  
    //         
    // 
    // Bits[29:28], RW_LB, default = 0x0
    //
    UINTX t_ngn_twl_adj_neg : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
  } Bits;
  UINTX Data;
} T_DDRT_DIMM0_BASIC_TIMING_MC2LM_STRUCT;
#endif // ASM_INC

#define T_DDRT_DIMM1_BASIC_TIMING_MC2LM_REG               0x00000A24
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay from GRANT to ERID. The min:max program range is TBD.  Any value outside
    // of the range is RFU. 
    //             The value of this field should be programmed during training as part
    // of roundtrip training. 
    //         
    // 
    // Bits[7:0], RW_LB, default = 0x6
    //
    UINTX t_ngn_gnt2erid : 8;
    //
    // Grant to 1st Data Delay. Not used by hardware.
    // 
    // Bits[15:8], RW_LB, default = 0x6
    //
    UINTX t_ngn_tcl : 8;
    //
    // Not used.  DIMM0 and DIMM1 must use the same tWL. 
    // 
    // Bits[23:16], RW_LB, default = 0x2
    //
    UINTX t_ngn_twl : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} T_DDRT_DIMM1_BASIC_TIMING_MC2LM_STRUCT;
#endif // ASM_INC

#define T_PERSIST_TIMING_MC2LM_REG                        0x00000A28
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //          This is the delay that the TWPQ must wait after
    //          issuing write data before considering the written data has reached
    //          persistent domain in FNV. The scheduler must monitor the ERR# pin in
    //          this duration and mark the transaction as visible only if ERR# is not
    //          asserted for Error latency duration after write data is issued. Note:
    //          Need to document the additional delay for the write data thru DDRIO
    //          and the delay of sensing ERR# assertion in DDRIO. The maximum  program
    //          range is 128 Dclks.
    //          
    // 
    // Bits[15:0], RW_LB, default = 0x20
    //
    UINTX t_persist_delay : 16;
    //
    // This is the delay that the data bus must be blocked after a GNT is scheduled.
    // The min:max program range is TBD.  Any value outside of the range is RFU. 
    // 
    // Bits[23:16], RW_LB, default = 0x4
    //
    UINTX t_gnt_dq : 8;
    //
    // 
    //          This is the delay that the data bus must be
    //          blocked after a GNT is scheduled when read data is going
    //          through ECC correction. 
    //         
    // 
    // Bits[31:24], RW_LB, default = 0xC
    //
    UINTX t_gnt_dq_retry : 8;
  } Bits;
  UINTX Data;
} T_PERSIST_TIMING_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_CREDIT_LIMIT_MC2LM_REG                       0x00000A2C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Max 64B Pending Read Credit to FM (FNV RPQ Depth)
    // 
    // Bits[7:0], RW_LB, default = 0x28
    //
    UINTX ngn_rd_credit : 8;
    //
    // Max 64B Pending Write Credit to FM (FNV WPQ depth)
    // 
    // Bits[15:8], RW_LB, default = 0x0
    //
    UINTX ngn_wr_credit : 8;
    //
    // Reserved for future use.
    // 
    // Bits[31:16], RW_LB, default = 0x30
    //
    UINTX reserved : 16;
  } Bits;
  UINTX Data;
} DDRT_CREDIT_LIMIT_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_CREDIT_COUNT_MC2LM_REG                       0x00000A30
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
    //
    // Current 64B Pending Read Credit Count to M2M
    // 
    // Bits[23:16], RO_V, default = 0x30
    //
    UINTX m2m_rd_cr_cnt : 8;
    //
    // Current 64B Pending Write Credit Count to M2M
    // 
    // Bits[31:24], RO_V, default = 0x30
    //
    UINTX m2m_wr_cr_cnt : 8;
  } Bits;
  UINTX Data;
} DDRT_CREDIT_COUNT_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_MAJOR_MODE_THRESHOLD1_MC2LM_REG              0x00000A34
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When channel is in DDRT RMM and the number of WDB entries gets to this level,
    // channel goes into DDRT WMM. The value must be at least 2. 
    // 
    // Bits[7:0], RW_LB, default = 0x18
    //
    UINTX wmm_enter : 8;
    //
    // When channel is in DDRT WMM and the number of WDB entries gets to this level,
    // channel goes back to DDRT RMM. The value must be between 1 and (WMM_Enter - 1).
    // 
    // Bits[15:8], RW_LB, default = 0x8
    //
    UINTX wmm_exit : 8;
    //
    // This count is used for the starvation switch. Channel will stay in DDRT RMM for
    // at least MIN_RMM_CYCLES number of cycles. Exception: DDRT ADR will force channel
    // into DDRT WMM. 
    // 
    // Bits[23:16], RW_LB, default = 0x1E
    //
    UINTX min_rmm_cycles : 8;
    //
    // This count is used for the starvation switch. Channel will stay in DDRT WMM for
    // at most MAX_WMM_CYCLES number of cycles. Exception: DDRT ADR will force channel
    // into DDRT WMM. 
    // 
    // Bits[31:24], RW_LB, default = 0x32
    //
    UINTX min_wmm_cycles : 8;
  } Bits;
  UINTX Data;
} DDRT_MAJOR_MODE_THRESHOLD1_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_NGN_CREDIT_COUNT_MC2LM_REG                   0x00000A38
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current count of Read credits to FM consumed on rank 0
    // 
    // Bits[7:0], RO_V, default = 0x28
    //
    UINTX ngn_rd_cr_cnt_ngn0 : 8;
    //
    // Current count of Write credits to FM consumed on rank 0
    // 
    // Bits[15:8], RO_V, default = 0x38
    //
    UINTX ngn_wr_cr_cnt_ngn0 : 8;
    //
    // Current count of Read credits to FM consumed on rank 1
    // 
    // Bits[23:16], RO_V, default = 0x28
    //
    UINTX ngn_rd_cr_cnt_ngn1 : 8;
    //
    // Current count of Write credits to FM consumed on rank 1
    // 
    // Bits[31:24], RO_V, default = 0x38
    //
    UINTX ngn_wr_cr_cnt_ngn1 : 8;
  } Bits;
  UINTX Data;
} DDRT_NGN_CREDIT_COUNT_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_MAJOR_MODE_THRESHOLD3_MC2LM_REG              0x00000A3C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         Force the scheduler to switch from DDR4 to DDRT major mode even if a single
    // DDRT command is present in the DDRT queues. This transition is  
    //         triggered after the scheduler has remained in DDR4 major mode for a critical
    // starvation number of cycles and no DDRT transaction was scheduled.  
    //         The critical starvation threshold is calculated as MODE_STARVE_CYCLE_THRESHOLD.DDRT
    // X critical_starve. A value of 0 in this field disables 
    //         the transition. 
    //         
    // 
    // Bits[4:0], RW_LB, default = 0x8
    //
    UINTX critical_starve : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 27;
  } Bits;
  UINTX Data;
} DDRT_MAJOR_MODE_THRESHOLD3_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_RPQL_MSK_MC2LM_REG                           0x00000A40
#ifndef ASM_INC
typedef union {
  struct {
    //
    // TRPQ[31:0] entry mask. Masking off the entry when set to one.
    // 
    // Bits[31:0], RW_LB, default = 0x0
    //
    UINTX ddrt_rpql_msk : 32;
  } Bits;
  UINTX Data;
} DDRT_RPQL_MSK_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_RPQH_MSK_MC2LM_REG                           0x00000A44
#ifndef ASM_INC
typedef union {
  struct {
    //
    // TRPQ[47:32] entry mask. Masking off the entry when set to one.
    // 
    // Bits[15:0], RW_LB, default = 0x0
    //
    UINTX ddrt_rpqh_msk : 16;
  } Bits;
  UINTX Data;
} DDRT_RPQH_MSK_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_WPQ_MSK_MC2LM_REG                            0x00000A48
#ifndef ASM_INC
typedef union {
  struct {
    //
    // TWPQ entry mask. Masking off the entry when set to one.
    // 
    // Bits[31:0], RW_LB, default = 0x0
    //
    UINTX ddrt_wpq_msk : 32;
  } Bits;
  UINTX Data;
} DDRT_WPQ_MSK_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_RETRY_TIMER2_MC2LM_REG                       0x00000A4C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Train reset duration. Program to the same value as vmse_retry_timer2.train_reset_time
    // 
    // Bits[7:0], RW_LB, default = 0xFF
    //
    UINTX train_reset_time : 8;
    //
    // Wait time in completion state (SUCCESS or FAILURE). Program to the same value
    // as vmse_retry_timer2.retry_cmpl_time 
    // 
    // Bits[14:8], RW_LB, default = 0x7F
    //
    UINTX retry_cmpl_time : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 17;
  } Bits;
  UINTX Data;
} DDRT_RETRY_TIMER2_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_DEFEATURE_MC2LM_REG                          0x00000A50
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Use RT empty before switching major mode
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mm_use_rt_empty : 1;
    //
    // 
    //         Set to 1 to block the ERID parity error detection. Default is
    //         to leave the error condition enabled. 
    //         
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX ignore_erid_parity_error : 1;
    //
    // 
    //          Set to 1 to force MC to ignore the ERID Fatal error. This error fires
    //          when MC detects a RPQ or underfill Read data packet where RID did not
    //  
    //          match the ERID. Default behavior is to treat the
    //          error as a fatal condition. If this bit is set, MC will block the
    //          fatal error and instead trigger the Error Flow FSM. 
    //         
    // 
    // Bits[2:2], RW_LB, default = 0x0
    //
    UINTX ignore_erid_fatal_error : 1;
    //
    // 
    //          Set to 1 to force DDRT scheduler to issue an Ack for a pcommit 
    //         
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX force_pcommit_ack : 1;
    //
    // 
    //          Set to 1 to for DDRT scheduler to ignore pcommit command. MC
    //          will send an ACK when a pcommit command is seen without
    //          draining the WPQ. 
    //         
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX ignore_pcommit : 1;
    //
    // disable DDRT Thermal event
    // 
    // Bits[5:5], RW_LB, default = 0x0
    //
    UINTX dis_thermal_event : 1;
    //
    // 
    //          This field is matched with the directory bits in the FNV IOT
    //          packet to generate a trigger. A value of 0 disables the
    //          trigger. 
    //         
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX fnv_iot_trig_match : 2;
    //
    // 
    //          Default behavior is for pcommit acks to be blocked once a
    //          channel hits link fail condition. If this bit is set, MC will send an
    //          ACK for pcommit even in link fail condition. This bit is used
    //          for pcommits directed to DDRT.
    //         
    // 
    // Bits[8:8], RW_LB, default = 0x0
    //
    UINTX pcommit_ack_for_linkfail : 1;
    //
    // 
    //          Default behavior of pcommit is to snapshot all outstanding
    //          writes to persistent or block region when a pcommit instruction is seen.
    //  
    //          If this bit is set then debug defeature is set then snapshot ALL wrs
    // in DDRT WPQ. 
    //         
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX pcommit_snapshot_all_wrs : 1;
    //
    // 
    //          Queue empty indication to PkGC flows will wait for all DDRT
    //          write credits to be returned by FNV
    //         
    // 
    // Bits[10:10], RW_LB, default = 0x0
    //
    UINTX pkgc_wait_ddrt_wr_credit : 1;
    //
    // 
    //         Set each bit in this field to 1 to force MC to ignore incoming
    //         REQ pin. Bit 11 is for Slot 0 and Bit 12 is for Slot 1 
    //         
    // 
    // Bits[12:11], RW_LB, default = 0x0
    //
    UINTX ignore_ddrt_req : 2;
    //
    // 
    //         Set each bit in this field to 1 to force MC to ignore incoming
    //         ERID pin. Bit 11 is for Slot 0 and Bit 12 is for Slot 1 
    //         
    // 
    // Bits[14:13], RW_LB, default = 0x0
    //
    UINTX ignore_erid : 2;
    //
    // 
    //         Set this bit to 1 to force the DDRT Retry FSM to ignore Viral
    //         condiion. When set, VIRAL command is not issued to FNV and DDRT FSM
    //         will not go to Link Fail.
    //         
    // 
    // Bits[15:15], RW_LB, default = 0x1
    //
    UINTX ignore_viral : 1;
    //
    // 
    //         Set this bit to 1 to force the DDRT to ignore the Retry bit
    //         from M2M. DDRT transactions will not go through the ECC
    //         correction path if this bit is set. 
    //         
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX ignore_retry_cmd : 1;
    //
    // 
    //         Set this bit to 1 to force the DDRT to ignore the check when
    //         ERID does not match a read packet but RID does.
    //         
    // 
    // Bits[17:17], RW_LB, default = 0x0
    //
    UINTX ignore_erid_notrd_err : 1;
    //
    // Spare.
    // 
    // Bits[31:18], RW_LB, default = 0x0
    //
    UINTX ddrt_defeature : 14;
  } Bits;
  UINTX Data;
} DDRT_DEFEATURE_MC2LM_STRUCT;
#endif // ASM_INC

#define T_DDRT_MISC_DELAY_MC2LM_REG                       0x00000A54
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Controls the delay to return RPQ credit to M2M after ERID is received 
    // 
    // Bits[4:0], RW_LB, default = 0x4
    //
    UINTX rpq_rid_to_credit_ret : 5;
    //
    // Controls the delay to move WPQ Partial to Full Write credit after ERID is received
    //  
    // 
    // Bits[9:5], RW_LB, default = 0x4
    //
    UINTX wpq_rid_to_fwr : 5;
    //
    // 
    //         CSR controls the delay to retrun the WPQ credit back to M2M
    //         after the Write data is read Write data buffer for the memory
    //         write. The maximum value that this can be programmed to is 12. 
    //         
    // 
    // Bits[13:10], RW_LB, default = 0x2
    //
    UINTX wpq_dealloc_to_credit_ret : 4;
    //
    // N/A
    // 
    // Bits[14:14], RW_LB, default = 0x0
    //
    UINTX force_ddrt_mode : 1;
    //
    // N/A
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX force_ddr4_mode : 1;
    //
    // 
    //         Control the delay to block Read Valid for non M2M read transaction
    //         when the transaction is using the correction path. 
    //         
    // 
    // Bits[19:16], RW_LB, default = 0x6
    //
    UINTX invld_erid_retry : 4;
    //
    // 
    //         Controls the delay from wpq ERID to underfill indication on read return
    // path.  
    //         The formula to program this is (t_ngn_tcl - 13) 
    //         
    // 
    // Bits[24:20], RW_LB, default = 0x2
    //
    UINTX wpq_rid_to_rt_ufill : 5;
    //
    // This field is not used. 
    // 
    // Bits[29:25], RW_LB, default = 0xF
    //
    UINTX wpq_flush_to_dealloc : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //         Set this field to 1 to enable DDRT 2N Timing. 
    //         
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX enable_ddrt_2n_timing : 1;
  } Bits;
  UINTX Data;
} T_DDRT_MISC_DELAY_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_WDB_PAR_ERR_CTL_MC2LM_REG                    0x00000A58
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 16 bit mask for injection on WDB read parity value
    // 
    // Bits[15:0], RW_LB, default = 0x0
    //
    UINTX inj_mask : 16;
    //
    // Parity error will be injected according to inj_mask on the next WDB read after
    // this bit is set. Enable bit will be unset after injection. 
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX enable : 1;
    //
    // Disable Write Data Buffer parity checking
    // 
    // Bits[17:17], RW_LB, default = 0x0
    //
    UINTX dis_wdb_par_chk : 1;
    //
    // Disable HA parity checking
    // 
    // Bits[18:18], RW_LB, default = 0x0
    //
    UINTX dis_ha_par_chk : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 13;
  } Bits;
  UINTX Data;
} DDRT_WDB_PAR_ERR_CTL_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_FNV0_EVENT0_MC2LM_REG                        0x00000A60
#ifndef ASM_INC
typedef union {
  struct {
    //
    // FNV event log
    // 
    // Bits[23:0], RWS_V, default = 0x0
    //
    UINTX log : 24;
    //
    // Packet ID of interrupt packet
    // 
    // Bits[26:24], RWS_V, default = 0x0
    //
    UINTX id : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // FNV event ERR0 assertion select. Upon logging a FNV low priority event, iMC to
    // generate a msgchn posted write to IIO to assert ERR0 pin if this select mask is
    // configured to one by BIOS during boot. Bit 29:28 can have all four combinations.
    // When both are set, both SMI and ERR# are armed. 
    // 
    // Bits[28:28], RWS_L, default = 0x0
    //
    UINTX err_select : 1;
    //
    // FNV event SMM interrupt select. Upon logging a FNV low priority event, iMC to
    // generate a msgchn posted write to UBox to generate SMI if this select mask is
    // configured to one by BIOS during boot. Bit 29:28 can have all four combinations.
    // When both are set, both SMI and ERR# are armed. 
    // 
    // Bits[29:29], RWS_L, default = 0x0
    //
    UINTX smi_select : 1;
    //
    // FNV event overflow. 2nd event is detected before the EVNET_VALID is cleared by
    // interrupt handler. 
    // 
    // Bits[30:30], RW1CS, default = 0x0
    //
    UINTX overflow : 1;
    //
    // FNV event valid. Event log is valid.
    // 
    // Bits[31:31], RW1CS, default = 0x0
    //
    UINTX valid : 1;
  } Bits;
  UINTX Data;
} DDRT_FNV0_EVENT0_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_FNV0_EVENT1_MC2LM_REG                        0x00000A64
#ifndef ASM_INC
typedef union {
  struct {
    //
    // FNV event log
    // 
    // Bits[23:0], RWS_V, default = 0x0
    //
    UINTX log : 24;
    //
    // Packet ID of interrupt packet
    // 
    // Bits[26:24], RWS_V, default = 0x0
    //
    UINTX id : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // FNV event ERR0 assertion select. Upon logging a FNV low priority event, iMC to
    // generate a msgchn posted write to IIO to assert ERR0 pin if this select mask is
    // configured to one by BIOS during boot. Bit 29:28 can have all four combinations.
    // When both are set, both SMI and ERR# are armed. 
    // 
    // Bits[28:28], RWS_L, default = 0x0
    //
    UINTX err_select : 1;
    //
    // FNV event SMM interrupt select. Upon logging a FNV low priority event, iMC to
    // generate a msgchn posted write to UBox to generate SMI if this select mask is
    // configured to one by BIOS during boot. Bit 29:28 can have all four combinations.
    // When both are set, both SMI and ERR# are armed. 
    // 
    // Bits[29:29], RWS_L, default = 0x0
    //
    UINTX smi_select : 1;
    //
    // FNV event overflow. 2nd event is detected before the EVNET_VALID is cleared by
    // interrupt handler. 
    // 
    // Bits[30:30], RW1CS, default = 0x0
    //
    UINTX overflow : 1;
    //
    // FNV event valid. Event log is valid.
    // 
    // Bits[31:31], RW1CS, default = 0x0
    //
    UINTX valid : 1;
  } Bits;
  UINTX Data;
} DDRT_FNV0_EVENT1_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_FNV1_EVENT0_MC2LM_REG                        0x00000A70
#ifndef ASM_INC
typedef union {
  struct {
    //
    // FNV event log
    // 
    // Bits[23:0], RWS_V, default = 0x0
    //
    UINTX log : 24;
    //
    // Packet ID of interrupt packet
    // 
    // Bits[26:24], RWS_V, default = 0x0
    //
    UINTX id : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // FNV event ERR0 assertion select. Upon logging a FNV low priority event, iMC to
    // generate a msgchn posted write to IIO to assert ERR0 pin if this select mask is
    // configured to one by BIOS during boot. Bit 29:28 can have all four combinations.
    // When both are set, both SMI and ERR# are armed. 
    // 
    // Bits[28:28], RWS_L, default = 0x0
    //
    UINTX err_select : 1;
    //
    // FNV event SMM interrupt select. Upon logging a FNV low priority event, iMC to
    // generate a msgchn posted write to UBox to generate SMI if this select mask is
    // configured to one by BIOS during boot. Bit 29:28 can have all four combinations.
    // When both are set, both SMI and ERR# are armed. 
    // 
    // Bits[29:29], RWS_L, default = 0x0
    //
    UINTX smi_select : 1;
    //
    // FNV event overflow. 2nd event is detected before the EVNET_VALID is cleared by
    // interrupt handler. 
    // 
    // Bits[30:30], RW1CS, default = 0x0
    //
    UINTX overflow : 1;
    //
    // FNV event valid. Event log is valid.
    // 
    // Bits[31:31], RW1CS, default = 0x0
    //
    UINTX valid : 1;
  } Bits;
  UINTX Data;
} DDRT_FNV1_EVENT0_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_FNV1_EVENT1_MC2LM_REG                        0x00000A74
#ifndef ASM_INC
typedef union {
  struct {
    //
    // FNV event log
    // 
    // Bits[23:0], RWS_V, default = 0x0
    //
    UINTX log : 24;
    //
    // Packet ID of interrupt packet
    // 
    // Bits[26:24], RWS_V, default = 0x0
    //
    UINTX id : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // FNV event ERR0 assertion select. Upon logging a FNV low priority event, iMC to
    // generate a msgchn posted write to IIO to assert ERR0 pin if this select mask is
    // configured to one by BIOS during boot. Bit 29:28 can have all four combinations.
    // When both are set, both SMI and ERR# are armed. 
    // 
    // Bits[28:28], RWS_L, default = 0x0
    //
    UINTX err_select : 1;
    //
    // FNV event SMM interrupt select. Upon logging a FNV low priority event, iMC to
    // generate a msgchn posted write to UBox to generate SMI if this select mask is
    // configured to one by BIOS during boot. Bit 29:28 can have all four combinations.
    // When both are set, both SMI and ERR# are armed. 
    // 
    // Bits[29:29], RWS_L, default = 0x0
    //
    UINTX smi_select : 1;
    //
    // FNV event overflow. 2nd event is detected before the EVNET_VALID is cleared by
    // interrupt handler. 
    // 
    // Bits[30:30], RW1CS, default = 0x0
    //
    UINTX overflow : 1;
    //
    // FNV event valid. Event log is valid.
    // 
    // Bits[31:31], RW1CS, default = 0x0
    //
    UINTX valid : 1;
  } Bits;
  UINTX Data;
} DDRT_FNV1_EVENT1_MC2LM_STRUCT;
#endif // ASM_INC

#define MODE_STARVE_CYCLE_THRESHOLD_MC2LM_REG             0x00000A78
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Threshold for number of cycles since exit from DDRT major mode before DDRT mode
    // is considered starved 
    // 
    // Bits[15:0], RW_LB, default = 0x100
    //
    UINTX ddrt : 16;
    //
    // Threshold for number of cycles since exit from DDR4 major mode before DDR4 mode
    // is considered starved 
    // 
    // Bits[31:16], RW_LB, default = 0x100
    //
    UINTX ddr4 : 16;
  } Bits;
  UINTX Data;
} MODE_STARVE_CYCLE_THRESHOLD_MC2LM_STRUCT;
#endif // ASM_INC

#define MODE_DELAYS_MC2LM_REG                             0x00000A7C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay while switching from DDRT to DDR4 major mode. During this period, the MC
    // will continue to remain in DDRT mode but no new DDRT transactions are scheduled
    // 
    // Bits[7:0], RW_LB, default = 0x10
    //
    UINTX ddrt_to_ddr4_delay : 8;
    //
    // Delay while switching from DDR4 to DDRT major mode. During this period, the MC
    // will continue to remain in DDR4 mode but no new DDR4 transactions are scheduled
    // 
    // Bits[15:8], RW_LB, default = 0x10
    //
    UINTX ddr4_to_ddrt_delay : 8;
  } Bits;
  UINTX Data;
} MODE_DELAYS_MC2LM_STRUCT;
#endif // ASM_INC

#define MODE_DDRT_CMD_STARVE_THRESHOLD_MC2LM_REG          0x00000A80
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Threshold of outstanding reads in DDRT RPQ to hit DDRT starvation condition
    // 
    // Bits[7:0], RW_LB, default = 0x10
    //
    UINTX reads : 8;
    //
    // Threshold of outstanding writes in DDRT WPQ to hit DDRT starvation condition
    // 
    // Bits[15:8], RW_LB, default = 0x10
    //
    UINTX writes : 8;
    //
    // Threshold of outstanding partials writes in DDRT WPQ to hit DDRT starvation condition
    // 
    // Bits[23:16], RW_LB, default = 0x10
    //
    UINTX partials : 8;
    //
    // Threshold of outstanding GNTs in DDRT RPQ to hit DDRT starvation condition
    // 
    // Bits[31:24], RW_LB, default = 0x10
    //
    UINTX gnts : 8;
  } Bits;
  UINTX Data;
} MODE_DDRT_CMD_STARVE_THRESHOLD_MC2LM_STRUCT;
#endif // ASM_INC

#define MODE_MIN_RESIDENCY_THRESHOLD_MC2LM_REG            0x00000A84
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Threshold for minumum number of cycles the MC should remain in DDRT major mode
    // 
    // Bits[15:0], RW_LB, default = 0x20
    //
    UINTX ddrt : 16;
    //
    // Threshold for minumum number of cycles the MC should remain in DDR4 major mode
    // 
    // Bits[31:16], RW_LB, default = 0x20
    //
    UINTX ddr4 : 16;
  } Bits;
  UINTX Data;
} MODE_MIN_RESIDENCY_THRESHOLD_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_MAJOR_MODE_THRESHOLD2_MC2LM_REG              0x00000A88
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DDR-T Partial Write Starvation Counter Pre-Scaler
    // When the counter increment to the STARV_CNTR_PRESCALER value, the STARV_CNTR_PRESCALER
    // counter will be roll over back to zero and start counting. There is a 3b partial
    // write starvation counter for each partial write in the write queue. 
    // At the roll over, all 3b partial write starvation counters will be incremented
    // by 1. The 3b pwr starvation counter will saturated at its max value to indicate
    // the partial write starvation condition. The 3b counter will be cleared when the
    // partial write is served. 
    // 
    // Bits[7:0], RW, default = 0x40
    //
    UINTX pwmm_starv_cntr_prescaler : 8;
    //
    // N/A
    // 
    // Bits[15:8], RW_LB, default = 0x5
    //
    UINTX gnt_exit : 8;
    //
    // N/A
    // 
    // Bits[23:16], RW_LB, default = 0x10
    //
    UINTX pwr_enter : 8;
    //
    // N/A
    // 
    // Bits[31:24], RW_LB, default = 0x5
    //
    UINTX pwr_exit : 8;
  } Bits;
  UINTX Data;
} DDRT_MAJOR_MODE_THRESHOLD2_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_RETRY_TIMER_MC2LM_REG                        0x00000A8C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Sets the limit as (2^retry_on_timer_limit) DCLKs for duration when Retry FSM can
    // be 
    //                      active before an error is triggered.
    //         
    // 
    // Bits[5:0], RW_LB, default = 0x19
    //
    UINTX retry_on_timer_limit : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 
    //         Set to 0 to enable watch dog timer for DDRT Retry FSM
    //         timer. The timer limit is programmed as (2^retry_on_timer_limit) DCLKs
    // for duration when Retry FSM can be 
    //         active before an error is triggered.
    //         
    // 
    // Bits[8:8], RW_LB, default = 0x1
    //
    UINTX disable_retry_timer : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 7;
    //
    // 
    //         Sets the limit in DCLKs for minimum duration that certain Retry
    //         states should remain before transitioning out of that state.  
    //         
    // 
    // Bits[23:16], RW_LB, default = 0x20
    //
    UINTX min_delay_limit : 8;
    //
    // 
    //         Sets the limit in DCLKs for for certain Retry that check
    //         events that depend on the round trip channel delay. 
    //         
    // 
    // Bits[31:24], RW_LB, default = 0x40
    //
    UINTX min_rt_delay : 8;
  } Bits;
  UINTX Data;
} DDRT_RETRY_TIMER_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_RETRY_LINK_FAIL_MC2LM_REG                    0x00000A90
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //          If the number of Error FSM interations within a DCLK interval 
    //          defined by DDRT_RETRY_LINK_FAIL.window exceeds the value
    //          programmed in DDRT_RETRY_LINK_FAIL.threshold, then a Link
    //          Fail condition is triggered. If the threshold is programed to 0
    //          then the Link Fail condition is disabled. 
    //         
    // 
    // Bits[15:0], RW_LB, default = 0x0
    //
    UINTX threshold : 16;
    //
    // 
    //          If the number of Error FSM interations within a DCLK interval 
    //          defined by (2^DDRT_RETRY_LINK_FAIL.window) exceeds the value
    //          programmed in DDRT_RETRY_LINK_FAIL.threshold, then a Link
    //          Fail condition is triggered. If the threshold is programed to 0
    //          then the Link Fail condition is disabled. 
    //         
    // 
    // Bits[21:16], RW_LB, default = 0x20
    //
    UINTX window : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
  } Bits;
  UINTX Data;
} DDRT_RETRY_LINK_FAIL_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_RETRY_CTL_MC2LM_REG                          0x00000A94
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         A 0 to 1 transition in this fields force the Retry FSM out of Idle. 
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX trigger_retry : 1;
    //
    // 
    //         Set this bit to force the Retry FSM to keep injecting the Error Ack Command
    // until the Error  
    //         signal is de-asserted. If this bit is not set, then the FSM  will inject
    //  
    //         Err Ack once and go to Link Fail is the NGN Error pin from any populated
    // NGN slot is not de-asserted. 
    //         
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX reissue_err_ack : 1;
    //
    // 
    //         Set this bit to reset all error counts and timers related to DDRT Retry
    // FSM.  
    //         The count will remain at 0 as long as this bit is a 1
    //         
    // 
    // Bits[2:2], RW_LB, default = 0x0
    //
    UINTX reset_err_cnt : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //         Number of times Force Error command is issued unsuccessfully in each DDRT
    //         Retry flow iteration to trigger Link Fail condition. A value of 0 
    //         in this field disables the check. 
    //         
    // 
    // Bits[7:4], RW_LB, default = 0x6
    //
    UINTX inj_cnt_limit : 4;
    //
    // 
    //         When set to 1, DDRT retry timer should always count when DDRT queues are
    // empty 
    //         When set to 0, DDRT retry timer will count when the MC is in DDRT mode
    // irrespective of whether the DDRT queues are empty or not. This is a debug option
    //  
    //         
    // 
    // Bits[8:8], RW_LB, default = 0x1
    //
    UINTX queue_empty_chk : 1;
    //
    // 
    //            Default behavior is to unblock DDRT reads as soon as FNV_ERR is de-asserted
    // and 
    //            to not wait for writes to drain. If the CSR bit is set then Retry FSM
    // will 
    //            wait for writes to drain before going back to Idle. 
    //         
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX force_write_drain : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 22;
  } Bits;
  UINTX Data;
} DDRT_RETRY_CTL_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_RETRY_STATUS_MC2LM_REG                       0x00000A98
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         Number of DCLKs Retry FSM has been active. 
    //         
    // 
    // Bits[15:0], RO_V, default = 0x0
    //
    UINTX current_iterations_cnt : 16;
    //
    // 
    //         Current state of the Retry FSM 
    //         
    // 
    // Bits[19:16], RO_V, default = 0x0
    //
    UINTX current_retry_state : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[21:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 
    //         Previous state of the Retry FSM 
    //         
    // 
    // Bits[25:22], RO_V, default = 0x0
    //
    UINTX previous_retry_state : 4;
    //
    // 
    //         WatchDog timer expired 
    //         
    // 
    // Bits[26:26], RO_V, default = 0x0
    //
    UINTX watchdog_timer_expired : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //         Count of the number of times Force Error command is issued unsuccessfully
    // in each DDRT 
    //         Retry flow iteration. 
    //         
    // 
    // Bits[31:28], RO_V, default = 0x0
    //
    UINTX inj_cmd_cnt : 4;
  } Bits;
  UINTX Data;
} DDRT_RETRY_STATUS_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_INJ_ERID_ERR_MC2LM_REG                       0x00000A9C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         Enable ERID Error injection 
    //         Enables Continuous injection. If continuous bit is not set then the
    //         trigger will be set up for a single injection on a 0 to 1 transition
    //         in the inj_error field. To allow continuous injection, both inj_error
    //         and continuous bits should be set. 
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX inj_error : 1;
    //
    // 
    //         Enables Continuous injection. If continuous bit is not set then the
    //         trigger will be set up for a single injection on a 0 to 1 transition
    //         in the inj_error field. To allow continuous injection, both inj_error
    //         and continuous bits should be set. 
    //         
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX continuous : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //         This bit is set when the 
    //         
    // 
    // Bits[3:3], RW_LBV, default = 0x0
    //
    UINTX done : 1;
    //
    // 
    //         8 bit mask to inject error on the ERID. 
    //         
    // 
    // Bits[11:4], RW_LB, default = 0x0
    //
    UINTX mask : 8;
    //
    // 
    //         7 bit match to inject error on the ERID. 
    //         
    // 
    // Bits[18:12], RW_LB, default = 0x0
    //
    UINTX match : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //         7 bit vector to enable comparison on each the bits in the match field.
    //         
    // 
    // Bits[26:20], RW_LB, default = 0x0
    //
    UINTX enable_match : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
  } Bits;
  UINTX Data;
} DDRT_INJ_ERID_ERR_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_DIMM_INFO_DIMM0_MC2LM_REG                    0x00000AA0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         Base address of the indirectly mapped region, in multiples of 64GB, expressed
    // as a DIMM address 
    //         
    // 
    // Bits[11:0], RO_V, default = 0x0
    //
    UINTX base_address : 12;
    //
    // 
    //         Length of the indirectly mapped region, in multiples of 64GB
    //         
    // 
    // Bits[23:12], RO_V, default = 0x0
    //
    UINTX length : 12;
    //
    // 
    //         Base address specified in bits 11:0 is valid
    //         
    // 
    // Bits[24:24], RO_V, default = 0x0
    //
    UINTX base_addr_valid : 1;
    //
    // 
    //         Length specified in bits 23:12 is valid
    //         
    // 
    // Bits[25:25], RO_V, default = 0x0
    //
    UINTX length_valid : 1;
    //
    // 
    //         Reserved for future use
    //         
    // 
    // Bits[30:26], RO_V, default = 0x0
    //
    UINTX rsvd : 5;
    //
    // 
    //         0 - non-Intel DIMM
    //         1 - Intel DIMM
    //         
    // 
    // Bits[31:31], RO_V, default = 0x0
    //
    UINTX intel_dimm : 1;
  } Bits;
  UINTX Data;
} DDRT_DIMM_INFO_DIMM0_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_DIMM_INFO_DIMM1_MC2LM_REG                    0x00000AA4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         Base address of the indirectly mapped region, in multiples of 64GB, expressed
    // as a DIMM address 
    //         
    // 
    // Bits[11:0], RO_V, default = 0x0
    //
    UINTX base_address : 12;
    //
    // 
    //         Length of the indirectly mapped region, in multiples of 64GB
    //         
    // 
    // Bits[23:12], RO_V, default = 0x0
    //
    UINTX length : 12;
    //
    // 
    //         Base address specified in bits 11:0 is valid
    //         
    // 
    // Bits[24:24], RO_V, default = 0x0
    //
    UINTX base_addr_valid : 1;
    //
    // 
    //         Length specified in bits 23:12 is valid
    //         
    // 
    // Bits[25:25], RO_V, default = 0x0
    //
    UINTX length_valid : 1;
    //
    // 
    //         Reserved for future use
    //         
    // 
    // Bits[30:26], RO_V, default = 0x0
    //
    UINTX rsvd : 5;
    //
    // 
    //         0 - non-Intel DIMM
    //         1 - Intel DIMM
    //         
    // 
    // Bits[31:31], RO_V, default = 0x0
    //
    UINTX intel_dimm : 1;
  } Bits;
  UINTX Data;
} DDRT_DIMM_INFO_DIMM1_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_CLK_GATING_MC2LM_REG                         0x00000AA8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         Timer to keep clocks running afer MC issues a GNT for last outstanding
    // REQ. This should more than the DDRT round trip 
    //         delay. Program to 0 to disable the timer, that is, timer will never start
    // and will not have any impact on the clock gating.  
    //         Program to all 1s to keep the timer always running. 
    //         
    // 
    // Bits[9:0], RW_LB, default = 0x40
    //
    UINTX reqcnt_timer : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
    //
    // 
    //         This bit must be set to 1 to enable various debug features in
    //         the DDRT scheduler logic. This bit need not be set to 1 for normal
    //         functional operation. 
    //         
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX en_ddrt_dfd_clk : 1;
    //
    // 
    //         Disable clock gating for the DDRT major mode logic 
    //         
    // 
    // Bits[21:21], RW_LB, default = 0x0
    //
    UINTX dis_major_mode_clkgating : 1;
    //
    // 
    //         Disable clock gating for the DDRT safe logic 
    //         
    // 
    // Bits[22:22], RW_LB, default = 0x0
    //
    UINTX dis_safe_clkgating : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //         Disable clock gating for the DDRT Retry FSM 
    //         
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX dis_retry_clkgating : 1;
    //
    // 
    //         Disable clock gating for the DDRT WPQ
    //         
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX dis_wdb_clkgating : 1;
    //
    // 
    //         Disable clock gating for the DDRT WPQ
    //         
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX dis_wpq_clkgating : 1;
    //
    // 
    //         Disable clock gating for the DDRT WPQ FSM logic 
    //         
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX dis_wpq_fsm_clkgating : 1;
    //
    // 
    //         Disable clock gating used to store addresses for reverse address decode
    //  
    //         
    // 
    // Bits[28:28], RW_LB, default = 0x0
    //
    UINTX dis_revaddr_log_clkgating : 1;
    //
    // 
    //         Disable clock gating for in the DDRT RPQ block 
    //         
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX dis_rpq_clkgating : 1;
    //
    // 
    //         Disable clock gating for CPGC logic in the DDRT block 
    //         
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX dis_cpgc_clkgating : 1;
    //
    // 
    //         Disable clock gating in DDRTS block. 
    //         
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX dis_ddrts_clkgating : 1;
  } Bits;
  UINTX Data;
} DDRT_CLK_GATING_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_MISC_CTL_MC2LM_REG                           0x00000AAC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //            0: Reads and writes will always be full cacheline
    //            1: MemInvXto* reads will be directory-only reads, and DirUpd will be
    // directory-only writes. 
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX en_dir_only_upd : 1;
    //
    // 
    //            1: DDRT RPQ Reads will not be scheduled in DDR4 mode
    //            0: DDRT RPQ Reads will be scheduled in DDR4 mode. GNTs continue to
    // be blocked in DDR4 mode 
    //         This bit should be set for DDRT 2N mode. 
    //         
    // 
    // Bits[1:1], RW_LB, default = 0x1
    //
    UINTX dis_ddrt_opp_rd : 1;
    //
    // 
    //            1: DDRT Underfill Reads will not be scheduled in DDR4 mode
    //            0: DDRT Underfill Reads will be scheduled in DDR4 mode. GNTs continue
    // to be blocked in DDR4 mode 
    //         This bit should be set for DDRT 2N mod.
    //         
    // 
    // Bits[2:2], RW_LB, default = 0x1
    //
    UINTX dis_ddrt_opp_ufill_rd : 1;
    //
    // 
    //            When setting to 1, force additional 1 cycle latency in decoding logic
    // (same latency as 3 channel mode). 
    //         
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX ddrt_dec_force_lat : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 28;
  } Bits;
  UINTX Data;
} DDRT_MISC_CTL_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_VIRAL_CTL_MC2LM_REG                          0x00000AB0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Disable viral triggering for ERID correctable Parity error. Viral signalling is
    // Error signalling is disabled by default 
    // 
    // Bits[0:0], RWS, default = 0x1
    //
    UINTX dis_erid_par : 1;
    //
    // Disable viral triggering for ERID fatal parity error
    // 
    // Bits[1:1], RWS, default = 0x0
    //
    UINTX dis_erid_uc : 1;
    //
    // Disable viral triggering for interrupt overflow errors
    // 
    // Bits[2:2], RWS, default = 0x1
    //
    UINTX dis_pending_intr_error : 1;
    //
    // Disable viral triggering for ERID FIFO over flow or underflow error
    // 
    // Bits[3:3], RWS, default = 0x0
    //
    UINTX dis_erid_fifo_error : 1;
    //
    // Disable viral triggering when number of write credit returned exceeds number of
    // outstanding writes 
    // 
    // Bits[4:4], RWS, default = 0x0
    //
    UINTX dis_wr_fnv_credit_error : 1;
    //
    // Disable viral triggering when number of read credit returned exceeds number of
    // outstanding reads 
    // 
    // Bits[5:5], RWS, default = 0x0
    //
    UINTX dis_rd_fnv_credit_error : 1;
    //
    // Disable viral triggering when there is a mismatch is command scheduled at DDRT
    // and global scheduler 
    // 
    // Bits[6:6], RWS, default = 0x0
    //
    UINTX dis_ddrt_scheduler_mismatch : 1;
    //
    // Disable viral triggering when FNV Error pin is asserted
    // 
    // Bits[7:7], RWS, default = 0x1
    //
    UINTX dis_fnv_error : 1;
    //
    // Disable viral triggering when FNV Error error is detected
    // 
    // Bits[8:8], RWS, default = 0x0
    //
    UINTX dis_fnv_thermal_error : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
  } Bits;
  UINTX Data;
} DDRT_VIRAL_CTL_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_MCA_CTL_MC2LM_REG                            0x00000AB4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Disable MCA Bank logging for ERID correctable Parity error. Viral signalling is
    // Error signalling is disabled by default 
    // 
    // Bits[0:0], RWS, default = 0x1
    //
    UINTX dis_erid_par : 1;
    //
    // Disable MCA Bank logging for ERID fatal parity error
    // 
    // Bits[1:1], RWS, default = 0x0
    //
    UINTX dis_erid_uc : 1;
    //
    // Disable MCA Bank logging for interrupt overflow errors
    // 
    // Bits[2:2], RWS, default = 0x0
    //
    UINTX dis_pending_intr_error : 1;
    //
    // Disable MCA Bank logging for ERID FIFO over flow or underflow error
    // 
    // Bits[3:3], RWS, default = 0x0
    //
    UINTX dis_erid_fifo_error : 1;
    //
    // Disable MCA Bank logging when number of write credit returned exceeds number of
    // outstanding writes 
    // 
    // Bits[4:4], RWS, default = 0x0
    //
    UINTX dis_wr_fnv_credit_error : 1;
    //
    // Disable MCA Bank logging when number of read credit returned exceeds number of
    // outstanding reads 
    // 
    // Bits[5:5], RWS, default = 0x0
    //
    UINTX dis_rd_fnv_credit_error : 1;
    //
    // Disable MCA Bank logging when there is a mismatch is command scheduled at DDRT
    // and global scheduler 
    // 
    // Bits[6:6], RWS, default = 0x0
    //
    UINTX dis_ddrt_scheduler_mismatch : 1;
    //
    // Disable MCA Bank logging when FNV pin error is asserted
    // 
    // Bits[7:7], RWS, default = 0x0
    //
    UINTX dis_fnv_error : 1;
    //
    // Disable MCA Bank logging when FNV thermal error is asserted
    // 
    // Bits[8:8], RWS, default = 0x0
    //
    UINTX dis_fnv_thermal_error : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 15;
    //
    // Enable SMI for correctable ERID parity error
    // 
    // Bits[24:24], RWS, default = 0x0
    //
    UINTX en_smi_fnv_err : 1;
    //
    // Enable SMI for correctable ERID parity error
    // 
    // Bits[25:25], RWS, default = 0x0
    //
    UINTX en_smi_erid_par : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 6;
  } Bits;
  UINTX Data;
} DDRT_MCA_CTL_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_CLK_GATING2_MC2LM_REG                        0x00000AB8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         Timer to keep clocks running for DDRT ReadQ or DDRT WriteQ
    //         after the queues drain all transactions. 
    //         
    // 
    // Bits[11:0], RW_LB, default = 0x40
    //
    UINTX ddrtq_busy_timer : 12;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 20;
  } Bits;
  UINTX Data;
} DDRT_CLK_GATING2_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_ECC_MODE_MC2LM_REG                           0x00000ABC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         ECC mode bits to issue to FNV as part of the write command. It is the
    // responsibility of software to program these bits 
    //         correctly. Note that an encoding of 11111 is the default Flow A ECC mode.
    //  
    //         
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX em : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 27;
  } Bits;
  UINTX Data;
} DDRT_ECC_MODE_MC2LM_STRUCT;
#endif // ASM_INC

#define CPGC_ERID_LFSR_CTL_MC2LM_REG                      0x00000D00
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX reset0 : 1;
    //
    // N/A
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX load0 : 1;
    //
    // 1: Selects Pattern Buffer mode; 0: Selects LFSR mode 
    // 
    // Bits[2:2], RW_LB, default = 0x0
    //
    UINTX mode0 : 1;
    //
    // N/A
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX stop_on_err0 : 1;
    //
    // N/A
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX mask_err0 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // N/A
    // 
    // Bits[8:8], RW_LB, default = 0x0
    //
    UINTX reset1 : 1;
    //
    // N/A
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX load1 : 1;
    //
    // 1: Selects Pattern Buffer mode; 0: Selects LFSR mode 
    // 
    // Bits[10:10], RW_LB, default = 0x0
    //
    UINTX mode1 : 1;
    //
    // N/A
    // 
    // Bits[11:11], RW_LB, default = 0x0
    //
    UINTX stop_on_err1 : 1;
    //
    // N/A
    // 
    // Bits[12:12], RW_LB, default = 0x0
    //
    UINTX mask_err1 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // 
    //              save_lfsr_seedrate * ^(reload_lfsr_seedrate-1) defines the
    //              periodic cacheline interval that the current LFSR value
    //              REUT#_CH#_PAT_CL_MUX#_PB_STATUS is saved into the
    //              REUT#_CH#_PAT_CL_MUX#_PB register. 
    //                When the save_lfsr_seedrate and reload_lfsr_seedrate is reached
    // in the same cycle only the saving of the LFSR seed takes place. 
    //                Examples:
    //                0 = Disable - the REUT#_CH#_PAT_CL_MUX#_PB_STATUS is never saved
    // into the REUT#_CH#_PAT_CL_MUX#_PB register. 
    //                1 = The REUT#_CH#_PAT_CL_MUX#_PB_STATUS is saved into the REUT#_CH#_PAT_CL_MUX#_PB
    // register every 2^(Reload_LFSR_Seed_Rate-1) cachelines. 
    //                2 = The REUT#_CH#_PAT_CL_MUX#_PB_STATUS is saved into the REUT#_CH#_PAT_CL_MUX#_PB
    // register every other 2^(Reload_LFSR_Seed_Rate-1) cachelines. 
    //                3 = The REUT#_CH#_PAT_CL_MUX#_PB_STATUS is saved into the REUT#_CH#_PAT_CL_MUX#_PB
    // register every fourth 2^(Reload_LFSR_Seed_Rate-1) cachelines. 
    //         
    // 
    // Bits[21:16], RW_LB, default = 0x0
    //
    UINTX save_lfsr_seedrate : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // 
    //             2^(reload_lfsr_seedrate-1) defines the periodic cacheline
    //             interval that the current LFSR Seed is reloaded from
    //             REUT#_CH#_PAT_CL_MUX#_PB. 
    //             When the save_lfsr_seedrate and reload_lfsr_seedrate is reached in
    // the same cycle only the saving of the LFSR seed takes place. 
    //                Examples:
    //                0 = Disable - the REUT#_CH#_PAT_CL_MUX#_PB_STATUS is never reloaded
    // into the REUT#_CH#_PAT_CL_MUX#_PB register. 
    //                1 = The LFSR seed is reloaded every cacheline operation from REUT#_CH#_PAT_CL_MUX#_PB.
    //                2 = The LFSR seed is reloaded every other cacheline operation from
    // REUT#_CH#_PAT_CL_MUX#_PB 
    //                3 = The LFSR seed is reloaded every fourth cacheline operation
    // from REUT#_CH#_PAT_CL_MUX#_PB 
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX reload_lfsr_seedrate : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 4;
    //
    // 
    //         Enable ERID LFSR training 
    //         
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX enable_erid_lfsr_training : 1;
  } Bits;
  UINTX Data;
} CPGC_ERID_LFSR_CTL_MC2LM_STRUCT;
#endif // ASM_INC

#define CPGC_ERID_LFSR_INIT0_MC2LM_REG                    0x00000D04
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[23:0], RW_LB, default = 0x0
    //
    UINTX seed : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} CPGC_ERID_LFSR_INIT0_MC2LM_STRUCT;
#endif // ASM_INC

#define CPGC_ERID_LFSR_INIT1_MC2LM_REG                    0x00000D08
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[23:0], RW_LB, default = 0x0
    //
    UINTX seed : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} CPGC_ERID_LFSR_INIT1_MC2LM_STRUCT;
#endif // ASM_INC

#define CPGC_ERID_LFSR_WR_STATUS0_MC2LM_REG               0x00000D0C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[23:0], RW_LB, default = 0x0
    //
    UINTX current_code : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} CPGC_ERID_LFSR_WR_STATUS0_MC2LM_STRUCT;
#endif // ASM_INC

#define CPGC_ERID_LFSR_WR_STATUS1_MC2LM_REG               0x00000D10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[23:0], RW_LB, default = 0x0
    //
    UINTX current_code : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} CPGC_ERID_LFSR_WR_STATUS1_MC2LM_STRUCT;
#endif // ASM_INC

#define CPGC_ERID_LFSR_RD_STATUS0_MC2LM_REG               0x00000D14
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[23:0], RW_LB, default = 0x0
    //
    UINTX current_code : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} CPGC_ERID_LFSR_RD_STATUS0_MC2LM_STRUCT;
#endif // ASM_INC

#define CPGC_ERID_LFSR_RD_STATUS1_MC2LM_REG               0x00000D18
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[23:0], RW_LB, default = 0x0
    //
    UINTX current_code : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} CPGC_ERID_LFSR_RD_STATUS1_MC2LM_STRUCT;
#endif // ASM_INC

#define CPGC_ERID_LFSR_ERR_MC2LM_REG                      0x00000D1C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 8 bit mask for Error
    // 
    // Bits[7:0], RW_LB, default = 0x0
    //
    UINTX mask : 8;
    //
    // 8 bit status per ERID bit
    // 
    // Bits[15:8], RW_LB, default = 0x0
    //
    UINTX status : 8;
    //
    // count of errors
    // 
    // Bits[31:16], RW_LB, default = 0x0
    //
    UINTX count : 16;
  } Bits;
  UINTX Data;
} CPGC_ERID_LFSR_ERR_MC2LM_STRUCT;
#endif // ASM_INC

#define CPGC_DDRT_MISC_CTL_MC2LM_REG                      0x00000D20
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         Set this to 1 only when the DDRT schedulers need to handle multple 
    //         outstanding transactions 
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX multi_credit_on : 1;
    //
    // 
    //         If this bit is set during multi-credit mode, then the scheduler ignores
    // the value programmed cpgc_max_credit field. 
    //         No restriction to block grants until a certain threshold of reads are
    // scheduled is done. Reads and Grants are scheduled as they become available.  
    //  
    //         
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX disable_max_credit_check : 1;
    //
    // 
    //         If this bit is set during multi-credit mode, then the scheduler ignores
    // ERID returned from DDRIO and use internally generated ERID value to deallocate
    // from RPQ. 
    //         Should be set to 1 when ERID is expected to incorrect during CPGC training.
    //         
    // 
    // Bits[2:2], RW_LB, default = 0x0
    //
    UINTX enable_erid_return : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
    //
    // 
    //         Maximum number of read credits allowed to CPGC sequencer. This limit is
    // used to block reads if the scheduler  
    //         accumulates reads with pending GNTs            
    //         
    // 
    // Bits[17:10], RW_LB, default = 0x0
    //
    UINTX cpgc_max_credit : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 14;
  } Bits;
  UINTX Data;
} CPGC_DDRT_MISC_CTL_MC2LM_STRUCT;
#endif // ASM_INC

#define NGN_ERROR_MC2LM_REG                               0x00000D24
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         This bit reflects the current status of NGN Error from Slot 0  as seen
    // in the memory controller.  
    //         If the error pin is asserted, this field shows value 1. The logging in
    // this field is not affected by ignore_ngn_err0 bit.  
    //         If the error condition is still in effect, then hardware will re-assert
    // the bit after software clears it.  
    //         
    // 
    // Bits[0:0], RW_LBV, default = 0x0
    //
    UINTX current_ngn_err0 : 1;
    //
    // 
    //         Hardware will set this bit to a 1 when it observes that NGN Error from
    // Slot 0  has been active. 
    //         The logging in this field is not affected by ignore_ngn_err0 bit.   
    //         Once set, hardware will keep the bit set even if NGN Error from Slot 0
    //  is not active until the bit is cleared by software.  
    //         It is the responsibility of software to clear this bit. 
    //         If the error condition is still in effect, then hardware will re-assert
    // the bit after software clears it.  
    //         
    // 
    // Bits[1:1], RW_LBV, default = 0x0
    //
    UINTX observed_ngn_err0_assert : 1;
    //
    // 
    //         Set this bit to 1 to mask the NGN Error from Slot 0 in the iMC.
    //         NGN_ERROR.current_ngn_err0 will still report the current state of error
    // signal, but the NGN retry flow will not be  
    //         initiated even if the error indication asserts. 
    //         
    // 
    // Bits[2:2], RW_LB, default = 0x1
    //
    UINTX ignore_ngn_err0 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //         This bit reflects the current status of NGN Error from Slot 1  as seen
    // in the memory controller.  
    //         If the error pin is asserted, this field shows value 1. The logging in
    // this field is not affected by ignore_ngn_err1 bit.  
    //         If the error condition is still in effect, then hardware will re-assert
    // the bit after software clears it.  
    //         
    // 
    // Bits[4:4], RW_LBV, default = 0x0
    //
    UINTX current_ngn_err1 : 1;
    //
    // 
    //         Hardware will set this bit to a 1 when it observes that NGN Error from
    // Slot 1  has been active. 
    //         The logging in this field is not affected by ignore_ngn_err1 bit.   
    //         Once set, hardware will keep the bit set even if NGN Error from Slot 1
    //  is not active until the bit is cleared by software.  
    //         It is the responsibility of software to clear this bit. 
    //         If the error condition is still in effect, then hardware will re-assert
    // the bit after software clears it.  
    //         
    // 
    // Bits[5:5], RW_LBV, default = 0x0
    //
    UINTX observed_ngn_err1_assert : 1;
    //
    // 
    //         Set this bit to 1 to mask the NGN Error from Slot 1 in the iMC.
    //         NGN_ERROR.current_ngn_err1 will still report the current state of error
    // signal, but the NGN retry flow will not be  
    //         initiated even if the error indication asserts. 
    //         
    // 
    // Bits[6:6], RW_LB, default = 0x1
    //
    UINTX ignore_ngn_err1 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //         Set this bit to 1 to force the DDRT Retry FSM to ignore ECC errors.
    //         The correct behavior is to start  retry FSM on DDRT read data ECC errors.
    //  
    //         This bit should be set during CPGC mode where Read data uses training
    // patterns that do not have good ECC.  
    //         
    // 
    // Bits[8:8], RW_LB, default = 0x1
    //
    UINTX ignore_ddrt_ecc_error : 1;
    //
    // 
    //         Set this bit to 1 to force the DDRT Retry FSM to ignore ERID parity errors.
    //         The correct behavior is to start retry FSM on ERID parity errors. 
    //         This bit should be set during CPGC mode where ERID parity error is not
    // reliable. 
    //         
    // 
    // Bits[9:9], RW_LB, default = 0x1
    //
    UINTX ignore_erid_parity_error : 1;
    //
    // 
    //         Set this bit to 1 to force the DDRT Retry FSM to ignore the DDR4 command
    // parity errors.  
    //         The correct behavior is to set this bit to 1 only when there is no DDRT
    // populated in the channel.  
    //         If the channel has a DDRT DIMM then the bit should be programmed to 0.
    //  
    //         
    // 
    // Bits[10:10], RW_LB, default = 0x1
    //
    UINTX ignore_ddr4_error : 1;
    //
    // 
    //         Spare
    //         
    // 
    // Bits[15:11], RW_LB, default = 0x0
    //
    UINTX spare : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 16;
  } Bits;
  UINTX Data;
} NGN_ERROR_MC2LM_STRUCT;
#endif // ASM_INC

#define CPGC_DDRT_PATWDB_RDWR_PNTR_MC2LM_REG              0x00000D28
#ifndef ASM_INC
typedef union {
  struct {
    //
    // WDB_Read_Write_Pointer indicates what cacheline in the WDB that is being indexed
    // in the REUT_CH#_PAT_WDB_PROG#.WDB_Data 
    // registers for writing of the contents of the WDB (See WDB_Data for more details).
    // Programming sequence : write a value to
    // PAT_WDB_RD_WR_PNTR;write a value to
    // CPGC_PATWDB_WR0; write a value to
    // CPGC_PATWDB_WR1; at this point the 64-bit value
    // {CPGC_PATWDB_WR1, CPGC_PATWDB_WR0} will be
    // transfered to the chunk Rdwr_Subpntr of
    // WDB_entry rdwr_pntr. Rdwr_subpntr will be
    // auto_incremented after each transfer like this
    // and rdwr_pntr will be auto_incremented after all
    // 8 chunks of a cacheline have been updated.
    // 
    // Bits[5:0], RW_V, default = 0x0
    //
    UINTX rdwr_pntr : 6;
    //
    // WDB_Read_Write_Sub_Pointer indicates what portion of a cacheline(64-bits) in the
    // WDB that is being indexed in the 
    // REUT_CH#_PAT_WDB_READ.WDB_Data and REUT_CH#_PAT_WDB_WRITE.WDB_Data registers for
    // writing of the contents of the WDB. 
    // 
    // Bits[8:6], RW_V, default = 0x0
    //
    UINTX rdwr_subpntr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
  } Bits;
  UINTX Data;
} CPGC_DDRT_PATWDB_RDWR_PNTR_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_MM_FSM_STATE_MC2LM_REG                       0x00000D2C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current state of DDRT Major mode FSM
    // 
    // Bits[2:0], RO_V, default = 0x0
    //
    UINTX current_state : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Events that triggered exits from DDRT mode
    // 
    // Bits[10:4], RO_V, default = 0x0
    //
    UINTX ddrt_exit_events : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Events that triggered exits from DDR4 mode
    // 
    // Bits[18:12], RO_V, default = 0x0
    //
    UINTX ddr4_exit_events : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Curent state of DDRT WMM FSM
    // 
    // Bits[21:20], RO_V, default = 0x0
    //
    UINTX wmm_state : 2;
    //
    // Partial is starved
    // 
    // Bits[22:22], RO_V, default = 0x0
    //
    UINTX partial_is_starved : 1;
    //
    // Partial is starved
    // 
    // Bits[23:23], RO_V, default = 0x0
    //
    UINTX write_is_starved : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 8;
  } Bits;
  UINTX Data;
} DDRT_MM_FSM_STATE_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_RPQ_DUMP_REG_MC2LM_REG                       0x00000D30
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Arraycontents[31:0]. This register is GATED by the DDRT_RPQ_DUMP_CFG2.VALID. When
    // the VALID bit is 0, this register is forced to zero. 
    // 
    // Bits[31:0], RO_V, default = 0x0
    //
    UINTX arraycontent : 32;
  } Bits;
  UINTX Data;
} DDRT_RPQ_DUMP_REG_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_RPQ_DUMP_CFG0_MC2LM_REG                      0x00000D34
#ifndef ASM_INC
typedef union {
  struct {
    //
    // setting a bit to 1 makes the trigger component a don't care
    // 
    // Bits[15:0], RW, default = 0x0
    //
    UINTX trigmask : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[21:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // entry select override
    // 
    // Bits[27:22], RW, default = 0x0
    //
    UINTX ridoverride : 6;
    //
    // selects 32 bit portion of entry to dump to RPQ dump reg
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINTX subentryselect : 2;
    //
    // continuous dump to RPQ dump reg after trigger
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX cont : 1;
    //
    // clear trigger count
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX clear : 1;
  } Bits;
  UINTX Data;
} DDRT_RPQ_DUMP_CFG0_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_RPQ_DUMP_CFG1_MC2LM_REG                      0x00000D38
#ifndef ASM_INC
typedef union {
  struct {
    //
    // score board index match value
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINTX sbindx : 7;
    //
    // channel id match value
    // 
    // Bits[8:7], RW, default = 0x0
    //
    UINTX chanid : 2;
    //
    // htid match value
    // 
    // Bits[15:9], RW, default = 0x0
    //
    UINTX htid : 7;
    //
    // type match value 0
    // 
    // Bits[21:16], RW, default = 0x0
    //
    UINTX type0 : 6;
    //
    // type match value 1
    // 
    // Bits[27:22], RW, default = 0x0
    //
    UINTX type1 : 6;
    //
    // rank 2:0 match value
    // 
    // Bits[30:28], RW, default = 0x0
    //
    UINTX rank : 3;
    //
    // ag2 match value
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX ag2 : 1;
  } Bits;
  UINTX Data;
} DDRT_RPQ_DUMP_CFG1_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_RPQ_DUMP_CFG2_MC2LM_REG                      0x00000D3C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // number of triggers to count before dump to RPQ dump reg
    // 
    // Bits[29:0], RW, default = 0x0
    //
    UINTX trigcount : 30;
    //
    // trigger count hit and RPQ dump reg contents are valid
    // Locked by MC_ARRAY_DUMP_LCK bit in EPMCDDRT_DFX_LCK_CNTL uCR register. When locked,
    // the VALID bit is cleared and the RPQ dump is disabled. 
    // 
    // Bits[30:30], RW_LV, default = 0x0
    //
    UINTX valid : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} DDRT_RPQ_DUMP_CFG2_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_RPQ_DUMP_CFG3_MC2LM_REG                      0x00000D40
#ifndef ASM_INC
typedef union {
  struct {
    //
    // address match value lower
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX addr_lo : 32;
  } Bits;
  UINTX Data;
} DDRT_RPQ_DUMP_CFG3_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_RPQ_DUMP_CFG4_MC2LM_REG                      0x00000D44
#ifndef ASM_INC
typedef union {
  struct {
    //
    // address match mask lower
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX addr_mask_lo : 32;
  } Bits;
  UINTX Data;
} DDRT_RPQ_DUMP_CFG4_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_RPQ_DUMP_CFG5_MC2LM_REG                      0x00000D48
#ifndef ASM_INC
typedef union {
  struct {
    //
    // address match value upper
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX addr_hi : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // address match mask upper
    // 
    // Bits[12:8], RW, default = 0x0
    //
    UINTX addr_mask_hi : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // type match value 2
    // 
    // Bits[21:16], RW, default = 0x0
    //
    UINTX type2 : 6;
    //
    // type match value 3
    // 
    // Bits[27:22], RW, default = 0x0
    //
    UINTX type3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} DDRT_RPQ_DUMP_CFG5_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_WPQ_DUMP_REG_MC2LM_REG                       0x00000D50
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Arraycontents[31:0]. This register is GATED by the DDRT_WPQ_DUMP_CFG2.VALID. When
    // the VALID bit is 0, this register is forced to zero. 
    // 
    // Bits[31:0], RO_V, default = 0x0
    //
    UINTX arraycontent : 32;
  } Bits;
  UINTX Data;
} DDRT_WPQ_DUMP_REG_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_WPQ_DUMP_CFG0_MC2LM_REG                      0x00000D54
#ifndef ASM_INC
typedef union {
  struct {
    //
    // setting a bit to 1 makes the trigger component a don't care
    // 
    // Bits[15:0], RW, default = 0x0
    //
    UINTX trigmask : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[21:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // entry select override
    // 
    // Bits[26:22], RW, default = 0x0
    //
    UINTX widoverride : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // selects 32 bit portion of entry to dump to WPQ dump reg
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINTX subentryselect : 2;
    //
    // continuous dump to RPQ dump reg after trigger
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX cont : 1;
    //
    // clear trigger count
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX clear : 1;
  } Bits;
  UINTX Data;
} DDRT_WPQ_DUMP_CFG0_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_WPQ_DUMP_CFG1_MC2LM_REG                      0x00000D58
#ifndef ASM_INC
typedef union {
  struct {
    //
    // score board index match value
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINTX sbindx : 7;
    //
    // channel id match value
    // 
    // Bits[8:7], RW, default = 0x0
    //
    UINTX chanid : 2;
    //
    // htid match value
    // 
    // Bits[15:9], RW, default = 0x0
    //
    UINTX htid : 7;
    //
    // type match value 0
    // 
    // Bits[21:16], RW, default = 0x0
    //
    UINTX type0 : 6;
    //
    // type match value 1
    // 
    // Bits[27:22], RW, default = 0x0
    //
    UINTX type1 : 6;
    //
    // rank 2:0 match value
    // 
    // Bits[30:28], RW, default = 0x0
    //
    UINTX rank : 3;
    //
    // ag2 match value
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX ag2 : 1;
  } Bits;
  UINTX Data;
} DDRT_WPQ_DUMP_CFG1_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_WPQ_DUMP_CFG2_MC2LM_REG                      0x00000D5C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // number of triggers to count before dump to RPQ dump reg
    // 
    // Bits[29:0], RW, default = 0x0
    //
    UINTX trigcount : 30;
    //
    // trigger count hit and RPQ dump reg contents are valid
    // Locked by MC_ARRAY_DUMP_LCK bit in EPMCDDRT_DFX_LCK_CNTL uCR register. When locked,
    // the VALID bit is cleared and the RPQ dump is disabled. 
    // 
    // Bits[30:30], RW_LV, default = 0x0
    //
    UINTX valid : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} DDRT_WPQ_DUMP_CFG2_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_WPQ_DUMP_CFG3_MC2LM_REG                      0x00000D60
#ifndef ASM_INC
typedef union {
  struct {
    //
    // address match value lower
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX addr_lo : 32;
  } Bits;
  UINTX Data;
} DDRT_WPQ_DUMP_CFG3_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_WPQ_DUMP_CFG4_MC2LM_REG                      0x00000D64
#ifndef ASM_INC
typedef union {
  struct {
    //
    // address match mask lower
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX addr_mask_lo : 32;
  } Bits;
  UINTX Data;
} DDRT_WPQ_DUMP_CFG4_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_WPQ_DUMP_CFG5_MC2LM_REG                      0x00000D68
#ifndef ASM_INC
typedef union {
  struct {
    //
    // address match value upper
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINTX addr_hi : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // address match mask upper
    // 
    // Bits[12:8], RW, default = 0x0
    //
    UINTX addr_mask_hi : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // type match value 2
    // 
    // Bits[21:16], RW, default = 0x0
    //
    UINTX type2 : 6;
    //
    // type match value 3
    // 
    // Bits[27:22], RW, default = 0x0
    //
    UINTX type3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} DDRT_WPQ_DUMP_CFG5_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_CMD_CNT_MC2LM_REG                            0x00000D6C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // GNTs ready to issue 
    // 
    // Bits[5:0], RO_V, default = 0x0
    //
    UINTX num_gnt : 6;
    //
    // Writes
    // 
    // Bits[11:6], RO_V, default = 0x0
    //
    UINTX num_wr : 6;
    //
    // Reads
    // 
    // Bits[17:12], RO_V, default = 0x0
    //
    UINTX num_rd : 6;
    //
    // PWRs
    // 
    // Bits[23:18], RO_V, default = 0x0
    //
    UINTX num_pwr : 6;
    //
    // Set if there are no outstanding Reqs
    // 
    // Bits[24:24], RO_V, default = 0x0
    //
    UINTX reqcntiszero : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} DDRT_CMD_CNT_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_TRIG_CTL_MC2LM_REG                           0x00000D70
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         Trigger when Retry FSM enters this state. This does not trigger for entry
    // into IDLE state.  
    //         
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX retry_state1 : 4;
    //
    // 
    //         Trigger when Retry FSM enters this state. This does not trigger for entry
    // into IDLE state.  
    //         
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX retry_state2 : 4;
    //
    // 
    //         Trigger when ERID correctable parity error is detected. 
    //         
    // 
    // Bits[8:8], RW_LB, default = 0x0
    //
    UINTX erid_par_err : 1;
    //
    // 
    //         Trigger when ERID uncorrectable error condition occurs. 
    //         
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX erid_uc_err : 1;
    //
    // 
    //         Trigger when ERID uncorrectable error condition occurs. 
    //         
    // 
    // Bits[10:10], RW_LB, default = 0x0
    //
    UINTX expected_nodata : 1;
    //
    // 
    //         Trigger when ERID uncorrectable error condition occurs. 
    //         
    // 
    // Bits[11:11], RW_LB, default = 0x0
    //
    UINTX unexpected_nodata : 1;
    //
    // 
    //         Trigger when ERID uncorrectable error condition occurs. 
    //         
    // 
    // Bits[12:12], RW_LB, default = 0x0
    //
    UINTX thermal_event : 1;
    //
    // 
    //         Trigger when DDRT Retry FSM watchdog timer fires. 
    //         
    // 
    // Bits[13:13], RW_LB, default = 0x0
    //
    UINTX retry_watchdog_tmr : 1;
    //
    // 
    //         Trigger when FNV Error is asserted. The LSB of the field is for 
    //         Slot 0 and MSB of the field is for Slot 1
    //         
    // 
    // Bits[15:14], RW_LB, default = 0x0
    //
    UINTX fnv_err_assert : 2;
    //
    // 
    //         Trigger when FNV Error is de-asserted. The LSB of the field is for 
    //         Slot 0 and MSB of the field is for Slot 1
    //         
    // 
    // Bits[17:16], RW_LB, default = 0x0
    //
    UINTX fnv_err_deassert : 2;
    //
    // 
    //         7 bit mask for events that cause Major Mode FSM to exit DDR4 mode. 
    //         The mask corresponds to the following conditions that caused
    //         exit from DDR4 mode. 
    //         Bit 6 : Retry commnads need to issue 
    //         Bit 5 : ACK command 
    //         Bit 4 : Pending DDRT commands while DDR4 queue is empty 
    //         Bit 3 : Major mode duration threshold hit 
    //         Bit 2 : DDRT command starved 
    //         Bit 1 : DDRT ADR Event 
    //         Bit 0 : DDRT maintenence command 
    //         
    // 
    // Bits[24:18], RW_LB, default = 0x0
    //
    UINTX ddr4_exit_events : 7;
    //
    // 
    //         5 bit mask for events that cause Major Mode FSM to exit DDR4 mode. 
    //         The mask corresponds to the following conditions that caused
    //         exit from DDRT mode. 
    //         Bit 4 : DDR4 ADR command 
    //         Bit 3 : DDR4 maintenence command 
    //         Bit 2 : Pending DDR4 commands while DDRT queue is empty 
    //         Bit 1 : DDRT queue is empty after waiting for min. number of cycles in
    // DDRT mode 
    //         Bit 1 : Pending DDR4 commands after waiting for min. number of cycles
    // in DDRT mode 
    //         
    // 
    // Bits[29:25], RW_LB, default = 0x0
    //
    UINTX ddrt_exit_events : 5;
    //
    // 
    //         Spare 
    //         
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} DDRT_TRIG_CTL_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_RETRY_TIMER_STATUS_HI_MC2LM_REG              0x00000D74
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         Upper 32b of Retry FSM watchdog timer. 
    //         
    // 
    // Bits[31:0], RO_V, default = 0x0
    //
    UINTX cnt : 32;
  } Bits;
  UINTX Data;
} DDRT_RETRY_TIMER_STATUS_HI_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_RETRY_TIMER_STATUS_LO_MC2LM_REG              0x00000D78
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         Lower 32b of Retry FSM watchdog timer. 
    //         
    // 
    // Bits[31:0], RO_V, default = 0x0
    //
    UINTX cnt : 32;
  } Bits;
  UINTX Data;
} DDRT_RETRY_TIMER_STATUS_LO_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_GLBRSP_CTL_MC2LM_REG                         0x00000D7C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         Kick off the Retry FSM 
    //         
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX trigger_retry_fsm : 2;
    //
    // 
    //         Switch from DDRT to DDR4 major mode as soon as the minimum
    //         duration in DDRT mode is met. 
    //         
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX enter_ddr4_mm : 2;
    //
    // 
    //         Switch from DDR4 to DDRT major mode as soon as the minimum
    //         duration in DDR4 mode is met. 
    //         
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX enter_ddrt_mm : 2;
    //
    // 
    //         Start blocking commands from DDRT scheduler using the command
    //         mask programmed in cmd_mask field. Command will be blocked as
    //         long as the global response output trigger is asserted. This
    //         mask can also be used along with the end_cmd_block field. 
    //         
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX start_cmd_block : 2;
    //
    // 
    //         Clear blocking commands from DDRT scheduler using the command
    //         mask programmed in cmd_mask field. 
    //         
    // 
    // Bits[9:8], RW_LB, default = 0x0
    //
    UINTX end_cmd_block : 2;
    //
    // 
    //         Mask to control which DDRT commands should be blocked using
    //         start_cmd_block and end_cmd_block knobs.
    //         Bit 5 : Maintenence Cmd 
    //         Bit 4 : RPQ GNT 
    //         Bit 3 : RPQ Read 
    //         Bit 2 : WPQ GNT 
    //         Bit 1 : WPQ Read 
    //         Bit 0 : WPQ Write  
    //         
    // 
    // Bits[15:10], RW_LB, default = 0x0
    //
    UINTX cmd_mask : 6;
    //
    // 
    //         Block credit returns to M2M as long as the global response
    //         trigger is asserted
    //         
    // 
    // Bits[17:16], RW_LB, default = 0x0
    //
    UINTX block_m2m_crdt : 2;
    //
    // 
    //         Spare 
    //         
    // 
    // Bits[25:18], RW_LB, default = 0x0
    //
    UINTX spare : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
  } Bits;
  UINTX Data;
} DDRT_GLBRSP_CTL_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_ERR_LOG_1ST_MC2LM_REG                        0x00000D80
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         Kick off the Retry FSM 
    //         
    // 
    // Bits[14:0], RW_V, default = 0x0
    //
    UINTX error : 15;
    //
    // 
    //         Additional information about error 
    //         
    // 
    // Bits[30:15], RW_V, default = 0x0
    //
    UINTX info : 16;
    //
    // 
    //         Register contains valid information 
    //         
    // 
    // Bits[31:31], RW_V, default = 0x0
    //
    UINTX valid : 1;
  } Bits;
  UINTX Data;
} DDRT_ERR_LOG_1ST_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_ERR_LOG_NEXT_MC2LM_REG                       0x00000D84
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         Errors seen 
    //         
    // 
    // Bits[14:0], RW_V, default = 0x0
    //
    UINTX error : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
    //
    // 
    //         Register contains valid information 
    //         
    // 
    // Bits[31:31], RW_V, default = 0x0
    //
    UINTX valid : 1;
  } Bits;
  UINTX Data;
} DDRT_ERR_LOG_NEXT_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_ERR_LOG_CTL_MC2LM_REG                        0x00000D88
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         Mask Errors from being logged into the DDDRT Error log registers 
    //         
    // 
    // Bits[14:0], RW_LB, default = 0x0
    //
    UINTX mask : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 17;
  } Bits;
  UINTX Data;
} DDRT_ERR_LOG_CTL_MC2LM_STRUCT;
#endif // ASM_INC

#define DDRT_WR_STARVE_CTL_MC2LM_REG                      0x00000D8C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //          Timer to control write starvation window. 
    //          The threshold field is incremented every (2^timer) DCLK ticks
    //         
    // 
    // Bits[5:0], RW_LB, default = 0x12
    //
    UINTX timer : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 
    //            If not write is issued in a (threshold x 2^timer) window
    //            then DDRT WMM is forced. The scheduler will remain in DDRT
    //            WMM until num_writes number of writes are issued. 
    //         
    // 
    // Bits[23:8], RW_LB, default = 0x6
    //
    UINTX threshold : 16;
    //
    // 
    //            Number of writes to issue in WWM before exiting when WMM is
    //            entered as a result of this mechanism. 
    //         
    // 
    // Bits[27:24], RW_LB, default = 0x4
    //
    UINTX num_writes : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
  } Bits;
  UINTX Data;
} DDRT_WR_STARVE_CTL_MC2LM_STRUCT;
#endif // ASM_INC


#endif // _MC2LM_H_
