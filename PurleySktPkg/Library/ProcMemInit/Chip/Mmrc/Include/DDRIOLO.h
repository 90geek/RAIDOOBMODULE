/*++

Copyright (c) 2005-2015 Intel Corporation. All rights reserved
This software and associated documentation (if any) is furnished
under a license and may only be used or copied in accordance
with the terms of the license. Except as permitted by such
license, no part of this software or documentation may be
reproduced, stored in a retrieval system, or transmitted in any
form or by any means without the express written consent of
Intel Corporation.

Module Name:

    File name:    DDRIOLO.h
    Input File:   SKX_MRC_for CTE updt-2015ww15.3.xlsx

Abstract:

    THIS FILE IS AUTO-GENERATED BY THE MMRC TOOL. DO NOT CHANGE THIS CODE.

    If edits are needed in this file, they must be done via the MMRC tool.

    If there is additional project-specific data required by the MMRC, it
    can be placed in DDRIOLO.h, which is used for non-tool-generated
    data

    Includes register defines specific to a project.

--*/
#ifndef _DDRIOLO_H_
#define _DDRIOLO_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define VID_DDRIOLO_REG                                   0x00000000
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The value is assigned by PCI-SIG to Intel.
    // 
    // Bits[15:0], RO, default = 0x8086
    //
    UINTX vendor_identification_number : 16;
  } Bits;
  UINTX Data;
} VID_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DID_DDRIOLO_REG                                   0x00000002
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  
    // Start (h)	End (h)	Device
    // 0x203F		0x203F	
    // 0x2040		0x204B	MC
    // 0x204C		0x204F	M3KTI
    // 0x2054		0x2054	CHASADALL
    // 0x2055		0x2055	CHAUTILALL
    // 0x2056		0x2056	CHAUTILALL1
    // 0x2057		0x2057	CHAPMAALL
    // 0x2058		0x205B	KTI
    // 0x2066		0x2067	M2MEM
    // 0x2068		0x206F	MC DDRIO
    // 0x2078		0x207F	VCU
    // 0x2080		0x2087	PCU
    // 0x2088		0x2088	
    // 0x2089		0x2089	
    // 0x208A		0x208A	
    // 0x208B		0x208B	
    // 0x208C		0x208C	
    // 0x208D		0x208D	CHAUTIL
    // 0x208E		0x208E	CHASAD
    // 0x208F		0x208F	CMSCHA
    // 0x2090		0x209F	RSVD FOR PCU FUNCTION 3
    // 	
    // 
    // Bits[15:0], RO, default = 0x2068
    //
    UINTX device_identification_number : 16;
  } Bits;
  UINTX Data;
} DID_DDRIOLO_STRUCT;
#endif // ASM_INC

#define PCICMD_DDRIOLO_REG                                0x00000004
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Hardwired to 0 since these devices don't decode any IO BARs
    // 
    // Bits[0:0], RO, default = 0x0
    //
    UINTX io_space_enable : 1;
    //
    // Hardwired to 0 since these devices don't decode any memory BARs
    // 
    // Bits[1:1], RO, default = 0x0
    //
    UINTX memory_space_enable : 1;
    //
    // Hardwired to 0 since these devices don't generate any transactions
    // 
    // Bits[2:2], RO, default = 0x0
    //
    UINTX bus_master_enable : 1;
    //
    // Not applicable. Hardwired to 0.
    // 
    // Bits[3:3], RO, default = 0x0
    //
    UINTX special_cycle_enable : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[4:4], RO, default = 0x0
    //
    UINTX memory_write_and_invalidate_enable : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[5:5], RO, default = 0x0
    //
    UINTX vga_palette_snoop_enable : 1;
    //
    // This bit has no impact on error reporting from these devices
    // 
    // Bits[6:6], RO, default = 0x0
    //
    UINTX parity_error_response : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX idsel_stepping_wait_cycle_control : 1;
    //
    // This bit has no impact on error reporting from these devices
    // 
    // Bits[8:8], RO, default = 0x0
    //
    UINTX serr_enable : 1;
    //
    // Not applicable to PCI Express and is hardwired to 0
    // 
    // Bits[9:9], RO, default = 0x0
    //
    UINTX fast_back_to_back_enable : 1;
    //
    // N/A for these devices
    // 
    // Bits[10:10], RO, default = 0x0
    //
    UINTX intx_disable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
  } Bits;
  UINTX Data;
} PCICMD_DDRIOLO_STRUCT;
#endif // ASM_INC

#define PCISTS_DDRIOLO_REG                                0x00000006
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Reflects the state of the INTA# signal at the input of the enable/disable circuit.
    //  This bit is set by HW to 1 when the INTA# is asserted.  This bit is reset by
    // HW to 0 after the interrupt is cleared (independent of the state of the Interrupt
    // Disable bit in the 0.4.0.PCICMD register). 
    // Hardwired to 0 on the processor
    // 
    // Bits[3:3], RO, default = 0x0
    //
    UINTX intx_status : 1;
    //
    // This bit indicates the presence of a capabilities list structure. When set to
    // 1, indicates the register at 34h provides an offset into the function. 
    // 
    // Bits[4:4], RO, default = 0x0
    //
    UINTX capabilities_list : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[5:5], RO, default = 0x0
    //
    UINTX x66mhz_capable : 1;
    //
    // Reserved
    // 
    // Bits[6:6], RO, default = 0x0
    //
    UINTX reserved : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX fast_back_to_back : 1;
    //
    // Hardwired to 0
    // 
    // Bits[8:8], RO, default = 0x0
    //
    UINTX master_data_parity_error : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[10:9], RO, default = 0x0
    //
    UINTX devsel_timing : 2;
    //
    // Hardwired to 0
    // 
    // Bits[11:11], RO, default = 0x0
    //
    UINTX signaled_target_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[12:12], RO, default = 0x0
    //
    UINTX received_target_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[13:13], RO, default = 0x0
    //
    UINTX received_master_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[14:14], RO, default = 0x0
    //
    UINTX signaled_system_error : 1;
    //
    // This bit is set when the device receives a packet on the primary side with an
    // uncorrectable data error (including a packet with poison bit set) or an uncorrectable
    // address/control parity error. The setting of this bit is regardless of the Parity
    // Error Response bit (PERRE) in the PCICMD register. 
    // 
    // Bits[15:15], RO_V, default = 0x0
    //
    UINTX detected_parity_error : 1;
  } Bits;
  UINTX Data;
} PCISTS_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RID_DDRIOLO_REG                                   0x00000008
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reflects the Uncore Revision ID after reset.
    // Reflects the Compatibility Revision ID after BIOS writes 0x69 to any RID register
    // in the processor uncore. 
    //         
    // 
    // Bits[7:0], RO_V, default = 0x0
    //
    UINTX revision_id : 8;
  } Bits;
  UINTX Data;
} RID_DDRIOLO_STRUCT;
#endif // ASM_INC

#define CCR_DDRIOLO_REG                                   0x00000009
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[7:0], RO_V, default = 0x0
    //
    UINTX register_level_programming_interface : 8;
    //
    // The value changes dependent upon the dev/func accessed. A table of the values
    // can be found in the Class-code tab of the msgch spread-sheet  
    // 	  Most dev-func will return 8'h80 for this field except for the following dev-func0,func1,...
    // combinations. The following exceptions will return 8'h01. Please refer to /src/uncore/ncu/f_ccr_reg.vh
    // for the full lookingup table. 
    //           bus-0, dev-8 func-1 
    //           bus-3, dev-14 to 16, func-0
    //           bus-3, dev-18, func-0, 1, 4, 5
    //         
    // 
    // Bits[15:8], RO_V, default = 0x80
    //
    UINTX sub_class : 8;
    //
    // The value changes dependent upon the dev-func accessed. A table of the values
    // can be found in the Class-code tab of the msgch spread-sheet  
    // 	  Most bus-dev-func will return 8'h08 for this field except for the following
    // bus-dev-func0,func1,... combinations. The following exceptions will return 8'h11.
    // Please refer to /src/uncore/ncu/f_ccr_reg.vhfor the full lookingup table. 
    //           bus-0, dev-8 func-1 
    //           bus-3, dev-14 to 16, func-0
    //           bus-3, dev-18, func-0, 1, 4, 5
    //         
    // 
    // Bits[23:16], RO_V, default = 0x8
    //
    UINTX base_class : 8;
  } Bits;
  UINTX Data;
} CCR_DDRIOLO_STRUCT;
#endif // ASM_INC

#define CLSR_DDRIOLO_REG                                  0x0000000C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Size of Cacheline
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX cacheline_size : 8;
  } Bits;
  UINTX Data;
} CLSR_DDRIOLO_STRUCT;
#endif // ASM_INC

#define PLAT_DDRIOLO_REG                                  0x0000000D
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Not applicable to PCI-Express. Hardwired to 00h.
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX primary_latency_timer : 8;
  } Bits;
  UINTX Data;
} PLAT_DDRIOLO_STRUCT;
#endif // ASM_INC

#define HDR_DDRIOLO_REG                                   0x0000000E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Type 0 header
    // 
    // Bits[6:0], RO, default = 0x0
    //
    UINTX configuration_layout : 7;
    //
    // This bit defaults to 1b since all these devices are multi-function
    // 
    // Bits[7:7], RO, default = 0x1
    //
    UINTX multi_function_device : 1;
  } Bits;
  UINTX Data;
} HDR_DDRIOLO_STRUCT;
#endif // ASM_INC

#define BIST_DDRIOLO_REG                                  0x0000000F
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Not supported. Hardwired to 00h
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX bist_tests : 8;
  } Bits;
  UINTX Data;
} BIST_DDRIOLO_STRUCT;
#endif // ASM_INC

#define CAPPTR_DDRIOLO_REG                                0x00000034
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Points to the first capability structure for the device which is the PCIe capability.
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX capability_pointer : 8;
  } Bits;
  UINTX Data;
} CAPPTR_DDRIOLO_STRUCT;
#endif // ASM_INC

#define INTL_DDRIOLO_REG                                  0x0000003C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A for these devices
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX interrupt_line : 8;
  } Bits;
  UINTX Data;
} INTL_DDRIOLO_STRUCT;
#endif // ASM_INC

#define INTPIN_DDRIOLO_REG                                0x0000003D
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A since these devices do not generate any interrupt on their own
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX interrupt_pin : 8;
  } Bits;
  UINTX Data;
} INTPIN_DDRIOLO_STRUCT;
#endif // ASM_INC

#define MINGNT_DDRIOLO_REG                                0x0000003E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The device does not burst as a PCI compliant master.
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX mgv : 8;
  } Bits;
  UINTX Data;
} MINGNT_DDRIOLO_STRUCT;
#endif // ASM_INC

#define MAXLAT_DDRIOLO_REG                                0x0000003F
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The device has no specific requirements for how often it needs to access the PCI
    // bus. 
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX mlv : 8;
  } Bits;
  UINTX Data;
} MAXLAT_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK0_0_DDRIOLO_REG                     0x00000200
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS (0: 1/16 UI
    // offset,  
    //           1: 3/16 UI Offset, 2: 5/16 UI Offsets, 3: 7/16 UI Offsets, 4: 9/16 UI
    // Offsets, 5,6,7: 11/16 UI Offsets.) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK1_0_DDRIOLO_REG                     0x00000204
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK2_0_DDRIOLO_REG                     0x00000208
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK2_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK3_0_DDRIOLO_REG                     0x0000020C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK3_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK4_0_DDRIOLO_REG                     0x00000210
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK4_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK5_0_DDRIOLO_REG                     0x00000214
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // mux select for crossover from ClkPiRef to CkPi4RcvEn, used in xover2to2 mode
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK5_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK6_0_DDRIOLO_REG                     0x00000218
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK6_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK7_0_DDRIOLO_REG                     0x0000021C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK7_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK0_0_DDRIOLO_REG                     0x00000220
#ifndef ASM_INC
typedef union {
  struct {
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK1_0_DDRIOLO_REG                     0x00000224
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK2_0_DDRIOLO_REG                     0x00000228
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK2_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK3_0_DDRIOLO_REG                     0x0000022C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK3_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK4_0_DDRIOLO_REG                     0x00000230
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK4_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK5_0_DDRIOLO_REG                     0x00000234
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK5_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK6_0_DDRIOLO_REG                     0x00000238
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK6_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK7_0_DDRIOLO_REG                     0x0000023C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK7_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK0_0_DDRIOLO_REG                     0x00000240
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // select one of the four DQ Clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK1_0_DDRIOLO_REG                     0x00000244
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK2_0_DDRIOLO_REG                     0x00000248
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK2_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK3_0_DDRIOLO_REG                     0x0000024C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK3_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK4_0_DDRIOLO_REG                     0x00000250
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK4_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK5_0_DDRIOLO_REG                     0x00000254
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK5_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK6_0_DDRIOLO_REG                     0x00000258
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK6_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK7_0_DDRIOLO_REG                     0x0000025C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK7_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK0_0_DDRIOLO_REG                     0x00000260
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte. 0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK1_0_DDRIOLO_REG                     0x00000264
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK2_0_DDRIOLO_REG                     0x00000268
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK2_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK3_0_DDRIOLO_REG                     0x0000026C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK3_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK4_0_DDRIOLO_REG                     0x00000270
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK4_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK5_0_DDRIOLO_REG                     0x00000274
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK5_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK6_0_DDRIOLO_REG                     0x00000278
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK6_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK7_0_DDRIOLO_REG                     0x0000027C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK7_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK0_0_DDRIOLO_REG                     0x00000280
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // selects which skewed DQSP (to sample even bits) is used in the RX FIFO. For proper
    // operation, always pick latest DQSP 
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // selects which skewed DQSN (to sample odd bits) is used in the RX FIFO. For proper
    // operation, always pick latest DQSN 
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK1_0_DDRIOLO_REG                     0x00000284
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK2_0_DDRIOLO_REG                     0x00000288
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK2_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK3_0_DDRIOLO_REG                     0x0000028C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK3_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK4_0_DDRIOLO_REG                     0x00000290
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK4_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK5_0_DDRIOLO_REG                     0x00000294
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK5_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK6_0_DDRIOLO_REG                     0x00000298
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK6_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK7_0_DDRIOLO_REG                     0x0000029C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK7_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXXTALKN0_0_DDRIOLO_REG                           0x000002A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 0
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank0 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 1 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank1 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 2
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank2 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 3 
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank3 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 4
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank4 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 5
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank5 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 6
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank6 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 7
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank7 : 4;
  } Bits;
  UINTX Data;
} TXXTALKN0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN0_0_DDRIOLO_REG                        0x000002A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit Rx Vref Control
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX vrefperbit0 : 7;
    //
    // Rsvd
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX halflsben0 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[14:8], RW_L, default = 0x0
    //
    UINTX vrefperbit1 : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX halflsben1 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[22:16], RW_L, default = 0x0
    //
    UINTX vrefperbit2 : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX halflsben2 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[30:24], RW_L, default = 0x0
    //
    UINTX vrefperbit3 : 7;
    //
    // shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX halflsben3 : 1;
  } Bits;
  UINTX Data;
} RXVREFCTRLN0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATATRAINFEEDBACKN0_0_DDRIOLO_REG                 0x000002A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Training Feedback Storage
    // 
    //         DataTrainFeedback Description:
    //          Training Step    Bits    Nibble    Description
    //         --------------    ----    -------  --------------------------------------------------------------------------------------------------------------------------------------------------------
    //         Cross Over Cal     0      0        Tx Dqs Phase Detection
    //         Cross Over Cal     1      0        Tx Dq Phase Detection
    //         Cross Over Cal     2      0        Rec En Phase Detection
    //         RcvEn              8:0    0        Byte detection
    //         Rx Dq-Dqs          0      0        Pass/fail
    //         Wr Leveling        8:0    0        Byte detection
    // 
    //         Cross Over Cal     3      1        Tx Dqs Phase Detection
    //         Cross Over Cal     4      1        Tx Dq Phase Detection
    //         Cross Over Cal     5      1        Rec En Phase Detection
    //         RcvEn             17:9    1        Byte detection
    //         Rx Dq-Dqs          1      1        Pass/fail
    //         Wr Leveling       17:9    1        Byte detection
    //         
    // 
    // Bits[17:0], RW_L, default = 0x0
    //
    UINTX datatrainfeedback : 18;
    //
    // Spare
    // 
    // Bits[31:18], RW_L, default = 0x0
    //
    UINTX spare : 14;
  } Bits;
  UINTX Data;
} DATATRAINFEEDBACKN0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N0_0_DDRIOLO_REG                      0x000002CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Visa debug bus LCB for DATA fub
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    //  VssHi control bits
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------
    // 	 disoverflow        24     Disable overflow logic from BDW
    // 	 fast panic enable  25     Bypass 2 flops in panic path for faster panic response
    // 	 vsshivccd2by3cfgen 26     Forces the driver DAC to get supply from 2/3 vccd
    // 	 vsshivccd2by3cfg   27:29  Current trim setting for 2/3 vccd mode, 001 fast,
    // 011 typical, 111 slow silicon  
    // 	 ddrvssh2ndcompen   30     Enable second comparator (ZBB mode)
    // 	 comp high bwen     31     Improve comparator performance to support low digital
    // voltage range 
    // 	
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl1 : 8;
    //
    // DQ TxEq setting selection to achieve constant EQ
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX dqtxeqsel : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSP pad to the Vref nibble bus
    //         
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqspvrefpgen : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSN pad to the Vref nibble bus
    //         
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX dqsnvrefpgen : 1;
    //
    //  
    //          If set to 0 (default), Vref generators selected through RxVrefSel[3:0]
    // are always on. 
    //          If set to 1, Vref generators are switched off while in Self Refresh.
    //         
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX vrefpwrsave : 1;
    //
    // Per-bit Enable connection to share Vref Bus
    // 
    // Bits[16:13], RW_L, default = 0x8
    //
    UINTX vreftonblbus : 4;
    //
    // Per Bit Verf generator Enable
    // 
    // Bits[20:17], RW_L, default = 0xF
    //
    UINTX rxvrefsel : 4;
    //
    // RefPiClkDelay
    // 
    // Bits[26:21], RW_L, default = 0x0
    //
    UINTX refpiclkdelay : 6;
    //
    // FNV Slave Delay Line Bypass Enable
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX fnvcrsdlbypassen : 1;
    //
    // FNV DLL Bypass Enable 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX fnvcrdllbypassen : 1;
    //
    // FNV Visa Fub Enable - data fub used for VISA if asserted 
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX fnvcrvisaen : 1;
    //
    // Enable write crc mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX writecrcenable : 1;
    //
    // This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
  } Bits;
  UINTX Data;
} DATACONTROL4N0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK1SELN0_0_DDRIOLO_REG                        0x000002D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor1 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr1d0 : 3;
    //
    // xtalk aggressor1 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr1d1 : 3;
    //
    // xtalk aggressor1 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr1d2 : 3;
    //
    // xtalk aggressor1 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr1d3 : 3;
    //
    // xtalk aggressor1 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr1d4 : 3;
    //
    // xtalk aggressor1 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr1d5 : 3;
    //
    // xtalk aggressor1 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr1d6 : 3;
    //
    // xtalk aggressor1 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr1d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK1SELN0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA0N0_0_DDRIOLO_REG                         0x000002D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp DrvUp Comp Value can be overriden via message channel if periodical
    // retrain is disable  
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Data Rcomp DrvDown Comp Value
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // VT Comp Values
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Data TCO Comp Value.
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Data Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} COMPDATA0N0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA1N0_0_DDRIOLO_REG                         0x000002D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp OdtUp Comp Value 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Data Rcomp Odt-Down Comp Value
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[21:12], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[31:22], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} COMPDATA1N0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETTRAINN0_0_DDRIOLO_REG                   0x000002DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained RxRcvEn Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcvenoffset : 6;
    //
    // Offset added to Trained Rx DQS Value.
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX rxdqsoffset : 7;
    //
    // Offset added to Trained Tx DQ Value.
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX txdqoffset : 6;
    //
    // Ooffset added to Trained Tx DQS Value.
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX txdqsoffset : 6;
    //
    // 2s Compliment offset added to Trained Vref Value.  Positive number increases Vref,
    // and each step is Vdd/384. 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX vrefoffset : 7;
  } Bits;
  UINTX Data;
} DATAOFFSETTRAINN0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETCOMPN0_0_DDRIOLO_REG                    0x000002E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2s Compliment offset added to DQ Drv-Up Comp Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX dqdrvupcompoffset : 6;
    //
    // 2s Compliment offset added to DQ Drv-Down Comp Value.
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX dqdrvdowncompoffset : 6;
    //
    // 2s Compliment offset added to DQ Odt-Up Comp Value.
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX dqodtupcompoffset : 5;
    //
    // 2s Compliment offset added to DQ Odt-Down Value.
    // 
    // Bits[21:17], RW_L, default = 0x0
    //
    UINTX dqodtdowncompoffset : 5;
    //
    // 2s Compliment offset added to DQ Tco Comp Value.
    // 
    // Bits[26:22], RW_L, default = 0x0
    //
    UINTX dqtcocompoffset : 5;
    //
    // 2s Compliment offset added to DQ Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX dqslewratecompoffset : 5;
  } Bits;
  UINTX Data;
} DATAOFFSETCOMPN0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK0SELN0_0_DDRIOLO_REG                        0x000002E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor0 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr0d0 : 3;
    //
    // xtalk aggressor0 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr0d1 : 3;
    //
    // xtalk aggressor0 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr0d2 : 3;
    //
    // xtalk aggressor0 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr0d3 : 3;
    //
    // xtalk aggressor0 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr0d4 : 3;
    //
    // xtalk aggressor0 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr0d5 : 3;
    //
    // xtalk aggressor0 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr0d6 : 3;
    //
    // xtalk aggressor0 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr0d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK0SELN0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N0_0_DDRIOLO_REG                      0x000002E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables Read DqDqs Training Mode
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX rxtrainingmode : 1;
    //
    // Enables Write Leveling Training Mode
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wltrainingmode : 1;
    //
    // Enables Read Leveling Training Mode.
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX rltrainingmode : 1;
    //
    // Enables SenseAmp offset cancellation training mode.
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX senseamptrainingmode : 1;
    //
    // When set, forces DQ/DQS drive enable to active.  Used in power measurements and
    // IO loopback mode  
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Power-down Disable:  Forces register file read, overriding the rank power down
    // logic. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rfon : 1;
    //
    // Power-down Disable:  Forces RxDqs PI clocks on.
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX rxpion : 1;
    //
    // Power-down Disable:  Forces TxDq and TxDqs PI clocks on.
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txpion : 1;
    //
    // 
    //           Forces on master DLL and all PI enables ON, despite both channel in
    // SelfRefresh, etc. low power states. 
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX internalclockson : 1;
    //
    // SaOffsetTrainTxon
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // Power-down:  All write commands are ignored for this data-byte.  Used in single-channel
    // MCI mode. 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX txdisable : 1;
    //
    // Power-down:  All read commands are ignored for this data-byte.  Used in single-channel
    // MCI mode.  
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX rxdisable : 1;
    //
    // Sets the duration of the first transmitted DQ bit of the burst. 0=1UI, 1=2UI.
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX txlong : 1;
    //
    // Controls the RX DQS CTLE setting.  (Code, CTLE) = { (0x0, Off),  (0x1, Use DQ),
    //  (0x2, BandPass),  (0x3, RSVD) }  
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX rxdqsctle : 2;
    //
    // Sets the RX read pointer offset on a reset.  Used during loopback and BERT mode.
    //  WrPtrPh1/WrPtrPh2 is reset to RxRdPt 
    // r (Default is to reset both to 0).
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX rxreadpointer : 3;
    //
    // Controls which segements of the driver are enabled:  {0: All, 1: Only ODT}.
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX driversegmentenable : 1;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a read c 
    // ommand to Rank = ReadRFRank
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX readrfrd : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a write  
    // command to Rank = ReadRFRank
    // 
    // Bits[21:21], RW_LV, default = 0x0
    //
    UINTX readrfwr : 1;
    //
    // Specifies the rank that ReadRFRd or ReadRFWr will manually download the CR values
    // from 
    // 
    // Bits[24:22], RW_LV, default = 0x0
    //
    UINTX readrfrank : 3;
    //
    // ODT is forced-on.
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // ODT and Senseamp are forced-off.
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsampoff : 1;
    //
    // not used
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disableodtstatic : 1;
    //
    // force ODT to the transmitter on, regardless of state of DriveEnable
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX ddrcrforceodton : 1;
    //
    // spare
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
    //
    // Enables long preamble for DDR4 devices
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX longpreambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL0N0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N0_0_DDRIOLO_REG                      0x000002EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable phase shift based crosstalk cancellation.
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX xtalkpienable : 1;
    //
    // select if 0: capacitive coupling; or 1: inductive coupling; xtalk dominant
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX xtalkpisign : 1;
    //
    // delta phase shift in one aggressor is in effect
    // 
    // Bits[4:2], RW_L, default = 0x0
    //
    UINTX xtalkpidelta : 3;
    //
    // reserved
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX burstlength10 : 1;
    //
    // Enable DLL Weak Lock to save power during CKE power down: {0: Disabled, 1: Enable}
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // IOT mode 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX iolbmodeen : 1;
    //
    // Controls which slave DLL are disabled: {0: nibble0, 1: nibble1, 2: not used}
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX sdlldisable : 1;
    //
    // not used
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // Controls the Current and BW of the Receiver: {0: 0.34Idll, 1: 0.66Idll, 2: 0.88Idll,
    // 3: Idll, 4: 1.33Idll, 5: 1.66Idll 
    // , 6: 2.00Idll, 7: 2.33Idll}
    // 
    // Bits[12:10], RW_L, default = 0x0
    //
    UINTX rxbiasctl : 3;
    //
    // Controls ODT turn-on delay.   To turn on N tQCK before RcvEn, program to RcvEn[8:6]
    //  N + 4. 
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX odtdelay : 4;
    //
    // Controls the ODT ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7, 18
    // tQCK) 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX odtduration : 3;
    //
    // Controls Senseamp turn-on delay.   To turn on N tQCK before RcvEn, program to
    // RcvEn[8:6]  N + 4. 
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX senseampdelay : 4;
    //
    // Controls the SenseAmp ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7,
    // 18 tQCK) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX senseampduration : 3;
    //
    // Cycles after the burst, when the current pulse should turn on by enabling OdtEn
    // for 1 cycle 
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX burstendodtdelay : 3;
    //
    // low voltage mode (ddr3lv, ddr3u, ddr4, smi, etc.)
    //             00: ddr3
    //             01: ddr3lv_smi
    //             10: ddr3u
    //             11: ddr4
    //         
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
  } Bits;
  UINTX Data;
} DATACONTROL1N0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N0_0_DDRIOLO_REG                      0x000002F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables SenseAmp offset cancellation training mode
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX rxvocselqnnnh : 5;
    //
    // Force on the internal Vref and Rx bias circuit, regardless of any other power
    // downs 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX forcebiason : 1;
    //
    // Force on the RxAmp only (as opposed to OdtSampOn, which turns on both ODT and
    // the amplifier). 
    //         Use for overclocking support where we may not be able to hit the fast
    // exit latency  
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX forcerxon : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // legacy from BDX for DDR3/VMSE configs"  DDRCOMP_CR_DDRCRCOMPOVR CTTermination
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Imode Select, 0: Swing Boost Mode; 1: (not supported) Xtalk Cancellation Mode
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX imodecfg : 1;
    //
    // Enable Imode EQ per byte lane. 
    //           0: Imode completely off 
    //           1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX imodeenable : 1;
    //
    // Spare
    // 
    // Bits[14:11], RW_L, default = 0x0
    //
    UINTX spare : 4;
    //
    // tbd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasen : 1;
    //
    // Spare1
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Binary Imode Coefficient, sets Imode current strength.
    //           (used for either Xtalk cancellation or swing boost)
    //           Code   Imode Current (approx)
    //           ------------------
    //           0000        0
    //           0001        1
    //           0010        2
    //             *
    //             *
    //             *
    //           1111        3
    // 
    // Bits[21:18], RW_L, default = 0x0
    //
    UINTX imodeeqcode : 4;
    //
    // Imode Scomp Override Enable
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX imodescompovrd : 1;
    //
    // strobe Rx Amp offset control
    // 
    // Bits[27:23], RW_L, default = 0xF
    //
    UINTX rxdqssaoffset : 5;
    //
    // disable the offset control in DQ and DQS RxAmp
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX rxoffsetdisable : 1;
    //
    // VMSE Logic Delay
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vmselogicdelay : 1;
    //
    // Spare2
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xoverdlyadj : 1;
  } Bits;
  UINTX Data;
} DATACONTROL2N0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N0_0_DDRIOLO_REG                      0x000002F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // binary default setting for static legs in DRV mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX drvstaticlegcfg : 2;
    //
    // binary default setting for static legs in ODT mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX odtstaticlegcfg : 2;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // not use
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rxdqssadisableshort : 1;
    //
    // This will tell which  segments are enabled out of reset.  
    //                      After that, a shift register will determine the enabled segments
    // 
    // Bits[8:6], RW_L, default = 0x1
    //
    UINTX odtsegmentenable : 3;
    //
    // This will tell which  segments are enabled out of reset. 
    // 
    // Bits[11:9], RW_L, default = 0x1
    //
    UINTX datasegmentenable : 3;
    //
    // When set, it will extends ODT by 1 qclk on read to write turnarounds. hsd 230773
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX longodtr2w : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // imodebias control 
    // 
    // Bits[14:14], RW_L, default = 0x1
    //
    UINTX imodebiasvrefen : 1;
    //
    // imodebias control. Also used for rxbiasana 
    // 
    // Bits[17:15], RW_L, default = 0x1
    //
    UINTX imodebiasrxbiastrim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // imodebias control 
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX imodebiasdfxddr4legup : 1;
    //
    // imodebias control 
    // 
    // Bits[20:20], RW_L, default = 0x1
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // ctle capacitor setting 
    // 
    // Bits[22:21], RW_L, default = 0x0
    //
    UINTX ddrcrctlecapen : 2;
    //
    // ctle resistor setting 
    // 
    // Bits[24:23], RW_L, default = 0x3
    //
    UINTX ddrcrctleresen : 2;
    //
    // RxBias CR 
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX pcasbiasclosedloopen : 1;
    //
    // RxBias CR 
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // RxBias CR 
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX rxbiasfoldedlegtrim : 2;
    //
    // RxBias CR 
    // 
    // Bits[30:29], RW_L, default = 0x1
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Spare
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX postambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL3N0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN0_0_DDRIOLO_REG                0x000002F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description: 
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode			
    //         PanicVoltage	 21:18  Unsigned integer controlling the voltage error on
    // VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking 
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADCN0_0_DDRIOLO_REG                   0x000002FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADCN0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK0_0_DDRIOLO_REG                     0x00000300
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK1_0_DDRIOLO_REG                     0x00000304
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK2_0_DDRIOLO_REG                     0x00000308
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK2_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK3_0_DDRIOLO_REG                     0x0000030C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK3_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK4_0_DDRIOLO_REG                     0x00000310
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK4_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK5_0_DDRIOLO_REG                     0x00000314
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK5_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK6_0_DDRIOLO_REG                     0x00000318
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK6_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK7_0_DDRIOLO_REG                     0x0000031C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK7_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK0_0_DDRIOLO_REG                     0x00000320
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK1_0_DDRIOLO_REG                     0x00000324
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK2_0_DDRIOLO_REG                     0x00000328
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK2_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK3_0_DDRIOLO_REG                     0x0000032C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK3_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK4_0_DDRIOLO_REG                     0x00000330
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK4_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK5_0_DDRIOLO_REG                     0x00000334
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK5_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK6_0_DDRIOLO_REG                     0x00000338
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK6_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK7_0_DDRIOLO_REG                     0x0000033C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK7_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK0_0_DDRIOLO_REG                     0x00000340
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the four clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK1_0_DDRIOLO_REG                     0x00000344
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the four clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK2_0_DDRIOLO_REG                     0x00000348
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK2_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK3_0_DDRIOLO_REG                     0x0000034C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK3_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK4_0_DDRIOLO_REG                     0x00000350
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // select one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK4_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK5_0_DDRIOLO_REG                     0x00000354
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK5_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK6_0_DDRIOLO_REG                     0x00000358
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK6_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK7_0_DDRIOLO_REG                     0x0000035C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK7_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK0_0_DDRIOLO_REG                     0x00000360
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK1_0_DDRIOLO_REG                     0x00000364
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK2_0_DDRIOLO_REG                     0x00000368
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK2_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK3_0_DDRIOLO_REG                     0x0000036C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK3_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK4_0_DDRIOLO_REG                     0x00000370
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK4_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK5_0_DDRIOLO_REG                     0x00000374
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK5_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK6_0_DDRIOLO_REG                     0x00000378
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK6_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK7_0_DDRIOLO_REG                     0x0000037C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK7_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK0_0_DDRIOLO_REG                     0x00000380
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK0_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK1_0_DDRIOLO_REG                     0x00000384
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK2_0_DDRIOLO_REG                     0x00000388
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK2_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK3_0_DDRIOLO_REG                     0x0000038C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK3_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK4_0_DDRIOLO_REG                     0x00000390
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK4_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK5_0_DDRIOLO_REG                     0x00000394
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK5_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK6_0_DDRIOLO_REG                     0x00000398
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK6_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK7_0_DDRIOLO_REG                     0x0000039C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK7_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXXTALKN1_0_DDRIOLO_REG                           0x000003A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Coefficent for bit[0] of the DQ byte 
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank0 : 4;
    //
    // Coefficent for bit[1] of the DQ byte 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank1 : 4;
    //
    // Coefficent for bit[2] of the DQ byte
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank2 : 4;
    //
    // Coefficent for bit[3] of the DQ byte 
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank3 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 4
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank4 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 5
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank5 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 6
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank6 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 7
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank7 : 4;
  } Bits;
  UINTX Data;
} TXXTALKN1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN1_0_DDRIOLO_REG                        0x000003A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit Rx Vref Control
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX vrefperbit0 : 7;
    //
    // Rsvd
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX halflsben0 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[14:8], RW_L, default = 0x0
    //
    UINTX vrefperbit1 : 7;
    //
    // Rsvd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX halflsben1 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[22:16], RW_L, default = 0x0
    //
    UINTX vrefperbit2 : 7;
    //
    // Rsvd
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX halflsben2 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[30:24], RW_L, default = 0x0
    //
    UINTX vrefperbit3 : 7;
    //
    // shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX halflsben3 : 1;
  } Bits;
  UINTX Data;
} RXVREFCTRLN1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATATRAINFEEDBACKN1_0_DDRIOLO_REG                 0x000003A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Training Feedback Storage
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX datatrainfeedback : 9;
    //
    // Spare
    // 
    // Bits[31:9], RW_L, default = 0x0
    //
    UINTX spare : 23;
  } Bits;
  UINTX Data;
} DATATRAINFEEDBACKN1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N1_0_DDRIOLO_REG                      0x000003CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Visa debug bus LCB for DATA fub
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    //  VssHi control bits
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------
    // 	 disoverflow        24     Disable overflow logic from BDW
    // 	 fast panic enable  25     Bypass 2 flops in panic path for faster panic response
    // 	 vsshivccd2by3cfgen 26     Forces the driver DAC to get supply from 2/3 vccd
    // 	 vsshivccd2by3cfg   27:29  Current trim setting for 2/3 vccd mode, 001 fast,
    // 011 typical, 111 slow silicon  
    // 	 ddrvssh2ndcompen   30     Enable second comparator (ZBB mode)
    // 	 comp high bwen     31     Improve comparator performance to support low digital
    // voltage range 
    // 	
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl1 : 8;
    //
    // DQ TxEq setting selection to achieve constant EQ
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX dqtxeqsel : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSP pad to the Vref nibble bus
    //         
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqspvrefpgen : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSN pad to the Vref nibble bus
    //         
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX dqsnvrefpgen : 1;
    //
    //  
    //          If set to 0 (default), Vref generators selected through RxVrefSel[3:0]
    // are always on. 
    //          If set to 1, Vref generators are switched off while in Self Refresh.
    //         
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX vrefpwrsave : 1;
    //
    // Per-bit Enable connection to share Vref Bus
    // 
    // Bits[16:13], RW_L, default = 0x8
    //
    UINTX vreftonblbus : 4;
    //
    // Per Bit Verf generator Enable
    // 
    // Bits[20:17], RW_L, default = 0xF
    //
    UINTX rxvrefsel : 4;
    //
    // RefPiClkDelay
    // 
    // Bits[26:21], RW_L, default = 0x0
    //
    UINTX refpiclkdelay : 6;
    //
    // FNV Slave Delay Line Bypass Enable
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX fnvcrsdlbypassen : 1;
    //
    // FNV DLL Bypass Enable 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX fnvcrdllbypassen : 1;
    //
    // FNV Visa Fub Enable - data fub used for VISA if asserted 
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX fnvcrvisaen : 1;
    //
    // Enable write crc mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX writecrcenable : 1;
    //
    // This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
  } Bits;
  UINTX Data;
} DATACONTROL4N1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK1SELN1_0_DDRIOLO_REG                        0x000003D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor1 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr1d0 : 3;
    //
    // xtalk aggressor1 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr1d1 : 3;
    //
    // xtalk aggressor1 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr1d2 : 3;
    //
    // xtalk aggressor1 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr1d3 : 3;
    //
    // xtalk aggressor1 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr1d4 : 3;
    //
    // xtalk aggressor1 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr1d5 : 3;
    //
    // xtalk aggressor1 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr1d6 : 3;
    //
    // xtalk aggressor1 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr1d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK1SELN1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA0N1_0_DDRIOLO_REG                         0x000003D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp DrvUp Comp Value can be overriden via message channel if periodical
    // retrain is disable  
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Data Rcomp DrvDown Comp Value
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // VT Comp Values
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Data TCO Comp Value.
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Data Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} COMPDATA0N1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA1N1_0_DDRIOLO_REG                         0x000003D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp OdtUp Comp Value 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Data Rcomp Odt-Down Comp Value
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[21:12], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[31:22], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} COMPDATA1N1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETTRAINN1_0_DDRIOLO_REG                   0x000003DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained RxRcvEn Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcvenoffset : 6;
    //
    // Offset added to Trained Rx DQS Value.
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX rxdqsoffset : 7;
    //
    // Offset added to Trained Tx DQ Value.
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX txdqoffset : 6;
    //
    // Ooffset added to Trained Tx DQS Value.
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX txdqsoffset : 6;
    //
    // 2s Compliment offset added to Trained Vref Value.  Positive number increases Vref,
    // and each step is Vdd/384. 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX vrefoffset : 7;
  } Bits;
  UINTX Data;
} DATAOFFSETTRAINN1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETCOMPN1_0_DDRIOLO_REG                    0x000003E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2s Compliment offset added to DQ Drv-Up Comp Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX dqdrvupcompoffset : 6;
    //
    // 2s Compliment offset added to DQ Drv-Down Comp Value.
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX dqdrvdowncompoffset : 6;
    //
    // 2s Compliment offset added to DQ Odt-Up Comp Value.
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX dqodtupcompoffset : 5;
    //
    // 2s Compliment offset added to DQ Odt-Down Value.
    // 
    // Bits[21:17], RW_L, default = 0x0
    //
    UINTX dqodtdowncompoffset : 5;
    //
    // 2s Compliment offset added to DQ Tco Comp Value.
    // 
    // Bits[26:22], RW_L, default = 0x0
    //
    UINTX dqtcocompoffset : 5;
    //
    // 2s Compliment offset added to DQ Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX dqslewratecompoffset : 5;
  } Bits;
  UINTX Data;
} DATAOFFSETCOMPN1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK0SELN1_0_DDRIOLO_REG                        0x000003E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor0 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr0d0 : 3;
    //
    // xtalk aggressor0 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr0d1 : 3;
    //
    // xtalk aggressor0 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr0d2 : 3;
    //
    // xtalk aggressor0 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr0d3 : 3;
    //
    // xtalk aggressor0 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr0d4 : 3;
    //
    // xtalk aggressor0 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr0d5 : 3;
    //
    // xtalk aggressor0 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr0d6 : 3;
    //
    // xtalk aggressor0 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr0d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK0SELN1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N1_0_DDRIOLO_REG                      0x000003E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables Read DqDqs Training Mode
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX rxtrainingmode : 1;
    //
    // Enables Write Leveling Training Mode
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wltrainingmode : 1;
    //
    // Enables Read Leveling Training Mode.
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX rltrainingmode : 1;
    //
    // Enables SenseAmp offset cancellation training mode.
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX senseamptrainingmode : 1;
    //
    // When set, forces DQ/DQS drive enable to active.  Used in power measurements and
    // IO loopback mode  
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Power-down Disable:  Forces register file read, overriding the rank power down
    // logic. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rfon : 1;
    //
    // Power-down Disable:  Forces RxDqs PI clocks on.
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX rxpion : 1;
    //
    // Power-down Disable:  Forces TxDq and TxDqs PI clocks on.
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txpion : 1;
    //
    // 
    //           Forces on master DLL and all PI enables ON, despite both channel in
    // SelfRefresh, etc. low power states. 
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX internalclockson : 1;
    //
    // SaOffsetTrainTxon
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // Power-down:  All write commands are ignored for this data-byte.  Used in single-channel
    // MCI mode. 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX txdisable : 1;
    //
    // Power-down:  All read commands are ignored for this data-byte.  Used in single-channel
    // MCI mode.  
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX rxdisable : 1;
    //
    // Sets the duration of the first transmitted DQ bit of the burst. 0=1UI, 1=2UI.
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX txlong : 1;
    //
    // Controls the RX DQS CTLE setting.  (Code, CTLE) = { (0x0, Off),  (0x1, Use DQ),
    //  (0x2, BandPass),  (0x3, RSVD) }  
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX rxdqsctle : 2;
    //
    // Sets the RX read pointer offset on a reset.  Used during loopback and BERT mode.
    //  WrPtrPh1/WrPtrPh2 is reset to RxRdPt 
    // r (Default is to reset both to 0).
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX rxreadpointer : 3;
    //
    // Controls which segements of the driver are enabled:  {0: All, 1: Only ODT}.
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX driversegmentenable : 1;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a read c 
    // ommand to Rank = ReadRFRank
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX readrfrd : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a write  
    // command to Rank = ReadRFRank
    // 
    // Bits[21:21], RW_LV, default = 0x0
    //
    UINTX readrfwr : 1;
    //
    // Specifies the rank that ReadRFRd or ReadRFWr will manually download the CR values
    // from 
    // 
    // Bits[24:22], RW_LV, default = 0x0
    //
    UINTX readrfrank : 3;
    //
    // ODT is forced-on.
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // ODT and Senseamp are forced-off.
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsampoff : 1;
    //
    // not used
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disableodtstatic : 1;
    //
    // force ODT to the transmitter on, regardless of state of DriveEnable
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX ddrcrforceodton : 1;
    //
    // spare
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
    //
    // Enables long preamble for DDR4 devices
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX longpreambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL0N1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N1_0_DDRIOLO_REG                      0x000003EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable phase shift based crosstalk cancellation.
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX xtalkpienable : 1;
    //
    // select if 0: capacitive coupling; or 1: inductive coupling; xtalk dominant
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX xtalkpisign : 1;
    //
    // delta phase shift in one aggressor is in effect
    // 
    // Bits[4:2], RW_L, default = 0x0
    //
    UINTX xtalkpidelta : 3;
    //
    // reserved
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX burstlength10 : 1;
    //
    // Enable DLL Weak Lock to save power during CKE power down: {0: Disabled, 1: Enable}
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // IOT mode 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX iolbmodeen : 1;
    //
    // Controls which slave DLL are disabled: {0: nibble0, 1: nibble1, 2: not used}
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX sdlldisable : 1;
    //
    // not used
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // Controls the Current and BW of the Receiver: {0: 0.34Idll, 1: 0.66Idll, 2: 0.88Idll,
    // 3: Idll, 4: 1.33Idll, 5: 1.66Idll 
    // , 6: 2.00Idll, 7: 2.33Idll}
    // 
    // Bits[12:10], RW_L, default = 0x0
    //
    UINTX rxbiasctl : 3;
    //
    // Controls ODT turn-on delay.   To turn on N tQCK before RcvEn, program to RcvEn[8:6]
    //  N + 4. 
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX odtdelay : 4;
    //
    // Controls the ODT ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7, 18
    // tQCK) 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX odtduration : 3;
    //
    // Controls Senseamp turn-on delay.   To turn on N tQCK before RcvEn, program to
    // RcvEn[8:6]  N + 4. 
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX senseampdelay : 4;
    //
    // Controls the SenseAmp ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7,
    // 18 tQCK) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX senseampduration : 3;
    //
    // Cycles after the burst, when the current pulse should turn on by enabling OdtEn
    // for 1 cycle 
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX burstendodtdelay : 3;
    //
    // low voltage mode (ddr3lv, ddr3u, ddr4, smi, etc.)
    //             00: ddr3
    //             01: ddr3lv_smi
    //             10: ddr3u
    //             11: ddr4
    //         
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
  } Bits;
  UINTX Data;
} DATACONTROL1N1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N1_0_DDRIOLO_REG                      0x000003F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables SenseAmp offset cancellation training mode
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX rxvocselqnnnh : 5;
    //
    // Force on the internal Vref and Rx bias circuit, regardless of any other power
    // downs 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX forcebiason : 1;
    //
    // Force on the RxAmp only (as opposed to OdtSampOn, which turns on both ODT and
    // the amplifier). 
    //         Use for overclocking support where we may not be able to hit the fast
    // exit latency  
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX forcerxon : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // legacy from BDX for DDR3/VMSE configs"  DDRCOMP_CR_DDRCRCOMPOVR CTTermination
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Imode Select, 0: Swing Boost Mode; 1: (not supported) Xtalk Cancellation Mode
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX imodecfg : 1;
    //
    // Enable Imode EQ per byte lane. 
    //           0: Imode completely off 
    //           1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX imodeenable : 1;
    //
    // Spare
    // 
    // Bits[14:11], RW_L, default = 0x0
    //
    UINTX spare : 4;
    //
    // tbd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasen : 1;
    //
    // Spare1
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Binary Imode Coefficient, sets Imode current strength.
    //           (used for either Xtalk cancellation or swing boost)
    //           Code   Imode Current (approx)
    //           ------------------
    //           0000        0
    //           0001        1
    //           0010        2
    //             *
    //             *
    //             *
    //           1111        3
    // 
    // Bits[21:18], RW_L, default = 0x0
    //
    UINTX imodeeqcode : 4;
    //
    // Imode Scomp Override Enable
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX imodescompovrd : 1;
    //
    // strobe Rx Amp offset control
    // 
    // Bits[27:23], RW_L, default = 0xF
    //
    UINTX rxdqssaoffset : 5;
    //
    // disable the offset control in DQ and DQS RxAmp
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX rxoffsetdisable : 1;
    //
    // VMSE Logic Delay
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vmselogicdelay : 1;
    //
    // Spare2
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xoverdlyadj : 1;
  } Bits;
  UINTX Data;
} DATACONTROL2N1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N1_0_DDRIOLO_REG                      0x000003F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // binary default setting for static legs in DRV mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX drvstaticlegcfg : 2;
    //
    // binary default setting for static legs in ODT mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX odtstaticlegcfg : 2;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // not use
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rxdqssadisableshort : 1;
    //
    // This will tell which  segments are enabled out of reset.  
    //                      After that, a shift register will determine the enabled segments
    // 
    // Bits[8:6], RW_L, default = 0x1
    //
    UINTX odtsegmentenable : 3;
    //
    // This will tell which  segments are enabled out of reset. 
    // 
    // Bits[11:9], RW_L, default = 0x1
    //
    UINTX datasegmentenable : 3;
    //
    // When set, it will extends ODT by 1 qclk on read to write turnarounds. hsd 230773
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX longodtr2w : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // imodebias control 
    // 
    // Bits[14:14], RW_L, default = 0x1
    //
    UINTX imodebiasvrefen : 1;
    //
    // imodebias control. Also used for rxbiasana 
    // 
    // Bits[17:15], RW_L, default = 0x1
    //
    UINTX imodebiasrxbiastrim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // imodebias control 
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX imodebiasdfxddr4legup : 1;
    //
    // imodebias control 
    // 
    // Bits[20:20], RW_L, default = 0x1
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // ctle capacitor setting 
    // 
    // Bits[22:21], RW_L, default = 0x0
    //
    UINTX ddrcrctlecapen : 2;
    //
    // ctle resistor setting 
    // 
    // Bits[24:23], RW_L, default = 0x3
    //
    UINTX ddrcrctleresen : 2;
    //
    // RxBias CR 
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX pcasbiasclosedloopen : 1;
    //
    // RxBias CR 
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // RxBias CR 
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX rxbiasfoldedlegtrim : 2;
    //
    // RxBias CR 
    // 
    // Bits[30:29], RW_L, default = 0x1
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Spare
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX postambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL3N1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN1_0_DDRIOLO_REG                0x000003F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description: 
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode			
    //         PanicVoltage	 21:18  Unsigned integer controlling the voltage error on
    // VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking 
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADCN1_0_DDRIOLO_REG                   0x000003FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADCN1_0_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK0_1_DDRIOLO_REG                     0x00000400
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS (0: 1/16 UI
    // offset,  
    //           1: 3/16 UI Offset, 2: 5/16 UI Offsets, 3: 7/16 UI Offsets, 4: 9/16 UI
    // Offsets, 5,6,7: 11/16 UI Offsets.) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK1_1_DDRIOLO_REG                     0x00000404
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK2_1_DDRIOLO_REG                     0x00000408
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK2_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK3_1_DDRIOLO_REG                     0x0000040C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK3_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK4_1_DDRIOLO_REG                     0x00000410
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK4_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK5_1_DDRIOLO_REG                     0x00000414
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // mux select for crossover from ClkPiRef to CkPi4RcvEn, used in xover2to2 mode
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK5_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK6_1_DDRIOLO_REG                     0x00000418
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK6_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK7_1_DDRIOLO_REG                     0x0000041C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK7_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK0_1_DDRIOLO_REG                     0x00000420
#ifndef ASM_INC
typedef union {
  struct {
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK1_1_DDRIOLO_REG                     0x00000424
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK2_1_DDRIOLO_REG                     0x00000428
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK2_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK3_1_DDRIOLO_REG                     0x0000042C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK3_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK4_1_DDRIOLO_REG                     0x00000430
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK4_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK5_1_DDRIOLO_REG                     0x00000434
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK5_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK6_1_DDRIOLO_REG                     0x00000438
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK6_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK7_1_DDRIOLO_REG                     0x0000043C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK7_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK0_1_DDRIOLO_REG                     0x00000440
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // select one of the four DQ Clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK1_1_DDRIOLO_REG                     0x00000444
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK2_1_DDRIOLO_REG                     0x00000448
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK2_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK3_1_DDRIOLO_REG                     0x0000044C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK3_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK4_1_DDRIOLO_REG                     0x00000450
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK4_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK5_1_DDRIOLO_REG                     0x00000454
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK5_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK6_1_DDRIOLO_REG                     0x00000458
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK6_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK7_1_DDRIOLO_REG                     0x0000045C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK7_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK0_1_DDRIOLO_REG                     0x00000460
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte. 0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK1_1_DDRIOLO_REG                     0x00000464
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK2_1_DDRIOLO_REG                     0x00000468
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK2_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK3_1_DDRIOLO_REG                     0x0000046C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK3_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK4_1_DDRIOLO_REG                     0x00000470
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK4_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK5_1_DDRIOLO_REG                     0x00000474
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK5_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK6_1_DDRIOLO_REG                     0x00000478
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK6_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK7_1_DDRIOLO_REG                     0x0000047C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK7_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK0_1_DDRIOLO_REG                     0x00000480
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // selects which skewed DQSP (to sample even bits) is used in the RX FIFO. For proper
    // operation, always pick latest DQSP 
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // selects which skewed DQSN (to sample odd bits) is used in the RX FIFO. For proper
    // operation, always pick latest DQSN 
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK1_1_DDRIOLO_REG                     0x00000484
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK2_1_DDRIOLO_REG                     0x00000488
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK2_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK3_1_DDRIOLO_REG                     0x0000048C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK3_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK4_1_DDRIOLO_REG                     0x00000490
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK4_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK5_1_DDRIOLO_REG                     0x00000494
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK5_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK6_1_DDRIOLO_REG                     0x00000498
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK6_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK7_1_DDRIOLO_REG                     0x0000049C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK7_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXXTALKN0_1_DDRIOLO_REG                           0x000004A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 0
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank0 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 1 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank1 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 2
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank2 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 3 
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank3 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 4
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank4 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 5
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank5 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 6
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank6 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 7
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank7 : 4;
  } Bits;
  UINTX Data;
} TXXTALKN0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN0_1_DDRIOLO_REG                        0x000004A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit Rx Vref Control
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX vrefperbit0 : 7;
    //
    // Rsvd
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX halflsben0 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[14:8], RW_L, default = 0x0
    //
    UINTX vrefperbit1 : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX halflsben1 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[22:16], RW_L, default = 0x0
    //
    UINTX vrefperbit2 : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX halflsben2 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[30:24], RW_L, default = 0x0
    //
    UINTX vrefperbit3 : 7;
    //
    // shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX halflsben3 : 1;
  } Bits;
  UINTX Data;
} RXVREFCTRLN0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATATRAINFEEDBACKN0_1_DDRIOLO_REG                 0x000004A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Training Feedback Storage
    // 
    //         DataTrainFeedback Description:
    //          Training Step    Bits    Nibble    Description
    //         --------------    ----    -------  --------------------------------------------------------------------------------------------------------------------------------------------------------
    //         Cross Over Cal     0      0        Tx Dqs Phase Detection
    //         Cross Over Cal     1      0        Tx Dq Phase Detection
    //         Cross Over Cal     2      0        Rec En Phase Detection
    //         RcvEn              8:0    0        Byte detection
    //         Rx Dq-Dqs          0      0        Pass/fail
    //         Wr Leveling        8:0    0        Byte detection
    // 
    //         Cross Over Cal     3      1        Tx Dqs Phase Detection
    //         Cross Over Cal     4      1        Tx Dq Phase Detection
    //         Cross Over Cal     5      1        Rec En Phase Detection
    //         RcvEn             17:9    1        Byte detection
    //         Rx Dq-Dqs          1      1        Pass/fail
    //         Wr Leveling       17:9    1        Byte detection
    //         
    // 
    // Bits[17:0], RW_L, default = 0x0
    //
    UINTX datatrainfeedback : 18;
    //
    // Spare
    // 
    // Bits[31:18], RW_L, default = 0x0
    //
    UINTX spare : 14;
  } Bits;
  UINTX Data;
} DATATRAINFEEDBACKN0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N0_1_DDRIOLO_REG                      0x000004CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Visa debug bus LCB for DATA fub
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    //  VssHi control bits
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------
    // 	 disoverflow        24     Disable overflow logic from BDW
    // 	 fast panic enable  25     Bypass 2 flops in panic path for faster panic response
    // 	 vsshivccd2by3cfgen 26     Forces the driver DAC to get supply from 2/3 vccd
    // 	 vsshivccd2by3cfg   27:29  Current trim setting for 2/3 vccd mode, 001 fast,
    // 011 typical, 111 slow silicon  
    // 	 ddrvssh2ndcompen   30     Enable second comparator (ZBB mode)
    // 	 comp high bwen     31     Improve comparator performance to support low digital
    // voltage range 
    // 	
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl1 : 8;
    //
    // DQ TxEq setting selection to achieve constant EQ
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX dqtxeqsel : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSP pad to the Vref nibble bus
    //         
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqspvrefpgen : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSN pad to the Vref nibble bus
    //         
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX dqsnvrefpgen : 1;
    //
    //  
    //          If set to 0 (default), Vref generators selected through RxVrefSel[3:0]
    // are always on. 
    //          If set to 1, Vref generators are switched off while in Self Refresh.
    //         
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX vrefpwrsave : 1;
    //
    // Per-bit Enable connection to share Vref Bus
    // 
    // Bits[16:13], RW_L, default = 0x8
    //
    UINTX vreftonblbus : 4;
    //
    // Per Bit Verf generator Enable
    // 
    // Bits[20:17], RW_L, default = 0xF
    //
    UINTX rxvrefsel : 4;
    //
    // RefPiClkDelay
    // 
    // Bits[26:21], RW_L, default = 0x0
    //
    UINTX refpiclkdelay : 6;
    //
    // FNV Slave Delay Line Bypass Enable
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX fnvcrsdlbypassen : 1;
    //
    // FNV DLL Bypass Enable 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX fnvcrdllbypassen : 1;
    //
    // FNV Visa Fub Enable - data fub used for VISA if asserted 
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX fnvcrvisaen : 1;
    //
    // Enable write crc mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX writecrcenable : 1;
    //
    // This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
  } Bits;
  UINTX Data;
} DATACONTROL4N0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK1SELN0_1_DDRIOLO_REG                        0x000004D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor1 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr1d0 : 3;
    //
    // xtalk aggressor1 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr1d1 : 3;
    //
    // xtalk aggressor1 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr1d2 : 3;
    //
    // xtalk aggressor1 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr1d3 : 3;
    //
    // xtalk aggressor1 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr1d4 : 3;
    //
    // xtalk aggressor1 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr1d5 : 3;
    //
    // xtalk aggressor1 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr1d6 : 3;
    //
    // xtalk aggressor1 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr1d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK1SELN0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA0N0_1_DDRIOLO_REG                         0x000004D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp DrvUp Comp Value can be overriden via message channel if periodical
    // retrain is disable  
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Data Rcomp DrvDown Comp Value
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // VT Comp Values
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Data TCO Comp Value.
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Data Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} COMPDATA0N0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA1N0_1_DDRIOLO_REG                         0x000004D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp OdtUp Comp Value 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Data Rcomp Odt-Down Comp Value
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[21:12], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[31:22], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} COMPDATA1N0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETTRAINN0_1_DDRIOLO_REG                   0x000004DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained RxRcvEn Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcvenoffset : 6;
    //
    // Offset added to Trained Rx DQS Value.
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX rxdqsoffset : 7;
    //
    // Offset added to Trained Tx DQ Value.
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX txdqoffset : 6;
    //
    // Ooffset added to Trained Tx DQS Value.
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX txdqsoffset : 6;
    //
    // 2s Compliment offset added to Trained Vref Value.  Positive number increases Vref,
    // and each step is Vdd/384. 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX vrefoffset : 7;
  } Bits;
  UINTX Data;
} DATAOFFSETTRAINN0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETCOMPN0_1_DDRIOLO_REG                    0x000004E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2s Compliment offset added to DQ Drv-Up Comp Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX dqdrvupcompoffset : 6;
    //
    // 2s Compliment offset added to DQ Drv-Down Comp Value.
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX dqdrvdowncompoffset : 6;
    //
    // 2s Compliment offset added to DQ Odt-Up Comp Value.
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX dqodtupcompoffset : 5;
    //
    // 2s Compliment offset added to DQ Odt-Down Value.
    // 
    // Bits[21:17], RW_L, default = 0x0
    //
    UINTX dqodtdowncompoffset : 5;
    //
    // 2s Compliment offset added to DQ Tco Comp Value.
    // 
    // Bits[26:22], RW_L, default = 0x0
    //
    UINTX dqtcocompoffset : 5;
    //
    // 2s Compliment offset added to DQ Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX dqslewratecompoffset : 5;
  } Bits;
  UINTX Data;
} DATAOFFSETCOMPN0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK0SELN0_1_DDRIOLO_REG                        0x000004E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor0 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr0d0 : 3;
    //
    // xtalk aggressor0 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr0d1 : 3;
    //
    // xtalk aggressor0 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr0d2 : 3;
    //
    // xtalk aggressor0 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr0d3 : 3;
    //
    // xtalk aggressor0 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr0d4 : 3;
    //
    // xtalk aggressor0 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr0d5 : 3;
    //
    // xtalk aggressor0 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr0d6 : 3;
    //
    // xtalk aggressor0 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr0d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK0SELN0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N0_1_DDRIOLO_REG                      0x000004E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables Read DqDqs Training Mode
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX rxtrainingmode : 1;
    //
    // Enables Write Leveling Training Mode
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wltrainingmode : 1;
    //
    // Enables Read Leveling Training Mode.
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX rltrainingmode : 1;
    //
    // Enables SenseAmp offset cancellation training mode.
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX senseamptrainingmode : 1;
    //
    // When set, forces DQ/DQS drive enable to active.  Used in power measurements and
    // IO loopback mode  
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Power-down Disable:  Forces register file read, overriding the rank power down
    // logic. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rfon : 1;
    //
    // Power-down Disable:  Forces RxDqs PI clocks on.
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX rxpion : 1;
    //
    // Power-down Disable:  Forces TxDq and TxDqs PI clocks on.
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txpion : 1;
    //
    // 
    //           Forces on master DLL and all PI enables ON, despite both channel in
    // SelfRefresh, etc. low power states. 
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX internalclockson : 1;
    //
    // SaOffsetTrainTxon
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // Power-down:  All write commands are ignored for this data-byte.  Used in single-channel
    // MCI mode. 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX txdisable : 1;
    //
    // Power-down:  All read commands are ignored for this data-byte.  Used in single-channel
    // MCI mode.  
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX rxdisable : 1;
    //
    // Sets the duration of the first transmitted DQ bit of the burst. 0=1UI, 1=2UI.
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX txlong : 1;
    //
    // Controls the RX DQS CTLE setting.  (Code, CTLE) = { (0x0, Off),  (0x1, Use DQ),
    //  (0x2, BandPass),  (0x3, RSVD) }  
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX rxdqsctle : 2;
    //
    // Sets the RX read pointer offset on a reset.  Used during loopback and BERT mode.
    //  WrPtrPh1/WrPtrPh2 is reset to RxRdPt 
    // r (Default is to reset both to 0).
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX rxreadpointer : 3;
    //
    // Controls which segements of the driver are enabled:  {0: All, 1: Only ODT}.
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX driversegmentenable : 1;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a read c 
    // ommand to Rank = ReadRFRank
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX readrfrd : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a write  
    // command to Rank = ReadRFRank
    // 
    // Bits[21:21], RW_LV, default = 0x0
    //
    UINTX readrfwr : 1;
    //
    // Specifies the rank that ReadRFRd or ReadRFWr will manually download the CR values
    // from 
    // 
    // Bits[24:22], RW_LV, default = 0x0
    //
    UINTX readrfrank : 3;
    //
    // ODT is forced-on.
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // ODT and Senseamp are forced-off.
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsampoff : 1;
    //
    // not used
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disableodtstatic : 1;
    //
    // force ODT to the transmitter on, regardless of state of DriveEnable
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX ddrcrforceodton : 1;
    //
    // spare
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
    //
    // Enables long preamble for DDR4 devices
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX longpreambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL0N0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N0_1_DDRIOLO_REG                      0x000004EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable phase shift based crosstalk cancellation.
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX xtalkpienable : 1;
    //
    // select if 0: capacitive coupling; or 1: inductive coupling; xtalk dominant
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX xtalkpisign : 1;
    //
    // delta phase shift in one aggressor is in effect
    // 
    // Bits[4:2], RW_L, default = 0x0
    //
    UINTX xtalkpidelta : 3;
    //
    // reserved
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX burstlength10 : 1;
    //
    // Enable DLL Weak Lock to save power during CKE power down: {0: Disabled, 1: Enable}
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // IOT mode 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX iolbmodeen : 1;
    //
    // Controls which slave DLL are disabled: {0: nibble0, 1: nibble1, 2: not used}
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX sdlldisable : 1;
    //
    // not used
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // Controls the Current and BW of the Receiver: {0: 0.34Idll, 1: 0.66Idll, 2: 0.88Idll,
    // 3: Idll, 4: 1.33Idll, 5: 1.66Idll 
    // , 6: 2.00Idll, 7: 2.33Idll}
    // 
    // Bits[12:10], RW_L, default = 0x0
    //
    UINTX rxbiasctl : 3;
    //
    // Controls ODT turn-on delay.   To turn on N tQCK before RcvEn, program to RcvEn[8:6]
    //  N + 4. 
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX odtdelay : 4;
    //
    // Controls the ODT ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7, 18
    // tQCK) 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX odtduration : 3;
    //
    // Controls Senseamp turn-on delay.   To turn on N tQCK before RcvEn, program to
    // RcvEn[8:6]  N + 4. 
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX senseampdelay : 4;
    //
    // Controls the SenseAmp ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7,
    // 18 tQCK) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX senseampduration : 3;
    //
    // Cycles after the burst, when the current pulse should turn on by enabling OdtEn
    // for 1 cycle 
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX burstendodtdelay : 3;
    //
    // low voltage mode (ddr3lv, ddr3u, ddr4, smi, etc.)
    //             00: ddr3
    //             01: ddr3lv_smi
    //             10: ddr3u
    //             11: ddr4
    //         
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
  } Bits;
  UINTX Data;
} DATACONTROL1N0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N0_1_DDRIOLO_REG                      0x000004F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables SenseAmp offset cancellation training mode
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX rxvocselqnnnh : 5;
    //
    // Force on the internal Vref and Rx bias circuit, regardless of any other power
    // downs 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX forcebiason : 1;
    //
    // Force on the RxAmp only (as opposed to OdtSampOn, which turns on both ODT and
    // the amplifier). 
    //         Use for overclocking support where we may not be able to hit the fast
    // exit latency  
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX forcerxon : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // legacy from BDX for DDR3/VMSE configs"  DDRCOMP_CR_DDRCRCOMPOVR CTTermination
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Imode Select, 0: Swing Boost Mode; 1: (not supported) Xtalk Cancellation Mode
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX imodecfg : 1;
    //
    // Enable Imode EQ per byte lane. 
    //           0: Imode completely off 
    //           1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX imodeenable : 1;
    //
    // Spare
    // 
    // Bits[14:11], RW_L, default = 0x0
    //
    UINTX spare : 4;
    //
    // tbd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasen : 1;
    //
    // Spare1
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Binary Imode Coefficient, sets Imode current strength.
    //           (used for either Xtalk cancellation or swing boost)
    //           Code   Imode Current (approx)
    //           ------------------
    //           0000        0
    //           0001        1
    //           0010        2
    //             *
    //             *
    //             *
    //           1111        3
    // 
    // Bits[21:18], RW_L, default = 0x0
    //
    UINTX imodeeqcode : 4;
    //
    // Imode Scomp Override Enable
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX imodescompovrd : 1;
    //
    // strobe Rx Amp offset control
    // 
    // Bits[27:23], RW_L, default = 0xF
    //
    UINTX rxdqssaoffset : 5;
    //
    // disable the offset control in DQ and DQS RxAmp
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX rxoffsetdisable : 1;
    //
    // VMSE Logic Delay
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vmselogicdelay : 1;
    //
    // Spare2
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xoverdlyadj : 1;
  } Bits;
  UINTX Data;
} DATACONTROL2N0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N0_1_DDRIOLO_REG                      0x000004F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // binary default setting for static legs in DRV mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX drvstaticlegcfg : 2;
    //
    // binary default setting for static legs in ODT mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX odtstaticlegcfg : 2;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // not use
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rxdqssadisableshort : 1;
    //
    // This will tell which  segments are enabled out of reset.  
    //                      After that, a shift register will determine the enabled segments
    // 
    // Bits[8:6], RW_L, default = 0x1
    //
    UINTX odtsegmentenable : 3;
    //
    // This will tell which  segments are enabled out of reset. 
    // 
    // Bits[11:9], RW_L, default = 0x1
    //
    UINTX datasegmentenable : 3;
    //
    // When set, it will extends ODT by 1 qclk on read to write turnarounds. hsd 230773
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX longodtr2w : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // imodebias control 
    // 
    // Bits[14:14], RW_L, default = 0x1
    //
    UINTX imodebiasvrefen : 1;
    //
    // imodebias control. Also used for rxbiasana 
    // 
    // Bits[17:15], RW_L, default = 0x1
    //
    UINTX imodebiasrxbiastrim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // imodebias control 
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX imodebiasdfxddr4legup : 1;
    //
    // imodebias control 
    // 
    // Bits[20:20], RW_L, default = 0x1
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // ctle capacitor setting 
    // 
    // Bits[22:21], RW_L, default = 0x0
    //
    UINTX ddrcrctlecapen : 2;
    //
    // ctle resistor setting 
    // 
    // Bits[24:23], RW_L, default = 0x3
    //
    UINTX ddrcrctleresen : 2;
    //
    // RxBias CR 
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX pcasbiasclosedloopen : 1;
    //
    // RxBias CR 
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // RxBias CR 
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX rxbiasfoldedlegtrim : 2;
    //
    // RxBias CR 
    // 
    // Bits[30:29], RW_L, default = 0x1
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Spare
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX postambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL3N0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN0_1_DDRIOLO_REG                0x000004F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description: 
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode			
    //         PanicVoltage	 21:18  Unsigned integer controlling the voltage error on
    // VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking 
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADCN0_1_DDRIOLO_REG                   0x000004FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADCN0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK0_1_DDRIOLO_REG                     0x00000500
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK1_1_DDRIOLO_REG                     0x00000504
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK2_1_DDRIOLO_REG                     0x00000508
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK2_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK3_1_DDRIOLO_REG                     0x0000050C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK3_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK4_1_DDRIOLO_REG                     0x00000510
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK4_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK5_1_DDRIOLO_REG                     0x00000514
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK5_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK6_1_DDRIOLO_REG                     0x00000518
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK6_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK7_1_DDRIOLO_REG                     0x0000051C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK7_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK0_1_DDRIOLO_REG                     0x00000520
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK1_1_DDRIOLO_REG                     0x00000524
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK2_1_DDRIOLO_REG                     0x00000528
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK2_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK3_1_DDRIOLO_REG                     0x0000052C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK3_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK4_1_DDRIOLO_REG                     0x00000530
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK4_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK5_1_DDRIOLO_REG                     0x00000534
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK5_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK6_1_DDRIOLO_REG                     0x00000538
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK6_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK7_1_DDRIOLO_REG                     0x0000053C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK7_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK0_1_DDRIOLO_REG                     0x00000540
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the four clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK1_1_DDRIOLO_REG                     0x00000544
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the four clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK2_1_DDRIOLO_REG                     0x00000548
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK2_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK3_1_DDRIOLO_REG                     0x0000054C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK3_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK4_1_DDRIOLO_REG                     0x00000550
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // select one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK4_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK5_1_DDRIOLO_REG                     0x00000554
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK5_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK6_1_DDRIOLO_REG                     0x00000558
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK6_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK7_1_DDRIOLO_REG                     0x0000055C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK7_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK0_1_DDRIOLO_REG                     0x00000560
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK1_1_DDRIOLO_REG                     0x00000564
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK2_1_DDRIOLO_REG                     0x00000568
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK2_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK3_1_DDRIOLO_REG                     0x0000056C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK3_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK4_1_DDRIOLO_REG                     0x00000570
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK4_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK5_1_DDRIOLO_REG                     0x00000574
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK5_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK6_1_DDRIOLO_REG                     0x00000578
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK6_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK7_1_DDRIOLO_REG                     0x0000057C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK7_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK0_1_DDRIOLO_REG                     0x00000580
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK0_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK1_1_DDRIOLO_REG                     0x00000584
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK2_1_DDRIOLO_REG                     0x00000588
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK2_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK3_1_DDRIOLO_REG                     0x0000058C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK3_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK4_1_DDRIOLO_REG                     0x00000590
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK4_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK5_1_DDRIOLO_REG                     0x00000594
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK5_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK6_1_DDRIOLO_REG                     0x00000598
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK6_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK7_1_DDRIOLO_REG                     0x0000059C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK7_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXXTALKN1_1_DDRIOLO_REG                           0x000005A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Coefficent for bit[0] of the DQ byte 
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank0 : 4;
    //
    // Coefficent for bit[1] of the DQ byte 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank1 : 4;
    //
    // Coefficent for bit[2] of the DQ byte
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank2 : 4;
    //
    // Coefficent for bit[3] of the DQ byte 
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank3 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 4
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank4 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 5
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank5 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 6
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank6 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 7
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank7 : 4;
  } Bits;
  UINTX Data;
} TXXTALKN1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN1_1_DDRIOLO_REG                        0x000005A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit Rx Vref Control
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX vrefperbit0 : 7;
    //
    // Rsvd
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX halflsben0 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[14:8], RW_L, default = 0x0
    //
    UINTX vrefperbit1 : 7;
    //
    // Rsvd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX halflsben1 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[22:16], RW_L, default = 0x0
    //
    UINTX vrefperbit2 : 7;
    //
    // Rsvd
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX halflsben2 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[30:24], RW_L, default = 0x0
    //
    UINTX vrefperbit3 : 7;
    //
    // shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX halflsben3 : 1;
  } Bits;
  UINTX Data;
} RXVREFCTRLN1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATATRAINFEEDBACKN1_1_DDRIOLO_REG                 0x000005A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Training Feedback Storage
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX datatrainfeedback : 9;
    //
    // Spare
    // 
    // Bits[31:9], RW_L, default = 0x0
    //
    UINTX spare : 23;
  } Bits;
  UINTX Data;
} DATATRAINFEEDBACKN1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N1_1_DDRIOLO_REG                      0x000005CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Visa debug bus LCB for DATA fub
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    //  VssHi control bits
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------
    // 	 disoverflow        24     Disable overflow logic from BDW
    // 	 fast panic enable  25     Bypass 2 flops in panic path for faster panic response
    // 	 vsshivccd2by3cfgen 26     Forces the driver DAC to get supply from 2/3 vccd
    // 	 vsshivccd2by3cfg   27:29  Current trim setting for 2/3 vccd mode, 001 fast,
    // 011 typical, 111 slow silicon  
    // 	 ddrvssh2ndcompen   30     Enable second comparator (ZBB mode)
    // 	 comp high bwen     31     Improve comparator performance to support low digital
    // voltage range 
    // 	
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl1 : 8;
    //
    // DQ TxEq setting selection to achieve constant EQ
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX dqtxeqsel : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSP pad to the Vref nibble bus
    //         
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqspvrefpgen : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSN pad to the Vref nibble bus
    //         
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX dqsnvrefpgen : 1;
    //
    //  
    //          If set to 0 (default), Vref generators selected through RxVrefSel[3:0]
    // are always on. 
    //          If set to 1, Vref generators are switched off while in Self Refresh.
    //         
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX vrefpwrsave : 1;
    //
    // Per-bit Enable connection to share Vref Bus
    // 
    // Bits[16:13], RW_L, default = 0x8
    //
    UINTX vreftonblbus : 4;
    //
    // Per Bit Verf generator Enable
    // 
    // Bits[20:17], RW_L, default = 0xF
    //
    UINTX rxvrefsel : 4;
    //
    // RefPiClkDelay
    // 
    // Bits[26:21], RW_L, default = 0x0
    //
    UINTX refpiclkdelay : 6;
    //
    // FNV Slave Delay Line Bypass Enable
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX fnvcrsdlbypassen : 1;
    //
    // FNV DLL Bypass Enable 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX fnvcrdllbypassen : 1;
    //
    // FNV Visa Fub Enable - data fub used for VISA if asserted 
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX fnvcrvisaen : 1;
    //
    // Enable write crc mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX writecrcenable : 1;
    //
    // This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
  } Bits;
  UINTX Data;
} DATACONTROL4N1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK1SELN1_1_DDRIOLO_REG                        0x000005D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor1 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr1d0 : 3;
    //
    // xtalk aggressor1 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr1d1 : 3;
    //
    // xtalk aggressor1 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr1d2 : 3;
    //
    // xtalk aggressor1 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr1d3 : 3;
    //
    // xtalk aggressor1 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr1d4 : 3;
    //
    // xtalk aggressor1 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr1d5 : 3;
    //
    // xtalk aggressor1 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr1d6 : 3;
    //
    // xtalk aggressor1 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr1d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK1SELN1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA0N1_1_DDRIOLO_REG                         0x000005D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp DrvUp Comp Value can be overriden via message channel if periodical
    // retrain is disable  
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Data Rcomp DrvDown Comp Value
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // VT Comp Values
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Data TCO Comp Value.
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Data Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} COMPDATA0N1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA1N1_1_DDRIOLO_REG                         0x000005D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp OdtUp Comp Value 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Data Rcomp Odt-Down Comp Value
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[21:12], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[31:22], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} COMPDATA1N1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETTRAINN1_1_DDRIOLO_REG                   0x000005DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained RxRcvEn Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcvenoffset : 6;
    //
    // Offset added to Trained Rx DQS Value.
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX rxdqsoffset : 7;
    //
    // Offset added to Trained Tx DQ Value.
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX txdqoffset : 6;
    //
    // Ooffset added to Trained Tx DQS Value.
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX txdqsoffset : 6;
    //
    // 2s Compliment offset added to Trained Vref Value.  Positive number increases Vref,
    // and each step is Vdd/384. 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX vrefoffset : 7;
  } Bits;
  UINTX Data;
} DATAOFFSETTRAINN1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETCOMPN1_1_DDRIOLO_REG                    0x000005E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2s Compliment offset added to DQ Drv-Up Comp Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX dqdrvupcompoffset : 6;
    //
    // 2s Compliment offset added to DQ Drv-Down Comp Value.
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX dqdrvdowncompoffset : 6;
    //
    // 2s Compliment offset added to DQ Odt-Up Comp Value.
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX dqodtupcompoffset : 5;
    //
    // 2s Compliment offset added to DQ Odt-Down Value.
    // 
    // Bits[21:17], RW_L, default = 0x0
    //
    UINTX dqodtdowncompoffset : 5;
    //
    // 2s Compliment offset added to DQ Tco Comp Value.
    // 
    // Bits[26:22], RW_L, default = 0x0
    //
    UINTX dqtcocompoffset : 5;
    //
    // 2s Compliment offset added to DQ Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX dqslewratecompoffset : 5;
  } Bits;
  UINTX Data;
} DATAOFFSETCOMPN1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK0SELN1_1_DDRIOLO_REG                        0x000005E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor0 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr0d0 : 3;
    //
    // xtalk aggressor0 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr0d1 : 3;
    //
    // xtalk aggressor0 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr0d2 : 3;
    //
    // xtalk aggressor0 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr0d3 : 3;
    //
    // xtalk aggressor0 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr0d4 : 3;
    //
    // xtalk aggressor0 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr0d5 : 3;
    //
    // xtalk aggressor0 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr0d6 : 3;
    //
    // xtalk aggressor0 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr0d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK0SELN1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N1_1_DDRIOLO_REG                      0x000005E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables Read DqDqs Training Mode
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX rxtrainingmode : 1;
    //
    // Enables Write Leveling Training Mode
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wltrainingmode : 1;
    //
    // Enables Read Leveling Training Mode.
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX rltrainingmode : 1;
    //
    // Enables SenseAmp offset cancellation training mode.
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX senseamptrainingmode : 1;
    //
    // When set, forces DQ/DQS drive enable to active.  Used in power measurements and
    // IO loopback mode  
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Power-down Disable:  Forces register file read, overriding the rank power down
    // logic. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rfon : 1;
    //
    // Power-down Disable:  Forces RxDqs PI clocks on.
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX rxpion : 1;
    //
    // Power-down Disable:  Forces TxDq and TxDqs PI clocks on.
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txpion : 1;
    //
    // 
    //           Forces on master DLL and all PI enables ON, despite both channel in
    // SelfRefresh, etc. low power states. 
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX internalclockson : 1;
    //
    // SaOffsetTrainTxon
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // Power-down:  All write commands are ignored for this data-byte.  Used in single-channel
    // MCI mode. 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX txdisable : 1;
    //
    // Power-down:  All read commands are ignored for this data-byte.  Used in single-channel
    // MCI mode.  
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX rxdisable : 1;
    //
    // Sets the duration of the first transmitted DQ bit of the burst. 0=1UI, 1=2UI.
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX txlong : 1;
    //
    // Controls the RX DQS CTLE setting.  (Code, CTLE) = { (0x0, Off),  (0x1, Use DQ),
    //  (0x2, BandPass),  (0x3, RSVD) }  
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX rxdqsctle : 2;
    //
    // Sets the RX read pointer offset on a reset.  Used during loopback and BERT mode.
    //  WrPtrPh1/WrPtrPh2 is reset to RxRdPt 
    // r (Default is to reset both to 0).
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX rxreadpointer : 3;
    //
    // Controls which segements of the driver are enabled:  {0: All, 1: Only ODT}.
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX driversegmentenable : 1;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a read c 
    // ommand to Rank = ReadRFRank
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX readrfrd : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a write  
    // command to Rank = ReadRFRank
    // 
    // Bits[21:21], RW_LV, default = 0x0
    //
    UINTX readrfwr : 1;
    //
    // Specifies the rank that ReadRFRd or ReadRFWr will manually download the CR values
    // from 
    // 
    // Bits[24:22], RW_LV, default = 0x0
    //
    UINTX readrfrank : 3;
    //
    // ODT is forced-on.
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // ODT and Senseamp are forced-off.
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsampoff : 1;
    //
    // not used
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disableodtstatic : 1;
    //
    // force ODT to the transmitter on, regardless of state of DriveEnable
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX ddrcrforceodton : 1;
    //
    // spare
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
    //
    // Enables long preamble for DDR4 devices
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX longpreambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL0N1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N1_1_DDRIOLO_REG                      0x000005EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable phase shift based crosstalk cancellation.
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX xtalkpienable : 1;
    //
    // select if 0: capacitive coupling; or 1: inductive coupling; xtalk dominant
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX xtalkpisign : 1;
    //
    // delta phase shift in one aggressor is in effect
    // 
    // Bits[4:2], RW_L, default = 0x0
    //
    UINTX xtalkpidelta : 3;
    //
    // reserved
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX burstlength10 : 1;
    //
    // Enable DLL Weak Lock to save power during CKE power down: {0: Disabled, 1: Enable}
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // IOT mode 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX iolbmodeen : 1;
    //
    // Controls which slave DLL are disabled: {0: nibble0, 1: nibble1, 2: not used}
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX sdlldisable : 1;
    //
    // not used
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // Controls the Current and BW of the Receiver: {0: 0.34Idll, 1: 0.66Idll, 2: 0.88Idll,
    // 3: Idll, 4: 1.33Idll, 5: 1.66Idll 
    // , 6: 2.00Idll, 7: 2.33Idll}
    // 
    // Bits[12:10], RW_L, default = 0x0
    //
    UINTX rxbiasctl : 3;
    //
    // Controls ODT turn-on delay.   To turn on N tQCK before RcvEn, program to RcvEn[8:6]
    //  N + 4. 
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX odtdelay : 4;
    //
    // Controls the ODT ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7, 18
    // tQCK) 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX odtduration : 3;
    //
    // Controls Senseamp turn-on delay.   To turn on N tQCK before RcvEn, program to
    // RcvEn[8:6]  N + 4. 
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX senseampdelay : 4;
    //
    // Controls the SenseAmp ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7,
    // 18 tQCK) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX senseampduration : 3;
    //
    // Cycles after the burst, when the current pulse should turn on by enabling OdtEn
    // for 1 cycle 
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX burstendodtdelay : 3;
    //
    // low voltage mode (ddr3lv, ddr3u, ddr4, smi, etc.)
    //             00: ddr3
    //             01: ddr3lv_smi
    //             10: ddr3u
    //             11: ddr4
    //         
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
  } Bits;
  UINTX Data;
} DATACONTROL1N1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N1_1_DDRIOLO_REG                      0x000005F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables SenseAmp offset cancellation training mode
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX rxvocselqnnnh : 5;
    //
    // Force on the internal Vref and Rx bias circuit, regardless of any other power
    // downs 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX forcebiason : 1;
    //
    // Force on the RxAmp only (as opposed to OdtSampOn, which turns on both ODT and
    // the amplifier). 
    //         Use for overclocking support where we may not be able to hit the fast
    // exit latency  
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX forcerxon : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // legacy from BDX for DDR3/VMSE configs"  DDRCOMP_CR_DDRCRCOMPOVR CTTermination
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Imode Select, 0: Swing Boost Mode; 1: (not supported) Xtalk Cancellation Mode
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX imodecfg : 1;
    //
    // Enable Imode EQ per byte lane. 
    //           0: Imode completely off 
    //           1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX imodeenable : 1;
    //
    // Spare
    // 
    // Bits[14:11], RW_L, default = 0x0
    //
    UINTX spare : 4;
    //
    // tbd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasen : 1;
    //
    // Spare1
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Binary Imode Coefficient, sets Imode current strength.
    //           (used for either Xtalk cancellation or swing boost)
    //           Code   Imode Current (approx)
    //           ------------------
    //           0000        0
    //           0001        1
    //           0010        2
    //             *
    //             *
    //             *
    //           1111        3
    // 
    // Bits[21:18], RW_L, default = 0x0
    //
    UINTX imodeeqcode : 4;
    //
    // Imode Scomp Override Enable
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX imodescompovrd : 1;
    //
    // strobe Rx Amp offset control
    // 
    // Bits[27:23], RW_L, default = 0xF
    //
    UINTX rxdqssaoffset : 5;
    //
    // disable the offset control in DQ and DQS RxAmp
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX rxoffsetdisable : 1;
    //
    // VMSE Logic Delay
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vmselogicdelay : 1;
    //
    // Spare2
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xoverdlyadj : 1;
  } Bits;
  UINTX Data;
} DATACONTROL2N1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N1_1_DDRIOLO_REG                      0x000005F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // binary default setting for static legs in DRV mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX drvstaticlegcfg : 2;
    //
    // binary default setting for static legs in ODT mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX odtstaticlegcfg : 2;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // not use
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rxdqssadisableshort : 1;
    //
    // This will tell which  segments are enabled out of reset.  
    //                      After that, a shift register will determine the enabled segments
    // 
    // Bits[8:6], RW_L, default = 0x1
    //
    UINTX odtsegmentenable : 3;
    //
    // This will tell which  segments are enabled out of reset. 
    // 
    // Bits[11:9], RW_L, default = 0x1
    //
    UINTX datasegmentenable : 3;
    //
    // When set, it will extends ODT by 1 qclk on read to write turnarounds. hsd 230773
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX longodtr2w : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // imodebias control 
    // 
    // Bits[14:14], RW_L, default = 0x1
    //
    UINTX imodebiasvrefen : 1;
    //
    // imodebias control. Also used for rxbiasana 
    // 
    // Bits[17:15], RW_L, default = 0x1
    //
    UINTX imodebiasrxbiastrim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // imodebias control 
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX imodebiasdfxddr4legup : 1;
    //
    // imodebias control 
    // 
    // Bits[20:20], RW_L, default = 0x1
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // ctle capacitor setting 
    // 
    // Bits[22:21], RW_L, default = 0x0
    //
    UINTX ddrcrctlecapen : 2;
    //
    // ctle resistor setting 
    // 
    // Bits[24:23], RW_L, default = 0x3
    //
    UINTX ddrcrctleresen : 2;
    //
    // RxBias CR 
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX pcasbiasclosedloopen : 1;
    //
    // RxBias CR 
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // RxBias CR 
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX rxbiasfoldedlegtrim : 2;
    //
    // RxBias CR 
    // 
    // Bits[30:29], RW_L, default = 0x1
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Spare
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX postambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL3N1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN1_1_DDRIOLO_REG                0x000005F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description: 
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode			
    //         PanicVoltage	 21:18  Unsigned integer controlling the voltage error on
    // VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking 
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADCN1_1_DDRIOLO_REG                   0x000005FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADCN1_1_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK0_2_DDRIOLO_REG                     0x00000600
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS (0: 1/16 UI
    // offset,  
    //           1: 3/16 UI Offset, 2: 5/16 UI Offsets, 3: 7/16 UI Offsets, 4: 9/16 UI
    // Offsets, 5,6,7: 11/16 UI Offsets.) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK1_2_DDRIOLO_REG                     0x00000604
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK2_2_DDRIOLO_REG                     0x00000608
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK2_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK3_2_DDRIOLO_REG                     0x0000060C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK3_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK4_2_DDRIOLO_REG                     0x00000610
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK4_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK5_2_DDRIOLO_REG                     0x00000614
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // mux select for crossover from ClkPiRef to CkPi4RcvEn, used in xover2to2 mode
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK5_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK6_2_DDRIOLO_REG                     0x00000618
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK6_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK7_2_DDRIOLO_REG                     0x0000061C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK7_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK0_2_DDRIOLO_REG                     0x00000620
#ifndef ASM_INC
typedef union {
  struct {
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK1_2_DDRIOLO_REG                     0x00000624
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK2_2_DDRIOLO_REG                     0x00000628
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK2_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK3_2_DDRIOLO_REG                     0x0000062C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK3_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK4_2_DDRIOLO_REG                     0x00000630
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK4_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK5_2_DDRIOLO_REG                     0x00000634
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK5_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK6_2_DDRIOLO_REG                     0x00000638
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK6_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK7_2_DDRIOLO_REG                     0x0000063C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK7_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK0_2_DDRIOLO_REG                     0x00000640
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // select one of the four DQ Clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK1_2_DDRIOLO_REG                     0x00000644
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK2_2_DDRIOLO_REG                     0x00000648
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK2_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK3_2_DDRIOLO_REG                     0x0000064C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK3_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK4_2_DDRIOLO_REG                     0x00000650
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK4_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK5_2_DDRIOLO_REG                     0x00000654
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK5_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK6_2_DDRIOLO_REG                     0x00000658
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK6_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK7_2_DDRIOLO_REG                     0x0000065C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK7_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK0_2_DDRIOLO_REG                     0x00000660
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte. 0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK1_2_DDRIOLO_REG                     0x00000664
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK2_2_DDRIOLO_REG                     0x00000668
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK2_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK3_2_DDRIOLO_REG                     0x0000066C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK3_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK4_2_DDRIOLO_REG                     0x00000670
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK4_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK5_2_DDRIOLO_REG                     0x00000674
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK5_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK6_2_DDRIOLO_REG                     0x00000678
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK6_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK7_2_DDRIOLO_REG                     0x0000067C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK7_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK0_2_DDRIOLO_REG                     0x00000680
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // selects which skewed DQSP (to sample even bits) is used in the RX FIFO. For proper
    // operation, always pick latest DQSP 
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // selects which skewed DQSN (to sample odd bits) is used in the RX FIFO. For proper
    // operation, always pick latest DQSN 
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK1_2_DDRIOLO_REG                     0x00000684
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK2_2_DDRIOLO_REG                     0x00000688
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK2_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK3_2_DDRIOLO_REG                     0x0000068C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK3_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK4_2_DDRIOLO_REG                     0x00000690
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK4_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK5_2_DDRIOLO_REG                     0x00000694
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK5_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK6_2_DDRIOLO_REG                     0x00000698
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK6_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK7_2_DDRIOLO_REG                     0x0000069C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK7_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXXTALKN0_2_DDRIOLO_REG                           0x000006A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 0
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank0 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 1 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank1 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 2
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank2 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 3 
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank3 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 4
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank4 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 5
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank5 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 6
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank6 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 7
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank7 : 4;
  } Bits;
  UINTX Data;
} TXXTALKN0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN0_2_DDRIOLO_REG                        0x000006A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit Rx Vref Control
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX vrefperbit0 : 7;
    //
    // Rsvd
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX halflsben0 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[14:8], RW_L, default = 0x0
    //
    UINTX vrefperbit1 : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX halflsben1 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[22:16], RW_L, default = 0x0
    //
    UINTX vrefperbit2 : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX halflsben2 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[30:24], RW_L, default = 0x0
    //
    UINTX vrefperbit3 : 7;
    //
    // shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX halflsben3 : 1;
  } Bits;
  UINTX Data;
} RXVREFCTRLN0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATATRAINFEEDBACKN0_2_DDRIOLO_REG                 0x000006A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Training Feedback Storage
    // 
    //         DataTrainFeedback Description:
    //          Training Step    Bits    Nibble    Description
    //         --------------    ----    -------  --------------------------------------------------------------------------------------------------------------------------------------------------------
    //         Cross Over Cal     0      0        Tx Dqs Phase Detection
    //         Cross Over Cal     1      0        Tx Dq Phase Detection
    //         Cross Over Cal     2      0        Rec En Phase Detection
    //         RcvEn              8:0    0        Byte detection
    //         Rx Dq-Dqs          0      0        Pass/fail
    //         Wr Leveling        8:0    0        Byte detection
    // 
    //         Cross Over Cal     3      1        Tx Dqs Phase Detection
    //         Cross Over Cal     4      1        Tx Dq Phase Detection
    //         Cross Over Cal     5      1        Rec En Phase Detection
    //         RcvEn             17:9    1        Byte detection
    //         Rx Dq-Dqs          1      1        Pass/fail
    //         Wr Leveling       17:9    1        Byte detection
    //         
    // 
    // Bits[17:0], RW_L, default = 0x0
    //
    UINTX datatrainfeedback : 18;
    //
    // Spare
    // 
    // Bits[31:18], RW_L, default = 0x0
    //
    UINTX spare : 14;
  } Bits;
  UINTX Data;
} DATATRAINFEEDBACKN0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N0_2_DDRIOLO_REG                      0x000006CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Visa debug bus LCB for DATA fub
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    //  VssHi control bits
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------
    // 	 disoverflow        24     Disable overflow logic from BDW
    // 	 fast panic enable  25     Bypass 2 flops in panic path for faster panic response
    // 	 vsshivccd2by3cfgen 26     Forces the driver DAC to get supply from 2/3 vccd
    // 	 vsshivccd2by3cfg   27:29  Current trim setting for 2/3 vccd mode, 001 fast,
    // 011 typical, 111 slow silicon  
    // 	 ddrvssh2ndcompen   30     Enable second comparator (ZBB mode)
    // 	 comp high bwen     31     Improve comparator performance to support low digital
    // voltage range 
    // 	
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl1 : 8;
    //
    // DQ TxEq setting selection to achieve constant EQ
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX dqtxeqsel : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSP pad to the Vref nibble bus
    //         
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqspvrefpgen : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSN pad to the Vref nibble bus
    //         
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX dqsnvrefpgen : 1;
    //
    //  
    //          If set to 0 (default), Vref generators selected through RxVrefSel[3:0]
    // are always on. 
    //          If set to 1, Vref generators are switched off while in Self Refresh.
    //         
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX vrefpwrsave : 1;
    //
    // Per-bit Enable connection to share Vref Bus
    // 
    // Bits[16:13], RW_L, default = 0x8
    //
    UINTX vreftonblbus : 4;
    //
    // Per Bit Verf generator Enable
    // 
    // Bits[20:17], RW_L, default = 0xF
    //
    UINTX rxvrefsel : 4;
    //
    // RefPiClkDelay
    // 
    // Bits[26:21], RW_L, default = 0x0
    //
    UINTX refpiclkdelay : 6;
    //
    // FNV Slave Delay Line Bypass Enable
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX fnvcrsdlbypassen : 1;
    //
    // FNV DLL Bypass Enable 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX fnvcrdllbypassen : 1;
    //
    // FNV Visa Fub Enable - data fub used for VISA if asserted 
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX fnvcrvisaen : 1;
    //
    // Enable write crc mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX writecrcenable : 1;
    //
    // This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
  } Bits;
  UINTX Data;
} DATACONTROL4N0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK1SELN0_2_DDRIOLO_REG                        0x000006D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor1 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr1d0 : 3;
    //
    // xtalk aggressor1 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr1d1 : 3;
    //
    // xtalk aggressor1 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr1d2 : 3;
    //
    // xtalk aggressor1 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr1d3 : 3;
    //
    // xtalk aggressor1 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr1d4 : 3;
    //
    // xtalk aggressor1 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr1d5 : 3;
    //
    // xtalk aggressor1 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr1d6 : 3;
    //
    // xtalk aggressor1 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr1d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK1SELN0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA0N0_2_DDRIOLO_REG                         0x000006D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp DrvUp Comp Value can be overriden via message channel if periodical
    // retrain is disable  
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Data Rcomp DrvDown Comp Value
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // VT Comp Values
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Data TCO Comp Value.
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Data Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} COMPDATA0N0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA1N0_2_DDRIOLO_REG                         0x000006D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp OdtUp Comp Value 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Data Rcomp Odt-Down Comp Value
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[21:12], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[31:22], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} COMPDATA1N0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETTRAINN0_2_DDRIOLO_REG                   0x000006DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained RxRcvEn Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcvenoffset : 6;
    //
    // Offset added to Trained Rx DQS Value.
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX rxdqsoffset : 7;
    //
    // Offset added to Trained Tx DQ Value.
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX txdqoffset : 6;
    //
    // Ooffset added to Trained Tx DQS Value.
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX txdqsoffset : 6;
    //
    // 2s Compliment offset added to Trained Vref Value.  Positive number increases Vref,
    // and each step is Vdd/384. 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX vrefoffset : 7;
  } Bits;
  UINTX Data;
} DATAOFFSETTRAINN0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETCOMPN0_2_DDRIOLO_REG                    0x000006E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2s Compliment offset added to DQ Drv-Up Comp Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX dqdrvupcompoffset : 6;
    //
    // 2s Compliment offset added to DQ Drv-Down Comp Value.
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX dqdrvdowncompoffset : 6;
    //
    // 2s Compliment offset added to DQ Odt-Up Comp Value.
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX dqodtupcompoffset : 5;
    //
    // 2s Compliment offset added to DQ Odt-Down Value.
    // 
    // Bits[21:17], RW_L, default = 0x0
    //
    UINTX dqodtdowncompoffset : 5;
    //
    // 2s Compliment offset added to DQ Tco Comp Value.
    // 
    // Bits[26:22], RW_L, default = 0x0
    //
    UINTX dqtcocompoffset : 5;
    //
    // 2s Compliment offset added to DQ Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX dqslewratecompoffset : 5;
  } Bits;
  UINTX Data;
} DATAOFFSETCOMPN0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK0SELN0_2_DDRIOLO_REG                        0x000006E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor0 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr0d0 : 3;
    //
    // xtalk aggressor0 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr0d1 : 3;
    //
    // xtalk aggressor0 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr0d2 : 3;
    //
    // xtalk aggressor0 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr0d3 : 3;
    //
    // xtalk aggressor0 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr0d4 : 3;
    //
    // xtalk aggressor0 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr0d5 : 3;
    //
    // xtalk aggressor0 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr0d6 : 3;
    //
    // xtalk aggressor0 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr0d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK0SELN0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N0_2_DDRIOLO_REG                      0x000006E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables Read DqDqs Training Mode
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX rxtrainingmode : 1;
    //
    // Enables Write Leveling Training Mode
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wltrainingmode : 1;
    //
    // Enables Read Leveling Training Mode.
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX rltrainingmode : 1;
    //
    // Enables SenseAmp offset cancellation training mode.
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX senseamptrainingmode : 1;
    //
    // When set, forces DQ/DQS drive enable to active.  Used in power measurements and
    // IO loopback mode  
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Power-down Disable:  Forces register file read, overriding the rank power down
    // logic. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rfon : 1;
    //
    // Power-down Disable:  Forces RxDqs PI clocks on.
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX rxpion : 1;
    //
    // Power-down Disable:  Forces TxDq and TxDqs PI clocks on.
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txpion : 1;
    //
    // 
    //           Forces on master DLL and all PI enables ON, despite both channel in
    // SelfRefresh, etc. low power states. 
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX internalclockson : 1;
    //
    // SaOffsetTrainTxon
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // Power-down:  All write commands are ignored for this data-byte.  Used in single-channel
    // MCI mode. 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX txdisable : 1;
    //
    // Power-down:  All read commands are ignored for this data-byte.  Used in single-channel
    // MCI mode.  
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX rxdisable : 1;
    //
    // Sets the duration of the first transmitted DQ bit of the burst. 0=1UI, 1=2UI.
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX txlong : 1;
    //
    // Controls the RX DQS CTLE setting.  (Code, CTLE) = { (0x0, Off),  (0x1, Use DQ),
    //  (0x2, BandPass),  (0x3, RSVD) }  
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX rxdqsctle : 2;
    //
    // Sets the RX read pointer offset on a reset.  Used during loopback and BERT mode.
    //  WrPtrPh1/WrPtrPh2 is reset to RxRdPt 
    // r (Default is to reset both to 0).
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX rxreadpointer : 3;
    //
    // Controls which segements of the driver are enabled:  {0: All, 1: Only ODT}.
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX driversegmentenable : 1;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a read c 
    // ommand to Rank = ReadRFRank
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX readrfrd : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a write  
    // command to Rank = ReadRFRank
    // 
    // Bits[21:21], RW_LV, default = 0x0
    //
    UINTX readrfwr : 1;
    //
    // Specifies the rank that ReadRFRd or ReadRFWr will manually download the CR values
    // from 
    // 
    // Bits[24:22], RW_LV, default = 0x0
    //
    UINTX readrfrank : 3;
    //
    // ODT is forced-on.
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // ODT and Senseamp are forced-off.
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsampoff : 1;
    //
    // not used
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disableodtstatic : 1;
    //
    // force ODT to the transmitter on, regardless of state of DriveEnable
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX ddrcrforceodton : 1;
    //
    // spare
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
    //
    // Enables long preamble for DDR4 devices
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX longpreambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL0N0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N0_2_DDRIOLO_REG                      0x000006EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable phase shift based crosstalk cancellation.
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX xtalkpienable : 1;
    //
    // select if 0: capacitive coupling; or 1: inductive coupling; xtalk dominant
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX xtalkpisign : 1;
    //
    // delta phase shift in one aggressor is in effect
    // 
    // Bits[4:2], RW_L, default = 0x0
    //
    UINTX xtalkpidelta : 3;
    //
    // reserved
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX burstlength10 : 1;
    //
    // Enable DLL Weak Lock to save power during CKE power down: {0: Disabled, 1: Enable}
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // IOT mode 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX iolbmodeen : 1;
    //
    // Controls which slave DLL are disabled: {0: nibble0, 1: nibble1, 2: not used}
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX sdlldisable : 1;
    //
    // not used
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // Controls the Current and BW of the Receiver: {0: 0.34Idll, 1: 0.66Idll, 2: 0.88Idll,
    // 3: Idll, 4: 1.33Idll, 5: 1.66Idll 
    // , 6: 2.00Idll, 7: 2.33Idll}
    // 
    // Bits[12:10], RW_L, default = 0x0
    //
    UINTX rxbiasctl : 3;
    //
    // Controls ODT turn-on delay.   To turn on N tQCK before RcvEn, program to RcvEn[8:6]
    //  N + 4. 
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX odtdelay : 4;
    //
    // Controls the ODT ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7, 18
    // tQCK) 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX odtduration : 3;
    //
    // Controls Senseamp turn-on delay.   To turn on N tQCK before RcvEn, program to
    // RcvEn[8:6]  N + 4. 
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX senseampdelay : 4;
    //
    // Controls the SenseAmp ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7,
    // 18 tQCK) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX senseampduration : 3;
    //
    // Cycles after the burst, when the current pulse should turn on by enabling OdtEn
    // for 1 cycle 
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX burstendodtdelay : 3;
    //
    // low voltage mode (ddr3lv, ddr3u, ddr4, smi, etc.)
    //             00: ddr3
    //             01: ddr3lv_smi
    //             10: ddr3u
    //             11: ddr4
    //         
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
  } Bits;
  UINTX Data;
} DATACONTROL1N0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N0_2_DDRIOLO_REG                      0x000006F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables SenseAmp offset cancellation training mode
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX rxvocselqnnnh : 5;
    //
    // Force on the internal Vref and Rx bias circuit, regardless of any other power
    // downs 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX forcebiason : 1;
    //
    // Force on the RxAmp only (as opposed to OdtSampOn, which turns on both ODT and
    // the amplifier). 
    //         Use for overclocking support where we may not be able to hit the fast
    // exit latency  
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX forcerxon : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // legacy from BDX for DDR3/VMSE configs"  DDRCOMP_CR_DDRCRCOMPOVR CTTermination
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Imode Select, 0: Swing Boost Mode; 1: (not supported) Xtalk Cancellation Mode
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX imodecfg : 1;
    //
    // Enable Imode EQ per byte lane. 
    //           0: Imode completely off 
    //           1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX imodeenable : 1;
    //
    // Spare
    // 
    // Bits[14:11], RW_L, default = 0x0
    //
    UINTX spare : 4;
    //
    // tbd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasen : 1;
    //
    // Spare1
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Binary Imode Coefficient, sets Imode current strength.
    //           (used for either Xtalk cancellation or swing boost)
    //           Code   Imode Current (approx)
    //           ------------------
    //           0000        0
    //           0001        1
    //           0010        2
    //             *
    //             *
    //             *
    //           1111        3
    // 
    // Bits[21:18], RW_L, default = 0x0
    //
    UINTX imodeeqcode : 4;
    //
    // Imode Scomp Override Enable
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX imodescompovrd : 1;
    //
    // strobe Rx Amp offset control
    // 
    // Bits[27:23], RW_L, default = 0xF
    //
    UINTX rxdqssaoffset : 5;
    //
    // disable the offset control in DQ and DQS RxAmp
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX rxoffsetdisable : 1;
    //
    // VMSE Logic Delay
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vmselogicdelay : 1;
    //
    // Spare2
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xoverdlyadj : 1;
  } Bits;
  UINTX Data;
} DATACONTROL2N0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N0_2_DDRIOLO_REG                      0x000006F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // binary default setting for static legs in DRV mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX drvstaticlegcfg : 2;
    //
    // binary default setting for static legs in ODT mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX odtstaticlegcfg : 2;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // not use
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rxdqssadisableshort : 1;
    //
    // This will tell which  segments are enabled out of reset.  
    //                      After that, a shift register will determine the enabled segments
    // 
    // Bits[8:6], RW_L, default = 0x1
    //
    UINTX odtsegmentenable : 3;
    //
    // This will tell which  segments are enabled out of reset. 
    // 
    // Bits[11:9], RW_L, default = 0x1
    //
    UINTX datasegmentenable : 3;
    //
    // When set, it will extends ODT by 1 qclk on read to write turnarounds. hsd 230773
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX longodtr2w : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // imodebias control 
    // 
    // Bits[14:14], RW_L, default = 0x1
    //
    UINTX imodebiasvrefen : 1;
    //
    // imodebias control. Also used for rxbiasana 
    // 
    // Bits[17:15], RW_L, default = 0x1
    //
    UINTX imodebiasrxbiastrim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // imodebias control 
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX imodebiasdfxddr4legup : 1;
    //
    // imodebias control 
    // 
    // Bits[20:20], RW_L, default = 0x1
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // ctle capacitor setting 
    // 
    // Bits[22:21], RW_L, default = 0x0
    //
    UINTX ddrcrctlecapen : 2;
    //
    // ctle resistor setting 
    // 
    // Bits[24:23], RW_L, default = 0x3
    //
    UINTX ddrcrctleresen : 2;
    //
    // RxBias CR 
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX pcasbiasclosedloopen : 1;
    //
    // RxBias CR 
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // RxBias CR 
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX rxbiasfoldedlegtrim : 2;
    //
    // RxBias CR 
    // 
    // Bits[30:29], RW_L, default = 0x1
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Spare
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX postambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL3N0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN0_2_DDRIOLO_REG                0x000006F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description: 
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode			
    //         PanicVoltage	 21:18  Unsigned integer controlling the voltage error on
    // VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking 
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADCN0_2_DDRIOLO_REG                   0x000006FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADCN0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK0_2_DDRIOLO_REG                     0x00000700
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK1_2_DDRIOLO_REG                     0x00000704
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK2_2_DDRIOLO_REG                     0x00000708
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK2_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK3_2_DDRIOLO_REG                     0x0000070C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK3_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK4_2_DDRIOLO_REG                     0x00000710
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK4_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK5_2_DDRIOLO_REG                     0x00000714
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK5_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK6_2_DDRIOLO_REG                     0x00000718
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK6_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK7_2_DDRIOLO_REG                     0x0000071C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK7_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK0_2_DDRIOLO_REG                     0x00000720
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK1_2_DDRIOLO_REG                     0x00000724
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK2_2_DDRIOLO_REG                     0x00000728
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK2_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK3_2_DDRIOLO_REG                     0x0000072C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK3_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK4_2_DDRIOLO_REG                     0x00000730
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK4_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK5_2_DDRIOLO_REG                     0x00000734
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK5_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK6_2_DDRIOLO_REG                     0x00000738
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK6_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK7_2_DDRIOLO_REG                     0x0000073C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK7_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK0_2_DDRIOLO_REG                     0x00000740
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the four clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK1_2_DDRIOLO_REG                     0x00000744
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the four clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK2_2_DDRIOLO_REG                     0x00000748
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK2_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK3_2_DDRIOLO_REG                     0x0000074C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK3_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK4_2_DDRIOLO_REG                     0x00000750
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // select one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK4_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK5_2_DDRIOLO_REG                     0x00000754
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK5_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK6_2_DDRIOLO_REG                     0x00000758
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK6_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK7_2_DDRIOLO_REG                     0x0000075C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK7_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK0_2_DDRIOLO_REG                     0x00000760
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK1_2_DDRIOLO_REG                     0x00000764
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK2_2_DDRIOLO_REG                     0x00000768
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK2_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK3_2_DDRIOLO_REG                     0x0000076C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK3_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK4_2_DDRIOLO_REG                     0x00000770
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK4_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK5_2_DDRIOLO_REG                     0x00000774
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK5_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK6_2_DDRIOLO_REG                     0x00000778
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK6_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK7_2_DDRIOLO_REG                     0x0000077C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK7_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK0_2_DDRIOLO_REG                     0x00000780
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK0_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK1_2_DDRIOLO_REG                     0x00000784
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK2_2_DDRIOLO_REG                     0x00000788
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK2_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK3_2_DDRIOLO_REG                     0x0000078C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK3_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK4_2_DDRIOLO_REG                     0x00000790
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK4_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK5_2_DDRIOLO_REG                     0x00000794
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK5_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK6_2_DDRIOLO_REG                     0x00000798
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK6_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK7_2_DDRIOLO_REG                     0x0000079C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK7_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXXTALKN1_2_DDRIOLO_REG                           0x000007A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Coefficent for bit[0] of the DQ byte 
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank0 : 4;
    //
    // Coefficent for bit[1] of the DQ byte 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank1 : 4;
    //
    // Coefficent for bit[2] of the DQ byte
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank2 : 4;
    //
    // Coefficent for bit[3] of the DQ byte 
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank3 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 4
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank4 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 5
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank5 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 6
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank6 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 7
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank7 : 4;
  } Bits;
  UINTX Data;
} TXXTALKN1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN1_2_DDRIOLO_REG                        0x000007A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit Rx Vref Control
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX vrefperbit0 : 7;
    //
    // Rsvd
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX halflsben0 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[14:8], RW_L, default = 0x0
    //
    UINTX vrefperbit1 : 7;
    //
    // Rsvd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX halflsben1 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[22:16], RW_L, default = 0x0
    //
    UINTX vrefperbit2 : 7;
    //
    // Rsvd
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX halflsben2 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[30:24], RW_L, default = 0x0
    //
    UINTX vrefperbit3 : 7;
    //
    // shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX halflsben3 : 1;
  } Bits;
  UINTX Data;
} RXVREFCTRLN1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATATRAINFEEDBACKN1_2_DDRIOLO_REG                 0x000007A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Training Feedback Storage
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX datatrainfeedback : 9;
    //
    // Spare
    // 
    // Bits[31:9], RW_L, default = 0x0
    //
    UINTX spare : 23;
  } Bits;
  UINTX Data;
} DATATRAINFEEDBACKN1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N1_2_DDRIOLO_REG                      0x000007CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Visa debug bus LCB for DATA fub
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    //  VssHi control bits
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------
    // 	 disoverflow        24     Disable overflow logic from BDW
    // 	 fast panic enable  25     Bypass 2 flops in panic path for faster panic response
    // 	 vsshivccd2by3cfgen 26     Forces the driver DAC to get supply from 2/3 vccd
    // 	 vsshivccd2by3cfg   27:29  Current trim setting for 2/3 vccd mode, 001 fast,
    // 011 typical, 111 slow silicon  
    // 	 ddrvssh2ndcompen   30     Enable second comparator (ZBB mode)
    // 	 comp high bwen     31     Improve comparator performance to support low digital
    // voltage range 
    // 	
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl1 : 8;
    //
    // DQ TxEq setting selection to achieve constant EQ
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX dqtxeqsel : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSP pad to the Vref nibble bus
    //         
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqspvrefpgen : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSN pad to the Vref nibble bus
    //         
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX dqsnvrefpgen : 1;
    //
    //  
    //          If set to 0 (default), Vref generators selected through RxVrefSel[3:0]
    // are always on. 
    //          If set to 1, Vref generators are switched off while in Self Refresh.
    //         
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX vrefpwrsave : 1;
    //
    // Per-bit Enable connection to share Vref Bus
    // 
    // Bits[16:13], RW_L, default = 0x8
    //
    UINTX vreftonblbus : 4;
    //
    // Per Bit Verf generator Enable
    // 
    // Bits[20:17], RW_L, default = 0xF
    //
    UINTX rxvrefsel : 4;
    //
    // RefPiClkDelay
    // 
    // Bits[26:21], RW_L, default = 0x0
    //
    UINTX refpiclkdelay : 6;
    //
    // FNV Slave Delay Line Bypass Enable
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX fnvcrsdlbypassen : 1;
    //
    // FNV DLL Bypass Enable 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX fnvcrdllbypassen : 1;
    //
    // FNV Visa Fub Enable - data fub used for VISA if asserted 
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX fnvcrvisaen : 1;
    //
    // Enable write crc mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX writecrcenable : 1;
    //
    // This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
  } Bits;
  UINTX Data;
} DATACONTROL4N1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK1SELN1_2_DDRIOLO_REG                        0x000007D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor1 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr1d0 : 3;
    //
    // xtalk aggressor1 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr1d1 : 3;
    //
    // xtalk aggressor1 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr1d2 : 3;
    //
    // xtalk aggressor1 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr1d3 : 3;
    //
    // xtalk aggressor1 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr1d4 : 3;
    //
    // xtalk aggressor1 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr1d5 : 3;
    //
    // xtalk aggressor1 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr1d6 : 3;
    //
    // xtalk aggressor1 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr1d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK1SELN1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA0N1_2_DDRIOLO_REG                         0x000007D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp DrvUp Comp Value can be overriden via message channel if periodical
    // retrain is disable  
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Data Rcomp DrvDown Comp Value
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // VT Comp Values
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Data TCO Comp Value.
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Data Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} COMPDATA0N1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA1N1_2_DDRIOLO_REG                         0x000007D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp OdtUp Comp Value 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Data Rcomp Odt-Down Comp Value
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[21:12], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[31:22], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} COMPDATA1N1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETTRAINN1_2_DDRIOLO_REG                   0x000007DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained RxRcvEn Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcvenoffset : 6;
    //
    // Offset added to Trained Rx DQS Value.
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX rxdqsoffset : 7;
    //
    // Offset added to Trained Tx DQ Value.
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX txdqoffset : 6;
    //
    // Ooffset added to Trained Tx DQS Value.
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX txdqsoffset : 6;
    //
    // 2s Compliment offset added to Trained Vref Value.  Positive number increases Vref,
    // and each step is Vdd/384. 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX vrefoffset : 7;
  } Bits;
  UINTX Data;
} DATAOFFSETTRAINN1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETCOMPN1_2_DDRIOLO_REG                    0x000007E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2s Compliment offset added to DQ Drv-Up Comp Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX dqdrvupcompoffset : 6;
    //
    // 2s Compliment offset added to DQ Drv-Down Comp Value.
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX dqdrvdowncompoffset : 6;
    //
    // 2s Compliment offset added to DQ Odt-Up Comp Value.
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX dqodtupcompoffset : 5;
    //
    // 2s Compliment offset added to DQ Odt-Down Value.
    // 
    // Bits[21:17], RW_L, default = 0x0
    //
    UINTX dqodtdowncompoffset : 5;
    //
    // 2s Compliment offset added to DQ Tco Comp Value.
    // 
    // Bits[26:22], RW_L, default = 0x0
    //
    UINTX dqtcocompoffset : 5;
    //
    // 2s Compliment offset added to DQ Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX dqslewratecompoffset : 5;
  } Bits;
  UINTX Data;
} DATAOFFSETCOMPN1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK0SELN1_2_DDRIOLO_REG                        0x000007E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor0 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr0d0 : 3;
    //
    // xtalk aggressor0 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr0d1 : 3;
    //
    // xtalk aggressor0 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr0d2 : 3;
    //
    // xtalk aggressor0 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr0d3 : 3;
    //
    // xtalk aggressor0 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr0d4 : 3;
    //
    // xtalk aggressor0 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr0d5 : 3;
    //
    // xtalk aggressor0 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr0d6 : 3;
    //
    // xtalk aggressor0 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr0d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK0SELN1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N1_2_DDRIOLO_REG                      0x000007E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables Read DqDqs Training Mode
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX rxtrainingmode : 1;
    //
    // Enables Write Leveling Training Mode
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wltrainingmode : 1;
    //
    // Enables Read Leveling Training Mode.
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX rltrainingmode : 1;
    //
    // Enables SenseAmp offset cancellation training mode.
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX senseamptrainingmode : 1;
    //
    // When set, forces DQ/DQS drive enable to active.  Used in power measurements and
    // IO loopback mode  
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Power-down Disable:  Forces register file read, overriding the rank power down
    // logic. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rfon : 1;
    //
    // Power-down Disable:  Forces RxDqs PI clocks on.
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX rxpion : 1;
    //
    // Power-down Disable:  Forces TxDq and TxDqs PI clocks on.
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txpion : 1;
    //
    // 
    //           Forces on master DLL and all PI enables ON, despite both channel in
    // SelfRefresh, etc. low power states. 
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX internalclockson : 1;
    //
    // SaOffsetTrainTxon
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // Power-down:  All write commands are ignored for this data-byte.  Used in single-channel
    // MCI mode. 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX txdisable : 1;
    //
    // Power-down:  All read commands are ignored for this data-byte.  Used in single-channel
    // MCI mode.  
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX rxdisable : 1;
    //
    // Sets the duration of the first transmitted DQ bit of the burst. 0=1UI, 1=2UI.
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX txlong : 1;
    //
    // Controls the RX DQS CTLE setting.  (Code, CTLE) = { (0x0, Off),  (0x1, Use DQ),
    //  (0x2, BandPass),  (0x3, RSVD) }  
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX rxdqsctle : 2;
    //
    // Sets the RX read pointer offset on a reset.  Used during loopback and BERT mode.
    //  WrPtrPh1/WrPtrPh2 is reset to RxRdPt 
    // r (Default is to reset both to 0).
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX rxreadpointer : 3;
    //
    // Controls which segements of the driver are enabled:  {0: All, 1: Only ODT}.
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX driversegmentenable : 1;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a read c 
    // ommand to Rank = ReadRFRank
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX readrfrd : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a write  
    // command to Rank = ReadRFRank
    // 
    // Bits[21:21], RW_LV, default = 0x0
    //
    UINTX readrfwr : 1;
    //
    // Specifies the rank that ReadRFRd or ReadRFWr will manually download the CR values
    // from 
    // 
    // Bits[24:22], RW_LV, default = 0x0
    //
    UINTX readrfrank : 3;
    //
    // ODT is forced-on.
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // ODT and Senseamp are forced-off.
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsampoff : 1;
    //
    // not used
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disableodtstatic : 1;
    //
    // force ODT to the transmitter on, regardless of state of DriveEnable
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX ddrcrforceodton : 1;
    //
    // spare
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
    //
    // Enables long preamble for DDR4 devices
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX longpreambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL0N1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N1_2_DDRIOLO_REG                      0x000007EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable phase shift based crosstalk cancellation.
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX xtalkpienable : 1;
    //
    // select if 0: capacitive coupling; or 1: inductive coupling; xtalk dominant
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX xtalkpisign : 1;
    //
    // delta phase shift in one aggressor is in effect
    // 
    // Bits[4:2], RW_L, default = 0x0
    //
    UINTX xtalkpidelta : 3;
    //
    // reserved
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX burstlength10 : 1;
    //
    // Enable DLL Weak Lock to save power during CKE power down: {0: Disabled, 1: Enable}
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // IOT mode 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX iolbmodeen : 1;
    //
    // Controls which slave DLL are disabled: {0: nibble0, 1: nibble1, 2: not used}
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX sdlldisable : 1;
    //
    // not used
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // Controls the Current and BW of the Receiver: {0: 0.34Idll, 1: 0.66Idll, 2: 0.88Idll,
    // 3: Idll, 4: 1.33Idll, 5: 1.66Idll 
    // , 6: 2.00Idll, 7: 2.33Idll}
    // 
    // Bits[12:10], RW_L, default = 0x0
    //
    UINTX rxbiasctl : 3;
    //
    // Controls ODT turn-on delay.   To turn on N tQCK before RcvEn, program to RcvEn[8:6]
    //  N + 4. 
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX odtdelay : 4;
    //
    // Controls the ODT ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7, 18
    // tQCK) 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX odtduration : 3;
    //
    // Controls Senseamp turn-on delay.   To turn on N tQCK before RcvEn, program to
    // RcvEn[8:6]  N + 4. 
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX senseampdelay : 4;
    //
    // Controls the SenseAmp ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7,
    // 18 tQCK) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX senseampduration : 3;
    //
    // Cycles after the burst, when the current pulse should turn on by enabling OdtEn
    // for 1 cycle 
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX burstendodtdelay : 3;
    //
    // low voltage mode (ddr3lv, ddr3u, ddr4, smi, etc.)
    //             00: ddr3
    //             01: ddr3lv_smi
    //             10: ddr3u
    //             11: ddr4
    //         
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
  } Bits;
  UINTX Data;
} DATACONTROL1N1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N1_2_DDRIOLO_REG                      0x000007F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables SenseAmp offset cancellation training mode
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX rxvocselqnnnh : 5;
    //
    // Force on the internal Vref and Rx bias circuit, regardless of any other power
    // downs 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX forcebiason : 1;
    //
    // Force on the RxAmp only (as opposed to OdtSampOn, which turns on both ODT and
    // the amplifier). 
    //         Use for overclocking support where we may not be able to hit the fast
    // exit latency  
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX forcerxon : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // legacy from BDX for DDR3/VMSE configs"  DDRCOMP_CR_DDRCRCOMPOVR CTTermination
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Imode Select, 0: Swing Boost Mode; 1: (not supported) Xtalk Cancellation Mode
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX imodecfg : 1;
    //
    // Enable Imode EQ per byte lane. 
    //           0: Imode completely off 
    //           1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX imodeenable : 1;
    //
    // Spare
    // 
    // Bits[14:11], RW_L, default = 0x0
    //
    UINTX spare : 4;
    //
    // tbd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasen : 1;
    //
    // Spare1
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Binary Imode Coefficient, sets Imode current strength.
    //           (used for either Xtalk cancellation or swing boost)
    //           Code   Imode Current (approx)
    //           ------------------
    //           0000        0
    //           0001        1
    //           0010        2
    //             *
    //             *
    //             *
    //           1111        3
    // 
    // Bits[21:18], RW_L, default = 0x0
    //
    UINTX imodeeqcode : 4;
    //
    // Imode Scomp Override Enable
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX imodescompovrd : 1;
    //
    // strobe Rx Amp offset control
    // 
    // Bits[27:23], RW_L, default = 0xF
    //
    UINTX rxdqssaoffset : 5;
    //
    // disable the offset control in DQ and DQS RxAmp
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX rxoffsetdisable : 1;
    //
    // VMSE Logic Delay
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vmselogicdelay : 1;
    //
    // Spare2
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xoverdlyadj : 1;
  } Bits;
  UINTX Data;
} DATACONTROL2N1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N1_2_DDRIOLO_REG                      0x000007F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // binary default setting for static legs in DRV mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX drvstaticlegcfg : 2;
    //
    // binary default setting for static legs in ODT mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX odtstaticlegcfg : 2;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // not use
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rxdqssadisableshort : 1;
    //
    // This will tell which  segments are enabled out of reset.  
    //                      After that, a shift register will determine the enabled segments
    // 
    // Bits[8:6], RW_L, default = 0x1
    //
    UINTX odtsegmentenable : 3;
    //
    // This will tell which  segments are enabled out of reset. 
    // 
    // Bits[11:9], RW_L, default = 0x1
    //
    UINTX datasegmentenable : 3;
    //
    // When set, it will extends ODT by 1 qclk on read to write turnarounds. hsd 230773
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX longodtr2w : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // imodebias control 
    // 
    // Bits[14:14], RW_L, default = 0x1
    //
    UINTX imodebiasvrefen : 1;
    //
    // imodebias control. Also used for rxbiasana 
    // 
    // Bits[17:15], RW_L, default = 0x1
    //
    UINTX imodebiasrxbiastrim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // imodebias control 
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX imodebiasdfxddr4legup : 1;
    //
    // imodebias control 
    // 
    // Bits[20:20], RW_L, default = 0x1
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // ctle capacitor setting 
    // 
    // Bits[22:21], RW_L, default = 0x0
    //
    UINTX ddrcrctlecapen : 2;
    //
    // ctle resistor setting 
    // 
    // Bits[24:23], RW_L, default = 0x3
    //
    UINTX ddrcrctleresen : 2;
    //
    // RxBias CR 
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX pcasbiasclosedloopen : 1;
    //
    // RxBias CR 
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // RxBias CR 
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX rxbiasfoldedlegtrim : 2;
    //
    // RxBias CR 
    // 
    // Bits[30:29], RW_L, default = 0x1
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Spare
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX postambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL3N1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN1_2_DDRIOLO_REG                0x000007F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description: 
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode			
    //         PanicVoltage	 21:18  Unsigned integer controlling the voltage error on
    // VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking 
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADCN1_2_DDRIOLO_REG                   0x000007FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADCN1_2_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK0_3_DDRIOLO_REG                     0x00000800
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS (0: 1/16 UI
    // offset,  
    //           1: 3/16 UI Offset, 2: 5/16 UI Offsets, 3: 7/16 UI Offsets, 4: 9/16 UI
    // Offsets, 5,6,7: 11/16 UI Offsets.) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK1_3_DDRIOLO_REG                     0x00000804
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK2_3_DDRIOLO_REG                     0x00000808
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK2_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK3_3_DDRIOLO_REG                     0x0000080C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK3_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK4_3_DDRIOLO_REG                     0x00000810
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK4_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK5_3_DDRIOLO_REG                     0x00000814
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // mux select for crossover from ClkPiRef to CkPi4RcvEn, used in xover2to2 mode
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK5_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK6_3_DDRIOLO_REG                     0x00000818
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK6_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK7_3_DDRIOLO_REG                     0x0000081C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK7_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK0_3_DDRIOLO_REG                     0x00000820
#ifndef ASM_INC
typedef union {
  struct {
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK1_3_DDRIOLO_REG                     0x00000824
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK2_3_DDRIOLO_REG                     0x00000828
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK2_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK3_3_DDRIOLO_REG                     0x0000082C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK3_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK4_3_DDRIOLO_REG                     0x00000830
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK4_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK5_3_DDRIOLO_REG                     0x00000834
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK5_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK6_3_DDRIOLO_REG                     0x00000838
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK6_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK7_3_DDRIOLO_REG                     0x0000083C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK7_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK0_3_DDRIOLO_REG                     0x00000840
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // select one of the four DQ Clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK1_3_DDRIOLO_REG                     0x00000844
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK2_3_DDRIOLO_REG                     0x00000848
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK2_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK3_3_DDRIOLO_REG                     0x0000084C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK3_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK4_3_DDRIOLO_REG                     0x00000850
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK4_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK5_3_DDRIOLO_REG                     0x00000854
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK5_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK6_3_DDRIOLO_REG                     0x00000858
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK6_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK7_3_DDRIOLO_REG                     0x0000085C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK7_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK0_3_DDRIOLO_REG                     0x00000860
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte. 0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK1_3_DDRIOLO_REG                     0x00000864
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK2_3_DDRIOLO_REG                     0x00000868
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK2_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK3_3_DDRIOLO_REG                     0x0000086C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK3_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK4_3_DDRIOLO_REG                     0x00000870
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK4_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK5_3_DDRIOLO_REG                     0x00000874
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK5_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK6_3_DDRIOLO_REG                     0x00000878
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK6_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK7_3_DDRIOLO_REG                     0x0000087C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK7_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK0_3_DDRIOLO_REG                     0x00000880
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // selects which skewed DQSP (to sample even bits) is used in the RX FIFO. For proper
    // operation, always pick latest DQSP 
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // selects which skewed DQSN (to sample odd bits) is used in the RX FIFO. For proper
    // operation, always pick latest DQSN 
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK1_3_DDRIOLO_REG                     0x00000884
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK2_3_DDRIOLO_REG                     0x00000888
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK2_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK3_3_DDRIOLO_REG                     0x0000088C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK3_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK4_3_DDRIOLO_REG                     0x00000890
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK4_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK5_3_DDRIOLO_REG                     0x00000894
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK5_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK6_3_DDRIOLO_REG                     0x00000898
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK6_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK7_3_DDRIOLO_REG                     0x0000089C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK7_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXXTALKN0_3_DDRIOLO_REG                           0x000008A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 0
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank0 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 1 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank1 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 2
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank2 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 3 
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank3 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 4
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank4 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 5
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank5 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 6
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank6 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 7
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank7 : 4;
  } Bits;
  UINTX Data;
} TXXTALKN0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN0_3_DDRIOLO_REG                        0x000008A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit Rx Vref Control
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX vrefperbit0 : 7;
    //
    // Rsvd
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX halflsben0 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[14:8], RW_L, default = 0x0
    //
    UINTX vrefperbit1 : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX halflsben1 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[22:16], RW_L, default = 0x0
    //
    UINTX vrefperbit2 : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX halflsben2 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[30:24], RW_L, default = 0x0
    //
    UINTX vrefperbit3 : 7;
    //
    // shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX halflsben3 : 1;
  } Bits;
  UINTX Data;
} RXVREFCTRLN0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATATRAINFEEDBACKN0_3_DDRIOLO_REG                 0x000008A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Training Feedback Storage
    // 
    //         DataTrainFeedback Description:
    //          Training Step    Bits    Nibble    Description
    //         --------------    ----    -------  --------------------------------------------------------------------------------------------------------------------------------------------------------
    //         Cross Over Cal     0      0        Tx Dqs Phase Detection
    //         Cross Over Cal     1      0        Tx Dq Phase Detection
    //         Cross Over Cal     2      0        Rec En Phase Detection
    //         RcvEn              8:0    0        Byte detection
    //         Rx Dq-Dqs          0      0        Pass/fail
    //         Wr Leveling        8:0    0        Byte detection
    // 
    //         Cross Over Cal     3      1        Tx Dqs Phase Detection
    //         Cross Over Cal     4      1        Tx Dq Phase Detection
    //         Cross Over Cal     5      1        Rec En Phase Detection
    //         RcvEn             17:9    1        Byte detection
    //         Rx Dq-Dqs          1      1        Pass/fail
    //         Wr Leveling       17:9    1        Byte detection
    //         
    // 
    // Bits[17:0], RW_L, default = 0x0
    //
    UINTX datatrainfeedback : 18;
    //
    // Spare
    // 
    // Bits[31:18], RW_L, default = 0x0
    //
    UINTX spare : 14;
  } Bits;
  UINTX Data;
} DATATRAINFEEDBACKN0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N0_3_DDRIOLO_REG                      0x000008CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Visa debug bus LCB for DATA fub
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    //  VssHi control bits
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------
    // 	 disoverflow        24     Disable overflow logic from BDW
    // 	 fast panic enable  25     Bypass 2 flops in panic path for faster panic response
    // 	 vsshivccd2by3cfgen 26     Forces the driver DAC to get supply from 2/3 vccd
    // 	 vsshivccd2by3cfg   27:29  Current trim setting for 2/3 vccd mode, 001 fast,
    // 011 typical, 111 slow silicon  
    // 	 ddrvssh2ndcompen   30     Enable second comparator (ZBB mode)
    // 	 comp high bwen     31     Improve comparator performance to support low digital
    // voltage range 
    // 	
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl1 : 8;
    //
    // DQ TxEq setting selection to achieve constant EQ
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX dqtxeqsel : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSP pad to the Vref nibble bus
    //         
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqspvrefpgen : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSN pad to the Vref nibble bus
    //         
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX dqsnvrefpgen : 1;
    //
    //  
    //          If set to 0 (default), Vref generators selected through RxVrefSel[3:0]
    // are always on. 
    //          If set to 1, Vref generators are switched off while in Self Refresh.
    //         
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX vrefpwrsave : 1;
    //
    // Per-bit Enable connection to share Vref Bus
    // 
    // Bits[16:13], RW_L, default = 0x8
    //
    UINTX vreftonblbus : 4;
    //
    // Per Bit Verf generator Enable
    // 
    // Bits[20:17], RW_L, default = 0xF
    //
    UINTX rxvrefsel : 4;
    //
    // RefPiClkDelay
    // 
    // Bits[26:21], RW_L, default = 0x0
    //
    UINTX refpiclkdelay : 6;
    //
    // FNV Slave Delay Line Bypass Enable
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX fnvcrsdlbypassen : 1;
    //
    // FNV DLL Bypass Enable 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX fnvcrdllbypassen : 1;
    //
    // FNV Visa Fub Enable - data fub used for VISA if asserted 
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX fnvcrvisaen : 1;
    //
    // Enable write crc mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX writecrcenable : 1;
    //
    // This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
  } Bits;
  UINTX Data;
} DATACONTROL4N0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK1SELN0_3_DDRIOLO_REG                        0x000008D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor1 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr1d0 : 3;
    //
    // xtalk aggressor1 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr1d1 : 3;
    //
    // xtalk aggressor1 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr1d2 : 3;
    //
    // xtalk aggressor1 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr1d3 : 3;
    //
    // xtalk aggressor1 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr1d4 : 3;
    //
    // xtalk aggressor1 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr1d5 : 3;
    //
    // xtalk aggressor1 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr1d6 : 3;
    //
    // xtalk aggressor1 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr1d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK1SELN0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA0N0_3_DDRIOLO_REG                         0x000008D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp DrvUp Comp Value can be overriden via message channel if periodical
    // retrain is disable  
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Data Rcomp DrvDown Comp Value
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // VT Comp Values
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Data TCO Comp Value.
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Data Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} COMPDATA0N0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA1N0_3_DDRIOLO_REG                         0x000008D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp OdtUp Comp Value 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Data Rcomp Odt-Down Comp Value
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[21:12], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[31:22], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} COMPDATA1N0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETTRAINN0_3_DDRIOLO_REG                   0x000008DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained RxRcvEn Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcvenoffset : 6;
    //
    // Offset added to Trained Rx DQS Value.
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX rxdqsoffset : 7;
    //
    // Offset added to Trained Tx DQ Value.
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX txdqoffset : 6;
    //
    // Ooffset added to Trained Tx DQS Value.
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX txdqsoffset : 6;
    //
    // 2s Compliment offset added to Trained Vref Value.  Positive number increases Vref,
    // and each step is Vdd/384. 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX vrefoffset : 7;
  } Bits;
  UINTX Data;
} DATAOFFSETTRAINN0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETCOMPN0_3_DDRIOLO_REG                    0x000008E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2s Compliment offset added to DQ Drv-Up Comp Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX dqdrvupcompoffset : 6;
    //
    // 2s Compliment offset added to DQ Drv-Down Comp Value.
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX dqdrvdowncompoffset : 6;
    //
    // 2s Compliment offset added to DQ Odt-Up Comp Value.
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX dqodtupcompoffset : 5;
    //
    // 2s Compliment offset added to DQ Odt-Down Value.
    // 
    // Bits[21:17], RW_L, default = 0x0
    //
    UINTX dqodtdowncompoffset : 5;
    //
    // 2s Compliment offset added to DQ Tco Comp Value.
    // 
    // Bits[26:22], RW_L, default = 0x0
    //
    UINTX dqtcocompoffset : 5;
    //
    // 2s Compliment offset added to DQ Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX dqslewratecompoffset : 5;
  } Bits;
  UINTX Data;
} DATAOFFSETCOMPN0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK0SELN0_3_DDRIOLO_REG                        0x000008E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor0 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr0d0 : 3;
    //
    // xtalk aggressor0 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr0d1 : 3;
    //
    // xtalk aggressor0 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr0d2 : 3;
    //
    // xtalk aggressor0 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr0d3 : 3;
    //
    // xtalk aggressor0 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr0d4 : 3;
    //
    // xtalk aggressor0 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr0d5 : 3;
    //
    // xtalk aggressor0 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr0d6 : 3;
    //
    // xtalk aggressor0 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr0d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK0SELN0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N0_3_DDRIOLO_REG                      0x000008E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables Read DqDqs Training Mode
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX rxtrainingmode : 1;
    //
    // Enables Write Leveling Training Mode
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wltrainingmode : 1;
    //
    // Enables Read Leveling Training Mode.
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX rltrainingmode : 1;
    //
    // Enables SenseAmp offset cancellation training mode.
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX senseamptrainingmode : 1;
    //
    // When set, forces DQ/DQS drive enable to active.  Used in power measurements and
    // IO loopback mode  
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Power-down Disable:  Forces register file read, overriding the rank power down
    // logic. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rfon : 1;
    //
    // Power-down Disable:  Forces RxDqs PI clocks on.
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX rxpion : 1;
    //
    // Power-down Disable:  Forces TxDq and TxDqs PI clocks on.
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txpion : 1;
    //
    // 
    //           Forces on master DLL and all PI enables ON, despite both channel in
    // SelfRefresh, etc. low power states. 
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX internalclockson : 1;
    //
    // SaOffsetTrainTxon
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // Power-down:  All write commands are ignored for this data-byte.  Used in single-channel
    // MCI mode. 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX txdisable : 1;
    //
    // Power-down:  All read commands are ignored for this data-byte.  Used in single-channel
    // MCI mode.  
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX rxdisable : 1;
    //
    // Sets the duration of the first transmitted DQ bit of the burst. 0=1UI, 1=2UI.
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX txlong : 1;
    //
    // Controls the RX DQS CTLE setting.  (Code, CTLE) = { (0x0, Off),  (0x1, Use DQ),
    //  (0x2, BandPass),  (0x3, RSVD) }  
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX rxdqsctle : 2;
    //
    // Sets the RX read pointer offset on a reset.  Used during loopback and BERT mode.
    //  WrPtrPh1/WrPtrPh2 is reset to RxRdPt 
    // r (Default is to reset both to 0).
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX rxreadpointer : 3;
    //
    // Controls which segements of the driver are enabled:  {0: All, 1: Only ODT}.
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX driversegmentenable : 1;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a read c 
    // ommand to Rank = ReadRFRank
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX readrfrd : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a write  
    // command to Rank = ReadRFRank
    // 
    // Bits[21:21], RW_LV, default = 0x0
    //
    UINTX readrfwr : 1;
    //
    // Specifies the rank that ReadRFRd or ReadRFWr will manually download the CR values
    // from 
    // 
    // Bits[24:22], RW_LV, default = 0x0
    //
    UINTX readrfrank : 3;
    //
    // ODT is forced-on.
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // ODT and Senseamp are forced-off.
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsampoff : 1;
    //
    // not used
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disableodtstatic : 1;
    //
    // force ODT to the transmitter on, regardless of state of DriveEnable
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX ddrcrforceodton : 1;
    //
    // spare
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
    //
    // Enables long preamble for DDR4 devices
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX longpreambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL0N0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N0_3_DDRIOLO_REG                      0x000008EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable phase shift based crosstalk cancellation.
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX xtalkpienable : 1;
    //
    // select if 0: capacitive coupling; or 1: inductive coupling; xtalk dominant
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX xtalkpisign : 1;
    //
    // delta phase shift in one aggressor is in effect
    // 
    // Bits[4:2], RW_L, default = 0x0
    //
    UINTX xtalkpidelta : 3;
    //
    // reserved
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX burstlength10 : 1;
    //
    // Enable DLL Weak Lock to save power during CKE power down: {0: Disabled, 1: Enable}
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // IOT mode 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX iolbmodeen : 1;
    //
    // Controls which slave DLL are disabled: {0: nibble0, 1: nibble1, 2: not used}
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX sdlldisable : 1;
    //
    // not used
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // Controls the Current and BW of the Receiver: {0: 0.34Idll, 1: 0.66Idll, 2: 0.88Idll,
    // 3: Idll, 4: 1.33Idll, 5: 1.66Idll 
    // , 6: 2.00Idll, 7: 2.33Idll}
    // 
    // Bits[12:10], RW_L, default = 0x0
    //
    UINTX rxbiasctl : 3;
    //
    // Controls ODT turn-on delay.   To turn on N tQCK before RcvEn, program to RcvEn[8:6]
    //  N + 4. 
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX odtdelay : 4;
    //
    // Controls the ODT ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7, 18
    // tQCK) 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX odtduration : 3;
    //
    // Controls Senseamp turn-on delay.   To turn on N tQCK before RcvEn, program to
    // RcvEn[8:6]  N + 4. 
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX senseampdelay : 4;
    //
    // Controls the SenseAmp ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7,
    // 18 tQCK) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX senseampduration : 3;
    //
    // Cycles after the burst, when the current pulse should turn on by enabling OdtEn
    // for 1 cycle 
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX burstendodtdelay : 3;
    //
    // low voltage mode (ddr3lv, ddr3u, ddr4, smi, etc.)
    //             00: ddr3
    //             01: ddr3lv_smi
    //             10: ddr3u
    //             11: ddr4
    //         
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
  } Bits;
  UINTX Data;
} DATACONTROL1N0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N0_3_DDRIOLO_REG                      0x000008F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables SenseAmp offset cancellation training mode
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX rxvocselqnnnh : 5;
    //
    // Force on the internal Vref and Rx bias circuit, regardless of any other power
    // downs 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX forcebiason : 1;
    //
    // Force on the RxAmp only (as opposed to OdtSampOn, which turns on both ODT and
    // the amplifier). 
    //         Use for overclocking support where we may not be able to hit the fast
    // exit latency  
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX forcerxon : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // legacy from BDX for DDR3/VMSE configs"  DDRCOMP_CR_DDRCRCOMPOVR CTTermination
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Imode Select, 0: Swing Boost Mode; 1: (not supported) Xtalk Cancellation Mode
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX imodecfg : 1;
    //
    // Enable Imode EQ per byte lane. 
    //           0: Imode completely off 
    //           1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX imodeenable : 1;
    //
    // Spare
    // 
    // Bits[14:11], RW_L, default = 0x0
    //
    UINTX spare : 4;
    //
    // tbd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasen : 1;
    //
    // Spare1
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Binary Imode Coefficient, sets Imode current strength.
    //           (used for either Xtalk cancellation or swing boost)
    //           Code   Imode Current (approx)
    //           ------------------
    //           0000        0
    //           0001        1
    //           0010        2
    //             *
    //             *
    //             *
    //           1111        3
    // 
    // Bits[21:18], RW_L, default = 0x0
    //
    UINTX imodeeqcode : 4;
    //
    // Imode Scomp Override Enable
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX imodescompovrd : 1;
    //
    // strobe Rx Amp offset control
    // 
    // Bits[27:23], RW_L, default = 0xF
    //
    UINTX rxdqssaoffset : 5;
    //
    // disable the offset control in DQ and DQS RxAmp
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX rxoffsetdisable : 1;
    //
    // VMSE Logic Delay
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vmselogicdelay : 1;
    //
    // Spare2
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xoverdlyadj : 1;
  } Bits;
  UINTX Data;
} DATACONTROL2N0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N0_3_DDRIOLO_REG                      0x000008F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // binary default setting for static legs in DRV mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX drvstaticlegcfg : 2;
    //
    // binary default setting for static legs in ODT mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX odtstaticlegcfg : 2;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // not use
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rxdqssadisableshort : 1;
    //
    // This will tell which  segments are enabled out of reset.  
    //                      After that, a shift register will determine the enabled segments
    // 
    // Bits[8:6], RW_L, default = 0x1
    //
    UINTX odtsegmentenable : 3;
    //
    // This will tell which  segments are enabled out of reset. 
    // 
    // Bits[11:9], RW_L, default = 0x1
    //
    UINTX datasegmentenable : 3;
    //
    // When set, it will extends ODT by 1 qclk on read to write turnarounds. hsd 230773
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX longodtr2w : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // imodebias control 
    // 
    // Bits[14:14], RW_L, default = 0x1
    //
    UINTX imodebiasvrefen : 1;
    //
    // imodebias control. Also used for rxbiasana 
    // 
    // Bits[17:15], RW_L, default = 0x1
    //
    UINTX imodebiasrxbiastrim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // imodebias control 
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX imodebiasdfxddr4legup : 1;
    //
    // imodebias control 
    // 
    // Bits[20:20], RW_L, default = 0x1
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // ctle capacitor setting 
    // 
    // Bits[22:21], RW_L, default = 0x0
    //
    UINTX ddrcrctlecapen : 2;
    //
    // ctle resistor setting 
    // 
    // Bits[24:23], RW_L, default = 0x3
    //
    UINTX ddrcrctleresen : 2;
    //
    // RxBias CR 
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX pcasbiasclosedloopen : 1;
    //
    // RxBias CR 
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // RxBias CR 
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX rxbiasfoldedlegtrim : 2;
    //
    // RxBias CR 
    // 
    // Bits[30:29], RW_L, default = 0x1
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Spare
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX postambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL3N0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN0_3_DDRIOLO_REG                0x000008F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description: 
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode			
    //         PanicVoltage	 21:18  Unsigned integer controlling the voltage error on
    // VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking 
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADCN0_3_DDRIOLO_REG                   0x000008FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADCN0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK0_3_DDRIOLO_REG                     0x00000900
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK1_3_DDRIOLO_REG                     0x00000904
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK2_3_DDRIOLO_REG                     0x00000908
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK2_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK3_3_DDRIOLO_REG                     0x0000090C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK3_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK4_3_DDRIOLO_REG                     0x00000910
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK4_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK5_3_DDRIOLO_REG                     0x00000914
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK5_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK6_3_DDRIOLO_REG                     0x00000918
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK6_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK7_3_DDRIOLO_REG                     0x0000091C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK7_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK0_3_DDRIOLO_REG                     0x00000920
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK1_3_DDRIOLO_REG                     0x00000924
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK2_3_DDRIOLO_REG                     0x00000928
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK2_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK3_3_DDRIOLO_REG                     0x0000092C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK3_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK4_3_DDRIOLO_REG                     0x00000930
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK4_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK5_3_DDRIOLO_REG                     0x00000934
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK5_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK6_3_DDRIOLO_REG                     0x00000938
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK6_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK7_3_DDRIOLO_REG                     0x0000093C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK7_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK0_3_DDRIOLO_REG                     0x00000940
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the four clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK1_3_DDRIOLO_REG                     0x00000944
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the four clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK2_3_DDRIOLO_REG                     0x00000948
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK2_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK3_3_DDRIOLO_REG                     0x0000094C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK3_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK4_3_DDRIOLO_REG                     0x00000950
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // select one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK4_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK5_3_DDRIOLO_REG                     0x00000954
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK5_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK6_3_DDRIOLO_REG                     0x00000958
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK6_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK7_3_DDRIOLO_REG                     0x0000095C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK7_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK0_3_DDRIOLO_REG                     0x00000960
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK1_3_DDRIOLO_REG                     0x00000964
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK2_3_DDRIOLO_REG                     0x00000968
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK2_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK3_3_DDRIOLO_REG                     0x0000096C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK3_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK4_3_DDRIOLO_REG                     0x00000970
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK4_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK5_3_DDRIOLO_REG                     0x00000974
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK5_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK6_3_DDRIOLO_REG                     0x00000978
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK6_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK7_3_DDRIOLO_REG                     0x0000097C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK7_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK0_3_DDRIOLO_REG                     0x00000980
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK0_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK1_3_DDRIOLO_REG                     0x00000984
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK2_3_DDRIOLO_REG                     0x00000988
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK2_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK3_3_DDRIOLO_REG                     0x0000098C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK3_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK4_3_DDRIOLO_REG                     0x00000990
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK4_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK5_3_DDRIOLO_REG                     0x00000994
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK5_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK6_3_DDRIOLO_REG                     0x00000998
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK6_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK7_3_DDRIOLO_REG                     0x0000099C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK7_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXXTALKN1_3_DDRIOLO_REG                           0x000009A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Coefficent for bit[0] of the DQ byte 
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank0 : 4;
    //
    // Coefficent for bit[1] of the DQ byte 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank1 : 4;
    //
    // Coefficent for bit[2] of the DQ byte
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank2 : 4;
    //
    // Coefficent for bit[3] of the DQ byte 
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank3 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 4
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank4 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 5
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank5 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 6
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank6 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 7
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank7 : 4;
  } Bits;
  UINTX Data;
} TXXTALKN1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN1_3_DDRIOLO_REG                        0x000009A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit Rx Vref Control
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX vrefperbit0 : 7;
    //
    // Rsvd
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX halflsben0 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[14:8], RW_L, default = 0x0
    //
    UINTX vrefperbit1 : 7;
    //
    // Rsvd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX halflsben1 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[22:16], RW_L, default = 0x0
    //
    UINTX vrefperbit2 : 7;
    //
    // Rsvd
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX halflsben2 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[30:24], RW_L, default = 0x0
    //
    UINTX vrefperbit3 : 7;
    //
    // shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX halflsben3 : 1;
  } Bits;
  UINTX Data;
} RXVREFCTRLN1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATATRAINFEEDBACKN1_3_DDRIOLO_REG                 0x000009A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Training Feedback Storage
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX datatrainfeedback : 9;
    //
    // Spare
    // 
    // Bits[31:9], RW_L, default = 0x0
    //
    UINTX spare : 23;
  } Bits;
  UINTX Data;
} DATATRAINFEEDBACKN1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N1_3_DDRIOLO_REG                      0x000009CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Visa debug bus LCB for DATA fub
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    //  VssHi control bits
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------
    // 	 disoverflow        24     Disable overflow logic from BDW
    // 	 fast panic enable  25     Bypass 2 flops in panic path for faster panic response
    // 	 vsshivccd2by3cfgen 26     Forces the driver DAC to get supply from 2/3 vccd
    // 	 vsshivccd2by3cfg   27:29  Current trim setting for 2/3 vccd mode, 001 fast,
    // 011 typical, 111 slow silicon  
    // 	 ddrvssh2ndcompen   30     Enable second comparator (ZBB mode)
    // 	 comp high bwen     31     Improve comparator performance to support low digital
    // voltage range 
    // 	
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl1 : 8;
    //
    // DQ TxEq setting selection to achieve constant EQ
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX dqtxeqsel : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSP pad to the Vref nibble bus
    //         
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqspvrefpgen : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSN pad to the Vref nibble bus
    //         
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX dqsnvrefpgen : 1;
    //
    //  
    //          If set to 0 (default), Vref generators selected through RxVrefSel[3:0]
    // are always on. 
    //          If set to 1, Vref generators are switched off while in Self Refresh.
    //         
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX vrefpwrsave : 1;
    //
    // Per-bit Enable connection to share Vref Bus
    // 
    // Bits[16:13], RW_L, default = 0x8
    //
    UINTX vreftonblbus : 4;
    //
    // Per Bit Verf generator Enable
    // 
    // Bits[20:17], RW_L, default = 0xF
    //
    UINTX rxvrefsel : 4;
    //
    // RefPiClkDelay
    // 
    // Bits[26:21], RW_L, default = 0x0
    //
    UINTX refpiclkdelay : 6;
    //
    // FNV Slave Delay Line Bypass Enable
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX fnvcrsdlbypassen : 1;
    //
    // FNV DLL Bypass Enable 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX fnvcrdllbypassen : 1;
    //
    // FNV Visa Fub Enable - data fub used for VISA if asserted 
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX fnvcrvisaen : 1;
    //
    // Enable write crc mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX writecrcenable : 1;
    //
    // This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
  } Bits;
  UINTX Data;
} DATACONTROL4N1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK1SELN1_3_DDRIOLO_REG                        0x000009D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor1 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr1d0 : 3;
    //
    // xtalk aggressor1 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr1d1 : 3;
    //
    // xtalk aggressor1 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr1d2 : 3;
    //
    // xtalk aggressor1 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr1d3 : 3;
    //
    // xtalk aggressor1 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr1d4 : 3;
    //
    // xtalk aggressor1 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr1d5 : 3;
    //
    // xtalk aggressor1 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr1d6 : 3;
    //
    // xtalk aggressor1 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr1d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK1SELN1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA0N1_3_DDRIOLO_REG                         0x000009D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp DrvUp Comp Value can be overriden via message channel if periodical
    // retrain is disable  
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Data Rcomp DrvDown Comp Value
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // VT Comp Values
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Data TCO Comp Value.
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Data Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} COMPDATA0N1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA1N1_3_DDRIOLO_REG                         0x000009D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp OdtUp Comp Value 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Data Rcomp Odt-Down Comp Value
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[21:12], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[31:22], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} COMPDATA1N1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETTRAINN1_3_DDRIOLO_REG                   0x000009DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained RxRcvEn Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcvenoffset : 6;
    //
    // Offset added to Trained Rx DQS Value.
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX rxdqsoffset : 7;
    //
    // Offset added to Trained Tx DQ Value.
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX txdqoffset : 6;
    //
    // Ooffset added to Trained Tx DQS Value.
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX txdqsoffset : 6;
    //
    // 2s Compliment offset added to Trained Vref Value.  Positive number increases Vref,
    // and each step is Vdd/384. 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX vrefoffset : 7;
  } Bits;
  UINTX Data;
} DATAOFFSETTRAINN1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETCOMPN1_3_DDRIOLO_REG                    0x000009E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2s Compliment offset added to DQ Drv-Up Comp Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX dqdrvupcompoffset : 6;
    //
    // 2s Compliment offset added to DQ Drv-Down Comp Value.
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX dqdrvdowncompoffset : 6;
    //
    // 2s Compliment offset added to DQ Odt-Up Comp Value.
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX dqodtupcompoffset : 5;
    //
    // 2s Compliment offset added to DQ Odt-Down Value.
    // 
    // Bits[21:17], RW_L, default = 0x0
    //
    UINTX dqodtdowncompoffset : 5;
    //
    // 2s Compliment offset added to DQ Tco Comp Value.
    // 
    // Bits[26:22], RW_L, default = 0x0
    //
    UINTX dqtcocompoffset : 5;
    //
    // 2s Compliment offset added to DQ Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX dqslewratecompoffset : 5;
  } Bits;
  UINTX Data;
} DATAOFFSETCOMPN1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK0SELN1_3_DDRIOLO_REG                        0x000009E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor0 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr0d0 : 3;
    //
    // xtalk aggressor0 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr0d1 : 3;
    //
    // xtalk aggressor0 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr0d2 : 3;
    //
    // xtalk aggressor0 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr0d3 : 3;
    //
    // xtalk aggressor0 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr0d4 : 3;
    //
    // xtalk aggressor0 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr0d5 : 3;
    //
    // xtalk aggressor0 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr0d6 : 3;
    //
    // xtalk aggressor0 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr0d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK0SELN1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N1_3_DDRIOLO_REG                      0x000009E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables Read DqDqs Training Mode
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX rxtrainingmode : 1;
    //
    // Enables Write Leveling Training Mode
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wltrainingmode : 1;
    //
    // Enables Read Leveling Training Mode.
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX rltrainingmode : 1;
    //
    // Enables SenseAmp offset cancellation training mode.
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX senseamptrainingmode : 1;
    //
    // When set, forces DQ/DQS drive enable to active.  Used in power measurements and
    // IO loopback mode  
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Power-down Disable:  Forces register file read, overriding the rank power down
    // logic. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rfon : 1;
    //
    // Power-down Disable:  Forces RxDqs PI clocks on.
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX rxpion : 1;
    //
    // Power-down Disable:  Forces TxDq and TxDqs PI clocks on.
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txpion : 1;
    //
    // 
    //           Forces on master DLL and all PI enables ON, despite both channel in
    // SelfRefresh, etc. low power states. 
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX internalclockson : 1;
    //
    // SaOffsetTrainTxon
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // Power-down:  All write commands are ignored for this data-byte.  Used in single-channel
    // MCI mode. 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX txdisable : 1;
    //
    // Power-down:  All read commands are ignored for this data-byte.  Used in single-channel
    // MCI mode.  
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX rxdisable : 1;
    //
    // Sets the duration of the first transmitted DQ bit of the burst. 0=1UI, 1=2UI.
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX txlong : 1;
    //
    // Controls the RX DQS CTLE setting.  (Code, CTLE) = { (0x0, Off),  (0x1, Use DQ),
    //  (0x2, BandPass),  (0x3, RSVD) }  
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX rxdqsctle : 2;
    //
    // Sets the RX read pointer offset on a reset.  Used during loopback and BERT mode.
    //  WrPtrPh1/WrPtrPh2 is reset to RxRdPt 
    // r (Default is to reset both to 0).
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX rxreadpointer : 3;
    //
    // Controls which segements of the driver are enabled:  {0: All, 1: Only ODT}.
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX driversegmentenable : 1;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a read c 
    // ommand to Rank = ReadRFRank
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX readrfrd : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a write  
    // command to Rank = ReadRFRank
    // 
    // Bits[21:21], RW_LV, default = 0x0
    //
    UINTX readrfwr : 1;
    //
    // Specifies the rank that ReadRFRd or ReadRFWr will manually download the CR values
    // from 
    // 
    // Bits[24:22], RW_LV, default = 0x0
    //
    UINTX readrfrank : 3;
    //
    // ODT is forced-on.
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // ODT and Senseamp are forced-off.
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsampoff : 1;
    //
    // not used
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disableodtstatic : 1;
    //
    // force ODT to the transmitter on, regardless of state of DriveEnable
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX ddrcrforceodton : 1;
    //
    // spare
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
    //
    // Enables long preamble for DDR4 devices
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX longpreambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL0N1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N1_3_DDRIOLO_REG                      0x000009EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable phase shift based crosstalk cancellation.
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX xtalkpienable : 1;
    //
    // select if 0: capacitive coupling; or 1: inductive coupling; xtalk dominant
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX xtalkpisign : 1;
    //
    // delta phase shift in one aggressor is in effect
    // 
    // Bits[4:2], RW_L, default = 0x0
    //
    UINTX xtalkpidelta : 3;
    //
    // reserved
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX burstlength10 : 1;
    //
    // Enable DLL Weak Lock to save power during CKE power down: {0: Disabled, 1: Enable}
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // IOT mode 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX iolbmodeen : 1;
    //
    // Controls which slave DLL are disabled: {0: nibble0, 1: nibble1, 2: not used}
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX sdlldisable : 1;
    //
    // not used
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // Controls the Current and BW of the Receiver: {0: 0.34Idll, 1: 0.66Idll, 2: 0.88Idll,
    // 3: Idll, 4: 1.33Idll, 5: 1.66Idll 
    // , 6: 2.00Idll, 7: 2.33Idll}
    // 
    // Bits[12:10], RW_L, default = 0x0
    //
    UINTX rxbiasctl : 3;
    //
    // Controls ODT turn-on delay.   To turn on N tQCK before RcvEn, program to RcvEn[8:6]
    //  N + 4. 
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX odtdelay : 4;
    //
    // Controls the ODT ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7, 18
    // tQCK) 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX odtduration : 3;
    //
    // Controls Senseamp turn-on delay.   To turn on N tQCK before RcvEn, program to
    // RcvEn[8:6]  N + 4. 
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX senseampdelay : 4;
    //
    // Controls the SenseAmp ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7,
    // 18 tQCK) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX senseampduration : 3;
    //
    // Cycles after the burst, when the current pulse should turn on by enabling OdtEn
    // for 1 cycle 
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX burstendodtdelay : 3;
    //
    // low voltage mode (ddr3lv, ddr3u, ddr4, smi, etc.)
    //             00: ddr3
    //             01: ddr3lv_smi
    //             10: ddr3u
    //             11: ddr4
    //         
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
  } Bits;
  UINTX Data;
} DATACONTROL1N1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N1_3_DDRIOLO_REG                      0x000009F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables SenseAmp offset cancellation training mode
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX rxvocselqnnnh : 5;
    //
    // Force on the internal Vref and Rx bias circuit, regardless of any other power
    // downs 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX forcebiason : 1;
    //
    // Force on the RxAmp only (as opposed to OdtSampOn, which turns on both ODT and
    // the amplifier). 
    //         Use for overclocking support where we may not be able to hit the fast
    // exit latency  
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX forcerxon : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // legacy from BDX for DDR3/VMSE configs"  DDRCOMP_CR_DDRCRCOMPOVR CTTermination
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Imode Select, 0: Swing Boost Mode; 1: (not supported) Xtalk Cancellation Mode
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX imodecfg : 1;
    //
    // Enable Imode EQ per byte lane. 
    //           0: Imode completely off 
    //           1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX imodeenable : 1;
    //
    // Spare
    // 
    // Bits[14:11], RW_L, default = 0x0
    //
    UINTX spare : 4;
    //
    // tbd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasen : 1;
    //
    // Spare1
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Binary Imode Coefficient, sets Imode current strength.
    //           (used for either Xtalk cancellation or swing boost)
    //           Code   Imode Current (approx)
    //           ------------------
    //           0000        0
    //           0001        1
    //           0010        2
    //             *
    //             *
    //             *
    //           1111        3
    // 
    // Bits[21:18], RW_L, default = 0x0
    //
    UINTX imodeeqcode : 4;
    //
    // Imode Scomp Override Enable
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX imodescompovrd : 1;
    //
    // strobe Rx Amp offset control
    // 
    // Bits[27:23], RW_L, default = 0xF
    //
    UINTX rxdqssaoffset : 5;
    //
    // disable the offset control in DQ and DQS RxAmp
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX rxoffsetdisable : 1;
    //
    // VMSE Logic Delay
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vmselogicdelay : 1;
    //
    // Spare2
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xoverdlyadj : 1;
  } Bits;
  UINTX Data;
} DATACONTROL2N1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N1_3_DDRIOLO_REG                      0x000009F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // binary default setting for static legs in DRV mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX drvstaticlegcfg : 2;
    //
    // binary default setting for static legs in ODT mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX odtstaticlegcfg : 2;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // not use
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rxdqssadisableshort : 1;
    //
    // This will tell which  segments are enabled out of reset.  
    //                      After that, a shift register will determine the enabled segments
    // 
    // Bits[8:6], RW_L, default = 0x1
    //
    UINTX odtsegmentenable : 3;
    //
    // This will tell which  segments are enabled out of reset. 
    // 
    // Bits[11:9], RW_L, default = 0x1
    //
    UINTX datasegmentenable : 3;
    //
    // When set, it will extends ODT by 1 qclk on read to write turnarounds. hsd 230773
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX longodtr2w : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // imodebias control 
    // 
    // Bits[14:14], RW_L, default = 0x1
    //
    UINTX imodebiasvrefen : 1;
    //
    // imodebias control. Also used for rxbiasana 
    // 
    // Bits[17:15], RW_L, default = 0x1
    //
    UINTX imodebiasrxbiastrim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // imodebias control 
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX imodebiasdfxddr4legup : 1;
    //
    // imodebias control 
    // 
    // Bits[20:20], RW_L, default = 0x1
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // ctle capacitor setting 
    // 
    // Bits[22:21], RW_L, default = 0x0
    //
    UINTX ddrcrctlecapen : 2;
    //
    // ctle resistor setting 
    // 
    // Bits[24:23], RW_L, default = 0x3
    //
    UINTX ddrcrctleresen : 2;
    //
    // RxBias CR 
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX pcasbiasclosedloopen : 1;
    //
    // RxBias CR 
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // RxBias CR 
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX rxbiasfoldedlegtrim : 2;
    //
    // RxBias CR 
    // 
    // Bits[30:29], RW_L, default = 0x1
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Spare
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX postambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL3N1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN1_3_DDRIOLO_REG                0x000009F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description: 
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode			
    //         PanicVoltage	 21:18  Unsigned integer controlling the voltage error on
    // VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking 
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADCN1_3_DDRIOLO_REG                   0x000009FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADCN1_3_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK0_4_DDRIOLO_REG                     0x00000C00
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS (0: 1/16 UI
    // offset,  
    //           1: 3/16 UI Offset, 2: 5/16 UI Offsets, 3: 7/16 UI Offsets, 4: 9/16 UI
    // Offsets, 5,6,7: 11/16 UI Offsets.) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK1_4_DDRIOLO_REG                     0x00000C04
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK2_4_DDRIOLO_REG                     0x00000C08
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK2_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK3_4_DDRIOLO_REG                     0x00000C0C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK3_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK4_4_DDRIOLO_REG                     0x00000C10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK4_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK5_4_DDRIOLO_REG                     0x00000C14
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // mux select for crossover from ClkPiRef to CkPi4RcvEn, used in xover2to2 mode
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK5_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK6_4_DDRIOLO_REG                     0x00000C18
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK6_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK7_4_DDRIOLO_REG                     0x00000C1C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK7_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK0_4_DDRIOLO_REG                     0x00000C20
#ifndef ASM_INC
typedef union {
  struct {
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK1_4_DDRIOLO_REG                     0x00000C24
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK2_4_DDRIOLO_REG                     0x00000C28
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK2_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK3_4_DDRIOLO_REG                     0x00000C2C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK3_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK4_4_DDRIOLO_REG                     0x00000C30
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK4_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK5_4_DDRIOLO_REG                     0x00000C34
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK5_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK6_4_DDRIOLO_REG                     0x00000C38
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK6_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK7_4_DDRIOLO_REG                     0x00000C3C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK7_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK0_4_DDRIOLO_REG                     0x00000C40
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // select one of the four DQ Clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK1_4_DDRIOLO_REG                     0x00000C44
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK2_4_DDRIOLO_REG                     0x00000C48
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK2_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK3_4_DDRIOLO_REG                     0x00000C4C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK3_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK4_4_DDRIOLO_REG                     0x00000C50
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK4_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK5_4_DDRIOLO_REG                     0x00000C54
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK5_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK6_4_DDRIOLO_REG                     0x00000C58
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK6_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK7_4_DDRIOLO_REG                     0x00000C5C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK7_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK0_4_DDRIOLO_REG                     0x00000C60
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte. 0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK1_4_DDRIOLO_REG                     0x00000C64
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK2_4_DDRIOLO_REG                     0x00000C68
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK2_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK3_4_DDRIOLO_REG                     0x00000C6C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK3_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK4_4_DDRIOLO_REG                     0x00000C70
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK4_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK5_4_DDRIOLO_REG                     0x00000C74
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK5_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK6_4_DDRIOLO_REG                     0x00000C78
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK6_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK7_4_DDRIOLO_REG                     0x00000C7C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK7_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK0_4_DDRIOLO_REG                     0x00000C80
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // selects which skewed DQSP (to sample even bits) is used in the RX FIFO. For proper
    // operation, always pick latest DQSP 
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // selects which skewed DQSN (to sample odd bits) is used in the RX FIFO. For proper
    // operation, always pick latest DQSN 
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK1_4_DDRIOLO_REG                     0x00000C84
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK2_4_DDRIOLO_REG                     0x00000C88
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK2_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK3_4_DDRIOLO_REG                     0x00000C8C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK3_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK4_4_DDRIOLO_REG                     0x00000C90
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK4_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK5_4_DDRIOLO_REG                     0x00000C94
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK5_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK6_4_DDRIOLO_REG                     0x00000C98
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK6_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK7_4_DDRIOLO_REG                     0x00000C9C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK7_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXXTALKN0_4_DDRIOLO_REG                           0x00000CA0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 0
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank0 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 1 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank1 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 2
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank2 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 3 
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank3 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 4
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank4 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 5
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank5 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 6
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank6 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 7
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank7 : 4;
  } Bits;
  UINTX Data;
} TXXTALKN0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN0_4_DDRIOLO_REG                        0x00000CA4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit Rx Vref Control
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX vrefperbit0 : 7;
    //
    // Rsvd
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX halflsben0 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[14:8], RW_L, default = 0x0
    //
    UINTX vrefperbit1 : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX halflsben1 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[22:16], RW_L, default = 0x0
    //
    UINTX vrefperbit2 : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX halflsben2 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[30:24], RW_L, default = 0x0
    //
    UINTX vrefperbit3 : 7;
    //
    // shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX halflsben3 : 1;
  } Bits;
  UINTX Data;
} RXVREFCTRLN0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATATRAINFEEDBACKN0_4_DDRIOLO_REG                 0x00000CA8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Training Feedback Storage
    // 
    //         DataTrainFeedback Description:
    //          Training Step    Bits    Nibble    Description
    //         --------------    ----    -------  --------------------------------------------------------------------------------------------------------------------------------------------------------
    //         Cross Over Cal     0      0        Tx Dqs Phase Detection
    //         Cross Over Cal     1      0        Tx Dq Phase Detection
    //         Cross Over Cal     2      0        Rec En Phase Detection
    //         RcvEn              8:0    0        Byte detection
    //         Rx Dq-Dqs          0      0        Pass/fail
    //         Wr Leveling        8:0    0        Byte detection
    // 
    //         Cross Over Cal     3      1        Tx Dqs Phase Detection
    //         Cross Over Cal     4      1        Tx Dq Phase Detection
    //         Cross Over Cal     5      1        Rec En Phase Detection
    //         RcvEn             17:9    1        Byte detection
    //         Rx Dq-Dqs          1      1        Pass/fail
    //         Wr Leveling       17:9    1        Byte detection
    //         
    // 
    // Bits[17:0], RW_L, default = 0x0
    //
    UINTX datatrainfeedback : 18;
    //
    // Spare
    // 
    // Bits[31:18], RW_L, default = 0x0
    //
    UINTX spare : 14;
  } Bits;
  UINTX Data;
} DATATRAINFEEDBACKN0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N0_4_DDRIOLO_REG                      0x00000CCC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Visa debug bus LCB for DATA fub
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    //  VssHi control bits
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------
    // 	 disoverflow        24     Disable overflow logic from BDW
    // 	 fast panic enable  25     Bypass 2 flops in panic path for faster panic response
    // 	 vsshivccd2by3cfgen 26     Forces the driver DAC to get supply from 2/3 vccd
    // 	 vsshivccd2by3cfg   27:29  Current trim setting for 2/3 vccd mode, 001 fast,
    // 011 typical, 111 slow silicon  
    // 	 ddrvssh2ndcompen   30     Enable second comparator (ZBB mode)
    // 	 comp high bwen     31     Improve comparator performance to support low digital
    // voltage range 
    // 	
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl1 : 8;
    //
    // DQ TxEq setting selection to achieve constant EQ
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX dqtxeqsel : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSP pad to the Vref nibble bus
    //         
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqspvrefpgen : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSN pad to the Vref nibble bus
    //         
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX dqsnvrefpgen : 1;
    //
    //  
    //          If set to 0 (default), Vref generators selected through RxVrefSel[3:0]
    // are always on. 
    //          If set to 1, Vref generators are switched off while in Self Refresh.
    //         
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX vrefpwrsave : 1;
    //
    // Per-bit Enable connection to share Vref Bus
    // 
    // Bits[16:13], RW_L, default = 0x8
    //
    UINTX vreftonblbus : 4;
    //
    // Per Bit Verf generator Enable
    // 
    // Bits[20:17], RW_L, default = 0xF
    //
    UINTX rxvrefsel : 4;
    //
    // RefPiClkDelay
    // 
    // Bits[26:21], RW_L, default = 0x0
    //
    UINTX refpiclkdelay : 6;
    //
    // FNV Slave Delay Line Bypass Enable
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX fnvcrsdlbypassen : 1;
    //
    // FNV DLL Bypass Enable 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX fnvcrdllbypassen : 1;
    //
    // FNV Visa Fub Enable - data fub used for VISA if asserted 
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX fnvcrvisaen : 1;
    //
    // Enable write crc mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX writecrcenable : 1;
    //
    // This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
  } Bits;
  UINTX Data;
} DATACONTROL4N0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK1SELN0_4_DDRIOLO_REG                        0x00000CD0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor1 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr1d0 : 3;
    //
    // xtalk aggressor1 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr1d1 : 3;
    //
    // xtalk aggressor1 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr1d2 : 3;
    //
    // xtalk aggressor1 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr1d3 : 3;
    //
    // xtalk aggressor1 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr1d4 : 3;
    //
    // xtalk aggressor1 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr1d5 : 3;
    //
    // xtalk aggressor1 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr1d6 : 3;
    //
    // xtalk aggressor1 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr1d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK1SELN0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA0N0_4_DDRIOLO_REG                         0x00000CD4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp DrvUp Comp Value can be overriden via message channel if periodical
    // retrain is disable  
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Data Rcomp DrvDown Comp Value
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // VT Comp Values
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Data TCO Comp Value.
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Data Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} COMPDATA0N0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA1N0_4_DDRIOLO_REG                         0x00000CD8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp OdtUp Comp Value 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Data Rcomp Odt-Down Comp Value
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[21:12], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[31:22], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} COMPDATA1N0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETTRAINN0_4_DDRIOLO_REG                   0x00000CDC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained RxRcvEn Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcvenoffset : 6;
    //
    // Offset added to Trained Rx DQS Value.
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX rxdqsoffset : 7;
    //
    // Offset added to Trained Tx DQ Value.
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX txdqoffset : 6;
    //
    // Ooffset added to Trained Tx DQS Value.
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX txdqsoffset : 6;
    //
    // 2s Compliment offset added to Trained Vref Value.  Positive number increases Vref,
    // and each step is Vdd/384. 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX vrefoffset : 7;
  } Bits;
  UINTX Data;
} DATAOFFSETTRAINN0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETCOMPN0_4_DDRIOLO_REG                    0x00000CE0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2s Compliment offset added to DQ Drv-Up Comp Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX dqdrvupcompoffset : 6;
    //
    // 2s Compliment offset added to DQ Drv-Down Comp Value.
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX dqdrvdowncompoffset : 6;
    //
    // 2s Compliment offset added to DQ Odt-Up Comp Value.
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX dqodtupcompoffset : 5;
    //
    // 2s Compliment offset added to DQ Odt-Down Value.
    // 
    // Bits[21:17], RW_L, default = 0x0
    //
    UINTX dqodtdowncompoffset : 5;
    //
    // 2s Compliment offset added to DQ Tco Comp Value.
    // 
    // Bits[26:22], RW_L, default = 0x0
    //
    UINTX dqtcocompoffset : 5;
    //
    // 2s Compliment offset added to DQ Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX dqslewratecompoffset : 5;
  } Bits;
  UINTX Data;
} DATAOFFSETCOMPN0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK0SELN0_4_DDRIOLO_REG                        0x00000CE4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor0 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr0d0 : 3;
    //
    // xtalk aggressor0 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr0d1 : 3;
    //
    // xtalk aggressor0 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr0d2 : 3;
    //
    // xtalk aggressor0 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr0d3 : 3;
    //
    // xtalk aggressor0 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr0d4 : 3;
    //
    // xtalk aggressor0 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr0d5 : 3;
    //
    // xtalk aggressor0 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr0d6 : 3;
    //
    // xtalk aggressor0 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr0d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK0SELN0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N0_4_DDRIOLO_REG                      0x00000CE8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables Read DqDqs Training Mode
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX rxtrainingmode : 1;
    //
    // Enables Write Leveling Training Mode
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wltrainingmode : 1;
    //
    // Enables Read Leveling Training Mode.
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX rltrainingmode : 1;
    //
    // Enables SenseAmp offset cancellation training mode.
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX senseamptrainingmode : 1;
    //
    // When set, forces DQ/DQS drive enable to active.  Used in power measurements and
    // IO loopback mode  
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Power-down Disable:  Forces register file read, overriding the rank power down
    // logic. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rfon : 1;
    //
    // Power-down Disable:  Forces RxDqs PI clocks on.
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX rxpion : 1;
    //
    // Power-down Disable:  Forces TxDq and TxDqs PI clocks on.
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txpion : 1;
    //
    // 
    //           Forces on master DLL and all PI enables ON, despite both channel in
    // SelfRefresh, etc. low power states. 
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX internalclockson : 1;
    //
    // SaOffsetTrainTxon
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // Power-down:  All write commands are ignored for this data-byte.  Used in single-channel
    // MCI mode. 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX txdisable : 1;
    //
    // Power-down:  All read commands are ignored for this data-byte.  Used in single-channel
    // MCI mode.  
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX rxdisable : 1;
    //
    // Sets the duration of the first transmitted DQ bit of the burst. 0=1UI, 1=2UI.
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX txlong : 1;
    //
    // Controls the RX DQS CTLE setting.  (Code, CTLE) = { (0x0, Off),  (0x1, Use DQ),
    //  (0x2, BandPass),  (0x3, RSVD) }  
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX rxdqsctle : 2;
    //
    // Sets the RX read pointer offset on a reset.  Used during loopback and BERT mode.
    //  WrPtrPh1/WrPtrPh2 is reset to RxRdPt 
    // r (Default is to reset both to 0).
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX rxreadpointer : 3;
    //
    // Controls which segements of the driver are enabled:  {0: All, 1: Only ODT}.
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX driversegmentenable : 1;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a read c 
    // ommand to Rank = ReadRFRank
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX readrfrd : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a write  
    // command to Rank = ReadRFRank
    // 
    // Bits[21:21], RW_LV, default = 0x0
    //
    UINTX readrfwr : 1;
    //
    // Specifies the rank that ReadRFRd or ReadRFWr will manually download the CR values
    // from 
    // 
    // Bits[24:22], RW_LV, default = 0x0
    //
    UINTX readrfrank : 3;
    //
    // ODT is forced-on.
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // ODT and Senseamp are forced-off.
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsampoff : 1;
    //
    // not used
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disableodtstatic : 1;
    //
    // force ODT to the transmitter on, regardless of state of DriveEnable
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX ddrcrforceodton : 1;
    //
    // spare
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
    //
    // Enables long preamble for DDR4 devices
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX longpreambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL0N0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N0_4_DDRIOLO_REG                      0x00000CEC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable phase shift based crosstalk cancellation.
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX xtalkpienable : 1;
    //
    // select if 0: capacitive coupling; or 1: inductive coupling; xtalk dominant
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX xtalkpisign : 1;
    //
    // delta phase shift in one aggressor is in effect
    // 
    // Bits[4:2], RW_L, default = 0x0
    //
    UINTX xtalkpidelta : 3;
    //
    // reserved
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX burstlength10 : 1;
    //
    // Enable DLL Weak Lock to save power during CKE power down: {0: Disabled, 1: Enable}
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // IOT mode 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX iolbmodeen : 1;
    //
    // Controls which slave DLL are disabled: {0: nibble0, 1: nibble1, 2: not used}
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX sdlldisable : 1;
    //
    // not used
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // Controls the Current and BW of the Receiver: {0: 0.34Idll, 1: 0.66Idll, 2: 0.88Idll,
    // 3: Idll, 4: 1.33Idll, 5: 1.66Idll 
    // , 6: 2.00Idll, 7: 2.33Idll}
    // 
    // Bits[12:10], RW_L, default = 0x0
    //
    UINTX rxbiasctl : 3;
    //
    // Controls ODT turn-on delay.   To turn on N tQCK before RcvEn, program to RcvEn[8:6]
    //  N + 4. 
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX odtdelay : 4;
    //
    // Controls the ODT ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7, 18
    // tQCK) 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX odtduration : 3;
    //
    // Controls Senseamp turn-on delay.   To turn on N tQCK before RcvEn, program to
    // RcvEn[8:6]  N + 4. 
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX senseampdelay : 4;
    //
    // Controls the SenseAmp ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7,
    // 18 tQCK) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX senseampduration : 3;
    //
    // Cycles after the burst, when the current pulse should turn on by enabling OdtEn
    // for 1 cycle 
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX burstendodtdelay : 3;
    //
    // low voltage mode (ddr3lv, ddr3u, ddr4, smi, etc.)
    //             00: ddr3
    //             01: ddr3lv_smi
    //             10: ddr3u
    //             11: ddr4
    //         
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
  } Bits;
  UINTX Data;
} DATACONTROL1N0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N0_4_DDRIOLO_REG                      0x00000CF0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables SenseAmp offset cancellation training mode
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX rxvocselqnnnh : 5;
    //
    // Force on the internal Vref and Rx bias circuit, regardless of any other power
    // downs 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX forcebiason : 1;
    //
    // Force on the RxAmp only (as opposed to OdtSampOn, which turns on both ODT and
    // the amplifier). 
    //         Use for overclocking support where we may not be able to hit the fast
    // exit latency  
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX forcerxon : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // legacy from BDX for DDR3/VMSE configs"  DDRCOMP_CR_DDRCRCOMPOVR CTTermination
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Imode Select, 0: Swing Boost Mode; 1: (not supported) Xtalk Cancellation Mode
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX imodecfg : 1;
    //
    // Enable Imode EQ per byte lane. 
    //           0: Imode completely off 
    //           1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX imodeenable : 1;
    //
    // Spare
    // 
    // Bits[14:11], RW_L, default = 0x0
    //
    UINTX spare : 4;
    //
    // tbd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasen : 1;
    //
    // Spare1
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Binary Imode Coefficient, sets Imode current strength.
    //           (used for either Xtalk cancellation or swing boost)
    //           Code   Imode Current (approx)
    //           ------------------
    //           0000        0
    //           0001        1
    //           0010        2
    //             *
    //             *
    //             *
    //           1111        3
    // 
    // Bits[21:18], RW_L, default = 0x0
    //
    UINTX imodeeqcode : 4;
    //
    // Imode Scomp Override Enable
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX imodescompovrd : 1;
    //
    // strobe Rx Amp offset control
    // 
    // Bits[27:23], RW_L, default = 0xF
    //
    UINTX rxdqssaoffset : 5;
    //
    // disable the offset control in DQ and DQS RxAmp
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX rxoffsetdisable : 1;
    //
    // VMSE Logic Delay
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vmselogicdelay : 1;
    //
    // Spare2
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xoverdlyadj : 1;
  } Bits;
  UINTX Data;
} DATACONTROL2N0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N0_4_DDRIOLO_REG                      0x00000CF4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // binary default setting for static legs in DRV mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX drvstaticlegcfg : 2;
    //
    // binary default setting for static legs in ODT mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX odtstaticlegcfg : 2;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // not use
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rxdqssadisableshort : 1;
    //
    // This will tell which  segments are enabled out of reset.  
    //                      After that, a shift register will determine the enabled segments
    // 
    // Bits[8:6], RW_L, default = 0x1
    //
    UINTX odtsegmentenable : 3;
    //
    // This will tell which  segments are enabled out of reset. 
    // 
    // Bits[11:9], RW_L, default = 0x1
    //
    UINTX datasegmentenable : 3;
    //
    // When set, it will extends ODT by 1 qclk on read to write turnarounds. hsd 230773
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX longodtr2w : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // imodebias control 
    // 
    // Bits[14:14], RW_L, default = 0x1
    //
    UINTX imodebiasvrefen : 1;
    //
    // imodebias control. Also used for rxbiasana 
    // 
    // Bits[17:15], RW_L, default = 0x1
    //
    UINTX imodebiasrxbiastrim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // imodebias control 
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX imodebiasdfxddr4legup : 1;
    //
    // imodebias control 
    // 
    // Bits[20:20], RW_L, default = 0x1
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // ctle capacitor setting 
    // 
    // Bits[22:21], RW_L, default = 0x0
    //
    UINTX ddrcrctlecapen : 2;
    //
    // ctle resistor setting 
    // 
    // Bits[24:23], RW_L, default = 0x3
    //
    UINTX ddrcrctleresen : 2;
    //
    // RxBias CR 
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX pcasbiasclosedloopen : 1;
    //
    // RxBias CR 
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // RxBias CR 
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX rxbiasfoldedlegtrim : 2;
    //
    // RxBias CR 
    // 
    // Bits[30:29], RW_L, default = 0x1
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Spare
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX postambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL3N0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN0_4_DDRIOLO_REG                0x00000CF8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description: 
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode			
    //         PanicVoltage	 21:18  Unsigned integer controlling the voltage error on
    // VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking 
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADCN0_4_DDRIOLO_REG                   0x00000CFC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADCN0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK0_4_DDRIOLO_REG                     0x00000D00
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK1_4_DDRIOLO_REG                     0x00000D04
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK2_4_DDRIOLO_REG                     0x00000D08
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK2_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK3_4_DDRIOLO_REG                     0x00000D0C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK3_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK4_4_DDRIOLO_REG                     0x00000D10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK4_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK5_4_DDRIOLO_REG                     0x00000D14
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK5_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK6_4_DDRIOLO_REG                     0x00000D18
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK6_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK7_4_DDRIOLO_REG                     0x00000D1C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK7_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK0_4_DDRIOLO_REG                     0x00000D20
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK1_4_DDRIOLO_REG                     0x00000D24
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK2_4_DDRIOLO_REG                     0x00000D28
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK2_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK3_4_DDRIOLO_REG                     0x00000D2C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK3_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK4_4_DDRIOLO_REG                     0x00000D30
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK4_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK5_4_DDRIOLO_REG                     0x00000D34
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK5_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK6_4_DDRIOLO_REG                     0x00000D38
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK6_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK7_4_DDRIOLO_REG                     0x00000D3C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK7_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK0_4_DDRIOLO_REG                     0x00000D40
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the four clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK1_4_DDRIOLO_REG                     0x00000D44
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the four clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK2_4_DDRIOLO_REG                     0x00000D48
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK2_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK3_4_DDRIOLO_REG                     0x00000D4C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK3_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK4_4_DDRIOLO_REG                     0x00000D50
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // select one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK4_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK5_4_DDRIOLO_REG                     0x00000D54
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK5_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK6_4_DDRIOLO_REG                     0x00000D58
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK6_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK7_4_DDRIOLO_REG                     0x00000D5C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK7_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK0_4_DDRIOLO_REG                     0x00000D60
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK1_4_DDRIOLO_REG                     0x00000D64
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK2_4_DDRIOLO_REG                     0x00000D68
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK2_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK3_4_DDRIOLO_REG                     0x00000D6C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK3_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK4_4_DDRIOLO_REG                     0x00000D70
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK4_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK5_4_DDRIOLO_REG                     0x00000D74
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK5_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK6_4_DDRIOLO_REG                     0x00000D78
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK6_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK7_4_DDRIOLO_REG                     0x00000D7C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK7_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK0_4_DDRIOLO_REG                     0x00000D80
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK0_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK1_4_DDRIOLO_REG                     0x00000D84
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK2_4_DDRIOLO_REG                     0x00000D88
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK2_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK3_4_DDRIOLO_REG                     0x00000D8C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK3_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK4_4_DDRIOLO_REG                     0x00000D90
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK4_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK5_4_DDRIOLO_REG                     0x00000D94
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK5_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK6_4_DDRIOLO_REG                     0x00000D98
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK6_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK7_4_DDRIOLO_REG                     0x00000D9C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK7_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXXTALKN1_4_DDRIOLO_REG                           0x00000DA0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Coefficent for bit[0] of the DQ byte 
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank0 : 4;
    //
    // Coefficent for bit[1] of the DQ byte 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank1 : 4;
    //
    // Coefficent for bit[2] of the DQ byte
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank2 : 4;
    //
    // Coefficent for bit[3] of the DQ byte 
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank3 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 4
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank4 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 5
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank5 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 6
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank6 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 7
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank7 : 4;
  } Bits;
  UINTX Data;
} TXXTALKN1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN1_4_DDRIOLO_REG                        0x00000DA4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit Rx Vref Control
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX vrefperbit0 : 7;
    //
    // Rsvd
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX halflsben0 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[14:8], RW_L, default = 0x0
    //
    UINTX vrefperbit1 : 7;
    //
    // Rsvd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX halflsben1 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[22:16], RW_L, default = 0x0
    //
    UINTX vrefperbit2 : 7;
    //
    // Rsvd
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX halflsben2 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[30:24], RW_L, default = 0x0
    //
    UINTX vrefperbit3 : 7;
    //
    // shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX halflsben3 : 1;
  } Bits;
  UINTX Data;
} RXVREFCTRLN1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATATRAINFEEDBACKN1_4_DDRIOLO_REG                 0x00000DA8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Training Feedback Storage
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX datatrainfeedback : 9;
    //
    // Spare
    // 
    // Bits[31:9], RW_L, default = 0x0
    //
    UINTX spare : 23;
  } Bits;
  UINTX Data;
} DATATRAINFEEDBACKN1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N1_4_DDRIOLO_REG                      0x00000DCC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Visa debug bus LCB for DATA fub
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    //  VssHi control bits
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------
    // 	 disoverflow        24     Disable overflow logic from BDW
    // 	 fast panic enable  25     Bypass 2 flops in panic path for faster panic response
    // 	 vsshivccd2by3cfgen 26     Forces the driver DAC to get supply from 2/3 vccd
    // 	 vsshivccd2by3cfg   27:29  Current trim setting for 2/3 vccd mode, 001 fast,
    // 011 typical, 111 slow silicon  
    // 	 ddrvssh2ndcompen   30     Enable second comparator (ZBB mode)
    // 	 comp high bwen     31     Improve comparator performance to support low digital
    // voltage range 
    // 	
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl1 : 8;
    //
    // DQ TxEq setting selection to achieve constant EQ
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX dqtxeqsel : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSP pad to the Vref nibble bus
    //         
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqspvrefpgen : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSN pad to the Vref nibble bus
    //         
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX dqsnvrefpgen : 1;
    //
    //  
    //          If set to 0 (default), Vref generators selected through RxVrefSel[3:0]
    // are always on. 
    //          If set to 1, Vref generators are switched off while in Self Refresh.
    //         
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX vrefpwrsave : 1;
    //
    // Per-bit Enable connection to share Vref Bus
    // 
    // Bits[16:13], RW_L, default = 0x8
    //
    UINTX vreftonblbus : 4;
    //
    // Per Bit Verf generator Enable
    // 
    // Bits[20:17], RW_L, default = 0xF
    //
    UINTX rxvrefsel : 4;
    //
    // RefPiClkDelay
    // 
    // Bits[26:21], RW_L, default = 0x0
    //
    UINTX refpiclkdelay : 6;
    //
    // FNV Slave Delay Line Bypass Enable
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX fnvcrsdlbypassen : 1;
    //
    // FNV DLL Bypass Enable 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX fnvcrdllbypassen : 1;
    //
    // FNV Visa Fub Enable - data fub used for VISA if asserted 
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX fnvcrvisaen : 1;
    //
    // Enable write crc mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX writecrcenable : 1;
    //
    // This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
  } Bits;
  UINTX Data;
} DATACONTROL4N1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK1SELN1_4_DDRIOLO_REG                        0x00000DD0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor1 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr1d0 : 3;
    //
    // xtalk aggressor1 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr1d1 : 3;
    //
    // xtalk aggressor1 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr1d2 : 3;
    //
    // xtalk aggressor1 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr1d3 : 3;
    //
    // xtalk aggressor1 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr1d4 : 3;
    //
    // xtalk aggressor1 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr1d5 : 3;
    //
    // xtalk aggressor1 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr1d6 : 3;
    //
    // xtalk aggressor1 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr1d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK1SELN1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA0N1_4_DDRIOLO_REG                         0x00000DD4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp DrvUp Comp Value can be overriden via message channel if periodical
    // retrain is disable  
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Data Rcomp DrvDown Comp Value
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // VT Comp Values
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Data TCO Comp Value.
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Data Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} COMPDATA0N1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA1N1_4_DDRIOLO_REG                         0x00000DD8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp OdtUp Comp Value 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Data Rcomp Odt-Down Comp Value
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[21:12], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[31:22], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} COMPDATA1N1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETTRAINN1_4_DDRIOLO_REG                   0x00000DDC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained RxRcvEn Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcvenoffset : 6;
    //
    // Offset added to Trained Rx DQS Value.
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX rxdqsoffset : 7;
    //
    // Offset added to Trained Tx DQ Value.
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX txdqoffset : 6;
    //
    // Ooffset added to Trained Tx DQS Value.
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX txdqsoffset : 6;
    //
    // 2s Compliment offset added to Trained Vref Value.  Positive number increases Vref,
    // and each step is Vdd/384. 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX vrefoffset : 7;
  } Bits;
  UINTX Data;
} DATAOFFSETTRAINN1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETCOMPN1_4_DDRIOLO_REG                    0x00000DE0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2s Compliment offset added to DQ Drv-Up Comp Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX dqdrvupcompoffset : 6;
    //
    // 2s Compliment offset added to DQ Drv-Down Comp Value.
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX dqdrvdowncompoffset : 6;
    //
    // 2s Compliment offset added to DQ Odt-Up Comp Value.
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX dqodtupcompoffset : 5;
    //
    // 2s Compliment offset added to DQ Odt-Down Value.
    // 
    // Bits[21:17], RW_L, default = 0x0
    //
    UINTX dqodtdowncompoffset : 5;
    //
    // 2s Compliment offset added to DQ Tco Comp Value.
    // 
    // Bits[26:22], RW_L, default = 0x0
    //
    UINTX dqtcocompoffset : 5;
    //
    // 2s Compliment offset added to DQ Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX dqslewratecompoffset : 5;
  } Bits;
  UINTX Data;
} DATAOFFSETCOMPN1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK0SELN1_4_DDRIOLO_REG                        0x00000DE4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor0 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr0d0 : 3;
    //
    // xtalk aggressor0 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr0d1 : 3;
    //
    // xtalk aggressor0 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr0d2 : 3;
    //
    // xtalk aggressor0 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr0d3 : 3;
    //
    // xtalk aggressor0 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr0d4 : 3;
    //
    // xtalk aggressor0 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr0d5 : 3;
    //
    // xtalk aggressor0 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr0d6 : 3;
    //
    // xtalk aggressor0 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr0d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK0SELN1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N1_4_DDRIOLO_REG                      0x00000DE8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables Read DqDqs Training Mode
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX rxtrainingmode : 1;
    //
    // Enables Write Leveling Training Mode
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wltrainingmode : 1;
    //
    // Enables Read Leveling Training Mode.
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX rltrainingmode : 1;
    //
    // Enables SenseAmp offset cancellation training mode.
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX senseamptrainingmode : 1;
    //
    // When set, forces DQ/DQS drive enable to active.  Used in power measurements and
    // IO loopback mode  
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Power-down Disable:  Forces register file read, overriding the rank power down
    // logic. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rfon : 1;
    //
    // Power-down Disable:  Forces RxDqs PI clocks on.
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX rxpion : 1;
    //
    // Power-down Disable:  Forces TxDq and TxDqs PI clocks on.
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txpion : 1;
    //
    // 
    //           Forces on master DLL and all PI enables ON, despite both channel in
    // SelfRefresh, etc. low power states. 
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX internalclockson : 1;
    //
    // SaOffsetTrainTxon
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // Power-down:  All write commands are ignored for this data-byte.  Used in single-channel
    // MCI mode. 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX txdisable : 1;
    //
    // Power-down:  All read commands are ignored for this data-byte.  Used in single-channel
    // MCI mode.  
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX rxdisable : 1;
    //
    // Sets the duration of the first transmitted DQ bit of the burst. 0=1UI, 1=2UI.
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX txlong : 1;
    //
    // Controls the RX DQS CTLE setting.  (Code, CTLE) = { (0x0, Off),  (0x1, Use DQ),
    //  (0x2, BandPass),  (0x3, RSVD) }  
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX rxdqsctle : 2;
    //
    // Sets the RX read pointer offset on a reset.  Used during loopback and BERT mode.
    //  WrPtrPh1/WrPtrPh2 is reset to RxRdPt 
    // r (Default is to reset both to 0).
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX rxreadpointer : 3;
    //
    // Controls which segements of the driver are enabled:  {0: All, 1: Only ODT}.
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX driversegmentenable : 1;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a read c 
    // ommand to Rank = ReadRFRank
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX readrfrd : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a write  
    // command to Rank = ReadRFRank
    // 
    // Bits[21:21], RW_LV, default = 0x0
    //
    UINTX readrfwr : 1;
    //
    // Specifies the rank that ReadRFRd or ReadRFWr will manually download the CR values
    // from 
    // 
    // Bits[24:22], RW_LV, default = 0x0
    //
    UINTX readrfrank : 3;
    //
    // ODT is forced-on.
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // ODT and Senseamp are forced-off.
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsampoff : 1;
    //
    // not used
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disableodtstatic : 1;
    //
    // force ODT to the transmitter on, regardless of state of DriveEnable
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX ddrcrforceodton : 1;
    //
    // spare
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
    //
    // Enables long preamble for DDR4 devices
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX longpreambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL0N1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N1_4_DDRIOLO_REG                      0x00000DEC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable phase shift based crosstalk cancellation.
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX xtalkpienable : 1;
    //
    // select if 0: capacitive coupling; or 1: inductive coupling; xtalk dominant
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX xtalkpisign : 1;
    //
    // delta phase shift in one aggressor is in effect
    // 
    // Bits[4:2], RW_L, default = 0x0
    //
    UINTX xtalkpidelta : 3;
    //
    // reserved
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX burstlength10 : 1;
    //
    // Enable DLL Weak Lock to save power during CKE power down: {0: Disabled, 1: Enable}
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // IOT mode 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX iolbmodeen : 1;
    //
    // Controls which slave DLL are disabled: {0: nibble0, 1: nibble1, 2: not used}
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX sdlldisable : 1;
    //
    // not used
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // Controls the Current and BW of the Receiver: {0: 0.34Idll, 1: 0.66Idll, 2: 0.88Idll,
    // 3: Idll, 4: 1.33Idll, 5: 1.66Idll 
    // , 6: 2.00Idll, 7: 2.33Idll}
    // 
    // Bits[12:10], RW_L, default = 0x0
    //
    UINTX rxbiasctl : 3;
    //
    // Controls ODT turn-on delay.   To turn on N tQCK before RcvEn, program to RcvEn[8:6]
    //  N + 4. 
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX odtdelay : 4;
    //
    // Controls the ODT ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7, 18
    // tQCK) 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX odtduration : 3;
    //
    // Controls Senseamp turn-on delay.   To turn on N tQCK before RcvEn, program to
    // RcvEn[8:6]  N + 4. 
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX senseampdelay : 4;
    //
    // Controls the SenseAmp ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7,
    // 18 tQCK) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX senseampduration : 3;
    //
    // Cycles after the burst, when the current pulse should turn on by enabling OdtEn
    // for 1 cycle 
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX burstendodtdelay : 3;
    //
    // low voltage mode (ddr3lv, ddr3u, ddr4, smi, etc.)
    //             00: ddr3
    //             01: ddr3lv_smi
    //             10: ddr3u
    //             11: ddr4
    //         
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
  } Bits;
  UINTX Data;
} DATACONTROL1N1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N1_4_DDRIOLO_REG                      0x00000DF0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables SenseAmp offset cancellation training mode
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX rxvocselqnnnh : 5;
    //
    // Force on the internal Vref and Rx bias circuit, regardless of any other power
    // downs 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX forcebiason : 1;
    //
    // Force on the RxAmp only (as opposed to OdtSampOn, which turns on both ODT and
    // the amplifier). 
    //         Use for overclocking support where we may not be able to hit the fast
    // exit latency  
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX forcerxon : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // legacy from BDX for DDR3/VMSE configs"  DDRCOMP_CR_DDRCRCOMPOVR CTTermination
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Imode Select, 0: Swing Boost Mode; 1: (not supported) Xtalk Cancellation Mode
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX imodecfg : 1;
    //
    // Enable Imode EQ per byte lane. 
    //           0: Imode completely off 
    //           1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX imodeenable : 1;
    //
    // Spare
    // 
    // Bits[14:11], RW_L, default = 0x0
    //
    UINTX spare : 4;
    //
    // tbd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasen : 1;
    //
    // Spare1
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Binary Imode Coefficient, sets Imode current strength.
    //           (used for either Xtalk cancellation or swing boost)
    //           Code   Imode Current (approx)
    //           ------------------
    //           0000        0
    //           0001        1
    //           0010        2
    //             *
    //             *
    //             *
    //           1111        3
    // 
    // Bits[21:18], RW_L, default = 0x0
    //
    UINTX imodeeqcode : 4;
    //
    // Imode Scomp Override Enable
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX imodescompovrd : 1;
    //
    // strobe Rx Amp offset control
    // 
    // Bits[27:23], RW_L, default = 0xF
    //
    UINTX rxdqssaoffset : 5;
    //
    // disable the offset control in DQ and DQS RxAmp
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX rxoffsetdisable : 1;
    //
    // VMSE Logic Delay
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vmselogicdelay : 1;
    //
    // Spare2
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xoverdlyadj : 1;
  } Bits;
  UINTX Data;
} DATACONTROL2N1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N1_4_DDRIOLO_REG                      0x00000DF4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // binary default setting for static legs in DRV mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX drvstaticlegcfg : 2;
    //
    // binary default setting for static legs in ODT mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX odtstaticlegcfg : 2;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // not use
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rxdqssadisableshort : 1;
    //
    // This will tell which  segments are enabled out of reset.  
    //                      After that, a shift register will determine the enabled segments
    // 
    // Bits[8:6], RW_L, default = 0x1
    //
    UINTX odtsegmentenable : 3;
    //
    // This will tell which  segments are enabled out of reset. 
    // 
    // Bits[11:9], RW_L, default = 0x1
    //
    UINTX datasegmentenable : 3;
    //
    // When set, it will extends ODT by 1 qclk on read to write turnarounds. hsd 230773
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX longodtr2w : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // imodebias control 
    // 
    // Bits[14:14], RW_L, default = 0x1
    //
    UINTX imodebiasvrefen : 1;
    //
    // imodebias control. Also used for rxbiasana 
    // 
    // Bits[17:15], RW_L, default = 0x1
    //
    UINTX imodebiasrxbiastrim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // imodebias control 
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX imodebiasdfxddr4legup : 1;
    //
    // imodebias control 
    // 
    // Bits[20:20], RW_L, default = 0x1
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // ctle capacitor setting 
    // 
    // Bits[22:21], RW_L, default = 0x0
    //
    UINTX ddrcrctlecapen : 2;
    //
    // ctle resistor setting 
    // 
    // Bits[24:23], RW_L, default = 0x3
    //
    UINTX ddrcrctleresen : 2;
    //
    // RxBias CR 
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX pcasbiasclosedloopen : 1;
    //
    // RxBias CR 
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // RxBias CR 
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX rxbiasfoldedlegtrim : 2;
    //
    // RxBias CR 
    // 
    // Bits[30:29], RW_L, default = 0x1
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Spare
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX postambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL3N1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN1_4_DDRIOLO_REG                0x00000DF8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description: 
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode			
    //         PanicVoltage	 21:18  Unsigned integer controlling the voltage error on
    // VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking 
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADCN1_4_DDRIOLO_REG                   0x00000DFC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADCN1_4_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK0_5_DDRIOLO_REG                     0x00000E00
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS (0: 1/16 UI
    // offset,  
    //           1: 3/16 UI Offset, 2: 5/16 UI Offsets, 3: 7/16 UI Offsets, 4: 9/16 UI
    // Offsets, 5,6,7: 11/16 UI Offsets.) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK1_5_DDRIOLO_REG                     0x00000E04
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK2_5_DDRIOLO_REG                     0x00000E08
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK2_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK3_5_DDRIOLO_REG                     0x00000E0C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK3_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK4_5_DDRIOLO_REG                     0x00000E10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK4_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK5_5_DDRIOLO_REG                     0x00000E14
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // mux select for crossover from ClkPiRef to CkPi4RcvEn, used in xover2to2 mode
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK5_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK6_5_DDRIOLO_REG                     0x00000E18
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK6_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK7_5_DDRIOLO_REG                     0x00000E1C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK7_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK0_5_DDRIOLO_REG                     0x00000E20
#ifndef ASM_INC
typedef union {
  struct {
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK1_5_DDRIOLO_REG                     0x00000E24
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK2_5_DDRIOLO_REG                     0x00000E28
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK2_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK3_5_DDRIOLO_REG                     0x00000E2C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK3_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK4_5_DDRIOLO_REG                     0x00000E30
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK4_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK5_5_DDRIOLO_REG                     0x00000E34
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK5_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK6_5_DDRIOLO_REG                     0x00000E38
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK6_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK7_5_DDRIOLO_REG                     0x00000E3C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK7_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK0_5_DDRIOLO_REG                     0x00000E40
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // select one of the four DQ Clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK1_5_DDRIOLO_REG                     0x00000E44
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK2_5_DDRIOLO_REG                     0x00000E48
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK2_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK3_5_DDRIOLO_REG                     0x00000E4C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK3_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK4_5_DDRIOLO_REG                     0x00000E50
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK4_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK5_5_DDRIOLO_REG                     0x00000E54
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK5_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK6_5_DDRIOLO_REG                     0x00000E58
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK6_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK7_5_DDRIOLO_REG                     0x00000E5C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK7_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK0_5_DDRIOLO_REG                     0x00000E60
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte. 0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK1_5_DDRIOLO_REG                     0x00000E64
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK2_5_DDRIOLO_REG                     0x00000E68
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK2_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK3_5_DDRIOLO_REG                     0x00000E6C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK3_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK4_5_DDRIOLO_REG                     0x00000E70
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK4_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK5_5_DDRIOLO_REG                     0x00000E74
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK5_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK6_5_DDRIOLO_REG                     0x00000E78
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK6_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK7_5_DDRIOLO_REG                     0x00000E7C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK7_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK0_5_DDRIOLO_REG                     0x00000E80
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // selects which skewed DQSP (to sample even bits) is used in the RX FIFO. For proper
    // operation, always pick latest DQSP 
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // selects which skewed DQSN (to sample odd bits) is used in the RX FIFO. For proper
    // operation, always pick latest DQSN 
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK1_5_DDRIOLO_REG                     0x00000E84
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK2_5_DDRIOLO_REG                     0x00000E88
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK2_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK3_5_DDRIOLO_REG                     0x00000E8C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK3_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK4_5_DDRIOLO_REG                     0x00000E90
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK4_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK5_5_DDRIOLO_REG                     0x00000E94
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK5_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK6_5_DDRIOLO_REG                     0x00000E98
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK6_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK7_5_DDRIOLO_REG                     0x00000E9C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK7_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXXTALKN0_5_DDRIOLO_REG                           0x00000EA0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 0
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank0 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 1 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank1 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 2
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank2 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 3 
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank3 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 4
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank4 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 5
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank5 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 6
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank6 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 7
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank7 : 4;
  } Bits;
  UINTX Data;
} TXXTALKN0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN0_5_DDRIOLO_REG                        0x00000EA4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit Rx Vref Control
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX vrefperbit0 : 7;
    //
    // Rsvd
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX halflsben0 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[14:8], RW_L, default = 0x0
    //
    UINTX vrefperbit1 : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX halflsben1 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[22:16], RW_L, default = 0x0
    //
    UINTX vrefperbit2 : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX halflsben2 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[30:24], RW_L, default = 0x0
    //
    UINTX vrefperbit3 : 7;
    //
    // shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX halflsben3 : 1;
  } Bits;
  UINTX Data;
} RXVREFCTRLN0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATATRAINFEEDBACKN0_5_DDRIOLO_REG                 0x00000EA8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Training Feedback Storage
    // 
    //         DataTrainFeedback Description:
    //          Training Step    Bits    Nibble    Description
    //         --------------    ----    -------  --------------------------------------------------------------------------------------------------------------------------------------------------------
    //         Cross Over Cal     0      0        Tx Dqs Phase Detection
    //         Cross Over Cal     1      0        Tx Dq Phase Detection
    //         Cross Over Cal     2      0        Rec En Phase Detection
    //         RcvEn              8:0    0        Byte detection
    //         Rx Dq-Dqs          0      0        Pass/fail
    //         Wr Leveling        8:0    0        Byte detection
    // 
    //         Cross Over Cal     3      1        Tx Dqs Phase Detection
    //         Cross Over Cal     4      1        Tx Dq Phase Detection
    //         Cross Over Cal     5      1        Rec En Phase Detection
    //         RcvEn             17:9    1        Byte detection
    //         Rx Dq-Dqs          1      1        Pass/fail
    //         Wr Leveling       17:9    1        Byte detection
    //         
    // 
    // Bits[17:0], RW_L, default = 0x0
    //
    UINTX datatrainfeedback : 18;
    //
    // Spare
    // 
    // Bits[31:18], RW_L, default = 0x0
    //
    UINTX spare : 14;
  } Bits;
  UINTX Data;
} DATATRAINFEEDBACKN0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N0_5_DDRIOLO_REG                      0x00000ECC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Visa debug bus LCB for DATA fub
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    //  VssHi control bits
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------
    // 	 disoverflow        24     Disable overflow logic from BDW
    // 	 fast panic enable  25     Bypass 2 flops in panic path for faster panic response
    // 	 vsshivccd2by3cfgen 26     Forces the driver DAC to get supply from 2/3 vccd
    // 	 vsshivccd2by3cfg   27:29  Current trim setting for 2/3 vccd mode, 001 fast,
    // 011 typical, 111 slow silicon  
    // 	 ddrvssh2ndcompen   30     Enable second comparator (ZBB mode)
    // 	 comp high bwen     31     Improve comparator performance to support low digital
    // voltage range 
    // 	
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl1 : 8;
    //
    // DQ TxEq setting selection to achieve constant EQ
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX dqtxeqsel : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSP pad to the Vref nibble bus
    //         
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqspvrefpgen : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSN pad to the Vref nibble bus
    //         
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX dqsnvrefpgen : 1;
    //
    //  
    //          If set to 0 (default), Vref generators selected through RxVrefSel[3:0]
    // are always on. 
    //          If set to 1, Vref generators are switched off while in Self Refresh.
    //         
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX vrefpwrsave : 1;
    //
    // Per-bit Enable connection to share Vref Bus
    // 
    // Bits[16:13], RW_L, default = 0x8
    //
    UINTX vreftonblbus : 4;
    //
    // Per Bit Verf generator Enable
    // 
    // Bits[20:17], RW_L, default = 0xF
    //
    UINTX rxvrefsel : 4;
    //
    // RefPiClkDelay
    // 
    // Bits[26:21], RW_L, default = 0x0
    //
    UINTX refpiclkdelay : 6;
    //
    // FNV Slave Delay Line Bypass Enable
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX fnvcrsdlbypassen : 1;
    //
    // FNV DLL Bypass Enable 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX fnvcrdllbypassen : 1;
    //
    // FNV Visa Fub Enable - data fub used for VISA if asserted 
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX fnvcrvisaen : 1;
    //
    // Enable write crc mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX writecrcenable : 1;
    //
    // This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
  } Bits;
  UINTX Data;
} DATACONTROL4N0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK1SELN0_5_DDRIOLO_REG                        0x00000ED0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor1 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr1d0 : 3;
    //
    // xtalk aggressor1 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr1d1 : 3;
    //
    // xtalk aggressor1 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr1d2 : 3;
    //
    // xtalk aggressor1 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr1d3 : 3;
    //
    // xtalk aggressor1 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr1d4 : 3;
    //
    // xtalk aggressor1 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr1d5 : 3;
    //
    // xtalk aggressor1 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr1d6 : 3;
    //
    // xtalk aggressor1 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr1d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK1SELN0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA0N0_5_DDRIOLO_REG                         0x00000ED4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp DrvUp Comp Value can be overriden via message channel if periodical
    // retrain is disable  
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Data Rcomp DrvDown Comp Value
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // VT Comp Values
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Data TCO Comp Value.
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Data Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} COMPDATA0N0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA1N0_5_DDRIOLO_REG                         0x00000ED8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp OdtUp Comp Value 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Data Rcomp Odt-Down Comp Value
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[21:12], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[31:22], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} COMPDATA1N0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETTRAINN0_5_DDRIOLO_REG                   0x00000EDC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained RxRcvEn Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcvenoffset : 6;
    //
    // Offset added to Trained Rx DQS Value.
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX rxdqsoffset : 7;
    //
    // Offset added to Trained Tx DQ Value.
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX txdqoffset : 6;
    //
    // Ooffset added to Trained Tx DQS Value.
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX txdqsoffset : 6;
    //
    // 2s Compliment offset added to Trained Vref Value.  Positive number increases Vref,
    // and each step is Vdd/384. 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX vrefoffset : 7;
  } Bits;
  UINTX Data;
} DATAOFFSETTRAINN0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETCOMPN0_5_DDRIOLO_REG                    0x00000EE0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2s Compliment offset added to DQ Drv-Up Comp Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX dqdrvupcompoffset : 6;
    //
    // 2s Compliment offset added to DQ Drv-Down Comp Value.
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX dqdrvdowncompoffset : 6;
    //
    // 2s Compliment offset added to DQ Odt-Up Comp Value.
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX dqodtupcompoffset : 5;
    //
    // 2s Compliment offset added to DQ Odt-Down Value.
    // 
    // Bits[21:17], RW_L, default = 0x0
    //
    UINTX dqodtdowncompoffset : 5;
    //
    // 2s Compliment offset added to DQ Tco Comp Value.
    // 
    // Bits[26:22], RW_L, default = 0x0
    //
    UINTX dqtcocompoffset : 5;
    //
    // 2s Compliment offset added to DQ Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX dqslewratecompoffset : 5;
  } Bits;
  UINTX Data;
} DATAOFFSETCOMPN0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK0SELN0_5_DDRIOLO_REG                        0x00000EE4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor0 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr0d0 : 3;
    //
    // xtalk aggressor0 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr0d1 : 3;
    //
    // xtalk aggressor0 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr0d2 : 3;
    //
    // xtalk aggressor0 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr0d3 : 3;
    //
    // xtalk aggressor0 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr0d4 : 3;
    //
    // xtalk aggressor0 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr0d5 : 3;
    //
    // xtalk aggressor0 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr0d6 : 3;
    //
    // xtalk aggressor0 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr0d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK0SELN0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N0_5_DDRIOLO_REG                      0x00000EE8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables Read DqDqs Training Mode
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX rxtrainingmode : 1;
    //
    // Enables Write Leveling Training Mode
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wltrainingmode : 1;
    //
    // Enables Read Leveling Training Mode.
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX rltrainingmode : 1;
    //
    // Enables SenseAmp offset cancellation training mode.
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX senseamptrainingmode : 1;
    //
    // When set, forces DQ/DQS drive enable to active.  Used in power measurements and
    // IO loopback mode  
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Power-down Disable:  Forces register file read, overriding the rank power down
    // logic. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rfon : 1;
    //
    // Power-down Disable:  Forces RxDqs PI clocks on.
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX rxpion : 1;
    //
    // Power-down Disable:  Forces TxDq and TxDqs PI clocks on.
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txpion : 1;
    //
    // 
    //           Forces on master DLL and all PI enables ON, despite both channel in
    // SelfRefresh, etc. low power states. 
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX internalclockson : 1;
    //
    // SaOffsetTrainTxon
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // Power-down:  All write commands are ignored for this data-byte.  Used in single-channel
    // MCI mode. 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX txdisable : 1;
    //
    // Power-down:  All read commands are ignored for this data-byte.  Used in single-channel
    // MCI mode.  
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX rxdisable : 1;
    //
    // Sets the duration of the first transmitted DQ bit of the burst. 0=1UI, 1=2UI.
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX txlong : 1;
    //
    // Controls the RX DQS CTLE setting.  (Code, CTLE) = { (0x0, Off),  (0x1, Use DQ),
    //  (0x2, BandPass),  (0x3, RSVD) }  
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX rxdqsctle : 2;
    //
    // Sets the RX read pointer offset on a reset.  Used during loopback and BERT mode.
    //  WrPtrPh1/WrPtrPh2 is reset to RxRdPt 
    // r (Default is to reset both to 0).
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX rxreadpointer : 3;
    //
    // Controls which segements of the driver are enabled:  {0: All, 1: Only ODT}.
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX driversegmentenable : 1;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a read c 
    // ommand to Rank = ReadRFRank
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX readrfrd : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a write  
    // command to Rank = ReadRFRank
    // 
    // Bits[21:21], RW_LV, default = 0x0
    //
    UINTX readrfwr : 1;
    //
    // Specifies the rank that ReadRFRd or ReadRFWr will manually download the CR values
    // from 
    // 
    // Bits[24:22], RW_LV, default = 0x0
    //
    UINTX readrfrank : 3;
    //
    // ODT is forced-on.
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // ODT and Senseamp are forced-off.
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsampoff : 1;
    //
    // not used
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disableodtstatic : 1;
    //
    // force ODT to the transmitter on, regardless of state of DriveEnable
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX ddrcrforceodton : 1;
    //
    // spare
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
    //
    // Enables long preamble for DDR4 devices
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX longpreambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL0N0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N0_5_DDRIOLO_REG                      0x00000EEC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable phase shift based crosstalk cancellation.
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX xtalkpienable : 1;
    //
    // select if 0: capacitive coupling; or 1: inductive coupling; xtalk dominant
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX xtalkpisign : 1;
    //
    // delta phase shift in one aggressor is in effect
    // 
    // Bits[4:2], RW_L, default = 0x0
    //
    UINTX xtalkpidelta : 3;
    //
    // reserved
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX burstlength10 : 1;
    //
    // Enable DLL Weak Lock to save power during CKE power down: {0: Disabled, 1: Enable}
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // IOT mode 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX iolbmodeen : 1;
    //
    // Controls which slave DLL are disabled: {0: nibble0, 1: nibble1, 2: not used}
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX sdlldisable : 1;
    //
    // not used
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // Controls the Current and BW of the Receiver: {0: 0.34Idll, 1: 0.66Idll, 2: 0.88Idll,
    // 3: Idll, 4: 1.33Idll, 5: 1.66Idll 
    // , 6: 2.00Idll, 7: 2.33Idll}
    // 
    // Bits[12:10], RW_L, default = 0x0
    //
    UINTX rxbiasctl : 3;
    //
    // Controls ODT turn-on delay.   To turn on N tQCK before RcvEn, program to RcvEn[8:6]
    //  N + 4. 
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX odtdelay : 4;
    //
    // Controls the ODT ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7, 18
    // tQCK) 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX odtduration : 3;
    //
    // Controls Senseamp turn-on delay.   To turn on N tQCK before RcvEn, program to
    // RcvEn[8:6]  N + 4. 
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX senseampdelay : 4;
    //
    // Controls the SenseAmp ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7,
    // 18 tQCK) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX senseampduration : 3;
    //
    // Cycles after the burst, when the current pulse should turn on by enabling OdtEn
    // for 1 cycle 
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX burstendodtdelay : 3;
    //
    // low voltage mode (ddr3lv, ddr3u, ddr4, smi, etc.)
    //             00: ddr3
    //             01: ddr3lv_smi
    //             10: ddr3u
    //             11: ddr4
    //         
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
  } Bits;
  UINTX Data;
} DATACONTROL1N0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N0_5_DDRIOLO_REG                      0x00000EF0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables SenseAmp offset cancellation training mode
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX rxvocselqnnnh : 5;
    //
    // Force on the internal Vref and Rx bias circuit, regardless of any other power
    // downs 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX forcebiason : 1;
    //
    // Force on the RxAmp only (as opposed to OdtSampOn, which turns on both ODT and
    // the amplifier). 
    //         Use for overclocking support where we may not be able to hit the fast
    // exit latency  
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX forcerxon : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // legacy from BDX for DDR3/VMSE configs"  DDRCOMP_CR_DDRCRCOMPOVR CTTermination
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Imode Select, 0: Swing Boost Mode; 1: (not supported) Xtalk Cancellation Mode
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX imodecfg : 1;
    //
    // Enable Imode EQ per byte lane. 
    //           0: Imode completely off 
    //           1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX imodeenable : 1;
    //
    // Spare
    // 
    // Bits[14:11], RW_L, default = 0x0
    //
    UINTX spare : 4;
    //
    // tbd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasen : 1;
    //
    // Spare1
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Binary Imode Coefficient, sets Imode current strength.
    //           (used for either Xtalk cancellation or swing boost)
    //           Code   Imode Current (approx)
    //           ------------------
    //           0000        0
    //           0001        1
    //           0010        2
    //             *
    //             *
    //             *
    //           1111        3
    // 
    // Bits[21:18], RW_L, default = 0x0
    //
    UINTX imodeeqcode : 4;
    //
    // Imode Scomp Override Enable
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX imodescompovrd : 1;
    //
    // strobe Rx Amp offset control
    // 
    // Bits[27:23], RW_L, default = 0xF
    //
    UINTX rxdqssaoffset : 5;
    //
    // disable the offset control in DQ and DQS RxAmp
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX rxoffsetdisable : 1;
    //
    // VMSE Logic Delay
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vmselogicdelay : 1;
    //
    // Spare2
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xoverdlyadj : 1;
  } Bits;
  UINTX Data;
} DATACONTROL2N0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N0_5_DDRIOLO_REG                      0x00000EF4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // binary default setting for static legs in DRV mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX drvstaticlegcfg : 2;
    //
    // binary default setting for static legs in ODT mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX odtstaticlegcfg : 2;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // not use
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rxdqssadisableshort : 1;
    //
    // This will tell which  segments are enabled out of reset.  
    //                      After that, a shift register will determine the enabled segments
    // 
    // Bits[8:6], RW_L, default = 0x1
    //
    UINTX odtsegmentenable : 3;
    //
    // This will tell which  segments are enabled out of reset. 
    // 
    // Bits[11:9], RW_L, default = 0x1
    //
    UINTX datasegmentenable : 3;
    //
    // When set, it will extends ODT by 1 qclk on read to write turnarounds. hsd 230773
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX longodtr2w : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // imodebias control 
    // 
    // Bits[14:14], RW_L, default = 0x1
    //
    UINTX imodebiasvrefen : 1;
    //
    // imodebias control. Also used for rxbiasana 
    // 
    // Bits[17:15], RW_L, default = 0x1
    //
    UINTX imodebiasrxbiastrim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // imodebias control 
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX imodebiasdfxddr4legup : 1;
    //
    // imodebias control 
    // 
    // Bits[20:20], RW_L, default = 0x1
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // ctle capacitor setting 
    // 
    // Bits[22:21], RW_L, default = 0x0
    //
    UINTX ddrcrctlecapen : 2;
    //
    // ctle resistor setting 
    // 
    // Bits[24:23], RW_L, default = 0x3
    //
    UINTX ddrcrctleresen : 2;
    //
    // RxBias CR 
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX pcasbiasclosedloopen : 1;
    //
    // RxBias CR 
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // RxBias CR 
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX rxbiasfoldedlegtrim : 2;
    //
    // RxBias CR 
    // 
    // Bits[30:29], RW_L, default = 0x1
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Spare
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX postambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL3N0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN0_5_DDRIOLO_REG                0x00000EF8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description: 
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode			
    //         PanicVoltage	 21:18  Unsigned integer controlling the voltage error on
    // VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking 
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADCN0_5_DDRIOLO_REG                   0x00000EFC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADCN0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK0_5_DDRIOLO_REG                     0x00000F00
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK1_5_DDRIOLO_REG                     0x00000F04
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK2_5_DDRIOLO_REG                     0x00000F08
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK2_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK3_5_DDRIOLO_REG                     0x00000F0C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK3_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK4_5_DDRIOLO_REG                     0x00000F10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK4_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK5_5_DDRIOLO_REG                     0x00000F14
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK5_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK6_5_DDRIOLO_REG                     0x00000F18
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK6_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK7_5_DDRIOLO_REG                     0x00000F1C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK7_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK0_5_DDRIOLO_REG                     0x00000F20
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK1_5_DDRIOLO_REG                     0x00000F24
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK2_5_DDRIOLO_REG                     0x00000F28
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK2_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK3_5_DDRIOLO_REG                     0x00000F2C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK3_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK4_5_DDRIOLO_REG                     0x00000F30
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK4_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK5_5_DDRIOLO_REG                     0x00000F34
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK5_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK6_5_DDRIOLO_REG                     0x00000F38
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK6_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK7_5_DDRIOLO_REG                     0x00000F3C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK7_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK0_5_DDRIOLO_REG                     0x00000F40
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the four clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK1_5_DDRIOLO_REG                     0x00000F44
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the four clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK2_5_DDRIOLO_REG                     0x00000F48
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK2_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK3_5_DDRIOLO_REG                     0x00000F4C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK3_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK4_5_DDRIOLO_REG                     0x00000F50
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // select one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK4_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK5_5_DDRIOLO_REG                     0x00000F54
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK5_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK6_5_DDRIOLO_REG                     0x00000F58
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK6_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK7_5_DDRIOLO_REG                     0x00000F5C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK7_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK0_5_DDRIOLO_REG                     0x00000F60
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK1_5_DDRIOLO_REG                     0x00000F64
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK2_5_DDRIOLO_REG                     0x00000F68
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK2_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK3_5_DDRIOLO_REG                     0x00000F6C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK3_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK4_5_DDRIOLO_REG                     0x00000F70
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK4_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK5_5_DDRIOLO_REG                     0x00000F74
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK5_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK6_5_DDRIOLO_REG                     0x00000F78
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK6_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK7_5_DDRIOLO_REG                     0x00000F7C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK7_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK0_5_DDRIOLO_REG                     0x00000F80
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK0_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK1_5_DDRIOLO_REG                     0x00000F84
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK2_5_DDRIOLO_REG                     0x00000F88
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK2_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK3_5_DDRIOLO_REG                     0x00000F8C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK3_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK4_5_DDRIOLO_REG                     0x00000F90
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK4_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK5_5_DDRIOLO_REG                     0x00000F94
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK5_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK6_5_DDRIOLO_REG                     0x00000F98
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK6_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK7_5_DDRIOLO_REG                     0x00000F9C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK7_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXXTALKN1_5_DDRIOLO_REG                           0x00000FA0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Coefficent for bit[0] of the DQ byte 
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank0 : 4;
    //
    // Coefficent for bit[1] of the DQ byte 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank1 : 4;
    //
    // Coefficent for bit[2] of the DQ byte
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank2 : 4;
    //
    // Coefficent for bit[3] of the DQ byte 
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank3 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 4
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank4 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 5
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank5 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 6
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank6 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 7
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank7 : 4;
  } Bits;
  UINTX Data;
} TXXTALKN1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN1_5_DDRIOLO_REG                        0x00000FA4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit Rx Vref Control
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX vrefperbit0 : 7;
    //
    // Rsvd
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX halflsben0 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[14:8], RW_L, default = 0x0
    //
    UINTX vrefperbit1 : 7;
    //
    // Rsvd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX halflsben1 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[22:16], RW_L, default = 0x0
    //
    UINTX vrefperbit2 : 7;
    //
    // Rsvd
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX halflsben2 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[30:24], RW_L, default = 0x0
    //
    UINTX vrefperbit3 : 7;
    //
    // shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX halflsben3 : 1;
  } Bits;
  UINTX Data;
} RXVREFCTRLN1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATATRAINFEEDBACKN1_5_DDRIOLO_REG                 0x00000FA8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Training Feedback Storage
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX datatrainfeedback : 9;
    //
    // Spare
    // 
    // Bits[31:9], RW_L, default = 0x0
    //
    UINTX spare : 23;
  } Bits;
  UINTX Data;
} DATATRAINFEEDBACKN1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N1_5_DDRIOLO_REG                      0x00000FCC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Visa debug bus LCB for DATA fub
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    //  VssHi control bits
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------
    // 	 disoverflow        24     Disable overflow logic from BDW
    // 	 fast panic enable  25     Bypass 2 flops in panic path for faster panic response
    // 	 vsshivccd2by3cfgen 26     Forces the driver DAC to get supply from 2/3 vccd
    // 	 vsshivccd2by3cfg   27:29  Current trim setting for 2/3 vccd mode, 001 fast,
    // 011 typical, 111 slow silicon  
    // 	 ddrvssh2ndcompen   30     Enable second comparator (ZBB mode)
    // 	 comp high bwen     31     Improve comparator performance to support low digital
    // voltage range 
    // 	
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl1 : 8;
    //
    // DQ TxEq setting selection to achieve constant EQ
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX dqtxeqsel : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSP pad to the Vref nibble bus
    //         
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqspvrefpgen : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSN pad to the Vref nibble bus
    //         
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX dqsnvrefpgen : 1;
    //
    //  
    //          If set to 0 (default), Vref generators selected through RxVrefSel[3:0]
    // are always on. 
    //          If set to 1, Vref generators are switched off while in Self Refresh.
    //         
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX vrefpwrsave : 1;
    //
    // Per-bit Enable connection to share Vref Bus
    // 
    // Bits[16:13], RW_L, default = 0x8
    //
    UINTX vreftonblbus : 4;
    //
    // Per Bit Verf generator Enable
    // 
    // Bits[20:17], RW_L, default = 0xF
    //
    UINTX rxvrefsel : 4;
    //
    // RefPiClkDelay
    // 
    // Bits[26:21], RW_L, default = 0x0
    //
    UINTX refpiclkdelay : 6;
    //
    // FNV Slave Delay Line Bypass Enable
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX fnvcrsdlbypassen : 1;
    //
    // FNV DLL Bypass Enable 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX fnvcrdllbypassen : 1;
    //
    // FNV Visa Fub Enable - data fub used for VISA if asserted 
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX fnvcrvisaen : 1;
    //
    // Enable write crc mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX writecrcenable : 1;
    //
    // This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
  } Bits;
  UINTX Data;
} DATACONTROL4N1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK1SELN1_5_DDRIOLO_REG                        0x00000FD0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor1 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr1d0 : 3;
    //
    // xtalk aggressor1 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr1d1 : 3;
    //
    // xtalk aggressor1 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr1d2 : 3;
    //
    // xtalk aggressor1 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr1d3 : 3;
    //
    // xtalk aggressor1 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr1d4 : 3;
    //
    // xtalk aggressor1 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr1d5 : 3;
    //
    // xtalk aggressor1 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr1d6 : 3;
    //
    // xtalk aggressor1 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr1d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK1SELN1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA0N1_5_DDRIOLO_REG                         0x00000FD4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp DrvUp Comp Value can be overriden via message channel if periodical
    // retrain is disable  
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Data Rcomp DrvDown Comp Value
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // VT Comp Values
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Data TCO Comp Value.
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Data Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} COMPDATA0N1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA1N1_5_DDRIOLO_REG                         0x00000FD8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp OdtUp Comp Value 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Data Rcomp Odt-Down Comp Value
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[21:12], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[31:22], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} COMPDATA1N1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETTRAINN1_5_DDRIOLO_REG                   0x00000FDC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained RxRcvEn Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcvenoffset : 6;
    //
    // Offset added to Trained Rx DQS Value.
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX rxdqsoffset : 7;
    //
    // Offset added to Trained Tx DQ Value.
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX txdqoffset : 6;
    //
    // Ooffset added to Trained Tx DQS Value.
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX txdqsoffset : 6;
    //
    // 2s Compliment offset added to Trained Vref Value.  Positive number increases Vref,
    // and each step is Vdd/384. 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX vrefoffset : 7;
  } Bits;
  UINTX Data;
} DATAOFFSETTRAINN1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETCOMPN1_5_DDRIOLO_REG                    0x00000FE0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2s Compliment offset added to DQ Drv-Up Comp Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX dqdrvupcompoffset : 6;
    //
    // 2s Compliment offset added to DQ Drv-Down Comp Value.
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX dqdrvdowncompoffset : 6;
    //
    // 2s Compliment offset added to DQ Odt-Up Comp Value.
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX dqodtupcompoffset : 5;
    //
    // 2s Compliment offset added to DQ Odt-Down Value.
    // 
    // Bits[21:17], RW_L, default = 0x0
    //
    UINTX dqodtdowncompoffset : 5;
    //
    // 2s Compliment offset added to DQ Tco Comp Value.
    // 
    // Bits[26:22], RW_L, default = 0x0
    //
    UINTX dqtcocompoffset : 5;
    //
    // 2s Compliment offset added to DQ Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX dqslewratecompoffset : 5;
  } Bits;
  UINTX Data;
} DATAOFFSETCOMPN1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK0SELN1_5_DDRIOLO_REG                        0x00000FE4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor0 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr0d0 : 3;
    //
    // xtalk aggressor0 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr0d1 : 3;
    //
    // xtalk aggressor0 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr0d2 : 3;
    //
    // xtalk aggressor0 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr0d3 : 3;
    //
    // xtalk aggressor0 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr0d4 : 3;
    //
    // xtalk aggressor0 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr0d5 : 3;
    //
    // xtalk aggressor0 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr0d6 : 3;
    //
    // xtalk aggressor0 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr0d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK0SELN1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N1_5_DDRIOLO_REG                      0x00000FE8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables Read DqDqs Training Mode
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX rxtrainingmode : 1;
    //
    // Enables Write Leveling Training Mode
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wltrainingmode : 1;
    //
    // Enables Read Leveling Training Mode.
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX rltrainingmode : 1;
    //
    // Enables SenseAmp offset cancellation training mode.
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX senseamptrainingmode : 1;
    //
    // When set, forces DQ/DQS drive enable to active.  Used in power measurements and
    // IO loopback mode  
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Power-down Disable:  Forces register file read, overriding the rank power down
    // logic. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rfon : 1;
    //
    // Power-down Disable:  Forces RxDqs PI clocks on.
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX rxpion : 1;
    //
    // Power-down Disable:  Forces TxDq and TxDqs PI clocks on.
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txpion : 1;
    //
    // 
    //           Forces on master DLL and all PI enables ON, despite both channel in
    // SelfRefresh, etc. low power states. 
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX internalclockson : 1;
    //
    // SaOffsetTrainTxon
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // Power-down:  All write commands are ignored for this data-byte.  Used in single-channel
    // MCI mode. 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX txdisable : 1;
    //
    // Power-down:  All read commands are ignored for this data-byte.  Used in single-channel
    // MCI mode.  
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX rxdisable : 1;
    //
    // Sets the duration of the first transmitted DQ bit of the burst. 0=1UI, 1=2UI.
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX txlong : 1;
    //
    // Controls the RX DQS CTLE setting.  (Code, CTLE) = { (0x0, Off),  (0x1, Use DQ),
    //  (0x2, BandPass),  (0x3, RSVD) }  
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX rxdqsctle : 2;
    //
    // Sets the RX read pointer offset on a reset.  Used during loopback and BERT mode.
    //  WrPtrPh1/WrPtrPh2 is reset to RxRdPt 
    // r (Default is to reset both to 0).
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX rxreadpointer : 3;
    //
    // Controls which segements of the driver are enabled:  {0: All, 1: Only ODT}.
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX driversegmentenable : 1;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a read c 
    // ommand to Rank = ReadRFRank
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX readrfrd : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a write  
    // command to Rank = ReadRFRank
    // 
    // Bits[21:21], RW_LV, default = 0x0
    //
    UINTX readrfwr : 1;
    //
    // Specifies the rank that ReadRFRd or ReadRFWr will manually download the CR values
    // from 
    // 
    // Bits[24:22], RW_LV, default = 0x0
    //
    UINTX readrfrank : 3;
    //
    // ODT is forced-on.
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // ODT and Senseamp are forced-off.
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsampoff : 1;
    //
    // not used
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disableodtstatic : 1;
    //
    // force ODT to the transmitter on, regardless of state of DriveEnable
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX ddrcrforceodton : 1;
    //
    // spare
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
    //
    // Enables long preamble for DDR4 devices
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX longpreambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL0N1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N1_5_DDRIOLO_REG                      0x00000FEC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable phase shift based crosstalk cancellation.
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX xtalkpienable : 1;
    //
    // select if 0: capacitive coupling; or 1: inductive coupling; xtalk dominant
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX xtalkpisign : 1;
    //
    // delta phase shift in one aggressor is in effect
    // 
    // Bits[4:2], RW_L, default = 0x0
    //
    UINTX xtalkpidelta : 3;
    //
    // reserved
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX burstlength10 : 1;
    //
    // Enable DLL Weak Lock to save power during CKE power down: {0: Disabled, 1: Enable}
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // IOT mode 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX iolbmodeen : 1;
    //
    // Controls which slave DLL are disabled: {0: nibble0, 1: nibble1, 2: not used}
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX sdlldisable : 1;
    //
    // not used
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // Controls the Current and BW of the Receiver: {0: 0.34Idll, 1: 0.66Idll, 2: 0.88Idll,
    // 3: Idll, 4: 1.33Idll, 5: 1.66Idll 
    // , 6: 2.00Idll, 7: 2.33Idll}
    // 
    // Bits[12:10], RW_L, default = 0x0
    //
    UINTX rxbiasctl : 3;
    //
    // Controls ODT turn-on delay.   To turn on N tQCK before RcvEn, program to RcvEn[8:6]
    //  N + 4. 
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX odtdelay : 4;
    //
    // Controls the ODT ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7, 18
    // tQCK) 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX odtduration : 3;
    //
    // Controls Senseamp turn-on delay.   To turn on N tQCK before RcvEn, program to
    // RcvEn[8:6]  N + 4. 
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX senseampdelay : 4;
    //
    // Controls the SenseAmp ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7,
    // 18 tQCK) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX senseampduration : 3;
    //
    // Cycles after the burst, when the current pulse should turn on by enabling OdtEn
    // for 1 cycle 
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX burstendodtdelay : 3;
    //
    // low voltage mode (ddr3lv, ddr3u, ddr4, smi, etc.)
    //             00: ddr3
    //             01: ddr3lv_smi
    //             10: ddr3u
    //             11: ddr4
    //         
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
  } Bits;
  UINTX Data;
} DATACONTROL1N1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N1_5_DDRIOLO_REG                      0x00000FF0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables SenseAmp offset cancellation training mode
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX rxvocselqnnnh : 5;
    //
    // Force on the internal Vref and Rx bias circuit, regardless of any other power
    // downs 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX forcebiason : 1;
    //
    // Force on the RxAmp only (as opposed to OdtSampOn, which turns on both ODT and
    // the amplifier). 
    //         Use for overclocking support where we may not be able to hit the fast
    // exit latency  
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX forcerxon : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // legacy from BDX for DDR3/VMSE configs"  DDRCOMP_CR_DDRCRCOMPOVR CTTermination
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Imode Select, 0: Swing Boost Mode; 1: (not supported) Xtalk Cancellation Mode
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX imodecfg : 1;
    //
    // Enable Imode EQ per byte lane. 
    //           0: Imode completely off 
    //           1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX imodeenable : 1;
    //
    // Spare
    // 
    // Bits[14:11], RW_L, default = 0x0
    //
    UINTX spare : 4;
    //
    // tbd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasen : 1;
    //
    // Spare1
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Binary Imode Coefficient, sets Imode current strength.
    //           (used for either Xtalk cancellation or swing boost)
    //           Code   Imode Current (approx)
    //           ------------------
    //           0000        0
    //           0001        1
    //           0010        2
    //             *
    //             *
    //             *
    //           1111        3
    // 
    // Bits[21:18], RW_L, default = 0x0
    //
    UINTX imodeeqcode : 4;
    //
    // Imode Scomp Override Enable
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX imodescompovrd : 1;
    //
    // strobe Rx Amp offset control
    // 
    // Bits[27:23], RW_L, default = 0xF
    //
    UINTX rxdqssaoffset : 5;
    //
    // disable the offset control in DQ and DQS RxAmp
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX rxoffsetdisable : 1;
    //
    // VMSE Logic Delay
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vmselogicdelay : 1;
    //
    // Spare2
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xoverdlyadj : 1;
  } Bits;
  UINTX Data;
} DATACONTROL2N1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N1_5_DDRIOLO_REG                      0x00000FF4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // binary default setting for static legs in DRV mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX drvstaticlegcfg : 2;
    //
    // binary default setting for static legs in ODT mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX odtstaticlegcfg : 2;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // not use
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rxdqssadisableshort : 1;
    //
    // This will tell which  segments are enabled out of reset.  
    //                      After that, a shift register will determine the enabled segments
    // 
    // Bits[8:6], RW_L, default = 0x1
    //
    UINTX odtsegmentenable : 3;
    //
    // This will tell which  segments are enabled out of reset. 
    // 
    // Bits[11:9], RW_L, default = 0x1
    //
    UINTX datasegmentenable : 3;
    //
    // When set, it will extends ODT by 1 qclk on read to write turnarounds. hsd 230773
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX longodtr2w : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // imodebias control 
    // 
    // Bits[14:14], RW_L, default = 0x1
    //
    UINTX imodebiasvrefen : 1;
    //
    // imodebias control. Also used for rxbiasana 
    // 
    // Bits[17:15], RW_L, default = 0x1
    //
    UINTX imodebiasrxbiastrim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // imodebias control 
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX imodebiasdfxddr4legup : 1;
    //
    // imodebias control 
    // 
    // Bits[20:20], RW_L, default = 0x1
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // ctle capacitor setting 
    // 
    // Bits[22:21], RW_L, default = 0x0
    //
    UINTX ddrcrctlecapen : 2;
    //
    // ctle resistor setting 
    // 
    // Bits[24:23], RW_L, default = 0x3
    //
    UINTX ddrcrctleresen : 2;
    //
    // RxBias CR 
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX pcasbiasclosedloopen : 1;
    //
    // RxBias CR 
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // RxBias CR 
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX rxbiasfoldedlegtrim : 2;
    //
    // RxBias CR 
    // 
    // Bits[30:29], RW_L, default = 0x1
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Spare
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX postambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL3N1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN1_5_DDRIOLO_REG                0x00000FF8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description: 
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode			
    //         PanicVoltage	 21:18  Unsigned integer controlling the voltage error on
    // VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking 
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADCN1_5_DDRIOLO_REG                   0x00000FFC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADCN1_5_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK0_8_DDRIOLO_REG                     0x00000A00
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS (0: 1/16 UI
    // offset,  
    //           1: 3/16 UI Offset, 2: 5/16 UI Offsets, 3: 7/16 UI Offsets, 4: 9/16 UI
    // Offsets, 5,6,7: 11/16 UI Offsets.) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK1_8_DDRIOLO_REG                     0x00000A04
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK2_8_DDRIOLO_REG                     0x00000A08
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK2_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK3_8_DDRIOLO_REG                     0x00000A0C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_N to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK3_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK4_8_DDRIOLO_REG                     0x00000A10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK4_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK5_8_DDRIOLO_REG                     0x00000A14
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // readx4modeenb
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // mux select for crossover from ClkPiRef to CkPi4RcvEn, used in xover2to2 mode
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK5_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK6_8_DDRIOLO_REG                     0x00000A18
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // per nibble READ timing control, delay DQS_P to match the earlest arrival DQ, 0~1.5UI
    // with step size ClkPi/64 
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK6_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK7_8_DDRIOLO_REG                     0x00000A1C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // CTLE current steering tuning (0=no eq, 7=max eq). It is decoded to
    //             CTLE resistor tuning: 00 - 3R (10.8Kohms), 01/10 -  R (3.6Kohms),
    // 11 - R/3 (1.2Kohms) 
    //             CTLE capacitor tuning: 00 - 0C (not used), 01 - 1C (200ff), 10 - 2C
    // (400ff), 11 - 3C (600ff) 
    //         
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK7_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK0_8_DDRIOLO_REG                     0x00000A20
#ifndef ASM_INC
typedef union {
  struct {
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_P to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // per bit READ timing control,
    //             delay DQS_N to match each DQ, 0~.25UI with step size ClkPi/64 added
    // to nibble delay RxDqsPDelay 
    //         
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK1_8_DDRIOLO_REG                     0x00000A24
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK2_8_DDRIOLO_REG                     0x00000A28
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK2_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK3_8_DDRIOLO_REG                     0x00000A2C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK3_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK4_8_DDRIOLO_REG                     0x00000A30
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK4_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK5_8_DDRIOLO_REG                     0x00000A34
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK5_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK6_8_DDRIOLO_REG                     0x00000A38
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK6_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK7_8_DDRIOLO_REG                     0x00000A3C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK7_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK0_8_DDRIOLO_REG                     0x00000A40
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // select one of the four DQ Clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK1_8_DDRIOLO_REG                     0x00000A44
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK2_8_DDRIOLO_REG                     0x00000A48
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK2_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK3_8_DDRIOLO_REG                     0x00000A4C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK3_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK4_8_DDRIOLO_REG                     0x00000A50
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK4_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK5_8_DDRIOLO_REG                     0x00000A54
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK5_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK6_8_DDRIOLO_REG                     0x00000A58
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK6_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK7_8_DDRIOLO_REG                     0x00000A5C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // Select one of the four DQ clk
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK7_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK0_8_DDRIOLO_REG                     0x00000A60
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte. 0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK1_8_DDRIOLO_REG                     0x00000A64
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK2_8_DDRIOLO_REG                     0x00000A68
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK2_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK3_8_DDRIOLO_REG                     0x00000A6C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK3_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK4_8_DDRIOLO_REG                     0x00000A70
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK4_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK5_8_DDRIOLO_REG                     0x00000A74
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK5_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK6_8_DDRIOLO_REG                     0x00000A78
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK6_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK7_8_DDRIOLO_REG                     0x00000A7C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK7_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK0_8_DDRIOLO_REG                     0x00000A80
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // selects which skewed DQSP (to sample even bits) is used in the RX FIFO. For proper
    // operation, always pick latest DQSP 
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // selects which skewed DQSN (to sample odd bits) is used in the RX FIFO. For proper
    // operation, always pick latest DQSN 
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK1_8_DDRIOLO_REG                     0x00000A84
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK2_8_DDRIOLO_REG                     0x00000A88
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK2_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK3_8_DDRIOLO_REG                     0x00000A8C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK3_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK4_8_DDRIOLO_REG                     0x00000A90
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // [0]=0 selects the raw output from the nibble DQS amplifier; [1] is not used.
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK4_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK5_8_DDRIOLO_REG                     0x00000A94
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK5_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK6_8_DDRIOLO_REG                     0x00000A98
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK6_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK7_8_DDRIOLO_REG                     0x00000A9C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // select the phase1 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK7_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXXTALKN0_8_DDRIOLO_REG                           0x00000AA0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 0
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank0 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 1 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank1 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 2
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank2 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 3 
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank3 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 4
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank4 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 5
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank5 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 6
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank6 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 7
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank7 : 4;
  } Bits;
  UINTX Data;
} TXXTALKN0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN0_8_DDRIOLO_REG                        0x00000AA4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit Rx Vref Control
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX vrefperbit0 : 7;
    //
    // Rsvd
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX halflsben0 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[14:8], RW_L, default = 0x0
    //
    UINTX vrefperbit1 : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX halflsben1 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[22:16], RW_L, default = 0x0
    //
    UINTX vrefperbit2 : 7;
    //
    // enables fine grain Vref control, shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX halflsben2 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[30:24], RW_L, default = 0x0
    //
    UINTX vrefperbit3 : 7;
    //
    // shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX halflsben3 : 1;
  } Bits;
  UINTX Data;
} RXVREFCTRLN0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATATRAINFEEDBACKN0_8_DDRIOLO_REG                 0x00000AA8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Training Feedback Storage
    // 
    //         DataTrainFeedback Description:
    //          Training Step    Bits    Nibble    Description
    //         --------------    ----    -------  --------------------------------------------------------------------------------------------------------------------------------------------------------
    //         Cross Over Cal     0      0        Tx Dqs Phase Detection
    //         Cross Over Cal     1      0        Tx Dq Phase Detection
    //         Cross Over Cal     2      0        Rec En Phase Detection
    //         RcvEn              8:0    0        Byte detection
    //         Rx Dq-Dqs          0      0        Pass/fail
    //         Wr Leveling        8:0    0        Byte detection
    // 
    //         Cross Over Cal     3      1        Tx Dqs Phase Detection
    //         Cross Over Cal     4      1        Tx Dq Phase Detection
    //         Cross Over Cal     5      1        Rec En Phase Detection
    //         RcvEn             17:9    1        Byte detection
    //         Rx Dq-Dqs          1      1        Pass/fail
    //         Wr Leveling       17:9    1        Byte detection
    //         
    // 
    // Bits[17:0], RW_L, default = 0x0
    //
    UINTX datatrainfeedback : 18;
    //
    // Spare
    // 
    // Bits[31:18], RW_L, default = 0x0
    //
    UINTX spare : 14;
  } Bits;
  UINTX Data;
} DATATRAINFEEDBACKN0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N0_8_DDRIOLO_REG                      0x00000ACC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Visa debug bus LCB for DATA fub
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    //  VssHi control bits
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------
    // 	 disoverflow        24     Disable overflow logic from BDW
    // 	 fast panic enable  25     Bypass 2 flops in panic path for faster panic response
    // 	 vsshivccd2by3cfgen 26     Forces the driver DAC to get supply from 2/3 vccd
    // 	 vsshivccd2by3cfg   27:29  Current trim setting for 2/3 vccd mode, 001 fast,
    // 011 typical, 111 slow silicon  
    // 	 ddrvssh2ndcompen   30     Enable second comparator (ZBB mode)
    // 	 comp high bwen     31     Improve comparator performance to support low digital
    // voltage range 
    // 	
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl1 : 8;
    //
    // DQ TxEq setting selection to achieve constant EQ
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX dqtxeqsel : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSP pad to the Vref nibble bus
    //         
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqspvrefpgen : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSN pad to the Vref nibble bus
    //         
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX dqsnvrefpgen : 1;
    //
    //  
    //          If set to 0 (default), Vref generators selected through RxVrefSel[3:0]
    // are always on. 
    //          If set to 1, Vref generators are switched off while in Self Refresh.
    //         
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX vrefpwrsave : 1;
    //
    // Per-bit Enable connection to share Vref Bus
    // 
    // Bits[16:13], RW_L, default = 0x8
    //
    UINTX vreftonblbus : 4;
    //
    // Per Bit Verf generator Enable
    // 
    // Bits[20:17], RW_L, default = 0xF
    //
    UINTX rxvrefsel : 4;
    //
    // RefPiClkDelay
    // 
    // Bits[26:21], RW_L, default = 0x0
    //
    UINTX refpiclkdelay : 6;
    //
    // FNV Slave Delay Line Bypass Enable
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX fnvcrsdlbypassen : 1;
    //
    // FNV DLL Bypass Enable 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX fnvcrdllbypassen : 1;
    //
    // FNV Visa Fub Enable - data fub used for VISA if asserted 
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX fnvcrvisaen : 1;
    //
    // Enable write crc mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX writecrcenable : 1;
    //
    // This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
  } Bits;
  UINTX Data;
} DATACONTROL4N0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK1SELN0_8_DDRIOLO_REG                        0x00000AD0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor1 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr1d0 : 3;
    //
    // xtalk aggressor1 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr1d1 : 3;
    //
    // xtalk aggressor1 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr1d2 : 3;
    //
    // xtalk aggressor1 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr1d3 : 3;
    //
    // xtalk aggressor1 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr1d4 : 3;
    //
    // xtalk aggressor1 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr1d5 : 3;
    //
    // xtalk aggressor1 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr1d6 : 3;
    //
    // xtalk aggressor1 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr1d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK1SELN0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA0N0_8_DDRIOLO_REG                         0x00000AD4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp DrvUp Comp Value can be overriden via message channel if periodical
    // retrain is disable  
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Data Rcomp DrvDown Comp Value
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // VT Comp Values
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Data TCO Comp Value.
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Data Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} COMPDATA0N0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA1N0_8_DDRIOLO_REG                         0x00000AD8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp OdtUp Comp Value 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Data Rcomp Odt-Down Comp Value
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[21:12], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[31:22], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} COMPDATA1N0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETTRAINN0_8_DDRIOLO_REG                   0x00000ADC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained RxRcvEn Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcvenoffset : 6;
    //
    // Offset added to Trained Rx DQS Value.
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX rxdqsoffset : 7;
    //
    // Offset added to Trained Tx DQ Value.
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX txdqoffset : 6;
    //
    // Ooffset added to Trained Tx DQS Value.
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX txdqsoffset : 6;
    //
    // 2s Compliment offset added to Trained Vref Value.  Positive number increases Vref,
    // and each step is Vdd/384. 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX vrefoffset : 7;
  } Bits;
  UINTX Data;
} DATAOFFSETTRAINN0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETCOMPN0_8_DDRIOLO_REG                    0x00000AE0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2s Compliment offset added to DQ Drv-Up Comp Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX dqdrvupcompoffset : 6;
    //
    // 2s Compliment offset added to DQ Drv-Down Comp Value.
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX dqdrvdowncompoffset : 6;
    //
    // 2s Compliment offset added to DQ Odt-Up Comp Value.
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX dqodtupcompoffset : 5;
    //
    // 2s Compliment offset added to DQ Odt-Down Value.
    // 
    // Bits[21:17], RW_L, default = 0x0
    //
    UINTX dqodtdowncompoffset : 5;
    //
    // 2s Compliment offset added to DQ Tco Comp Value.
    // 
    // Bits[26:22], RW_L, default = 0x0
    //
    UINTX dqtcocompoffset : 5;
    //
    // 2s Compliment offset added to DQ Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX dqslewratecompoffset : 5;
  } Bits;
  UINTX Data;
} DATAOFFSETCOMPN0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK0SELN0_8_DDRIOLO_REG                        0x00000AE4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor0 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr0d0 : 3;
    //
    // xtalk aggressor0 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr0d1 : 3;
    //
    // xtalk aggressor0 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr0d2 : 3;
    //
    // xtalk aggressor0 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr0d3 : 3;
    //
    // xtalk aggressor0 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr0d4 : 3;
    //
    // xtalk aggressor0 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr0d5 : 3;
    //
    // xtalk aggressor0 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr0d6 : 3;
    //
    // xtalk aggressor0 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr0d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK0SELN0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N0_8_DDRIOLO_REG                      0x00000AE8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables Read DqDqs Training Mode
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX rxtrainingmode : 1;
    //
    // Enables Write Leveling Training Mode
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wltrainingmode : 1;
    //
    // Enables Read Leveling Training Mode.
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX rltrainingmode : 1;
    //
    // Enables SenseAmp offset cancellation training mode.
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX senseamptrainingmode : 1;
    //
    // When set, forces DQ/DQS drive enable to active.  Used in power measurements and
    // IO loopback mode  
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Power-down Disable:  Forces register file read, overriding the rank power down
    // logic. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rfon : 1;
    //
    // Power-down Disable:  Forces RxDqs PI clocks on.
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX rxpion : 1;
    //
    // Power-down Disable:  Forces TxDq and TxDqs PI clocks on.
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txpion : 1;
    //
    // 
    //           Forces on master DLL and all PI enables ON, despite both channel in
    // SelfRefresh, etc. low power states. 
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX internalclockson : 1;
    //
    // SaOffsetTrainTxon
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // Power-down:  All write commands are ignored for this data-byte.  Used in single-channel
    // MCI mode. 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX txdisable : 1;
    //
    // Power-down:  All read commands are ignored for this data-byte.  Used in single-channel
    // MCI mode.  
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX rxdisable : 1;
    //
    // Sets the duration of the first transmitted DQ bit of the burst. 0=1UI, 1=2UI.
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX txlong : 1;
    //
    // Controls the RX DQS CTLE setting.  (Code, CTLE) = { (0x0, Off),  (0x1, Use DQ),
    //  (0x2, BandPass),  (0x3, RSVD) }  
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX rxdqsctle : 2;
    //
    // Sets the RX read pointer offset on a reset.  Used during loopback and BERT mode.
    //  WrPtrPh1/WrPtrPh2 is reset to RxRdPt 
    // r (Default is to reset both to 0).
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX rxreadpointer : 3;
    //
    // Controls which segements of the driver are enabled:  {0: All, 1: Only ODT}.
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX driversegmentenable : 1;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a read c 
    // ommand to Rank = ReadRFRank
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX readrfrd : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a write  
    // command to Rank = ReadRFRank
    // 
    // Bits[21:21], RW_LV, default = 0x0
    //
    UINTX readrfwr : 1;
    //
    // Specifies the rank that ReadRFRd or ReadRFWr will manually download the CR values
    // from 
    // 
    // Bits[24:22], RW_LV, default = 0x0
    //
    UINTX readrfrank : 3;
    //
    // ODT is forced-on.
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // ODT and Senseamp are forced-off.
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsampoff : 1;
    //
    // not used
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disableodtstatic : 1;
    //
    // force ODT to the transmitter on, regardless of state of DriveEnable
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX ddrcrforceodton : 1;
    //
    // spare
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
    //
    // Enables long preamble for DDR4 devices
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX longpreambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL0N0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N0_8_DDRIOLO_REG                      0x00000AEC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable phase shift based crosstalk cancellation.
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX xtalkpienable : 1;
    //
    // select if 0: capacitive coupling; or 1: inductive coupling; xtalk dominant
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX xtalkpisign : 1;
    //
    // delta phase shift in one aggressor is in effect
    // 
    // Bits[4:2], RW_L, default = 0x0
    //
    UINTX xtalkpidelta : 3;
    //
    // reserved
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX burstlength10 : 1;
    //
    // Enable DLL Weak Lock to save power during CKE power down: {0: Disabled, 1: Enable}
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // IOT mode 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX iolbmodeen : 1;
    //
    // Controls which slave DLL are disabled: {0: nibble0, 1: nibble1, 2: not used}
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX sdlldisable : 1;
    //
    // not used
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // Controls the Current and BW of the Receiver: {0: 0.34Idll, 1: 0.66Idll, 2: 0.88Idll,
    // 3: Idll, 4: 1.33Idll, 5: 1.66Idll 
    // , 6: 2.00Idll, 7: 2.33Idll}
    // 
    // Bits[12:10], RW_L, default = 0x0
    //
    UINTX rxbiasctl : 3;
    //
    // Controls ODT turn-on delay.   To turn on N tQCK before RcvEn, program to RcvEn[8:6]
    //  N + 4. 
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX odtdelay : 4;
    //
    // Controls the ODT ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7, 18
    // tQCK) 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX odtduration : 3;
    //
    // Controls Senseamp turn-on delay.   To turn on N tQCK before RcvEn, program to
    // RcvEn[8:6]  N + 4. 
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX senseampdelay : 4;
    //
    // Controls the SenseAmp ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7,
    // 18 tQCK) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX senseampduration : 3;
    //
    // Cycles after the burst, when the current pulse should turn on by enabling OdtEn
    // for 1 cycle 
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX burstendodtdelay : 3;
    //
    // low voltage mode (ddr3lv, ddr3u, ddr4, smi, etc.)
    //             00: ddr3
    //             01: ddr3lv_smi
    //             10: ddr3u
    //             11: ddr4
    //         
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
  } Bits;
  UINTX Data;
} DATACONTROL1N0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N0_8_DDRIOLO_REG                      0x00000AF0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables SenseAmp offset cancellation training mode
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX rxvocselqnnnh : 5;
    //
    // Force on the internal Vref and Rx bias circuit, regardless of any other power
    // downs 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX forcebiason : 1;
    //
    // Force on the RxAmp only (as opposed to OdtSampOn, which turns on both ODT and
    // the amplifier). 
    //         Use for overclocking support where we may not be able to hit the fast
    // exit latency  
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX forcerxon : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // legacy from BDX for DDR3/VMSE configs"  DDRCOMP_CR_DDRCRCOMPOVR CTTermination
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Imode Select, 0: Swing Boost Mode; 1: (not supported) Xtalk Cancellation Mode
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX imodecfg : 1;
    //
    // Enable Imode EQ per byte lane. 
    //           0: Imode completely off 
    //           1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX imodeenable : 1;
    //
    // Spare
    // 
    // Bits[14:11], RW_L, default = 0x0
    //
    UINTX spare : 4;
    //
    // tbd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasen : 1;
    //
    // Spare1
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Binary Imode Coefficient, sets Imode current strength.
    //           (used for either Xtalk cancellation or swing boost)
    //           Code   Imode Current (approx)
    //           ------------------
    //           0000        0
    //           0001        1
    //           0010        2
    //             *
    //             *
    //             *
    //           1111        3
    // 
    // Bits[21:18], RW_L, default = 0x0
    //
    UINTX imodeeqcode : 4;
    //
    // Imode Scomp Override Enable
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX imodescompovrd : 1;
    //
    // strobe Rx Amp offset control
    // 
    // Bits[27:23], RW_L, default = 0xF
    //
    UINTX rxdqssaoffset : 5;
    //
    // disable the offset control in DQ and DQS RxAmp
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX rxoffsetdisable : 1;
    //
    // VMSE Logic Delay
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vmselogicdelay : 1;
    //
    // Spare2
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xoverdlyadj : 1;
  } Bits;
  UINTX Data;
} DATACONTROL2N0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N0_8_DDRIOLO_REG                      0x00000AF4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // binary default setting for static legs in DRV mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX drvstaticlegcfg : 2;
    //
    // binary default setting for static legs in ODT mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX odtstaticlegcfg : 2;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // not use
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rxdqssadisableshort : 1;
    //
    // This will tell which  segments are enabled out of reset.  
    //                      After that, a shift register will determine the enabled segments
    // 
    // Bits[8:6], RW_L, default = 0x1
    //
    UINTX odtsegmentenable : 3;
    //
    // This will tell which  segments are enabled out of reset. 
    // 
    // Bits[11:9], RW_L, default = 0x1
    //
    UINTX datasegmentenable : 3;
    //
    // When set, it will extends ODT by 1 qclk on read to write turnarounds. hsd 230773
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX longodtr2w : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // imodebias control 
    // 
    // Bits[14:14], RW_L, default = 0x1
    //
    UINTX imodebiasvrefen : 1;
    //
    // imodebias control. Also used for rxbiasana 
    // 
    // Bits[17:15], RW_L, default = 0x1
    //
    UINTX imodebiasrxbiastrim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // imodebias control 
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX imodebiasdfxddr4legup : 1;
    //
    // imodebias control 
    // 
    // Bits[20:20], RW_L, default = 0x1
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // ctle capacitor setting 
    // 
    // Bits[22:21], RW_L, default = 0x0
    //
    UINTX ddrcrctlecapen : 2;
    //
    // ctle resistor setting 
    // 
    // Bits[24:23], RW_L, default = 0x3
    //
    UINTX ddrcrctleresen : 2;
    //
    // RxBias CR 
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX pcasbiasclosedloopen : 1;
    //
    // RxBias CR 
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // RxBias CR 
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX rxbiasfoldedlegtrim : 2;
    //
    // RxBias CR 
    // 
    // Bits[30:29], RW_L, default = 0x1
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Spare
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX postambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL3N0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN0_8_DDRIOLO_REG                0x00000AF8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description: 
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode			
    //         PanicVoltage	 21:18  Unsigned integer controlling the voltage error on
    // VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking 
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADCN0_8_DDRIOLO_REG                   0x00000AFC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADCN0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK0_8_DDRIOLO_REG                     0x00000B00
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK1_8_DDRIOLO_REG                     0x00000B04
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK2_8_DDRIOLO_REG                     0x00000B08
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK2_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK3_8_DDRIOLO_REG                     0x00000B0C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK3_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK4_8_DDRIOLO_REG                     0x00000B10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK4_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK5_8_DDRIOLO_REG                     0x00000B14
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK5_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK6_8_DDRIOLO_REG                     0x00000B18
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK6_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N1RANK7_8_DDRIOLO_REG                     0x00000B1C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RcvEn timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX rcvendelay : 9;
    //
    // ReadX8ModeEn
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX readx8modeen : 1;
    //
    // common DQS_P delay control, per nibble
    // 
    // Bits[16:10], RW_L, default = 0x0
    //
    UINTX rxdqspdelay : 7;
    //
    // common DQS_N delay control, per nibble
    // 
    // Bits[23:17], RW_L, default = 0x0
    //
    UINTX rxdqsndelay : 7;
    //
    // Rx DQ delay, per nibble, used in case if DQ is too early than DQS
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX rxdqdelay : 3;
    //
    // Rx Equalization code:  {4:3} controls the cap tuning 0: (not used), 1: 200ff,
    // 2: 400ff, 3: 600ff,  
    //                      controls the resistor tuning (0: 3R, 1: 1R, 2: 1R, 3: R/3).
    //  
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX rxeq : 3;
    //
    // reserved
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX spare : 2;
  } Bits;
  UINTX Data;
} RXGROUP0N1RANK7_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK0_8_DDRIOLO_REG                     0x00000B20
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK1_8_DDRIOLO_REG                     0x00000B24
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK2_8_DDRIOLO_REG                     0x00000B28
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK2_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK3_8_DDRIOLO_REG                     0x00000B2C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK3_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK4_8_DDRIOLO_REG                     0x00000B30
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK4_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK5_8_DDRIOLO_REG                     0x00000B34
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK5_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK6_8_DDRIOLO_REG                     0x00000B38
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK6_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N1RANK7_8_DDRIOLO_REG                     0x00000B3C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX rxdqspdelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX rxdqspdelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX rxdqspdelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX rxdqspdelay3 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX rxdqsndelay0 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX rxdqsndelay1 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX rxdqsndelay2 : 4;
    //
    // Read timing offset DQS to match a DQ bit.  +tQCLK/4 with step size of tQCK/64
    //  
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX rxdqsndelay3 : 4;
  } Bits;
  UINTX Data;
} RXGROUP1N1RANK7_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK0_8_DDRIOLO_REG                     0x00000B40
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the four clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK1_8_DDRIOLO_REG                     0x00000B44
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the four clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK2_8_DDRIOLO_REG                     0x00000B48
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK2_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK3_8_DDRIOLO_REG                     0x00000B4C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK3_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK4_8_DDRIOLO_REG                     0x00000B50
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // select one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK4_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK5_8_DDRIOLO_REG                     0x00000B54
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK5_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK6_8_DDRIOLO_REG                     0x00000B58
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // xelect for crossover from PiRef to PiN for bit 1
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK6_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N1RANK7_8_DDRIOLO_REG                     0x00000B5C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write DQ timing control.  Unsigned number from 0 to 8 tQCK with step size of tQCK/64
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX txdqdelay : 9;
    //
    // Write DQS timing control.  Unsigned number from 0 to 8 tQCK with step size of
    // tQCK/64 
    // 
    // Bits[17:9], RW_L, default = 0x0
    //
    UINTX txdqsdelay : 9;
    //
    // one of the 4 clocks
    // 
    // Bits[19:18], RW_L, default = 0x0
    //
    UINTX txdqpiclksel : 2;
    //
    // Spare
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX spare : 2;
    //
    // xelect for crossover from Qclk to CkPi4Dqs
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX txdqsxsel : 1;
    //
    // Write Equalization codes.  5 bit control, but only 24 of them are meaningful.
    //             The decoding is 1-1 matched, means 0 is 0 legs enabled for deemphasized,
    // 1 is 1 leg enabled 
    //             for deemphasized, and so on.
    //             BDX-change. Increased the width by 1bit for TXEQ tracking
    //         
    // 
    // Bits[28:23], RW_L, default = 0x0
    //
    UINTX txeq : 6;
    //
    // Rsvd
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX x8writeen : 1;
    //
    // Rsvd
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} TXGROUP0N1RANK7_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK0_8_DDRIOLO_REG                     0x00000B60
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK1_8_DDRIOLO_REG                     0x00000B64
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK2_8_DDRIOLO_REG                     0x00000B68
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK2_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK3_8_DDRIOLO_REG                     0x00000B6C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK3_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK4_8_DDRIOLO_REG                     0x00000B70
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK4_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK5_8_DDRIOLO_REG                     0x00000B74
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK5_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK6_8_DDRIOLO_REG                     0x00000B78
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK6_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N1RANK7_8_DDRIOLO_REG                     0x00000B7C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Write timing offset for bit[0] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX txdqpicode0 : 6;
    //
    // Write timing offset for bit[1] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX txdqpicode1 : 6;
    //
    // Write timing offset for bit[2] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[17:12], RW_L, default = 0x0
    //
    UINTX txdqpicode2 : 6;
    //
    // Write timing offset for bit[3] of the DQ byte.  0 to toQCK with step size of tQCK/64
    // 
    // Bits[23:18], RW_L, default = 0x0
    //
    UINTX txdqpicode3 : 6;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} TXGROUP1N1RANK7_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK0_8_DDRIOLO_REG                     0x00000B80
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK0_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK1_8_DDRIOLO_REG                     0x00000B84
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK2_8_DDRIOLO_REG                     0x00000B88
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK2_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK3_8_DDRIOLO_REG                     0x00000B8C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK3_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK4_8_DDRIOLO_REG                     0x00000B90
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK4_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK5_8_DDRIOLO_REG                     0x00000B94
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK5_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK6_8_DDRIOLO_REG                     0x00000B98
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK6_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN1RANK7_8_DDRIOLO_REG                     0x00000B9C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Amplifier voltage offset for bit[0] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX saoffset0 : 5;
    //
    // Amplifier voltage offset for bit[1] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[9:5], RW_L, default = 0x0
    //
    UINTX saoffset1 : 5;
    //
    // Amplifier voltage offset for bit[2] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[14:10], RW_L, default = 0x0
    //
    UINTX saoffset2 : 5;
    //
    // Amplifier voltage offset for bit[3] of the DQ byte. {0: Most negative offset,...
    // 8: 0 offset, ... 63: Most postive offset}  
    // 
    // Bits[19:15], RW_L, default = 0x0
    //
    UINTX saoffset3 : 5;
    //
    // x4/x8 DQS mux select
    //             [0]=1 selects the raw output from the nibble0 DQS amplifier in x8
    // mode;  
    //             [0]=0 select nibble1 amplifier output in x4 mode; 
    //             [1] is not used.
    //         
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX rxdqspsel : 2;
    //
    // select the phase2 dqs clock skewed with max delay to drive rxFIFO write
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX rxdqsnsel : 2;
    //
    // Rsvd
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX rsvd : 8;
  } Bits;
  UINTX Data;
} RXOFFSETN1RANK7_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXXTALKN1_8_DDRIOLO_REG                           0x00000BA0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Coefficent for bit[0] of the DQ byte 
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank0 : 4;
    //
    // Coefficent for bit[1] of the DQ byte 
    // 
    // Bits[7:4], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank1 : 4;
    //
    // Coefficent for bit[2] of the DQ byte
    // 
    // Bits[11:8], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank2 : 4;
    //
    // Coefficent for bit[3] of the DQ byte 
    // 
    // Bits[15:12], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank3 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for Rank 4
    // 
    // Bits[19:16], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank4 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 5
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank5 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 6
    // 
    // Bits[27:24], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank6 : 4;
    //
    // This may need to be set for bits 3:0 in the nibble for rank 7
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX twototwologicdelayrank7 : 4;
  } Bits;
  UINTX Data;
} TXXTALKN1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN1_8_DDRIOLO_REG                        0x00000BA4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit Rx Vref Control
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX vrefperbit0 : 7;
    //
    // Rsvd
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX halflsben0 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[14:8], RW_L, default = 0x0
    //
    UINTX vrefperbit1 : 7;
    //
    // Rsvd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX halflsben1 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[22:16], RW_L, default = 0x0
    //
    UINTX vrefperbit2 : 7;
    //
    // Rsvd
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX halflsben2 : 1;
    //
    // Per bit Rx Vref Control
    // 
    // Bits[30:24], RW_L, default = 0x0
    //
    UINTX vrefperbit3 : 7;
    //
    // shift down the Vref voltage by ~0.5 stepsize
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX halflsben3 : 1;
  } Bits;
  UINTX Data;
} RXVREFCTRLN1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATATRAINFEEDBACKN1_8_DDRIOLO_REG                 0x00000BA8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Training Feedback Storage
    // 
    // Bits[8:0], RW_L, default = 0x0
    //
    UINTX datatrainfeedback : 9;
    //
    // Spare
    // 
    // Bits[31:9], RW_L, default = 0x0
    //
    UINTX spare : 23;
  } Bits;
  UINTX Data;
} DATATRAINFEEDBACKN1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N1_8_DDRIOLO_REG                      0x00000BCC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable Visa debug bus LCB for DATA fub
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    //  VssHi control bits
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------
    // 	 disoverflow        24     Disable overflow logic from BDW
    // 	 fast panic enable  25     Bypass 2 flops in panic path for faster panic response
    // 	 vsshivccd2by3cfgen 26     Forces the driver DAC to get supply from 2/3 vccd
    // 	 vsshivccd2by3cfg   27:29  Current trim setting for 2/3 vccd mode, 001 fast,
    // 011 typical, 111 slow silicon  
    // 	 ddrvssh2ndcompen   30     Enable second comparator (ZBB mode)
    // 	 comp high bwen     31     Improve comparator performance to support low digital
    // voltage range 
    // 	
    // 
    // Bits[8:1], RW_L, default = 0x0
    //
    UINTX vsshiorvrefctl1 : 8;
    //
    // DQ TxEq setting selection to achieve constant EQ
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX dqtxeqsel : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSP pad to the Vref nibble bus
    //         
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqspvrefpgen : 1;
    //
    // 
    //          nables the pass-gate that connects the DQSN pad to the Vref nibble bus
    //         
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX dqsnvrefpgen : 1;
    //
    //  
    //          If set to 0 (default), Vref generators selected through RxVrefSel[3:0]
    // are always on. 
    //          If set to 1, Vref generators are switched off while in Self Refresh.
    //         
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX vrefpwrsave : 1;
    //
    // Per-bit Enable connection to share Vref Bus
    // 
    // Bits[16:13], RW_L, default = 0x8
    //
    UINTX vreftonblbus : 4;
    //
    // Per Bit Verf generator Enable
    // 
    // Bits[20:17], RW_L, default = 0xF
    //
    UINTX rxvrefsel : 4;
    //
    // RefPiClkDelay
    // 
    // Bits[26:21], RW_L, default = 0x0
    //
    UINTX refpiclkdelay : 6;
    //
    // FNV Slave Delay Line Bypass Enable
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX fnvcrsdlbypassen : 1;
    //
    // FNV DLL Bypass Enable 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX fnvcrdllbypassen : 1;
    //
    // FNV Visa Fub Enable - data fub used for VISA if asserted 
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX fnvcrvisaen : 1;
    //
    // Enable write crc mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX writecrcenable : 1;
    //
    // This bit helps to bypass the delaycell in transmitter
    // 
    // Bits[31:31], RW_L, default = 0x1
    //
    UINTX bdx_sys : 1;
  } Bits;
  UINTX Data;
} DATACONTROL4N1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK1SELN1_8_DDRIOLO_REG                        0x00000BD0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor1 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr1d0 : 3;
    //
    // xtalk aggressor1 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr1d1 : 3;
    //
    // xtalk aggressor1 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr1d2 : 3;
    //
    // xtalk aggressor1 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr1d3 : 3;
    //
    // xtalk aggressor1 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr1d4 : 3;
    //
    // xtalk aggressor1 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr1d5 : 3;
    //
    // xtalk aggressor1 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr1d6 : 3;
    //
    // xtalk aggressor1 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr1d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK1SELN1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA0N1_8_DDRIOLO_REG                         0x00000BD4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp DrvUp Comp Value can be overriden via message channel if periodical
    // retrain is disable  
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Data Rcomp DrvDown Comp Value
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // VT Comp Values
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Data TCO Comp Value.
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Data Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} COMPDATA0N1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define COMPDATA1N1_8_DDRIOLO_REG                         0x00000BD8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Data Rcomp OdtUp Comp Value 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Data Rcomp Odt-Down Comp Value
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Panic DrvDn RComp Value.
    // 
    // Bits[21:12], RW_L, default = 0x10
    //
    UINTX panicdrvdn : 10;
    //
    // Panic DrvUp RComp Comp Value.
    // 
    // Bits[31:22], RW_L, default = 0x10
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} COMPDATA1N1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETTRAINN1_8_DDRIOLO_REG                   0x00000BDC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Offset added to Trained RxRcvEn Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcvenoffset : 6;
    //
    // Offset added to Trained Rx DQS Value.
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX rxdqsoffset : 7;
    //
    // Offset added to Trained Tx DQ Value.
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX txdqoffset : 6;
    //
    // Ooffset added to Trained Tx DQS Value.
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX txdqsoffset : 6;
    //
    // 2s Compliment offset added to Trained Vref Value.  Positive number increases Vref,
    // and each step is Vdd/384. 
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX vrefoffset : 7;
  } Bits;
  UINTX Data;
} DATAOFFSETTRAINN1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATAOFFSETCOMPN1_8_DDRIOLO_REG                    0x00000BE0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2s Compliment offset added to DQ Drv-Up Comp Value.
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX dqdrvupcompoffset : 6;
    //
    // 2s Compliment offset added to DQ Drv-Down Comp Value.
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX dqdrvdowncompoffset : 6;
    //
    // 2s Compliment offset added to DQ Odt-Up Comp Value.
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX dqodtupcompoffset : 5;
    //
    // 2s Compliment offset added to DQ Odt-Down Value.
    // 
    // Bits[21:17], RW_L, default = 0x0
    //
    UINTX dqodtdowncompoffset : 5;
    //
    // 2s Compliment offset added to DQ Tco Comp Value.
    // 
    // Bits[26:22], RW_L, default = 0x0
    //
    UINTX dqtcocompoffset : 5;
    //
    // 2s Compliment offset added to DQ Slew Rate Comp Value.
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX dqslewratecompoffset : 5;
  } Bits;
  UINTX Data;
} DATAOFFSETCOMPN1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define ATTACK0SELN1_8_DDRIOLO_REG                        0x00000BE4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // xtalk aggressor0 select for dq bit[0] in a byte
    // 
    // Bits[2:0], RW_L, default = 0x0
    //
    UINTX attackr0d0 : 3;
    //
    // xtalk aggressor0 select for dq bit[1] in a byte
    // 
    // Bits[5:3], RW_L, default = 0x0
    //
    UINTX attackr0d1 : 3;
    //
    // xtalk aggressor0 select for dq bit[2] in a byte
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX attackr0d2 : 3;
    //
    // xtalk aggressor0 select for dq bit[3] in a byte
    // 
    // Bits[11:9], RW_L, default = 0x0
    //
    UINTX attackr0d3 : 3;
    //
    // xtalk aggressor0 select for dq bit[4] in a byte
    // 
    // Bits[14:12], RW_L, default = 0x0
    //
    UINTX attackr0d4 : 3;
    //
    // xtalk aggressor0 select for dq bit[5] in a byte
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX attackr0d5 : 3;
    //
    // xtalk aggressor0 select for dq bit[6] in a byte
    // 
    // Bits[20:18], RW_L, default = 0x0
    //
    UINTX attackr0d6 : 3;
    //
    // xtalk aggressor0 select for dq bit[7] in a byte
    // 
    // Bits[23:21], RW_L, default = 0x0
    //
    UINTX attackr0d7 : 3;
    //
    // spare bits.
    // 
    // Bits[31:24], RW_L, default = 0x0
    //
    UINTX spare : 8;
  } Bits;
  UINTX Data;
} ATTACK0SELN1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N1_8_DDRIOLO_REG                      0x00000BE8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables Read DqDqs Training Mode
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX rxtrainingmode : 1;
    //
    // Enables Write Leveling Training Mode
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wltrainingmode : 1;
    //
    // Enables Read Leveling Training Mode.
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX rltrainingmode : 1;
    //
    // Enables SenseAmp offset cancellation training mode.
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX senseamptrainingmode : 1;
    //
    // When set, forces DQ/DQS drive enable to active.  Used in power measurements and
    // IO loopback mode  
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX txon : 1;
    //
    // Power-down Disable:  Forces register file read, overriding the rank power down
    // logic. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rfon : 1;
    //
    // Power-down Disable:  Forces RxDqs PI clocks on.
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX rxpion : 1;
    //
    // Power-down Disable:  Forces TxDq and TxDqs PI clocks on.
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX txpion : 1;
    //
    // 
    //           Forces on master DLL and all PI enables ON, despite both channel in
    // SelfRefresh, etc. low power states. 
    //         
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX internalclockson : 1;
    //
    // SaOffsetTrainTxon
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX saoffsettraintxon : 1;
    //
    // Power-down:  All write commands are ignored for this data-byte.  Used in single-channel
    // MCI mode. 
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX txdisable : 1;
    //
    // Power-down:  All read commands are ignored for this data-byte.  Used in single-channel
    // MCI mode.  
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX rxdisable : 1;
    //
    // Sets the duration of the first transmitted DQ bit of the burst. 0=1UI, 1=2UI.
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX txlong : 1;
    //
    // Controls the RX DQS CTLE setting.  (Code, CTLE) = { (0x0, Off),  (0x1, Use DQ),
    //  (0x2, BandPass),  (0x3, RSVD) }  
    // 
    // Bits[14:13], RW_L, default = 0x0
    //
    UINTX rxdqsctle : 2;
    //
    // Sets the RX read pointer offset on a reset.  Used during loopback and BERT mode.
    //  WrPtrPh1/WrPtrPh2 is reset to RxRdPt 
    // r (Default is to reset both to 0).
    // 
    // Bits[17:15], RW_L, default = 0x0
    //
    UINTX rxreadpointer : 3;
    //
    // Controls which segements of the driver are enabled:  {0: All, 1: Only ODT}.
    // 
    // Bits[18:18], RW_L, default = 0x0
    //
    UINTX driversegmentenable : 1;
    //
    // This will be connected to all tx, and must toggle 1->0 after a power state
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX drvpupdis : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a read c 
    // ommand to Rank = ReadRFRank
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX readrfrd : 1;
    //
    // Self clearing command bit. When set, it will download the three 32 bit lines from
    // the RegFile associated with a write  
    // command to Rank = ReadRFRank
    // 
    // Bits[21:21], RW_LV, default = 0x0
    //
    UINTX readrfwr : 1;
    //
    // Specifies the rank that ReadRFRd or ReadRFWr will manually download the CR values
    // from 
    // 
    // Bits[24:22], RW_LV, default = 0x0
    //
    UINTX readrfrank : 3;
    //
    // ODT is forced-on.
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // ODT and Senseamp are forced-off.
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsampoff : 1;
    //
    // not used
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disableodtstatic : 1;
    //
    // force ODT to the transmitter on, regardless of state of DriveEnable
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX ddrcrforceodton : 1;
    //
    // spare
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX spare : 1;
    //
    // Enables Xover Calibration Training Mode
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX xovercal : 1;
    //
    // Enables long preamble for DDR4 devices
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX longpreambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL0N1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N1_8_DDRIOLO_REG                      0x00000BEC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // enable phase shift based crosstalk cancellation.
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX xtalkpienable : 1;
    //
    // select if 0: capacitive coupling; or 1: inductive coupling; xtalk dominant
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX xtalkpisign : 1;
    //
    // delta phase shift in one aggressor is in effect
    // 
    // Bits[4:2], RW_L, default = 0x0
    //
    UINTX xtalkpidelta : 3;
    //
    // reserved
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX burstlength10 : 1;
    //
    // Enable DLL Weak Lock to save power during CKE power down: {0: Disabled, 1: Enable}
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX dllweaklock : 1;
    //
    // IOT mode 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX iolbmodeen : 1;
    //
    // Controls which slave DLL are disabled: {0: nibble0, 1: nibble1, 2: not used}
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX sdlldisable : 1;
    //
    // not used
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // Controls the Current and BW of the Receiver: {0: 0.34Idll, 1: 0.66Idll, 2: 0.88Idll,
    // 3: Idll, 4: 1.33Idll, 5: 1.66Idll 
    // , 6: 2.00Idll, 7: 2.33Idll}
    // 
    // Bits[12:10], RW_L, default = 0x0
    //
    UINTX rxbiasctl : 3;
    //
    // Controls ODT turn-on delay.   To turn on N tQCK before RcvEn, program to RcvEn[8:6]
    //  N + 4. 
    // 
    // Bits[16:13], RW_L, default = 0x0
    //
    UINTX odtdelay : 4;
    //
    // Controls the ODT ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7, 18
    // tQCK) 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX odtduration : 3;
    //
    // Controls Senseamp turn-on delay.   To turn on N tQCK before RcvEn, program to
    // RcvEn[8:6]  N + 4. 
    // 
    // Bits[23:20], RW_L, default = 0x0
    //
    UINTX senseampdelay : 4;
    //
    // Controls the SenseAmp ON duration from (Code, Duration) = (0x0, 11 tQCK) to (0x7,
    // 18 tQCK) 
    // 
    // Bits[26:24], RW_L, default = 0x0
    //
    UINTX senseampduration : 3;
    //
    // Cycles after the burst, when the current pulse should turn on by enabling OdtEn
    // for 1 cycle 
    // 
    // Bits[29:27], RW_L, default = 0x0
    //
    UINTX burstendodtdelay : 3;
    //
    // low voltage mode (ddr3lv, ddr3u, ddr4, smi, etc.)
    //             00: ddr3
    //             01: ddr3lv_smi
    //             10: ddr3u
    //             11: ddr4
    //         
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX lvmode : 2;
  } Bits;
  UINTX Data;
} DATACONTROL1N1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N1_8_DDRIOLO_REG                      0x00000BF0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enables SenseAmp offset cancellation training mode
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX rxvocselqnnnh : 5;
    //
    // Force on the internal Vref and Rx bias circuit, regardless of any other power
    // downs 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX forcebiason : 1;
    //
    // Force on the RxAmp only (as opposed to OdtSampOn, which turns on both ODT and
    // the amplifier). 
    //         Use for overclocking support where we may not be able to hit the fast
    // exit latency  
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX forcerxon : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // legacy from BDX for DDR3/VMSE configs"  DDRCOMP_CR_DDRCRCOMPOVR CTTermination
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Imode Select, 0: Swing Boost Mode; 1: (not supported) Xtalk Cancellation Mode
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX imodecfg : 1;
    //
    // Enable Imode EQ per byte lane. 
    //           0: Imode completely off 
    //           1: Imode enabled (Xtalk cancellation OR swing boost selected by ImodeCfg
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX imodeenable : 1;
    //
    // Spare
    // 
    // Bits[14:11], RW_L, default = 0x0
    //
    UINTX spare : 4;
    //
    // tbd
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX imodebiasen : 1;
    //
    // Spare1
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX spare1 : 2;
    //
    // Binary Imode Coefficient, sets Imode current strength.
    //           (used for either Xtalk cancellation or swing boost)
    //           Code   Imode Current (approx)
    //           ------------------
    //           0000        0
    //           0001        1
    //           0010        2
    //             *
    //             *
    //             *
    //           1111        3
    // 
    // Bits[21:18], RW_L, default = 0x0
    //
    UINTX imodeeqcode : 4;
    //
    // Imode Scomp Override Enable
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX imodescompovrd : 1;
    //
    // strobe Rx Amp offset control
    // 
    // Bits[27:23], RW_L, default = 0xF
    //
    UINTX rxdqssaoffset : 5;
    //
    // disable the offset control in DQ and DQS RxAmp
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX rxoffsetdisable : 1;
    //
    // VMSE Logic Delay
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX vmselogicdelay : 1;
    //
    // Spare2
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX spare2 : 1;
    //
    // not used
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX xoverdlyadj : 1;
  } Bits;
  UINTX Data;
} DATACONTROL2N1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N1_8_DDRIOLO_REG                      0x00000BF4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // binary default setting for static legs in DRV mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX drvstaticlegcfg : 2;
    //
    // binary default setting for static legs in ODT mode
    //            0    0       0 legs (EQ disabled)
    //            0    1       3 legs (EQ max 3 legs)
    //            1    0       6 legs (EQ max 6 legs)
    //            1    1      12 legs (EQ max 12 legs)
    //           In most cases, we would set this to be 11, but for some configurations
    // that require a higher  
    //           Ron value, we need to reduce the number of static legs enabled so that
    // fast corner can hit  
    //           the higher Ron target value.
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX odtstaticlegcfg : 2;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down mode the level
    // shifters. 
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling 
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // not use
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX rxdqssadisableshort : 1;
    //
    // This will tell which  segments are enabled out of reset.  
    //                      After that, a shift register will determine the enabled segments
    // 
    // Bits[8:6], RW_L, default = 0x1
    //
    UINTX odtsegmentenable : 3;
    //
    // This will tell which  segments are enabled out of reset. 
    // 
    // Bits[11:9], RW_L, default = 0x1
    //
    UINTX datasegmentenable : 3;
    //
    // When set, it will extends ODT by 1 qclk on read to write turnarounds. hsd 230773
    // 
    // Bits[12:12], RW_L, default = 0x1
    //
    UINTX longodtr2w : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // imodebias control 
    // 
    // Bits[14:14], RW_L, default = 0x1
    //
    UINTX imodebiasvrefen : 1;
    //
    // imodebias control. Also used for rxbiasana 
    // 
    // Bits[17:15], RW_L, default = 0x1
    //
    UINTX imodebiasrxbiastrim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // imodebias control 
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX imodebiasdfxddr4legup : 1;
    //
    // imodebias control 
    // 
    // Bits[20:20], RW_L, default = 0x1
    //
    UINTX imodebiasdfxlegdn : 1;
    //
    // ctle capacitor setting 
    // 
    // Bits[22:21], RW_L, default = 0x0
    //
    UINTX ddrcrctlecapen : 2;
    //
    // ctle resistor setting 
    // 
    // Bits[24:23], RW_L, default = 0x3
    //
    UINTX ddrcrctleresen : 2;
    //
    // RxBias CR 
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX pcasbiasclosedloopen : 1;
    //
    // RxBias CR 
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX rxbiassel : 1;
    //
    // RxBias CR 
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX rxbiasfoldedlegtrim : 2;
    //
    // RxBias CR 
    // 
    // Bits[30:29], RW_L, default = 0x1
    //
    UINTX rxbiasgcncomp : 2;
    //
    // Spare
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX postambleenable : 1;
  } Bits;
  UINTX Data;
} DATACONTROL3N1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN1_8_DDRIOLO_REG                0x00000BF8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   Channel 0 fubs : VssHi adjust setting. Channel1 fubs: DIMM VREF adjust settings.
    // 
    //         VssHi Field Description: 
    // 
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode          23     Selects the code to output:  {0: Code, 1: TCode}
    //         GainBoost        22     Enable gain boost is panic mode by updating code/tcode			
    //         PanicVoltage	 21:18  Unsigned integer controlling the voltage error on
    // VssHi that will trigger the panic driver.  Step size of VccDDQ/192 (0 to 117mV)
    //         CloseLoop        17     Enables the VssHi close loop tracking 
    //         PanicEn          16     Enables the VssHi Panic Driver
    //         BWError          15:14  Limits the loop gain (ie: difference between code
    // and tcode) to +/- 2^(SlowBWError) 
    //         OpenLoop         13     Operates VssHi in open loop mode with the target
    // Vref code directly driving the output DAC with no feedback involved 
    //         SampleDivider    12:10  Controls the loop bandwidth by dividing down the
    // input clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32,
    // 6: Qclk/64, 7: Qclk/128} 
    //         LoBWDivider      9:8    For the slow integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         HiBWDivider      7:6    For the fast integrator, selects the net number
    // of samples in a given direction to trip the filter.  {0: 4 samples, 1: 16 samples,
    // 2: 32 samples, 3: 64 samples} 
    //         Target           5:0    Unsigned integer controlling the target VssHi
    // voltage.  Step size of VccDDQ/192 and starting value of VccDDQ*20/192 
    // 
    //         
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DLLPITESTANDADCN1_8_DDRIOLO_REG                   0x00000BFC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Starts the test running.  Bit will stay high as long as test is running (ie:
    // poll for completion 
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX runtest : 1;
    //
    // Load the CR value for Count[9:0] into the FSM
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX load : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC.  
    //         
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX modehvm : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count  (0 to 1023 with step
    // size of ~ 1pS).  Mutex with ModeHVM/ModeADC.  
    //         
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX modedv : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV).  Mutex with ModeHVM/ModeDV.  
    //         
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX modeadc : 1;
    //
    // Load FSM with a starting point for count
    //         
    // 
    // Bits[14:5], RW_L, default = 0x0
    //
    UINTX loadcount : 10;
    //
    // Current Count code from the FSM (Read Only)
    //         
    // 
    // Bits[24:15], RO_V, default = 0x0
    //
    UINTX countstatus : 10;
    //
    // Spare 
    //         
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX spare : 7;
  } Bits;
  UINTX Data;
} DLLPITESTANDADCN1_8_DDRIOLO_STRUCT;
#endif // ASM_INC

#define VSSHIORVREFCONTROLN0_0_FIELD_DDRIOLO_REG          0x000002F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created  for new fields 
    // 
    // Bits[5:0], RW, default = 0x1E
    //
    UINTX vtargetgd : 6;
    //
    // New register created  for new fields 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINTX fastintgfactorgd : 2;
    //
    // New register created  for new fields 
    // 
    // Bits[9:8], RW, default = 0x2
    //
    UINTX slowintgfactorgd : 2;
    //
    // New register created  for new fields 
    // 
    // Bits[12:10], RW, default = 0x0
    //
    UINTX divctrl : 3;
    //
    // New register created  for new fields 
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINTX cropenloopgd : 1;
    //
    // New register created  for new fields 
    // 
    // Bits[15:14], RW, default = 0x2
    //
    UINTX maxerrgd : 2;
    //
    // New register created  for new fields 
    // 
    // Bits[16:16], RW, default = 0x1
    //
    UINTX panicengdl : 1;
    //
    // New register created  for new fields 
    // 
    // Bits[17:17], RW, default = 0x1
    //
    UINTX closeloopcr : 1;
    //
    // New register created  for new fields 
    // 
    // Bits[21:18], RW, default = 0x5
    //
    UINTX codepanic : 4;
    //
    // New register created  for new fields 
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINTX gainboostgdl : 1;
    //
    // New register created  for new fields 
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX viewselgdl : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} VSSHIORVREFCONTROLN0_0_FIELD_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXVREFCTRLN0_0_DATA_DDRIOLO_REG                   0x000002A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} RXVREFCTRLN0_0_DATA_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL0N0_0_DATA_DDRIOLO_REG                 0x000002E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DATACONTROL0N0_0_DATA_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL1N0_0_DATA_DDRIOLO_REG                 0x000002EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DATACONTROL1N0_0_DATA_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N0_0_DATA_DDRIOLO_REG                 0x000002F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DATACONTROL2N0_0_DATA_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL3N0_0_DATA_DDRIOLO_REG                 0x000002F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DATACONTROL3N0_0_DATA_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL4N0_0_DATA_DDRIOLO_REG                 0x000002CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DATACONTROL4N0_0_DATA_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXXTALKN0_0_DATA_DDRIOLO_REG                      0x000002A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} TXXTALKN0_0_DATA_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXOFFSETN0RANK0_0_DATA_DDRIOLO_REG                0x00000280
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} RXOFFSETN0RANK0_0_DATA_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP0N0RANK0_0_DATA_DDRIOLO_REG                0x00000200
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} RXGROUP0N0RANK0_0_DATA_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP0N0RANK0_0_DATA_DDRIOLO_REG                0x00000240
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} TXGROUP0N0RANK0_0_DATA_DDRIOLO_STRUCT;
#endif // ASM_INC

#define RXGROUP1N0RANK0_0_DATA_DDRIOLO_REG                0x00000220
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} RXGROUP1N0RANK0_0_DATA_DDRIOLO_STRUCT;
#endif // ASM_INC

#define TXGROUP1N0RANK0_0_DATA_DDRIOLO_REG                0x00000260
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} TXGROUP1N0RANK0_0_DATA_DDRIOLO_STRUCT;
#endif // ASM_INC

#define DATACONTROL2N0_0_FIELD_DDRIOLO_REG                0x000002F0
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[10:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 11;
    //
    // New register created for new fields: Spare[0]
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX spare_bit0 : 1;
    //
    // New register created for new fields: Spare[1]
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX spare_bit1 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 19;
  } Bits;
  UINTX Data;
} DATACONTROL2N0_0_FIELD_DDRIOLO_STRUCT;


#endif // _DDRIOLO_H_
