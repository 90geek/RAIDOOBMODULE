/*++

Copyright (c) 2005-2015 Intel Corporation. All rights reserved
This software and associated documentation (if any) is furnished
under a license and may only be used or copied in accordance
with the terms of the license. Except as permitted by such
license, no part of this software or documentation may be
reproduced, stored in a retrieval system, or transmitted in any
form or by any means without the express written consent of
Intel Corporation.

Module Name:

    File name:    COMP.h
    Input File:   SKX_MRC_for CTE updt-2015ww15.3.xlsx

Abstract:

    THIS FILE IS AUTO-GENERATED BY THE MMRC TOOL. DO NOT CHANGE THIS CODE.

    If edits are needed in this file, they must be done via the MMRC tool.

    If there is additional project-specific data required by the MMRC, it
    can be placed in COMP.h, which is used for non-tool-generated
    data

    Includes register defines specific to a project.

--*/
#ifndef _COMP_H_
#define _COMP_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define DDRCRDATACOMP0_COMP_REG                           0x00000F04
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Sets the resistive value (aka driving strength) of the pull-up block of the transmitter
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Spare 
    // 
    // Bits[8:6], RW_L, default = 0x0
    //
    UINTX spare0 : 3;
    //
    // Sets the resistive value (aka driving strength) of the pull-down block of the
    // transmitter 
    // 
    // Bits[14:9], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // Compensates for Vt offset in source follower driver in DimmVref and VssHi
    // 
    // Bits[19:15], RW_L, default = 0x5
    //
    UINTX vtcomp : 5;
    //
    // Skews to incoming duty cycle to achieve 50% duty cycle at the transmitter output
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Set the delay between different segments of the output buffer to adjust slew rate
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX slewratecomp : 5;
  } Bits;
  UINTX Data;
} DDRCRDATACOMP0_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRDATACOMP1_COMP_REG                           0x00000F08
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Sets the resistive value of the pull-up block of on die termination 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX rcompodtup : 6;
    //
    // Sets the resistive value of the pull-dn block of on die termination
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX rcompodtdown : 6;
    //
    // Sets the resistive value of the VssHi Panic driver pulldown to move VssHi by a
    // precise dV when it gets out of spec 
    // 
    // Bits[21:12], RW_L, default = 0x30
    //
    UINTX panicdrvdn : 10;
    //
    // Sets the resistive value of the VssHi Panic driver pullup to move VssHi by a precise
    // dV when it gets out of spec. 
    // 
    // Bits[31:22], RW_L, default = 0x30
    //
    UINTX panicdrvup : 10;
  } Bits;
  UINTX Data;
} DDRCRDATACOMP1_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRCMDCOMP_COMP_REG                             0x00000F0C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Set the delay between different segments of the output buffer to adjust slew rate
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX scomp : 6;
    //
    // Skews to incoming duty cycle to achieve 50% duty cycle at the transmitter output
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Sets the resistive value (aka driving strength) of the pull-up block of the transmitter
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Sets the resistive value (aka driving strength) of the pull-down block of the
    // transmitter 
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // not used.
    // 
    // Bits[27:25], RW_L, default = 0x4
    //
    UINTX lscomp : 3;
    //
    // Spare
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX spare : 4;
  } Bits;
  UINTX Data;
} DDRCRCMDCOMP_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRCTLCOMP_COMP_REG                             0x00000F10
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Set the delay between different segments of the output buffer to adjust slew rate
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX scomp : 6;
    //
    // Skews to incoming duty cycle to achieve 50% duty cycle at the transmitter output
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Sets the resistive value (aka driving strength) of the pull-up block of the transmitter
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Sets the resistive value (aka driving strength) of the pull-down block of the
    // transmitter 
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // Sets the level shifter pulse width compensation value to optimize EOS vs. Functionality.
    //   
    //           it is sent to CTL pins controling RxAmp for Loopback operation.
    // 
    // Bits[27:25], RW_L, default = 0x4
    //
    UINTX lscomp : 3;
    //
    // Spare
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX spare : 4;
  } Bits;
  UINTX Data;
} DDRCRCTLCOMP_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRCLKCOMP_CMP_COMP_REG                         0x00000F14
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Set the delay between different segments of the output buffer to adjust slew rate
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX scomp : 6;
    //
    // Skews to incoming duty cycle to achieve 50% duty cycle at the transmitter output
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX tcocomp : 7;
    //
    // Sets the resistive value (aka driving strength) of the pull-up block of the transmitter
    // 
    // Bits[18:13], RW_L, default = 0x0
    //
    UINTX rcompdrvup : 6;
    //
    // Sets the resistive value (aka driving strength) of the pull-down block of the
    // transmitter 
    // 
    // Bits[24:19], RW_L, default = 0x0
    //
    UINTX rcompdrvdown : 6;
    //
    // Sets the level shifter pulse width compensation value to optimize EOS vs. Functionality.
    //  
    //           it is sent to CLK pins controling RxAmp for Loopback operation.
    // 
    // Bits[27:25], RW_L, default = 0x4
    //
    UINTX lscomp : 3;
    //
    // Spare
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX spare : 4;
  } Bits;
  UINTX Data;
} DDRCRCLKCOMP_CMP_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRCOMPCTL0_COMP_REG                            0x00000F18
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX lvmodevalid : 1;
    //
    // low voltage mode (DDR3LV, DDR3U, DDR4)
    //             01: DDR3LV
    //             10: DDR3U
    //             11: DDR4
    //         DIMM support is processor type specific. 
    //         
    // 
    // Bits[2:1], RW_L, default = 0x3
    //
    UINTX lvmode : 2;
    //
    // Enable Visa debug bus LCB for COMP fub
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX visabusenable : 1;
    //
    // Offset between DqOdt Up and Down
    // 
    // Bits[9:4], RW_L, default = 0x0
    //
    UINTX dqodtupdnoff : 6;
    //
    // Skip DqRcomOdtDn compensation and use DqOdtDn = DqOdtUp + DqOdtUpDnOff
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX fixodtd : 1;
    //
    // 2's compliment analog offset for DqRcompDrvUp Vref with step size of Vccddq/64
    // 
    // Bits[17:11], RW_L, default = 0x0
    //
    UINTX dqdrvpupvref : 7;
    //
    // 2's compliment analog offset for DqRcompDrvDown Vref with step size of Vccddq/96
    // 
    // Bits[24:18], RW_L, default = 0x0
    //
    UINTX dqdrvpdnvref : 7;
    //
    // 2's compliment analog offset for DqOdtcompDrvUp Vref with step size of Vccddq/96
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX dqodtpupvref : 7;
  } Bits;
  UINTX Data;
} DDRCRCOMPCTL0_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRCOMPCTL1_COMP_REG                            0x00000F1C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // # of delay cells in DqScomp delayline. (Min Setting > 3)
    // 
    // Bits[3:0], RW_L, default = 0x0
    //
    UINTX dqscompcells : 4;
    //
    // When set (1'b1), SCOMP locks to a cycle, otherwise locks to a phase
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX dqscomppc : 1;
    //
    // # of delay cells in CmdScomp delayline = CmdScompCells
    // 
    // Bits[8:5], RW_L, default = 0x0
    //
    UINTX cmdscompcells : 4;
    //
    // When set (1'b1), SCOMP locks to a cycle, otherwise locks to a phase
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX cmdscomppc : 1;
    //
    // # of delay cells in CtlScomp delayline = CtlScompCells
    // 
    // Bits[13:10], RW_L, default = 0x0
    //
    UINTX ctlscompcells : 4;
    //
    // When set (1'b1), SCOMP locks to a cycle, otherwise locks to a phase
    // 
    // Bits[14:14], RW_L, default = 0x0
    //
    UINTX ctlscomppc : 1;
    //
    // Digital Offset to Tco code for CMD and CTL buffer vs. DQ buffer used for compensation
    // 
    // Bits[18:15], RW_L, default = 0x0
    //
    UINTX tcocmdoffset : 4;
    //
    // Enable all comp clocks and analog circuits overriding any power downs
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX compclkon : 1;
    //
    // not used.
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX vccddqhi : 1;
    //
    // Vref control for TcoComp loop, can be used to offset FSM result
    // 
    // Bits[27:21], RW_L, default = 0x0
    //
    UINTX tcovref : 7;
    //
    // not used.
    // 
    // Bits[29:28], RW_L, default = 0x0
    //
    UINTX gcncomp : 2;
    //
    // Enable single step through the global FSM for debug
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX sinstep : 1;
    //
    // Advance the global comp FSM by a single step for debug
    // 
    // Bits[31:31], RW_LV, default = 0x0
    //
    UINTX sinstepadv : 1;
  } Bits;
  UINTX Data;
} DDRCRCOMPCTL1_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRCOMPCTL2_COMP_REG                            0x00000F20
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ODT Comp Loop Staic Leg Config. 00: 0-leg; 01: 3-leg; 10: 6-leg; 11: 12-leg
    // 
    // Bits[1:0], RW_L, default = 0x3
    //
    UINTX odtstatlegen : 2;
    //
    // DQ Comp Loop Staic Leg Config. 00: 0-leg; 01: 3-leg; 10: 6-leg; 11: 12-leg
    // 
    // Bits[3:2], RW_L, default = 0x3
    //
    UINTX txdqstatlegen : 2;
    //
    // Cmd Comp Loop Staic Leg Config. 00: 0-leg; 01: 3-leg; 10: 6-leg; 11: 12-leg
    // 
    // Bits[5:4], RW_L, default = 0x3
    //
    UINTX cmdstatlegen : 2;
    //
    // unsiged analog offset for DqOdtRcompDrvDown Vref with step size of 0.75mW
    // 
    // Bits[12:6], RW_L, default = 0x0
    //
    UINTX dqodtpdnvref : 7;
    //
    // unsiged analog offset for ClkRcompDrvUp Vref with step size of 0.75mV
    // 
    // Bits[19:13], RW_L, default = 0x0
    //
    UINTX clkdrvpupvref : 7;
    //
    // unsigned analog offset for ClkRcompDrvDown Vref with step size of 0.75mV
    // 
    // Bits[26:20], RW_L, default = 0x0
    //
    UINTX clkdrvpdnvref : 7;
    //
    // rcomp dfx mode
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX rcomp_dfx_mode : 1;
    //
    // level shift hold enable
    //                      Holds the HV control values and power down the level shifters.
    //                      Apply "1" after training.  Slow timing - not advised for
    // fast enabling. 
    // 
    // Bits[28:28], RW_L, default = 0x0
    //
    UINTX lvlshft_holden : 1;
    //
    // Force ODT on used in dq/clk/ctl rcomp AIP
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX forceodton : 1;
    //
    // DDR3 Narrow Range
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX ddr3nren : 1;
    //
    // highbwen for panicvtcomp
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX highbwen : 1;
  } Bits;
  UINTX Data;
} DDRCRCOMPCTL2_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRCOMPVSSHI_COMP_REG                           0x00000F24
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Unsigned integer to select Vref for Panic DriverDn compensation. Step size of
    // VccIO/128 
    // 
    // Bits[5:0], RW_L, default = 0x0
    //
    UINTX panicdrvdnvref : 6;
    //
    // Unsigned integer to select Vref for Panic DriverUp compensation. Step size of
    // VccIO/128 
    // 
    // Bits[11:6], RW_L, default = 0x0
    //
    UINTX panicdrvupvref : 6;
    //
    // Digital Offset to VtComp value.  Unsigned interger in the VccIO domain with a
    // step size of VccIO/128 
    // 
    // Bits[16:12], RW_L, default = 0x0
    //
    UINTX vtoffset : 5;
    //
    // Slope adjustment to the VtComp value.  {0: 0, 1: -1/4, 2: -1/8, 3: -1/16, 4: +1/2,
    // 5: +1/4, 6: +1/8, 7: +1/16} 
    // 
    // Bits[19:17], RW_L, default = 0x0
    //
    UINTX vtslopea : 3;
    //
    // Slope adjustment to the VtComp value.  {0: 0, 1: -1/4, 2: -1/8, 3: -1/16, 4: +1/2,
    // 5: +1/4, 6: +1/8, 7: +1/16} 
    // 
    // Bits[22:20], RW_L, default = 0x0
    //
    UINTX vtslopeb : 3;
    //
    // divide by clk select for panicvt comp
    // 
    // Bits[25:23], RW_L, default = 0x0
    //
    UINTX clkdiv : 3;
    //
    // When this CSR bit is cleared,  S3LocalVcc in DIMM Vref is always on
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX ddrdmvrfs3localpwrgoodoverride : 1;
    //
    // Spare
    // 
    // Bits[27:27], RW_L, default = 0x0
    //
    UINTX disablemcdfxclkqnnnh : 1;
    //
    // Spare
    // 
    // Bits[31:28], RW_L, default = 0x0
    //
    UINTX spare : 4;
  } Bits;
  UINTX Data;
} DDRCRCOMPVSSHI_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRCOMPOVR_COMP_REG                             0x00000F28
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Override Data Rcomp DriveUp Value
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX dqdrvu : 1;
    //
    // Override Data Rcomp DriveDn Value
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX dqdrvd : 1;
    //
    // Override Data Rcomp OdtUp Value
    // 
    // Bits[2:2], RW_L, default = 0x0
    //
    UINTX dqodtu : 1;
    //
    // Override Data Rcomp OdtDn Value
    // 
    // Bits[3:3], RW_L, default = 0x0
    //
    UINTX dqodtd : 1;
    //
    // Override Cmd Rcomp DriveUp Value
    // 
    // Bits[4:4], RW_L, default = 0x0
    //
    UINTX cmddrvu : 1;
    //
    // Override Cmd Rcomp DriveDn Value
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX cmddrvd : 1;
    //
    // Override Ctl Rcomp DriveUp Value
    // 
    // Bits[6:6], RW_L, default = 0x0
    //
    UINTX ctldrvu : 1;
    //
    // Override Ctl Rcomp DriveDn Value
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX ctldrvd : 1;
    //
    // Override Clk Rcomp DriveUp Value
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX clkdrvu : 1;
    //
    // Override Clk Rcomp DriveDn Value
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX clkdrvd : 1;
    //
    // Override Data Scomp Value
    // 
    // Bits[10:10], RW_L, default = 0x0
    //
    UINTX dqsr : 1;
    //
    // Override Cmd Scomp Value
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX cmdsr : 1;
    //
    // Override Ctl Scomp Value
    // 
    // Bits[12:12], RW_L, default = 0x0
    //
    UINTX ctlsr : 1;
    //
    // Override Clk Scomp Value
    // 
    // Bits[13:13], RW_L, default = 0x0
    //
    UINTX clksr : 1;
    //
    // Override Data TcoOffset Value
    // 
    // Bits[14:14], RW_L, default = 0x0
    //
    UINTX dqtcooff : 1;
    //
    // Override Cmd TcoOffset Value
    // 
    // Bits[15:15], RW_L, default = 0x0
    //
    UINTX cmdtcooff : 1;
    //
    // Override Data Tco Value
    // 
    // Bits[16:16], RW_L, default = 0x1
    //
    UINTX dqtco : 1;
    //
    // Override Cmd Tco Value
    // 
    // Bits[17:17], RW_L, default = 0x1
    //
    UINTX cmdtco : 1;
    //
    // Override Ctl Tco Value
    // 
    // Bits[18:18], RW_L, default = 0x1
    //
    UINTX ctltco : 1;
    //
    // Override Clk Tco Value
    // 
    // Bits[19:19], RW_L, default = 0x1
    //
    UINTX clktco : 1;
    //
    // Enable finer vref resolution in ddr4
    // 
    // Bits[20:20], RW_L, default = 0x0
    //
    UINTX ddr4extend : 1;
    //
    // Override Panic DriveUp Value
    // 
    // Bits[21:21], RW_L, default = 0x0
    //
    UINTX panicdrvup : 1;
    //
    // Override Panic DriveDn Value
    // 
    // Bits[22:22], RW_L, default = 0x0
    //
    UINTX panicdrvdn : 1;
    //
    // Override VT Comp Value
    // 
    // Bits[23:23], RW_L, default = 0x0
    //
    UINTX vtcomp : 1;
    //
    // Override ViewDig DriveEn Value
    // 
    // Bits[24:24], RW_L, default = 0x0
    //
    UINTX viewdigdrven : 1;
    //
    //  used to be VccddqHi in HSW, both are equivalent
    //           1 - Nominal Vccddq voltage is 1.5v
    //           0 - Nominal Vccddq voltage is 1.35v or 1.2v
    //         
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX cttermination : 1;
    //
    // Override Clkgating signal for lcben in ifc
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX centerrptclkenovrd : 1;
    //
    // Spare
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX spare2 : 5;
  } Bits;
  UINTX Data;
} DDRCRCOMPOVR_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRCOMPVSSHICONTROL_COMP_REG                    0x00000F2C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VssHi control bits
    // 
    // Bits[23:0], RW_L, default = 0x4D8238
    //
    UINTX vsshiorvrefctl : 24;
    //
    // Read the current code being generated by the VssHi feedback loop.  Use SelCode
    // field to control which instance is read.  
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} DDRCRCOMPVSSHICONTROL_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRDIMMVREFCONTROL1_COMP_REG                    0x00000F30
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Ch0 CA DIMM Vref Control. 
    //                       2s compliment encoding with 0 = Vdd/2, range of +/- Vdd/6
    // and step size of Vdd/384 (3.9mV) 
    // 		      NOTE: LSB (bit 0) is a DFX feature (averaging between two codes) - only
    // use even codes so that LSB is '0'. 
    //         
    // 
    // Bits[7:0], RW_L, default = 0x0
    //
    UINTX ch0cavrefctl : 8;
    //
    //  ch2 DQ DIMM Vref Control.
    //                       2s compliment encoding with 0 = Vdd/2, range of +/- Vdd/6
    // and step size of Vdd/384 (3.9mV) 
    // 		      NOTE: LSB (bit 7) is a DFX feature (averaging between two codes) - only
    // use even codes so that LSB is '0'. 
    //         
    // 
    // Bits[15:8], RW_L, default = 0x0
    //
    UINTX ch2cavrefctl : 8;
    //
    //  ch1 DQ DIMM Vref Control.
    //                       2s compliment encoding with 0 = Vdd/2, range of +/- Vdd/6
    // and step size of Vdd/384 (3.9mV) 
    // 		      NOTE: LSB (bit 14) is a DFX feature - only use even codes so that LSB
    // is '0'. 
    //         
    // 
    // Bits[23:16], RW_L, default = 0x0
    //
    UINTX ch1cavrefctl : 8;
    //
    // Enables Ch0 CA DIMM Vref
    // 
    // Bits[24:24], RW_L, default = 0x0
    //
    UINTX ch0caendimmvref : 1;
    //
    // Enables Channel 2 DIMM Vref
    // 
    // Bits[25:25], RW_L, default = 0x0
    //
    UINTX ch2caendimmvref : 1;
    //
    // Enables Channel 1 DIMM Vref
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX ch1caendimmvref : 1;
    //
    //  For the HiZ Timer, selects the number of clocks for the timer to expire 
    //                       {0: 4 cycles, 1: 8 cycles, 2: 16 cycles, 3: 32 cycles}
    //         
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX hiztimerctrl : 2;
    //
    // Ch0 CA Vref controller has completed initial convergence and is in slow BW mode.
    //  If used as a lock detector, add 5uS after slow BW mode is achieved for full convergence
    // 
    // Bits[29:29], RO_V, default = 0x0
    //
    UINTX ch0caslowbw : 1;
    //
    // Ch1 Vref controller has completed initial convergence and is in slow BW mode.
    //  If used as a lock detector, add 5uS after slow BW mode is achieved for full convergence
    // 
    // Bits[30:30], RO_V, default = 0x0
    //
    UINTX ch1caslowbw : 1;
    //
    // Ch2 Vref controller has completed initial convergence and is in slow BW mode.
    //  If used as a lock detector, add 5uS after slow BW mode is achieved for full convergence
    // 
    // Bits[31:31], RO_V, default = 0x0
    //
    UINTX ch2caslowbw : 1;
  } Bits;
  UINTX Data;
} DDRCRDIMMVREFCONTROL1_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRDIMMVREFCONTROL2_COMP_REG                    0x00000F34
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  DIMM VREF adjust settings.
    //          Field          Bits    Description
    //         -------         ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //         SelCode         23:21   Selects the code to output:  [0] = {0: Code, 1:
    // TCode}  [2:1] = {0: Select Ch0 CA Code, 1: Select DQCh1 Code, 2: Select DQCh2
    // Code}   
    //     VtOffset    20:18   Offset for VtComp to convert from VccIO to VccDDQ.  Signed
    // integer in VccDDQ domain with a step size of VccDDQ/48 (32 mV) 
    //     VtSlopeA    17:15   Slope correction to convert between VtComp in VccIO to
    // VccDDQ: {0: 0, 1: -1/8, 2: -1/16, 3: -1/32. 4: +1/4, 5: +1/8, 6: +1/16. 7: +1/32}
    //     VtSlopeB    14:12   Slope correction to convert between VtComp in VccIO to
    // VccDDQ: {0: 0, 1: -1/8, 2: -1/16, 3: -1/32. 4: +1/4, 5: +1/8, 6: +1/16. 7: +1/32}
    //     Reserved        11      Reserved for future usage
    //     HiBWEnable  10  Enables high bandwidth mode after a code change to allow fast
    // loop convergence 
    //     SlowBWError 9:8 In slow BW mode, limits the loop gain (ie: difference between
    // code and tcode) to +/- 2^(SlowBWError) 
    //     OpenLoop    7   Operates the dimm vref in open loop mode with the target Vref
    // code directly driving the output DAC with no feedback involved 
    //     SampleDivider   6:4 Controls the loop bandwidth by dividing down the input
    // clock: {0: Qclk, 1: Qclk/2, 2: Qclk/4, 3: Qclk/8, 4: Qclk/16, 5: Qclk/32, 6: Qclk/64,
    // 7: Qclk/128} 
    //     LoBWDivider 3:2 For the slow integrator, selects the net number of samples
    // in a given direction to trip the filter.  {0: 4 samples, 1: 8 samples, 2: 16 samples,
    // 3: 32 samples}  
    //     HiBWDivider 1:0 For the fast integrator, selects the net number of samples
    // in a given direction to trip the filter.  {0: 4 samples, 1: 8 samples, 2: 16 samples,
    // 3: 32 samples}  
    //         
    // 
    // Bits[23:0], RW_L, default = 0xE4500
    //
    UINTX dimmvrefctl : 24;
    //
    // Read the current code being generated by the feedback loop.  Use SelCode field
    // to control which instance is read 
    // 
    // Bits[31:24], RO_V, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} DDRCRDIMMVREFCONTROL2_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRSPDCFG1_COMP_REG                             0x00000F38
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   SPD config1
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //     
    //         spd_rcomp          21:15   view CComp
    //         spd_scomp_p        14:9   view SComp
    //         spd_scomp_n          8:3   view SComp
    //         spd_slowbuffer_ctl2    2   View Slow buffer control / Control ddr_viewdig1
    //  
    //         spd_slowbuffer_ctl1    1   View Slow buffer control / Control ddr_viewdig0
    //  
    //         spd_ddr_chdbg_sel      0   View Debug mux select in spd,  / 1'b1  - select
    // ch0   
    //         
    // 
    // Bits[21:0], RW_L, default = 0x0
    //
    UINTX crspdcfg1 : 22;
    //
    // Odt up segment Enable
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX odtupsegen : 2;
    //
    // Odt down segment Enable
    // 
    // Bits[25:24], RW_L, default = 0x0
    //
    UINTX odtdnsegen : 2;
    //
    // Dq segment Override
    // 
    // Bits[26:26], RW_L, default = 0x0
    //
    UINTX odtsegovrd : 1;
    //
    // Reserved for future usage
    // 
    // Bits[31:27], RW_L, default = 0x0
    //
    UINTX rsvd : 5;
  } Bits;
  UINTX Data;
} DDRCRSPDCFG1_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRSPDCFG2_COMP_REG                             0x00000F3C
#ifndef ASM_INC
typedef union {
  struct {
    //
    //   SPD config2
    //         Field Description: 
    // 
    //          Field             Bits    Description
    //         -------            ----    ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    //     
    //         spd_smbus1b           14   SPD/
    //         spd_hys_configp    13:12   SPD/Memhot/View
    //         spd_hys_confign_b  11:10   SPD/Memhot/View
    //         spd_rcompnctl        9:5   SPD/Memhot RComp
    //         spd_scompnctl        4:0   SPD/Memhot SComp
    //         
    // 
    // Bits[14:0], RW_L, default = 0x0
    //
    UINTX crspdcfg2 : 15;
    //
    // Dq up segment Enable
    // 
    // Bits[16:15], RW_L, default = 0x0
    //
    UINTX dqupsegen : 2;
    //
    // Dq down segment Enable
    // 
    // Bits[18:17], RW_L, default = 0x0
    //
    UINTX dqdnsegen : 2;
    //
    // Dq segment Override
    // 
    // Bits[19:19], RW_L, default = 0x0
    //
    UINTX dqsegovrd : 1;
    //
    // Clk up segment Enable
    // 
    // Bits[21:20], RW_L, default = 0x0
    //
    UINTX clkupsegen : 2;
    //
    // Clk down segment Enable
    // 
    // Bits[23:22], RW_L, default = 0x0
    //
    UINTX clkdnsegen : 2;
    //
    // Clk segment Override
    // 
    // Bits[24:24], RW_L, default = 0x0
    //
    UINTX clksegovrd : 1;
    //
    // Ctl up segment Enable
    // 
    // Bits[26:25], RW_L, default = 0x0
    //
    UINTX ctlupsegen : 2;
    //
    // Ctl down segment Enable
    // 
    // Bits[28:27], RW_L, default = 0x0
    //
    UINTX ctldnsegen : 2;
    //
    // Ctl segment Override
    // 
    // Bits[29:29], RW_L, default = 0x0
    //
    UINTX ctlsegovrd : 1;
    //
    // Reserved for future usage
    // 
    // Bits[31:30], RW_L, default = 0x0
    //
    UINTX rsvd : 2;
  } Bits;
  UINTX Data;
} DDRCRSPDCFG2_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRCOMPCTL3_COMP_REG                            0x00000F40
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2's compliment analog offset for CmdRcompDrvUp Vref with step size of Vccddq/96
    // 
    // Bits[6:0], RW_L, default = 0x0
    //
    UINTX cmddrvpupvref : 7;
    //
    // 2's compliment analog offset for CmdRcompDrvDown Vref with step size of Vccddq/96
    // 
    // Bits[13:7], RW_L, default = 0x0
    //
    UINTX cmddrvpdnvref : 7;
    //
    // 2's compliment analog offset for CtlRcompDrvUp Vref with step size of Vccddq/96
    // 
    // Bits[20:14], RW_L, default = 0x0
    //
    UINTX ctldrvpupvref : 7;
    //
    // 2's compliment analog offset for CtlRcompDrvDown Vref with step size of Vccddq/96
    // 
    // Bits[27:21], RW_L, default = 0x0
    //
    UINTX ctldrvpdnvref : 7;
    //
    // Switch capacitor comparator clock select
    // 
    // Bits[29:28], RW_L, default = 0x0
    //
    UINTX swcapcmpclksel : 2;
    //
    // Half LSB Shift Enable
    // 
    // Bits[30:30], RW_L, default = 0x0
    //
    UINTX halflsbshiften : 1;
    //
    // dfxsel for cmd rcomp
    // 
    // Bits[31:31], RW_L, default = 0x0
    //
    UINTX dfxsel : 1;
  } Bits;
  UINTX Data;
} DDRCRCOMPCTL3_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRCOMPVSSHI1_COMP_REG                          0x00000F44
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Spare
    // 
    // Bits[17:0], RW_L, default = 0x0
    //
    UINTX spare0 : 18;
    //
    // Multiplier to the Panic Comp Up code to expand to 10 bits
    // 
    // Bits[24:18], RW_L, default = 0x0
    //
    UINTX paniccompupmult : 7;
    //
    // Multiplier to the Panic Comp Dn code to expand to 10 bits
    // 
    // Bits[31:25], RW_L, default = 0x0
    //
    UINTX paniccompdnmult : 7;
  } Bits;
  UINTX Data;
} DDRCRCOMPVSSHI1_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRDIMMVREFCONTROL2_FIELD_COMP_REG              0x00000F34
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created  for new fields 
    // 
    // Bits[1:0], RW, default = 0x2
    //
    UINTX fastbwfactor : 2;
    //
    // New register created  for new fields 
    // 
    // Bits[3:2], RW, default = 0x1
    //
    UINTX slowbwfactor : 2;
    //
    // New register created  for new fields 
    // 
    // Bits[6:4], RW, default = 0x6
    //
    UINTX dividerctl : 3;
    //
    // New register created  for new fields 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINTX openloopen : 1;
    //
    // New register created  for new fields 
    // 
    // Bits[9:8], RW, default = 0x1
    //
    UINTX slowbwmaxerror : 2;
    //
    // New register created  for new fields 
    // 
    // Bits[10:10], RW, default = 0x1
    //
    UINTX fastbwmodeen : 1;
    //
    // New register created  for new fields 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX spare : 1;
    //
    // New register created  for new fields 
    // 
    // Bits[14:12], RW, default = 0x6
    //
    UINTX vtslopeb : 3;
    //
    // New register created  for new fields 
    // 
    // Bits[17:15], RW, default = 0x4
    //
    UINTX vtslopea : 3;
    //
    // New register created  for new fields 
    // 
    // Bits[20:18], RW, default = 0x5
    //
    UINTX vtoffset : 3;
    //
    // New register created  for new fields 
    // 
    // Bits[23:21], RW, default = 0x0
    //
    UINTX selcode : 3;
    //
    // New register created  for new fields 
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX outputcode : 8;
  } Bits;
  UINTX Data;
} DDRCRDIMMVREFCONTROL2_FIELD_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRCOMPVSSHI_DATA_COMP_REG                      0x00000F24
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DDRCRCOMPVSSHI_DATA_COMP_STRUCT;
#endif // ASM_INC

#define DDRCRCOMPOVR_DATA_COMP_REG                        0x00000F28
#ifndef ASM_INC
typedef union {
  struct {
    //
    // New register created for setting/reading entire data
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX data : 32;
  } Bits;
  UINTX Data;
} DDRCRCOMPOVR_DATA_COMP_STRUCT;
#endif // ASM_INC


#endif // _COMP_H_
