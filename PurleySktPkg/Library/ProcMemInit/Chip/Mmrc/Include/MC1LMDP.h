/*++

Copyright (c) 2005-2015 Intel Corporation. All rights reserved
This software and associated documentation (if any) is furnished
under a license and may only be used or copied in accordance
with the terms of the license. Except as permitted by such
license, no part of this software or documentation may be
reproduced, stored in a retrieval system, or transmitted in any
form or by any means without the express written consent of
Intel Corporation.

Module Name:

    File name:    MC1LMDP.h
    Input File:   SKX_MRC_for CTE updt-2015ww15.3.xlsx

Abstract:

    THIS FILE IS AUTO-GENERATED BY THE MMRC TOOL. DO NOT CHANGE THIS CODE.

    If edits are needed in this file, they must be done via the MMRC tool.

    If there is additional project-specific data required by the MMRC, it
    can be placed in MC1LMDP.h, which is used for non-tool-generated
    data

    Includes register defines specific to a project.

--*/
#ifndef _MC1LMDP_H_
#define _MC1LMDP_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define VID_MC1LMDP_REG                                   0x00000000
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The value is assigned by PCI-SIG to Intel.
    // 
    // Bits[15:0], RO, default = 0x8086
    //
    UINTX vendor_identification_number : 16;
  } Bits;
  UINTX Data;
} VID_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DID_MC1LMDP_REG                                   0x00000002
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  
    // Start (h)	End (h)	Device
    // 0x203F		0x203F	
    // 0x2040		0x204B	MC
    // 0x204C		0x204F	M3KTI
    // 0x2054		0x2054	CHASADALL
    // 0x2055		0x2055	CHAUTILALL
    // 0x2056		0x2056	CHAUTILALL1
    // 0x2057		0x2057	CHAPMAALL
    // 0x2058		0x205B	KTI
    // 0x2066		0x2067	M2MEM
    // 0x2068		0x206F	MC DDRIO
    // 0x2078		0x207F	VCU
    // 0x2080		0x2087	PCU
    // 0x2088		0x2088	
    // 0x2089		0x2089	
    // 0x208A		0x208A	
    // 0x208B		0x208B	
    // 0x208C		0x208C	
    // 0x208D		0x208D	CHAUTIL
    // 0x208E		0x208E	CHASAD
    // 0x208F		0x208F	CMSCHA
    // 0x2090		0x209F	RSVD FOR PCU FUNCTION 3
    // 	
    // 
    // Bits[15:0], RO, default = 0x2043
    //
    UINTX device_identification_number : 16;
  } Bits;
  UINTX Data;
} DID_MC1LMDP_STRUCT;
#endif // ASM_INC

#define PCICMD_MC1LMDP_REG                                0x00000004
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Hardwired to 0 since these devices don't decode any IO BARs
    // 
    // Bits[0:0], RO, default = 0x0
    //
    UINTX io_space_enable : 1;
    //
    // Hardwired to 0 since these devices don't decode any memory BARs
    // 
    // Bits[1:1], RO, default = 0x0
    //
    UINTX memory_space_enable : 1;
    //
    // Hardwired to 0 since these devices don't generate any transactions
    // 
    // Bits[2:2], RO, default = 0x0
    //
    UINTX bus_master_enable : 1;
    //
    // Not applicable. Hardwired to 0.
    // 
    // Bits[3:3], RO, default = 0x0
    //
    UINTX special_cycle_enable : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[4:4], RO, default = 0x0
    //
    UINTX memory_write_and_invalidate_enable : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[5:5], RO, default = 0x0
    //
    UINTX vga_palette_snoop_enable : 1;
    //
    // This bit has no impact on error reporting from these devices
    // 
    // Bits[6:6], RO, default = 0x0
    //
    UINTX parity_error_response : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX idsel_stepping_wait_cycle_control : 1;
    //
    // This bit has no impact on error reporting from these devices
    // 
    // Bits[8:8], RO, default = 0x0
    //
    UINTX serr_enable : 1;
    //
    // Not applicable to PCI Express and is hardwired to 0
    // 
    // Bits[9:9], RO, default = 0x0
    //
    UINTX fast_back_to_back_enable : 1;
    //
    // N/A for these devices
    // 
    // Bits[10:10], RO, default = 0x0
    //
    UINTX intx_disable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
  } Bits;
  UINTX Data;
} PCICMD_MC1LMDP_STRUCT;
#endif // ASM_INC

#define PCISTS_MC1LMDP_REG                                0x00000006
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Reflects the state of the INTA# signal at the input of the enable/disable circuit.
    //  This bit is set by HW to 1 when the INTA# is asserted.  This bit is reset by
    // HW to 0 after the interrupt is cleared (independent of the state of the Interrupt
    // Disable bit in the 0.4.0.PCICMD register). 
    // Hardwired to 0 on the processor
    // 
    // Bits[3:3], RO, default = 0x0
    //
    UINTX intx_status : 1;
    //
    // This bit indicates the presence of a capabilities list structure. When set to
    // 1, indicates the register at 34h provides an offset into the function. 
    // 
    // Bits[4:4], RO, default = 0x1
    //
    UINTX capabilities_list : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[5:5], RO, default = 0x0
    //
    UINTX x66mhz_capable : 1;
    //
    // Reserved
    // 
    // Bits[6:6], RO, default = 0x0
    //
    UINTX reserved : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX fast_back_to_back : 1;
    //
    // Hardwired to 0
    // 
    // Bits[8:8], RO, default = 0x0
    //
    UINTX master_data_parity_error : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[10:9], RO, default = 0x0
    //
    UINTX devsel_timing : 2;
    //
    // Hardwired to 0
    // 
    // Bits[11:11], RO, default = 0x0
    //
    UINTX signaled_target_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[12:12], RO, default = 0x0
    //
    UINTX received_target_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[13:13], RO, default = 0x0
    //
    UINTX received_master_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[14:14], RO, default = 0x0
    //
    UINTX signaled_system_error : 1;
    //
    // This bit is set when the device receives a packet on the primary side with an
    // uncorrectable data error (including a packet with poison bit set) or an uncorrectable
    // address/control parity error. The setting of this bit is regardless of the Parity
    // Error Response bit (PERRE) in the PCICMD register. 
    // 
    // Bits[15:15], RO_V, default = 0x0
    //
    UINTX detected_parity_error : 1;
  } Bits;
  UINTX Data;
} PCISTS_MC1LMDP_STRUCT;
#endif // ASM_INC

#define RID_MC1LMDP_REG                                   0x00000008
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reflects the Uncore Revision ID after reset.
    // Reflects the Compatibility Revision ID after BIOS writes 0x69 to any RID register
    // in the processor uncore. 
    //         
    // 
    // Bits[7:0], RO_V, default = 0x0
    //
    UINTX revision_id : 8;
  } Bits;
  UINTX Data;
} RID_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CCR_MC1LMDP_REG                                   0x00000009
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[7:0], RO_V, default = 0x0
    //
    UINTX register_level_programming_interface : 8;
    //
    // The value changes dependent upon the dev/func accessed. A table of the values
    // can be found in the Class-code tab of the msgch spread-sheet  
    // 	  Most dev-func will return 8'h80 for this field except for the following dev-func0,func1,...
    // combinations. The following exceptions will return 8'h01. Please refer to /src/uncore/ncu/f_ccr_reg.vh
    // for the full lookingup table. 
    //           bus-0, dev-8 func-1 
    //           bus-3, dev-14 to 16, func-0
    //           bus-3, dev-18, func-0, 1, 4, 5
    //         
    // 
    // Bits[15:8], RO_V, default = 0x80
    //
    UINTX sub_class : 8;
    //
    // The value changes dependent upon the dev-func accessed. A table of the values
    // can be found in the Class-code tab of the msgch spread-sheet  
    // 	  Most bus-dev-func will return 8'h08 for this field except for the following
    // bus-dev-func0,func1,... combinations. The following exceptions will return 8'h11.
    // Please refer to /src/uncore/ncu/f_ccr_reg.vhfor the full lookingup table. 
    //           bus-0, dev-8 func-1 
    //           bus-3, dev-14 to 16, func-0
    //           bus-3, dev-18, func-0, 1, 4, 5
    //         
    // 
    // Bits[23:16], RO_V, default = 0x8
    //
    UINTX base_class : 8;
  } Bits;
  UINTX Data;
} CCR_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CLSR_MC1LMDP_REG                                  0x0000000C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Size of Cacheline
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX cacheline_size : 8;
  } Bits;
  UINTX Data;
} CLSR_MC1LMDP_STRUCT;
#endif // ASM_INC

#define PLAT_MC1LMDP_REG                                  0x0000000D
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Not applicable to PCI-Express. Hardwired to 00h.
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX primary_latency_timer : 8;
  } Bits;
  UINTX Data;
} PLAT_MC1LMDP_STRUCT;
#endif // ASM_INC

#define HDR_MC1LMDP_REG                                   0x0000000E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Type 0 header
    // 
    // Bits[6:0], RO, default = 0x0
    //
    UINTX configuration_layout : 7;
    //
    // This bit defaults to 1b since all these devices are multi-function
    // 
    // Bits[7:7], RO, default = 0x1
    //
    UINTX multi_function_device : 1;
  } Bits;
  UINTX Data;
} HDR_MC1LMDP_STRUCT;
#endif // ASM_INC

#define BIST_MC1LMDP_REG                                  0x0000000F
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Not supported. Hardwired to 00h
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX bist_tests : 8;
  } Bits;
  UINTX Data;
} BIST_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CAPPTR_MC1LMDP_REG                                0x00000034
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Points to the first capability structure for the device which is the PCIe capability.
    // 
    // Bits[7:0], RO, default = 0x40
    //
    UINTX capability_pointer : 8;
  } Bits;
  UINTX Data;
} CAPPTR_MC1LMDP_STRUCT;
#endif // ASM_INC

#define INTL_MC1LMDP_REG                                  0x0000003C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A for these devices
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX interrupt_line : 8;
  } Bits;
  UINTX Data;
} INTL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define INTPIN_MC1LMDP_REG                                0x0000003D
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A since these devices do not generate any interrupt on their own
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX interrupt_pin : 8;
  } Bits;
  UINTX Data;
} INTPIN_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MINGNT_MC1LMDP_REG                                0x0000003E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The device does not burst as a PCI compliant master.
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX mgv : 8;
  } Bits;
  UINTX Data;
} MINGNT_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MAXLAT_MC1LMDP_REG                                0x0000003F
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The device has no specific requirements for how often it needs to access the PCI
    // bus. 
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX mlv : 8;
  } Bits;
  UINTX Data;
} MAXLAT_MC1LMDP_STRUCT;
#endif // ASM_INC

#define SCRATCHPAD_MC1LMDP_REG                            0x000001FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SCRATCHPAD
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX scratchpad : 32;
  } Bits;
  UINTX Data;
} SCRATCHPAD_MC1LMDP_STRUCT;
#endif // ASM_INC

#define SVID_MC1LMDP_REG                                  0x0000002C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The default value specifies Intel but can be set to any value once after reset.
    // 
    // Bits[15:0], RW_O, default = 0x8086
    //
    UINTX subsystem_vendor_identification_number : 16;
  } Bits;
  UINTX Data;
} SVID_MC1LMDP_STRUCT;
#endif // ASM_INC

#define SDID_MC1LMDP_REG                                  0x0000002E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Assigned by the subsystem vendor to uniquely identify the subsystem
    // 
    // Bits[15:0], RW_O, default = 0x0
    //
    UINTX subsystem_device_identification_number : 16;
  } Bits;
  UINTX Data;
} SDID_MC1LMDP_STRUCT;
#endif // ASM_INC

#define PXPCAP_MC1LMDP_REG                                0x00000040
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Provides the PCI Express capability ID assigned by PCI-SIG.
    // 
    // Bits[7:0], RO, default = 0x10
    //
    UINTX capability_id : 8;
    //
    // Pointer to the next capability. Set to 0 to indicate there are no more capability
    // structures. 
    // 
    // Bits[15:8], RO, default = 0x0
    //
    UINTX next_ptr : 8;
    //
    // PCI Express Capability is Compliant with Version 1.0 of the PCI Express Spec.
    // Note:
    // This capability structure is not compliant with Versions beyond 1.0, since they
    // require additional capability registers to be reserved. The only purpose for this
    // capability structure is to make enhanced configuration space available. Minimizing
    // the size of this structure is accomplished by reporting version 1.0 compliancy
    // and reporting that this is an integrated root port device. As such, only three
    // Dwords of configuration space are required for this structure. 
    // 
    // Bits[19:16], RO, default = 0x1
    //
    UINTX capability_version : 4;
    //
    // Device type is Root Complex Integrated Endpoint
    // 
    // Bits[23:20], RO, default = 0x9
    //
    UINTX device_port_type : 4;
    //
    // N/A for integrated endpoints
    // 
    // Bits[24:24], RO, default = 0x0
    //
    UINTX slot_implemented : 1;
    //
    // N/A for this device
    // 
    // Bits[29:25], RO, default = 0x0
    //
    UINTX interrupt_message_number : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} PXPCAP_MC1LMDP_STRUCT;
#endif // ASM_INC

#define ROUNDTRIP0_MC1LMDP_REG                            0x00000080
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rank 0 round trip latency in QCLK, 88 max configurable value
    // 
    // Bits[7:0], RW, default = 0xB
    //
    UINTX rt_rank0 : 8;
    //
    // Rank 1 round trip latency in QCLK
    // 
    // Bits[15:8], RW, default = 0xB
    //
    UINTX rt_rank1 : 8;
    //
    // Rank 2 round trip latency in QCLK
    // 
    // Bits[23:16], RW, default = 0xB
    //
    UINTX rt_rank2 : 8;
    //
    // Rank 3 round trip latency in QCLK
    // 
    // Bits[31:24], RW, default = 0xB
    //
    UINTX rt_rank3 : 8;
  } Bits;
  UINTX Data;
} ROUNDTRIP0_MC1LMDP_STRUCT;
#endif // ASM_INC

#define ROUNDTRIP1_MC1LMDP_REG                            0x00000084
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rank 4 round trip latency in QCLK
    // 
    // Bits[7:0], RW, default = 0xB
    //
    UINTX rt_rank4 : 8;
    //
    // Rank 5 round trip latency in QCLK
    // 
    // Bits[15:8], RW, default = 0xB
    //
    UINTX rt_rank5 : 8;
    //
    // Rank 6 round trip latency in QCLK
    // 
    // Bits[23:16], RW, default = 0xB
    //
    UINTX rt_rank6 : 8;
    //
    // Rank 7 round trip latency in QCLK
    // 
    // Bits[31:24], RW, default = 0xB
    //
    UINTX rt_rank7 : 8;
  } Bits;
  UINTX Data;
} ROUNDTRIP1_MC1LMDP_STRUCT;
#endif // ASM_INC

#define IOLATENCY0_MC1LMDP_REG                            0x0000008C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rank 0 IO latency in QCLK
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX io_lat_rank0 : 4;
    //
    // Rank 1 IO latency in QCLK
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX io_lat_rank1 : 4;
    //
    // Rank 2 IO latency in QCLK
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX io_lat_rank2 : 4;
    //
    // Rank 3 IO latency in QCLK
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX io_lat_rank3 : 4;
    //
    // Rank 4 IO latency in QCLK
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX io_lat_rank4 : 4;
    //
    // Rank 5 IO latency in QCLK
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX io_lat_rank5 : 4;
    //
    // Rank 6 IO latency in QCLK
    // 
    // Bits[27:24], RW, default = 0x0
    //
    UINTX io_lat_rank6 : 4;
    //
    // Rank 7 IO latency in QCLK
    // 
    // Bits[31:28], RW, default = 0x0
    //
    UINTX io_lat_rank7 : 4;
  } Bits;
  UINTX Data;
} IOLATENCY0_MC1LMDP_STRUCT;
#endif // ASM_INC

#define IOLATENCY1_MC1LMDP_REG                            0x00000090
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX io_lat_io_comp : 8;
    //
    //     1 = DDR4 write CRC is enabled
    //             0 = DDR4 write CRC is disabled
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX cr_wrcrc_enable : 1;
    //
    // All the bits those are high, lead to inversion of correct CRC in the 8
    // 	 bit CRC generated per device (be it x4 or x8)
    // 	 Note that there is no provision for injecting error in the all-ones of the
    //          9th beat of X8 device CRC
    // 
    // Bits[16:9], RW, default = 0x0
    //
    UINTX cr_crc_err_inj : 8;
    //
    //     When this bit is set high, then the first write operation is injected with
    // 	 a CRC error as defined by cr_crc_err_inj field. The subsequent writes are 
    //          not injected with errors.
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINTX cr_oneshot_err_inj : 1;
    //
    // N/A
    // 
    // Bits[25:18], RW, default = 0x14
    //
    UINTX wr_io_lat_io_comp : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // N/A
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINTX cr_cont_wrcrc_err_inj : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
  } Bits;
  UINTX Data;
} IOLATENCY1_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CMPL_TO_DATA_DELAY_MC1LMDP_REG                    0x000000A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // rt bit
    // 
    // Bits[4:0], RW_LB, default = 0xC
    //
    UINTX rt_bit : 5;
    //
    // cmpl_program_delay
    // 
    // Bits[7:5], RW_LB, default = 0x0
    //
    UINTX cmpl_program_delay : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 24;
  } Bits;
  UINTX Data;
} CMPL_TO_DATA_DELAY_MC1LMDP_STRUCT;
#endif // ASM_INC

#define PXPENHCAP_MC1LMDP_REG                             0x00000100
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Indicates there are no capability structures in the enhanced configuration space.
    // 
    // Bits[15:0], RO, default = 0x0
    //
    UINTX capability_id : 16;
    //
    // Indicates there are no capability structures in the enhanced configuration space.
    // 
    // Bits[19:16], RO, default = 0x0
    //
    UINTX capability_version : 4;
    //
    // N/A
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX next_capability_offset : 12;
  } Bits;
  UINTX Data;
} PXPENHCAP_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CORRERRCNT_0_MC1LMDP_REG                          0x00000104
#ifndef ASM_INC
typedef union {
  struct {
    //
    // fixme_carol: change to RWS_LBV and pwrgd_reset.  The corrected error count for
    // this rank. Hardware automatically clear this field when the corresponding OVERFLOW_x
    // bit is changing from 0 to 1. 
    // This counter increments in number of cacheline accesses - not by codewords. On
    // a read access, if either of the codewords or both codewords have a corrected error,
    // this counter increments by 1. 
    // Register: DEVTAG_CNTL<Rank>, Field FAILDEVICE: This field is updated once per
    // cacheline access not by codeword. On a read access, the device is logged as follows
    // Corr_Err_On_CodeWord_0__Corr_Err_On_CoreWord_1__Device Logged
    // Yes_____________________No______________________Corrected Device from CodeWord0
    // No______________________Yes_____________________Corrected Device from CodeWord1
    // Yes_____________________Yes_____________________Corrected Device from CodeWord0
    // 
    // Bits[14:0], RW_LBV, default = 0x0
    //
    UINTX cor_err_cnt_0 : 15;
    //
    // The corrected error count for this rank has been overflowed. Once set it can only
    // be cleared via a write from BIOS. 
    // 
    // Bits[15:15], RW1CS, default = 0x0
    //
    UINTX overflow_0 : 1;
    //
    // fixme_carol: change to RWS_LBV and pwrgd_reset. The corrected error count for
    // this rank. Hardware automatically clear this field when the corresponding OVERFLOW_x
    // bit is changing from 0 to 1. 
    // This counter increments in number of cacheline accesses - not by codewords. On
    // a read access, if either of the codewords or both codewords have a corrected error,
    // this counter increments by 1. 
    // Register: DEVTAG_CNTL<Rank>, Field FAILDEVICE: This field is updated once per
    // cacheline access not by codeword. On a read access, the device is logged as follows
    // Corr_Err_On_CodeWord_0__Corr_Err_On_CoreWord_1__Device Logged
    // Yes_____________________No______________________Corrected Device from CodeWord0
    // No______________________Yes_____________________Corrected Device from CodeWord1
    // Yes_____________________Yes_____________________Corrected Device from CodeWord0
    // 
    // Bits[30:16], RW_LBV, default = 0x0
    //
    UINTX cor_err_cnt_1 : 15;
    //
    // The corrected error count for this rank has been overflowed. Once set it can only
    // be cleared via a write from BIOS. 
    // 
    // Bits[31:31], RW1CS, default = 0x0
    //
    UINTX overflow_1 : 1;
  } Bits;
  UINTX Data;
} CORRERRCNT_0_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CORRERRCNT_1_MC1LMDP_REG                          0x00000108
#ifndef ASM_INC
typedef union {
  struct {
    //
    // fixme_carol: change to RWS_LBV and pwrgd_reset. The corrected error count for
    // this rank. 
    // 
    // Bits[14:0], RW_LBV, default = 0x0
    //
    UINTX cor_err_cnt_2 : 15;
    //
    // The corrected error count has crested over the limit for this rank. Once set it
    // can only be cleared via a write from BIOS. 
    // 
    // Bits[15:15], RW1CS, default = 0x0
    //
    UINTX overflow_2 : 1;
    //
    // fixme_carol: change to RWS_LBV and pwrgd_reset. The corrected error count for
    // this rank. 
    // 
    // Bits[30:16], RW_LBV, default = 0x0
    //
    UINTX cor_err_cnt_3 : 15;
    //
    // The corrected error count has crested over the limit for this rank. Once set it
    // can only be cleared via a write from BIOS. 
    // 
    // Bits[31:31], RW1CS, default = 0x0
    //
    UINTX overflow_3 : 1;
  } Bits;
  UINTX Data;
} CORRERRCNT_1_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CORRERRCNT_2_MC1LMDP_REG                          0x0000010C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // fixme_carol: change to RWS_LBV and pwrgd_reset. The corrected error count for
    // this rank. 
    // 
    // Bits[14:0], RW_LBV, default = 0x0
    //
    UINTX cor_err_cnt_4 : 15;
    //
    // The corrected error count has crested over the limit for this rank. Once set it
    // can only be cleared via a write from BIOS. 
    // 
    // Bits[15:15], RW1CS, default = 0x0
    //
    UINTX overflow_4 : 1;
    //
    // fixme_carol: change to RWS_LBV and pwrgd_reset. The corrected error count for
    // this rank. 
    // 
    // Bits[30:16], RW_LBV, default = 0x0
    //
    UINTX cor_err_cnt_5 : 15;
    //
    // The corrected error count has crested over the limit for this rank. Once set it
    // can only be cleared via a write from BIOS. 
    // 
    // Bits[31:31], RW1CS, default = 0x0
    //
    UINTX overflow_5 : 1;
  } Bits;
  UINTX Data;
} CORRERRCNT_2_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CORRERRCNT_3_MC1LMDP_REG                          0x00000110
#ifndef ASM_INC
typedef union {
  struct {
    //
    // fixme_carol: change to RWS_LBV and pwrgd_reset. The corrected error count for
    // this rank. 
    // 
    // Bits[14:0], RW_LBV, default = 0x0
    //
    UINTX cor_err_cnt_6 : 15;
    //
    // The corrected error count has crested over the limit for this rank. Once set it
    // can only be cleared via a write from BIOS. 
    // 
    // Bits[15:15], RW1CS, default = 0x0
    //
    UINTX overflow_6 : 1;
    //
    // fixme_carol: change to RWS_LBV and pwrgd_reset. The corrected error count for
    // this rank. 
    // 
    // Bits[30:16], RW_LBV, default = 0x0
    //
    UINTX cor_err_cnt_7 : 15;
    //
    // The corrected error count has crested over the limit for this rank. Once set it
    // can only be cleared via a write from BIOS. 
    // 
    // Bits[31:31], RW1CS, default = 0x0
    //
    UINTX overflow_7 : 1;
  } Bits;
  UINTX Data;
} CORRERRCNT_3_MC1LMDP_STRUCT;
#endif // ASM_INC

#define RETRY_RD_ERR_LOG_ADDRESS2_MC1LMDP_REG             0x00000114
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Row address for the last retry
    // 
    // Bits[20:0], RWS_V, default = 0x0
    //
    UINTX row : 21;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 11;
  } Bits;
  UINTX Data;
} RETRY_RD_ERR_LOG_ADDRESS2_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DETECTION_DEBUG_LOG_ADDRESS2_MC1LMDP_REG          0x00000118
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Row address for the last retry
    // 
    // Bits[20:0], RWS_V, default = 0x0
    //
    UINTX row : 21;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 11;
  } Bits;
  UINTX Data;
} DETECTION_DEBUG_LOG_ADDRESS2_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CORRERRTHRSHLD_0_MC1LMDP_REG                      0x0000011C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The corrected error threshold for this rank that will be compared to the per rank
    // corrected error counter. 
    // 
    // Bits[14:0], RW_LB, default = 0x7FFF
    //
    UINTX cor_err_th_0 : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // The corrected error threshold for this rank that will be compared to the per rank
    // corrected error counter. 
    // 
    // Bits[30:16], RW_LB, default = 0x7FFF
    //
    UINTX cor_err_th_1 : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
  } Bits;
  UINTX Data;
} CORRERRTHRSHLD_0_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CORRERRTHRSHLD_1_MC1LMDP_REG                      0x00000120
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The corrected error threshold for this rank that will be compared to the per rank
    // corrected error counter. 
    // 
    // Bits[14:0], RW_LB, default = 0x7FFF
    //
    UINTX cor_err_th_2 : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // The corrected error threshold for this rank that will be compared to the per rank
    // corrected error counter. 
    // 
    // Bits[30:16], RW_LB, default = 0x7FFF
    //
    UINTX cor_err_th_3 : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
  } Bits;
  UINTX Data;
} CORRERRTHRSHLD_1_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CORRERRTHRSHLD_2_MC1LMDP_REG                      0x00000124
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The corrected error threshold for this rank that will be compared to the per rank
    // corrected error counter. 
    // 
    // Bits[14:0], RW_LB, default = 0x7FFF
    //
    UINTX cor_err_th_4 : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // The corrected error threshold for this rank that will be compared to the per rank
    // corrected error counter. 
    // 
    // Bits[30:16], RW_LB, default = 0x7FFF
    //
    UINTX cor_err_th_5 : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
  } Bits;
  UINTX Data;
} CORRERRTHRSHLD_2_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CORRERRTHRSHLD_3_MC1LMDP_REG                      0x00000128
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The corrected error threshold for this rank that will be compared to the per rank
    // corrected error counter. 
    // 
    // Bits[14:0], RW_LB, default = 0x7FFF
    //
    UINTX cor_err_th_6 : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // The corrected error threshold for this rank that will be compared to the per rank
    // corrected error counter. 
    // 
    // Bits[30:16], RW_LB, default = 0x7FFF
    //
    UINTX cor_err_th_7 : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
  } Bits;
  UINTX Data;
} CORRERRTHRSHLD_3_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DETECTION_DEBUG_LOG_ADDRESS1_MC1LMDP_REG          0x0000012C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rank CS0-CS7 (encoded chip select) of the read
    // 
    // Bits[2:0], RWS_V, default = 0x0
    //
    UINTX chip_select : 3;
    //
    //  C0-C2 (encoded subrank) for the read. 
    // 
    // Bits[5:3], RWS_V, default = 0x0
    //
    UINTX cbit : 3;
    //
    //  Bank ID for the read.  Bottom two bits are Bank Group, top two bits are Bank
    // Address 
    // 
    // Bits[9:6], RWS_V, default = 0x0
    //
    UINTX bank : 4;
    //
    // Column address for the last retry
    // 
    // Bits[21:10], RWS_V, default = 0x0
    //
    UINTX col : 12;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
  } Bits;
  UINTX Data;
} DETECTION_DEBUG_LOG_ADDRESS1_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CORRECTION_DEBUG_LOG_MC1LMDP_REG                  0x00000130
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 1LM adddc: failed column number is over data bits 0-63(64 columns)  
    // 
    // Bits[5:0], RWS_V, default = 0x0
    //
    UINTX adddc_failed_col_num : 6;
    //
    // 1LM adddc: metadata failed column number is over metadata bits 0-3(4 columns)
    //   
    // 
    // Bits[9:6], RWS_V, default = 0x0
    //
    UINTX adddc_meta_failed_col_num : 4;
    //
    // 1LM adddc: parity column syndrome low 
    // 
    // Bits[13:10], RWS_V, default = 0x0
    //
    UINTX adddc_par_col_syn_low : 4;
    //
    // 1LM adddc: parity column syndrome high 
    // 
    // Bits[17:14], RWS_V, default = 0x0
    //
    UINTX adddc_par_col_syn_high : 4;
    //
    // 1LM adddc: one column failed only in 1st half 
    // 
    // Bits[18:18], RWS_V, default = 0x0
    //
    UINTX adddc_one_col_failed_1st : 1;
    //
    // 1LM adddc: one column failed only in 2nd half 
    // 
    // Bits[19:19], RWS_V, default = 0x0
    //
    UINTX adddc_one_col_failed_2nd : 1;
    //
    // 1LM adddc: one column failed over both half 
    // 
    // Bits[20:20], RWS_V, default = 0x0
    //
    UINTX adddc_one_col_failed : 1;
    //
    // 1LM adddc: 2 columns that include ParityColumn and Locator bits are failed 
    // 
    // Bits[21:21], RWS_V, default = 0x0
    //
    UINTX adddc_pc_col_failed : 1;
    //
    // 1LM adddc: any of the metadata  bits failed (m0 , m1) 
    // 
    // Bits[22:22], RWS_V, default = 0x0
    //
    UINTX adddc_meta_bit_failed : 1;
    //
    // 1LM adddc: half of the failed column is in the spare device 
    // 
    // Bits[23:23], RWS_V, default = 0x0
    //
    UINTX adddc_failed_col_in_spare_dev : 1;
    //
    // adddc: one data device failed
    // 
    // Bits[24:24], RWS_V, default = 0x0
    //
    UINTX adddc_one_data_dev_failed : 1;
    //
    // adddc: metadata device failed
    // 
    // Bits[25:25], RWS_V, default = 0x0
    //
    UINTX adddc_meta_dev_failed : 1;
    //
    // adddc: locator device failed
    // 
    // Bits[26:26], RWS_V, default = 0x0
    //
    UINTX adddc_loc_dev_failed : 1;
    //
    // adddc: parity device failed
    // 
    // Bits[27:27], RWS_V, default = 0x0
    //
    UINTX adddc_par_dev_failed : 1;
    //
    // sddc DUE case: there are more than one failed device
    // 
    // Bits[28:28], RWS_V, default = 0x0
    //
    UINTX sddc_multi_dev_failed : 1;
    //
    // sddc DUE case: there are (parity) errors but we are unable to located the failed
    // device 
    // 
    // Bits[29:29], RWS_V, default = 0x0
    //
    UINTX sddc_par_err_no_ls_match : 1;
    //
    // sddc DUE case: metadata bits have errors cannot be trusted. this signal was sent
    // to m2m to indicate metadata error 
    // 
    // Bits[30:30], RWS_V, default = 0x0
    //
    UINTX sddc_meta_err : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} CORRECTION_DEBUG_LOG_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CORRERRORSTATUS_MC1LMDP_REG                       0x00000134
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This 8 bit field is the per rank error over-threshold status bits. The organization
    // is as follows: 
    // Bit 0 : Rank 0
    // Bit 1 : Rank 1
    // Bit 2 : Rank 2
    // Bit 3 : Rank 3
    // Bit 4 : Rank 4
    // Bit 5 : Rank 5
    // Bit 6 : Rank 6
    // Bit 7 : Rank 7
    // Note: The register tracks which rank has reached or exceeded the corresponding
    // CORRERRTHRSHLD threshold settings. 
    // 
    // Bits[7:0], RW1C, default = 0x0
    //
    UINTX err_overflow_stat : 8;
    //
    // N/A
    // 
    // Bits[10:8], RW_V, default = 0x0
    //
    UINTX dimm_alert : 3;
    //
    // N/A
    // 
    // Bits[13:11], RW, default = 0x6
    //
    UINTX dimm_alert_select : 3;
    //
    // This field get set with 1'b1 , if the corresponding rank detected ddr4 crc in
    // one of its write data. This will be cleared by BIOS 
    // 
    // Bits[21:14], RW_V, default = 0x0
    //
    UINTX ddr4crc_rank_log : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
  } Bits;
  UINTX Data;
} CORRERRORSTATUS_MC1LMDP_STRUCT;
#endif // ASM_INC

#define LEAKY_BKT_2ND_CNTR_REG_MC1LMDP_REG                0x00000138
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per rank secondary leaky bucket counter (2b per rank)
    // bit 15:14: rank 7 secondary leaky bucket counter
    // bit 13:12: rank 6 secondary leaky bucket counter
    // bit 11:10: rank 5 secondary leaky bucket counter
    // bit 9:8: rank 4 secondary leaky bucket counter
    // bit 7:6: rank 3 secondary leaky bucket counter
    // bit 5:4: rank 2 secondary leaky bucket counter
    // bit 3:2: rank 1 secondary leaky bucket counter
    // bit 1:0: rank 0 secondary leaky bucket counter
    // 
    // Bits[15:0], RW_V, default = 0x0
    //
    UINTX leaky_bkt_2nd_cntr : 16;
    //
    // Secondary Leaky Bucket Counter Limit (2b per DIMM). This register defines secondary
    // leaky bucket counter limit for all 8 logical ranks within channel. The counter
    // logic will generate the secondary LEAK pulse to decrement the rank's correctable
    // error counter by 1 when the corresponding rank leaky bucket rank counter roll
    // over at the predefined counter limit. The counter increment at the primary leak
    // pulse from the LEAKY_BUCKET_CNTR_LO and LEAKY_BUCKET_CNTR_HI logic. 
    // Bit[31:30]: Rank 7 Secondary Leaky Bucket Counter Limit
    // Bit[29:28]: Rank 6 Secondary Leaky Bucket Counter Limit
    // Bit[27:26]: Rank 5 Secondary Leaky Bucket Counter Limit
    // Bit[25:24]: Rank 4 Secondary Leaky Bucket Counter Limit
    // Bit[23:22]: Rank 3 Secondary Leaky Bucket Counter Limit
    // Bit[21:20]: Rank 2 Secondary Leaky Bucket Counter Limit
    // Bit[19:18]: Rank 1 Secondary Leaky Bucket Counter Limit
    // Bit[17:16]: Rank 0 Secondary Leaky Bucket Counter Limit
    // The value of the limit is defined as the following:
    // 0: the LEAK pulse is generated one DCLK after the primary LEAK pulse is asserted.
    // 1: the LEAK pulse is generated one DCLK after the counter roll over at 1.
    // 2: the LEAK pulse is generated one DCLK after the counter roll over at 2.
    // 3: the LEAK pulse is generated one DCLK after the counter roll over at 3.
    // 
    // Bits[31:16], RW, default = 0x0
    //
    UINTX leaky_bkt_2nd_cntr_limit : 16;
  } Bits;
  UINTX Data;
} LEAKY_BKT_2ND_CNTR_REG_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CORRECTION_DEBUG_PLUS1_LOG_MC1LMDP_REG            0x0000013C
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  plus1: cache line is transfered over 8 transacations
    // 		      tnx0 or tnx1 =>  0 
    // 		      tnx2 or tnx3 =>  1
    // 		      tnx4 or tnx5 =>  2
    // 		      tnx6 or tnx7 =>  3
    // 		      no match     =>  7
    // 	
    // 
    // Bits[2:0], RWS_V, default = 0x0
    //
    UINTX tnx_num : 3;
    //
    // plus1: one of the metadata bit has an error
    // 
    // Bits[18:3], RWS_V, default = 0x0
    //
    UINTX meta_bit_num : 16;
    //
    // plus1: one of the locator bit has an error
    // 
    // Bits[30:19], RWS_V, default = 0x0
    //
    UINTX loc_bit_num : 12;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} CORRECTION_DEBUG_PLUS1_LOG_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DEVTAG_CNTL_0_MC1LMDP_REG                         0x00000140
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Hardware will capture the fail device ID of the rank in the FailDevice field upon
    // successfull correction from the device correction engine. After SDDC is enabled
    // HW may not update this field. 
    // Native DDR/Intel SMI 2 2:1/Intel SMI 2 1:1x8:
    // Valid Range is decimal 0-17 to indicate which x4 device (independent channel)
    // or x8 device (lock-step mode) has failed. 
    // Intel SMI 2 1:1x4(DDDC):
    // Valid Range is decimal 0-35 to indicate which x4 device has failed.
    // Note that when DDDC has been enabled on the non-spare device, and a subsequent
    // failure of the spare device occurs, the value logged here will be equal to the
    // DDDC faildevice. 
    // 
    // Bits[5:0], RWS_V, default = 0x3F
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Device tagging (SDDC) enable for this rank. Once set, the parity device of the
    // rank is used for the replacement device content. After tagging, the rank will
    // no longer have the "correction" capability. ECC error "detection" capability will
    // not degrade after setting this bit. 
    // Warning: For lock-step channel configuration, only one x8 device can be tagged
    // per rank-pair. SMM software must identify which channel should be tagged for this
    // rank and only set the corresponding DEVTAG_CNTL_x.EN bit for the channel contains
    // the fail device. The DEVTAG_CNTL_x.EN on the other channel of the corresponding
    // rank must not be set. 
    // DDDC: (EX processor only)
    // On DDDC supported systems, BIOS has the option to enable SDDC in conjuntion with
    // DDDC_CNTL:SPARING to enable faster sparing with SDDC substitution. This field
    // is cleared by HW on completion of DDDC sparing. 
    // 
    // Bits[7:7], RWS_L, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} DEVTAG_CNTL_0_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DEVTAG_CNTL_1_MC1LMDP_REG                         0x00000141
#ifndef ASM_INC
typedef union {
  struct {
    //
    // See DEVTAG_CNTL_0 for description.
    // 
    // Bits[5:0], RWS_V, default = 0x3F
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // See DEVTAG_CNTL_0 for description.
    // 
    // Bits[7:7], RWS_L, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} DEVTAG_CNTL_1_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DEVTAG_CNTL_2_MC1LMDP_REG                         0x00000142
#ifndef ASM_INC
typedef union {
  struct {
    //
    // See DEVTAG_CNTL_0 for description.
    // 
    // Bits[5:0], RWS_V, default = 0x3F
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // See DEVTAG_CNTL_0 for description.
    // 
    // Bits[7:7], RWS_L, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} DEVTAG_CNTL_2_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DEVTAG_CNTL_3_MC1LMDP_REG                         0x00000143
#ifndef ASM_INC
typedef union {
  struct {
    //
    // See DEVTAG_CNTL_0 for description.
    // 
    // Bits[5:0], RWS_V, default = 0x3F
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // See DEVTAG_CNTL_0 for description.
    // 
    // Bits[7:7], RWS_L, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} DEVTAG_CNTL_3_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DEVTAG_CNTL_4_MC1LMDP_REG                         0x00000144
#ifndef ASM_INC
typedef union {
  struct {
    //
    // See DEVTAG_CNTL_0 for description.
    // 
    // Bits[5:0], RWS_V, default = 0x3F
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // See DEVTAG_CNTL_0 for description.
    // 
    // Bits[7:7], RWS_L, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} DEVTAG_CNTL_4_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DEVTAG_CNTL_5_MC1LMDP_REG                         0x00000145
#ifndef ASM_INC
typedef union {
  struct {
    //
    // See DEVTAG_CNTL_0 for description.
    // 
    // Bits[5:0], RWS_V, default = 0x3F
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // See DEVTAG_CNTL_0 for description.
    // 
    // Bits[7:7], RWS_L, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} DEVTAG_CNTL_5_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DEVTAG_CNTL_6_MC1LMDP_REG                         0x00000146
#ifndef ASM_INC
typedef union {
  struct {
    //
    // See DEVTAG_CNTL_0 for description.
    // 
    // Bits[5:0], RWS_V, default = 0x3F
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // See DEVTAG_CNTL_0 for description.
    // 
    // Bits[7:7], RWS_L, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} DEVTAG_CNTL_6_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DEVTAG_CNTL_7_MC1LMDP_REG                         0x00000147
#ifndef ASM_INC
typedef union {
  struct {
    //
    // See DEVTAG_CNTL_0 for description.
    // 
    // Bits[5:0], RWS_V, default = 0x3F
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // See DEVTAG_CNTL_0 for description.
    // 
    // Bits[7:7], RWS_L, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} DEVTAG_CNTL_7_MC1LMDP_STRUCT;
#endif // ASM_INC

#define RETRY_RD_ERR_LOG_LOCATOR_MC1LMDP_REG              0x00000148
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  this register hold the value of locator syndrome from correction path. the number
    // of LS bits are the same for sddc and adddc ecc 
    // 
    // Bits[15:0], RWS_V, default = 0x0
    //
    UINTX loc_syn : 16;
    //
    // this register hold the value of plus1 locator syndrome from correction path. the
    // number of plus1 LS bits are the same for all the plus1 modes  
    // 
    // Bits[27:16], RWS_V, default = 0x0
    //
    UINTX plus1_loc_syn : 12;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
  } Bits;
  UINTX Data;
} RETRY_RD_ERR_LOG_LOCATOR_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DETECTION_DEBUG_LOG_MC1LMDP_REG                   0x0000014C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // indicate the ecc mode the register is logging for :
    // 		 4'b0000 => sddc 2LM
    // 		 4'b0001 => sddc 1LM
    // 		 4'b0010 => sddc +1  2LM
    // 		 4'b0011 => sddc +1 1LM
    // 		 4'b0100 => adddc 2LM
    // 		 4'b0101 => adddc 1LM
    // 		 4'b0110 => adddc +1 2LM
    // 		 4'b0111 => adddc +1 1LM
    // 		 4'b1000 => ddrt
    // 		 4'b1001 => x8 sddc
    // 		 4'b1010 => x8 sddc +1   
    // 		 4'b1011 => not a valid ecc mode                     
    //         
    // 
    // Bits[3:0], RWS_V, default = 0x0
    //
    UINTX mode : 4;
    //
    // During detection locator error was detected
    // 
    // Bits[4:4], RWS_V, default = 0x0
    //
    UINTX loc_err : 1;
    //
    // During detection parity error was detected
    // 
    // Bits[5:5], RWS_V, default = 0x0
    //
    UINTX par_err : 1;
    //
    // The ecc error indication sent to m2m
    // 
    // Bits[6:6], RWS_V, default = 0x0
    //
    UINTX ecc_err : 1;
    //
    //  this register hold the value of intermediate locator syndrome from detection
    // path. only valid for x4 sddc 1LM 
    // 
    // Bits[18:7], RWS_V, default = 0x0
    //
    UINTX inter_loc_syn : 12;
    //
    // Only for x4 sddc 1LM  ecc error indication sent to m2m for 1st half of CL
    // 
    // Bits[19:19], RWS_V, default = 0x0
    //
    UINTX err_1st : 1;
    //
    // Only for x4 sddc 1LM  ecc error indication sent to m2m for 2nd half of CL
    // 
    // Bits[20:20], RWS_V, default = 0x0
    //
    UINTX err_2nd : 1;
    //
    // The contents of this register have valid data as well as detection_debug_log_parity,
    // detection_debug_log_locator,detection_debug_log_address1, and detection_debug_log_address2
    //     
    // 
    // Bits[21:21], RWS_V, default = 0x0
    //
    UINTX v : 1;
    //
    // Lock register after the first error, do not overflow.
    // 
    // Bits[22:22], RWS, default = 0x0
    //
    UINTX noover : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} DETECTION_DEBUG_LOG_MC1LMDP_STRUCT;
#endif // ASM_INC

#define RETRY_RD_ERR_LOG_PARITY_MC1LMDP_REG               0x00000150
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  this register hold the parity syndrome(mask) from correction path. for sddc/x8/ddrt
    // parity syndrome is 32 bits.  
    //                       but for adddc it is 16 bits so the 16 upper bits are always
    // 0 for adddc 
    // 
    // Bits[31:0], RWS_V, default = 0x0
    //
    UINTX par_syn : 32;
  } Bits;
  UINTX Data;
} RETRY_RD_ERR_LOG_PARITY_MC1LMDP_STRUCT;
#endif // ASM_INC

#define RETRY_RD_ERR_LOG_MC1LMDP_REG                      0x00000154
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The contents of this register have valid data as well as RETRY_RD_ERR_LOG_PARITY,
    // RETRY_RD_ERR_LOG_LOCATOR, RETRY_RD_ERR_LOG_ADDRESS1, and RETRY_RD_ERR_LOG_ADDRESS2.
    // 
    // Bits[0:0], RWS_V, default = 0x0
    //
    UINTX v : 1;
    //
    // Uncorrectable error. Logs cannot be overwritten while UC is set. This bit is not
    // controlled by MC, but by a lock indication from HA. 
    // 
    // Bits[1:1], RWS_V, default = 0x0
    //
    UINTX uc : 1;
    //
    // The log has been overwritten.
    // 
    // Bits[2:2], RWS_V, default = 0x0
    //
    UINTX over : 1;
    //
    // indicate the ecc mode the register is logging for :
    // 		 4'b0000 => sddc 2LM
    // 		 4'b0001 => sddc 1LM
    // 		 4'b0010 => sddc +1  2LM
    // 		 4'b0011 => sddc +1 1LM
    // 		 4'b0100 => adddc 2LM
    // 		 4'b0101 => adddc 1LM
    // 		 4'b0110 => adddc +1 2LM
    // 		 4'b0111 => adddc +1 1LM
    // 		 4'b1000 => ddrt
    // 		 4'b1001 => x8 sddc
    // 		 4'b1010 => x8 sddc +1   
    // 		 4'b1011 => not a valid ecc mode                     
    //         
    // 
    // Bits[6:3], RWS_V, default = 0x0
    //
    UINTX mode : 4;
    //
    // During the last log, entered correction but was not able to correct hte error
    // => DUE 
    // 
    // Bits[7:7], RWS_V, default = 0x0
    //
    UINTX corr_err : 1;
    //
    // During the last log, entered correction but no ecc error was detected
    // 
    // Bits[8:8], RWS_V, default = 0x0
    //
    UINTX corr_noerr : 1;
    //
    // During the last log, entered correction and detect a correctable ecc error and
    //  corrected 
    // 
    // Bits[9:9], RWS_V, default = 0x0
    //
    UINTX corr_correctable : 1;
    //
    // During the last log, entered correction, error was in parity device which consider
    // a correctable error  
    // 
    // Bits[10:10], RWS_V, default = 0x0
    //
    UINTX corr_correctable_par_dev : 1;
    //
    // During the last log, the ecc error indication sent to m2m
    // 
    // Bits[11:11], RWS_V, default = 0x0
    //
    UINTX ecc_err : 1;
    //
    // If en_patspr is set, this will indicate if the log is from patrol/spr or HA.
    // 
    // Bits[12:12], RWS_V, default = 0x0
    //
    UINTX patspr : 1;
    //
    // Default operation is to log only HA generated retries. Setting this bit will enable
    // logging of patrol and sparing retries. Note: Use of this bit may cause a patrol
    // or spare log to be locked by HA lock signal. 
    // 
    // Bits[13:13], RWS, default = 0x1
    //
    UINTX en_patspr : 1;
    //
    // Lock register after the first error, do not overflow.
    // 
    // Bits[14:14], RWS, default = 0x0
    //
    UINTX noover : 1;
    //
    // Enable error logging. Will log on every retry.
    // 
    // Bits[15:15], RWS, default = 0x1
    //
    UINTX en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} RETRY_RD_ERR_LOG_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_MCA_CTL_MC1LMDP_REG                          0x00000158
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable CSR logging. If set, the error will be logged in the corresponding log
    // field in this register. 
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX err0_en : 1;
    //
    // Error was logged by HW. BIOS clears by writing 0.
    // 
    // Bits[1:1], RW1CS, default = 0x0
    //
    UINTX err0_log : 1;
    //
    // Enable/Disable CMCI signaling. When disabled, these errors will not be included
    // in the Corrected Error Count. Note: for corrected errors in general, CMCI is only
    // signaled when corr_err_cnt==corr_err_threshold. 
    // 
    // Bits[2:2], RW_LB, default = 0x0
    //
    UINTX err0_cmci : 1;
    //
    // Enable/Disable SMI signaling each time error occurs.
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX err0_smi : 1;
    //
    // Enable CSR logging. If set, the error will be logged in the corresponding log
    // field in this register. 
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX err1_en : 1;
    //
    // Error was logged by HW. BIOS clears by writing 0.
    // 
    // Bits[5:5], RW1CS, default = 0x0
    //
    UINTX err1_log : 1;
    //
    // Enable/Disable CMCI signaling. When disabled, these errors will not be included
    // in the Corrected Error Count. Note: for corrected errors in general, CMCI is only
    // signaled when corr_err_cnt==corr_err_threshold. 
    // 
    // Bits[6:6], RW_LB, default = 0x0
    //
    UINTX err1_cmci : 1;
    //
    // Enable/Disable SMI signaling each time error occurs.
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX err1_smi : 1;
    //
    // Enable CSR logging. If set, the error will be logged in the corresponding log
    // field in this register. 
    // 
    // Bits[8:8], RW_LB, default = 0x0
    //
    UINTX err2_en : 1;
    //
    // Error was logged by HW. BIOS clears by writing 0.
    // 
    // Bits[9:9], RW1CS, default = 0x0
    //
    UINTX err2_log : 1;
    //
    // Enable/Disable CMCI signaling. When disabled, these errors will not be included
    // in the Corrected Error Count. Note: for corrected errors in general, CMCI is only
    // signaled when corr_err_cnt==corr_err_threshold. 
    // 
    // Bits[10:10], RW_LB, default = 0x0
    //
    UINTX err2_cmci : 1;
    //
    // Enable/Disable SMI signaling each time error occurs.
    // 
    // Bits[11:11], RW_LB, default = 0x0
    //
    UINTX err2_smi : 1;
    //
    // Enable CSR logging. If set, the error will be logged in the corresponding log
    // field in this register. 
    // 
    // Bits[12:12], RW_LB, default = 0x0
    //
    UINTX err3_en : 1;
    //
    // Error was logged by HW. BIOS clears by writing 0.
    // 
    // Bits[13:13], RW1CS, default = 0x0
    //
    UINTX err3_log : 1;
    //
    // Enable/Disable CMCI signaling. When disabled, these errors will not be included
    // in the Corrected Error Count. Note: for corrected errors in general, CMCI is only
    // signaled when corr_err_cnt==corr_err_threshold. 
    // 
    // Bits[14:14], RW_LB, default = 0x0
    //
    UINTX err3_cmci : 1;
    //
    // Enable/Disable SMI signaling each time error occurs.
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX err3_smi : 1;
    //
    // Enable CSR logging. If set, the error will be logged in the corresponding log
    // field in this register. 
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX err4_en : 1;
    //
    // Error was logged by HW. BIOS clears by writing 0.
    // 
    // Bits[17:17], RW1CS, default = 0x0
    //
    UINTX err4_log : 1;
    //
    // Enable/Disable CMCI signaling. When disabled, these errors will not be included
    // in the Corrected Error Count. Note: for corrected errors in general, CMCI is only
    // signaled when corr_err_cnt==corr_err_threshold. 
    // 
    // Bits[18:18], RW_LB, default = 0x0
    //
    UINTX err4_cmci : 1;
    //
    // Enable/Disable SMI signaling each time error occurs.
    // 
    // Bits[19:19], RW_LB, default = 0x0
    //
    UINTX err4_smi : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 12;
  } Bits;
  UINTX Data;
} VMSE_MCA_CTL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define RETRY_RD_ERR_LOG_ADDRESS1_MC1LMDP_REG             0x0000015C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Holds the failed device number: for sddc/ddrt/x8 the device number is between
    // 0-17. for adddc device number between 0-16 and 18-35  dev 17 is the spare device
    //  
    // 
    // Bits[5:0], RWS_V, default = 0x0
    //
    UINTX failed_dev : 6;
    //
    // Rank CS0-CS7 (encoded chip select) of retried read
    // 
    // Bits[8:6], RWS_V, default = 0x0
    //
    UINTX chip_select : 3;
    //
    //  C0-C2 (encoded subrank) for last retry. 
    // 
    // Bits[11:9], RWS_V, default = 0x0
    //
    UINTX cbit : 3;
    //
    //  Bank ID for last retry.  Bottom two bits are Bank Group, top two bits are Bank
    // Address 
    // 
    // Bits[15:12], RWS_V, default = 0x0
    //
    UINTX bank : 4;
    //
    // Column address for the last retry
    // 
    // Bits[27:16], RWS_V, default = 0x0
    //
    UINTX col : 12;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
  } Bits;
  UINTX Data;
} RETRY_RD_ERR_LOG_ADDRESS1_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DFT_RDRET_CONTROL_MC1LMDP_REG                     0x00000160
#ifndef ASM_INC
typedef union {
  struct {
    //
    // These bits will replace ecc bits coming back from pads when mode bits in this
    // register are non_zero 
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX ecc_bits : 8;
    //
    // 00= rdret_dft is disabled
    // 01= rdret_dft is enabled with lfsr clocked on free running qclk.
    // 10= rdret_dft is enabled with lfsr clocked on sample DDR.
    // 11= rdret_dft is enabled with lfsr not clocked.
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINTX mode : 2;
    //
    // 00000 0x544a31c34562d8bd
    // 00001 0xa731a0883bfe067c
    // 00010 0x3538e4a7139fae94
    // 00011 0xba07a1e9f08c03f6
    // 00100 0x788af32dcfe2a68d
    // 00101 0x4adbaba47e5c251f
    // 00110 0x34eed8ff12ad115c
    // 00111 0xfcc3d08a5b7cda8d
    // 01000 0xf2ae1efd13815494
    // 01001 0xa570857f1675a8a2
    // 01010 0x13d5110591290d2f
    // 01011 0x6789118327be202f
    // 01100 0x7a391ddb84826998
    // 01101 0xa54f30c8affc3169
    // 01110 0xd67b1c052b5af39e
    // 01111 0xca46737a38285c24
    // 10000 0x257c40d8e0a5c571
    // 10001 0xe17f9ca88c1ccee5
    // 10010 0xa70f03dd9d03a7de
    // 10011 0xebbddca22a728039
    // 10100 0x710151796a9f8981
    // 10101 0x3512be901c6ae21d
    // 10110 0xe2365ec374e91f47
    // 10111 0x6a6f5c5c7cb74da8
    // 11000 0x084d8ce28bff7215
    // 11001 0x21aef5d1ded4cef2
    // 11010 0xb9f9f2bd1692f3a4
    // 11011 0x62bed2d667121de9
    // 11100 0x8000000000000000
    // 11101 0xffffffffffffffff
    // 11110 0xaaaaaaaaaaaaaaaa
    // 11111 0x5555555555555555
    // 
    // Bits[14:10], RW, default = 0x0
    //
    UINTX lfsr_seed : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 17;
  } Bits;
  UINTX Data;
} DFT_RDRET_CONTROL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define ALERTSIGNAL_MC1LMDP_REG                           0x00000164
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If 1, alert signal (DDR4 parity error) has been observed. This bit is intended
    // to be used as feedback during CMD/address training. A write 1 will clear this
    // field. 
    // 
    // Bits[0:0], RW1C, default = 0x0
    //
    UINTX seen : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} ALERTSIGNAL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PDA_MC1LMDP_REG                              0x00000168
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This register will be driven on DQ lines during Per Dram Addressability Mode Register
    // Set 
    // operations according to the following table. A 0 in a bit position will select
    // the 
    // corresponding device for Per Dram addressability Transaction.
    // for x8 devices:
    // bit [0] will be driven on DQ[7:0]
    // bit [1] will be driven on DQ[15:8]
    // bit [2] will be driven on DQ[23:16]
    // bit [3] will be driven on DQ[31:24]
    // bit [4] will be driven on DQ[39:32]
    // bit [5] will be driven on DQ[47:40]
    // bit [6] will be driven on DQ[55:48]
    // bit [7] will be driven on DQ[63:56]
    // bit [8] will be driven on DQ[71:64]
    // for x4 devices:
    // bit [0] will be driven on DQ[3:0]
    // bit [1] will be driven on DQ[7:4]
    // bit [2] will be driven on DQ[11:8]
    // bit [3] will be driven on DQ[15:12]
    // bit [4] will be driven on DQ[19:16]
    // bit [5] will be driven on DQ[23:20]
    // bit [6] will be driven on DQ[27:24]
    // bit [7] will be driven on DQ[31:28]
    // bit [8] will be driven on DQ[35:32]
    // bit [9] will be driven on DQ[39:36]
    // bit [10] will be driven on DQ[43:40]
    // bit [11] will be driven on DQ[47:44]
    // bit [12] will be driven on DQ[51:48]
    // bit [13] will be driven on DQ[55:52]
    // bit [14] will be driven on DQ[59:56]
    // bit [15] will be driven on DQ[63:60]
    // bit [16] will be driven on DQ[67:64]
    // bit [17] will be driven on DQ[71:68]
    // 
    // Bits[17:0], RW_LB, default = 0x0
    //
    UINTX device_select : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // This field is the logical rank select for PDA transaction and should match the
    // same field 
    // in CPGC_PDA_SHADOW register and should be set to match Chip Select fields programmed
    // into 
    // CADB for this transaction (see Rank Naming Convention in MAS for mapping of Chip
    // selects 
    // to logical ranks)
    // 
    // Bits[22:20], RW_LB, default = 0x0
    //
    UINTX rank_select : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 9;
  } Bits;
  UINTX Data;
} CPGC_PDA_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DETECTION_DEBUG_LOG_PARITY_MC1LMDP_REG            0x0000016C
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  this register hold the parity syndrome(mask) from detection path. for sddc/x8/ddrt
    // parity syndrome is 32 bits.  
    //                       but for adddc it is 16 bits so the 16 upper bits are always
    // 0 for adddc 
    // 
    // Bits[31:0], RWS_V, default = 0x0
    //
    UINTX par_syn : 32;
  } Bits;
  UINTX Data;
} DETECTION_DEBUG_LOG_PARITY_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DENGATEHEALTHCNTR_MC1LMDP_REG                     0x00000170
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If 1, this counter will count. If 0, it will not.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX enable : 1;
    //
    // note: even if this filed is marked as rw-lv, it is is rw_lb_v but there is no
    // such thing supported by critter. 
    // This is the current value of the counter.
    // In native ddr4 mode, this value is important in each channel that is not fused
    // off. 
    // In Intel SMI 2 mode, channels 1 and 3 values in each MC should be ignored.
    // This is a saturating counter.
    // 
    // Bits[36:1], RW_LV, default = 0x0
    //
    UINTX value : 36;
    //
    // If 1, this counter will count clocks (for testability only); if 0, this counter
    // will count number of clocks we spend 
    // time handling Intel SMI 2 errors or ddr4 Command/Address parity error.
    // 
    // Bits[37:37], RW_LB, default = 0x0
    //
    UINTX event_select : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:38], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 26;
  } Bits;
  UINTX Data;
} DENGATEHEALTHCNTR_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MR_READ_RESULT_DQ12TO0_MC1LMDP_REG                0x00000178
#ifndef ASM_INC
typedef union {
  struct {
    //
    // For by 8 parts: device 0 result: MR_READ_RESULT_DQ12TO0[7:0]
    // device 1 result: MR_READ_RESULT_DQ12TO0[23:16]
    // For by 4 parts: device 0 result: MR_READ_RESULT_DQ12TO0[7:0]
    // device 1 result: MR_READ_RESULT_DQ12TO0[15:8]
    // device 2 result: MR_READ_RESULT_DQ12TO0[23:16]
    // device 3 result: MR_READ_RESULT_DQ12TO0[31:24]
    // 
    // Bits[31:0], RO, default = 0x0
    //
    UINTX dq : 32;
  } Bits;
  UINTX Data;
} MR_READ_RESULT_DQ12TO0_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MR_READ_RESULT_DQ28TO16_MC1LMDP_REG               0x0000017C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // For by 8 parts: device 2 result: MR_READ_RESULT_DQ28TO16[7:0]
    // device 3 result: MR_READ_RESULT_DQ28TO16[23:16]
    // For by 4 parts: device 4 result: MR_READ_RESULT_DQ28TO16[7:0]
    // device 5 result: MR_READ_RESULT_DQ28TO16[15:8]
    // device 6 result: MR_READ_RESULT_DQ28TO16[23:16]
    // device 7 result: MR_READ_RESULT_DQ28TO16[31:24]
    // 
    // Bits[31:0], RO, default = 0x0
    //
    UINTX dq : 32;
  } Bits;
  UINTX Data;
} MR_READ_RESULT_DQ28TO16_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MR_READ_RESULT_DQ44TO32_MC1LMDP_REG               0x00000180
#ifndef ASM_INC
typedef union {
  struct {
    //
    // For by 8 parts: device 4 result: MR_READ_RESULT_DQ44TO32[7:0]
    // device 5 result: MR_READ_RESULT_DQ44TO32[23:16]
    // For by 4 parts: device 8 result: MR_READ_RESULT_DQ44TO32[7:0]
    // device 9 result: MR_READ_RESULT_DQ44TO32[15:8]
    // device 10 result: MR_READ_RESULT_DQ44TO32[23:16]
    // device 11 result: MR_READ_RESULT_DQ44TO32[31:24]
    // 
    // Bits[31:0], RO, default = 0x0
    //
    UINTX dq : 32;
  } Bits;
  UINTX Data;
} MR_READ_RESULT_DQ44TO32_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MR_READ_RESULT_DQ60TO48_MC1LMDP_REG               0x00000184
#ifndef ASM_INC
typedef union {
  struct {
    //
    // For by 8 parts: device 6 result: MR_READ_RESULT_DQ60To48[7:0]
    // device 7 result: MR_READ_RESULT_DQ60To48[23:16]
    // For by 4 parts: device 12 result: MR_READ_RESULT_DQ60To48[7:0]
    // device 13 result: MR_READ_RESULT_DQ60To48[15:8]
    // device 14 result: MR_READ_RESULT_DQ60To48[23:16]
    // device 15 result: MR_READ_RESULT_DQ60To48[31:24]
    // 
    // Bits[31:0], RO, default = 0x0
    //
    UINTX dq : 32;
  } Bits;
  UINTX Data;
} MR_READ_RESULT_DQ60TO48_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MR_READ_RESULT_DQ68TO64_MC1LMDP_REG               0x00000188
#ifndef ASM_INC
typedef union {
  struct {
    //
    // For by 8 parts: device 8 result: MR_READ_RESULT_DQ68TO64[7:0]
    // For by 4 parts: device 16 result: MR_READ_RESULT_DQ68TO64[7:0]
    // device 17 result: MR_READ_RESULT_DQ68TO64[15:8]
    // 
    // Bits[15:0], RO, default = 0x0
    //
    UINTX dq : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} MR_READ_RESULT_DQ68TO64_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_VIRAL_CTL_MC1LMDP_REG                        0x0000018C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Disable viral triggering for M2Mem write data parity error for DDR4. Viral signalling
    // is Error signalling is disabled by default 
    // 
    // Bits[0:0], RWS, default = 0x1
    //
    UINTX dis_ha_wr_data_par_err : 1;
    //
    // Disable viral triggering for M2Mem write data parity error for DDRT. Viral signalling
    // is Error signalling is disabled by default 
    // 
    // Bits[1:1], RWS, default = 0x1
    //
    UINTX dis_ddrt_ha_wr_data_par_err : 1;
    //
    // Disable viral triggering for M2Mem write data byte enable parity error for DDR4.
    // Viral signalling is Error signalling is disabled by default 
    // 
    // Bits[2:2], RWS, default = 0x1
    //
    UINTX dis_ha_wr_be_par_err : 1;
    //
    // Disable viral triggering for M2Mem write data byte enable parity error for DDRT.
    // Viral signalling is Error signalling is disabled by default 
    // 
    // Bits[3:3], RWS, default = 0x1
    //
    UINTX dis_ddrt_ha_wr_be_par_err : 1;
    //
    // Disable viral triggering for DDR4 WDB parity error. Viral signalling is Error
    // signalling is disabled by default 
    // 
    // Bits[4:4], RWS, default = 0x1
    //
    UINTX dis_wdb_par_err : 1;
    //
    // Disable viral triggering for DDRT WDB parity error. Viral signalling is Error
    // signalling is disabled by default 
    // 
    // Bits[5:5], RWS, default = 0x1
    //
    UINTX dis_ddrt_wdb_par_err : 1;
    //
    // Disable viral triggering for RPQ0 rpa parity error. Viral signalling is Error
    // signalling is disabled by default 
    // 
    // Bits[6:6], RWS, default = 0x1
    //
    UINTX dis_rpq0_rpa_par_err : 1;
    //
    // Disable viral triggering for RPQ1 rpa parity error. Viral signalling is Error
    // signalling is disabled by default 
    // 
    // Bits[7:7], RWS, default = 0x1
    //
    UINTX dis_rpq1_rpa_par_err : 1;
    //
    // Disable viral triggering for WPQ wpa parity error. Viral signalling is Error signalling
    // is disabled by default 
    // 
    // Bits[8:8], RWS, default = 0x1
    //
    UINTX dis_wpq_wpa_par_err : 1;
    //
    // Disable viral triggering for uncorrectable patrol scurb error. Viral signalling
    // is Error signalling is disabled by default 
    // 
    // Bits[9:9], RWS, default = 0x1
    //
    UINTX dis_uncorr_pat_err : 1;
    //
    // Disable viral triggering for uncorrectable sparing error. Viral signalling is
    // Error signalling is disabled by default 
    // 
    // Bits[10:10], RWS, default = 0x1
    //
    UINTX dis_uncorr_spr_err : 1;
    //
    // Disable viral triggering for APPP error. Viral signalling is Error signalling
    // is disabled by default 
    // 
    // Bits[11:11], RWS, default = 0x1
    //
    UINTX dis_appp_err : 1;
    //
    // Disable viral triggering for viral bit send from FV. Viral signalling is Error
    // signalling is disabled by default 
    // 
    // Bits[12:12], RWS, default = 0x1
    //
    UINTX dis_fv_viral_bit : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 19;
  } Bits;
  UINTX Data;
} DDR4_VIRAL_CTL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define WRROUNDTRIP0_MC1LMDP_REG                          0x00000190
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rank 0 round trip latency in QCLK, 88 max configurable value
    // 
    // Bits[7:0], RW, default = 0x1D
    //
    UINTX rt_rank0 : 8;
    //
    // Rank 1 round trip latency in QCLK
    // 
    // Bits[15:8], RW, default = 0x1D
    //
    UINTX rt_rank1 : 8;
    //
    // Rank 2 round trip latency in QCLK
    // 
    // Bits[23:16], RW, default = 0x1D
    //
    UINTX rt_rank2 : 8;
    //
    // Rank 3 round trip latency in QCLK
    // 
    // Bits[31:24], RW, default = 0x1D
    //
    UINTX rt_rank3 : 8;
  } Bits;
  UINTX Data;
} WRROUNDTRIP0_MC1LMDP_STRUCT;
#endif // ASM_INC

#define WRROUNDTRIP1_MC1LMDP_REG                          0x00000194
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rank 4 round trip latency in QCLK
    // 
    // Bits[7:0], RW, default = 0x1D
    //
    UINTX rt_rank4 : 8;
    //
    // Rank 5 round trip latency in QCLK
    // 
    // Bits[15:8], RW, default = 0x1D
    //
    UINTX rt_rank5 : 8;
    //
    // Rank 6 round trip latency in QCLK
    // 
    // Bits[23:16], RW, default = 0x1D
    //
    UINTX rt_rank6 : 8;
    //
    // Rank 7 round trip latency in QCLK
    // 
    // Bits[31:24], RW, default = 0x1D
    //
    UINTX rt_rank7 : 8;
  } Bits;
  UINTX Data;
} WRROUNDTRIP1_MC1LMDP_STRUCT;
#endif // ASM_INC

#define WRIOLATENCY_MC1LMDP_REG                           0x00000198
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rank 0 IO latency in QCLK
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX io_lat_rank0 : 4;
    //
    // Rank 1 IO latency in QCLK
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX io_lat_rank1 : 4;
    //
    // Rank 2 IO latency in QCLK
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINTX io_lat_rank2 : 4;
    //
    // Rank 3 IO latency in QCLK
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINTX io_lat_rank3 : 4;
    //
    // Rank 4 IO latency in QCLK
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX io_lat_rank4 : 4;
    //
    // Rank 5 IO latency in QCLK
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX io_lat_rank5 : 4;
    //
    // Rank 6 IO latency in QCLK
    // 
    // Bits[27:24], RW, default = 0x0
    //
    UINTX io_lat_rank6 : 4;
    //
    // Rank 7 IO latency in QCLK
    // 
    // Bits[31:28], RW, default = 0x0
    //
    UINTX io_lat_rank7 : 4;
  } Bits;
  UINTX Data;
} WRIOLATENCY_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DETECTION_DEBUG_LOG_LOCATOR_MC1LMDP_REG           0x0000019C
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  this register hold the value of locator syndrome from detection path. the number
    // of LS bits are the same for sddc and adddc ecc 
    // 
    // Bits[15:0], RWS_V, default = 0x0
    //
    UINTX loc_syn : 16;
    //
    // this register hold the value of plus1 locator syndrome from detection path. the
    // number of plus1 LS bits are the same for all the plus1 modes  
    // 
    // Bits[27:16], RWS_V, default = 0x0
    //
    UINTX plus1_loc_syn : 12;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
  } Bits;
  UINTX Data;
} DETECTION_DEBUG_LOG_LOCATOR_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MCSCRAMBLECONFIG_MC1LMDP_REG                      0x000001E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // TX_ENABLE: DDR4 Tx data bus scrambling.
    // 
    // Bits[0:0], RWS_L, default = 0x0
    //
    UINTX tx_enable : 1;
    //
    // RX_ENABLE: DDR4 Rx data bus scrambling.
    // 
    // Bits[1:1], RWS_L, default = 0x0
    //
    UINTX rx_enable : 1;
    //
    // Channel enable
    // 
    // Bits[2:2], RWS_L, default = 0x0
    //
    UINTX ch_enable : 1;
    //
    // lock bit for the seed update.
    // 1b = lock
    // 0b = unlock
    // 
    // Bits[3:3], RWS_O, default = 0x0
    //
    UINTX seed_lock : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // TX_ENABLE: DDR-T Tx data bus scrambling.
    // 
    // Bits[7:7], RWS_L, default = 0x0
    //
    UINTX tx_enable_ddrt : 1;
    //
    // RX_ENABLE: DDR-T Rx data bus scrambling.
    // 
    // Bits[8:8], RWS_L, default = 0x0
    //
    UINTX rx_enable_ddrt : 1;
    //
    // DDRT Channel enable
    // 
    // Bits[9:9], RWS_L, default = 0x0
    //
    UINTX ch_enable_ddrt : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 22;
  } Bits;
  UINTX Data;
} MCSCRAMBLECONFIG_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MCSCRAMBLE_SEED_SEL_MC1LMDP_REG                   0x000001E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reordering the lower srambling seed select control.
    // 
    // Bits[15:0], RWS_L, default = 0x0
    //
    UINTX scrb_lower_seed_sel : 16;
    //
    // Reordering the upper srambling seed select control.
    // 
    // Bits[31:16], RWS_L, default = 0x0
    //
    UINTX scrb_upper_seed_sel : 16;
  } Bits;
  UINTX Data;
} MCSCRAMBLE_SEED_SEL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MCSCRAMBLE_SEED_SEL_DDRT_MC1LMDP_REG              0x000001E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reordering the lower srambling seed select control.
    // 
    // Bits[15:0], RWS_L, default = 0x0
    //
    UINTX scrb_lower_seed_sel_ddrt : 16;
    //
    // Reordering the upper srambling seed select control.
    // 
    // Bits[31:16], RWS_L, default = 0x0
    //
    UINTX scrb_upper_seed_sel_ddrt : 16;
  } Bits;
  UINTX Data;
} MCSCRAMBLE_SEED_SEL_DDRT_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MCSCRAMBLE_RX_SEED_DDRT_MC1LMDP_REG               0x000001EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DDRT Rx descramble seed
    // 
    // Bits[15:0], RWS_L, default = 0xEE37
    //
    UINTX seed : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} MCSCRAMBLE_RX_SEED_DDRT_MC1LMDP_STRUCT;
#endif // ASM_INC

#define STRETCH_MODE_MC1LMDP_REG                          0x00000220
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is the number of times multiplied by 4 the number of clocks receive enable
    // will be extended from the normal ratio. The stretch ratio is also known as Stretch
    // Factor (STF): 
    // 010: STF=2
    // 011: STF=3
    // 100: STF=4
    // Other values - reserved
    // 
    // Bits[2:0], RWS_L, default = 0x0
    //
    UINTX stretch_ratio : 3;
    //
    // 00: Stretch-mode is off
    // 01: Tester stretch-mode
    // 10: System stretch-mode
    // 11: Reserved
    // 
    // Bits[4:3], RWS_L, default = 0x0
    //
    UINTX tester_mode : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 27;
  } Bits;
  UINTX Data;
} STRETCH_MODE_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MCDPDBGPRESEL0_MC1LMDP_REG                        0x00000240
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This selects which set of signals will be driven on lane 0 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[4:0], RWS_L, default = 0x0
    //
    UINTX ln0dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // This selects which set of signals will be driven on lane 1 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[12:8], RWS_L, default = 0x0
    //
    UINTX ln1dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // This selects which set of signals will be driven on lane 2 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[20:16], RWS_L, default = 0x0
    //
    UINTX ln2dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // This selects which set of signals will be driven on lane 3 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[28:24], RWS_L, default = 0x0
    //
    UINTX ln3dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
  } Bits;
  UINTX Data;
} MCDPDBGPRESEL0_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MCDPDBGPRESEL1_MC1LMDP_REG                        0x00000244
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This selects which set of signals will be driven on lane 4 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[4:0], RWS_L, default = 0x0
    //
    UINTX ln4dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // This selects which set of signals will be driven on lane 5 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[12:8], RWS_L, default = 0x0
    //
    UINTX ln5dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // This selects which set of signals will be driven on lane 6 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[20:16], RWS_L, default = 0x0
    //
    UINTX ln6dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // This selects which set of signals will be driven on lane 7 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[28:24], RWS_L, default = 0x0
    //
    UINTX ln7dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 3;
  } Bits;
  UINTX Data;
} MCDPDBGPRESEL1_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDRT_DATAPATH_DELAY_MC1LMDP_REG                   0x00000248
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay after DDRT write is scheduled
    // 
    // Bits[7:0], RW_LB, default = 0x22
    //
    UINTX wr : 8;
    //
    // Delay after DDRT read is scheduled
    // 
    // Bits[15:8], RW_LB, default = 0x28
    //
    UINTX rd : 8;
    //
    // Delay between ERID and RdValid in DDRT mode; the programmed value should be real
    // delay value minus 2 
    // 
    // Bits[20:16], RW_LB, default = 0x3
    //
    UINTX erid_to_rdvalid_delay : 5;
    //
    // for ddrt hard failure BIOS program the failed nibble number(device number)
    // 
    // Bits[25:21], RW_LB, default = 0x12
    //
    UINTX failed_nibble_number : 5;
    //
    // for ddrt hard failure force to take the correction path all the time
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX ddrt_force_correction : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
  } Bits;
  UINTX Data;
} DDRT_DATAPATH_DELAY_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDRT_DATAPATH_DELAY2_MC1LMDP_REG                  0x0000024C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ERID to retry delay
    // 
    // Bits[4:0], RW_LB, default = 0x4
    //
    UINTX erid_to_retry_delay : 5;
    //
    // ERID to earlier version of retry delay
    // 
    // Bits[9:5], RW_LB, default = 0x2
    //
    UINTX erid_to_earlyretry_delay : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 22;
  } Bits;
  UINTX Data;
} DDRT_DATAPATH_DELAY2_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MCRRDVISACFG_MC1LMDP_REG                          0x00000260
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RWS_L, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RWS_L, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RWS_L, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RWS_L, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RWS_L, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCRRDVISACFG_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MCRTVISACFG_MC1LMDP_REG                           0x00000264
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RWS_L, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RWS_L, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RWS_L, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RWS_L, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RWS_L, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCRTVISACFG_MC1LMDP_STRUCT;
#endif // ASM_INC

#define X4MODESEL_MC1LMDP_REG                             0x00000268
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Controls the DDRIO x4 (if set) / x8 (if cleared) DIMM0 DQS select.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINTX dimm0_mode : 1;
    //
    // Controls the DDRIO x4 (if set) / x8 (if cleared) DIMM1 DQS select.
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINTX dimm1_mode : 1;
    //
    // Controls the DDRIO x4 (if set) / x8 (if cleared) DIMM2 DQS select.
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINTX dimm2_mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 29;
  } Bits;
  UINTX Data;
} X4MODESEL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CORRECTION_DEBUG_DEV_VEC_1_MC1LMDP_REG            0x00000310
#ifndef ASM_INC
typedef union {
  struct {
    //
    // sddc device: 0-15 data device, dev16 metadata/locator device, dev17 parity device
    // 
    // Bits[17:0], RWS_V, default = 0x0
    //
    UINTX sddc : 18;
    //
    // adddc device 1st half: 0-15 data device, and dev16 metadata device. (dev 17 is
    // not included since it is the spare dev) 
    //                      only 14 bits (data device 0-13) in this register the rest
    // in correction_debug_dev_vec_2 register 
    // 
    // Bits[31:18], RWS_V, default = 0x0
    //
    UINTX adddc_1st : 14;
  } Bits;
  UINTX Data;
} CORRECTION_DEBUG_DEV_VEC_1_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CORRECTION_DEBUG_DEV_VEC_2_MC1LMDP_REG            0x00000314
#ifndef ASM_INC
typedef union {
  struct {
    //
    // adddc device 1st half: 0-15 data device, dev16 metadata device. (dev 17 is not
    // included since it is the spare dev) 
    //                      data device 0-13 in correction_debug_dev_vec_1 register
    //                      this register holds data device 14-15, and metadata 
    // 
    // Bits[2:0], RWS_V, default = 0x0
    //
    UINTX adddc_1st : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // adddc device 2nd half: 0-15 data device (device 18-33), dev16 locator device(dev34),
    // dev17 parity device(dev35) 
    // 
    // Bits[21:4], RWS_V, default = 0x0
    //
    UINTX adddc_2nd : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 10;
  } Bits;
  UINTX Data;
} CORRECTION_DEBUG_DEV_VEC_2_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CORRECTION_DEBUG_CORR_DATA_CNTL_MC1LMDP_REG       0x00000318
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  select which chunk of data to write to the data register
    //                       0-15 to select over 512 bits of data (e.x. sel=0 returns
    // bits [31:0] 0f 512 bit data) 
    //                       16 select over 32 bits of ecc data 
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX mux_sel : 5;
    //
    //  will enable the clock of the data register(correction_debug_corr_data).
    // 		      if this is not set the data is not valid 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX clk_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 26;
  } Bits;
  UINTX Data;
} CORRECTION_DEBUG_CORR_DATA_CNTL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CORRECTION_DEBUG_CORR_DATA_MC1LMDP_REG            0x0000031C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // accumulated data before it gets corrected. 512 bit data + 32 ecc data write to
    // this field over 17 writes  
    // 
    // Bits[31:0], RO_V, default = 0x0
    //
    UINTX accum_data : 32;
  } Bits;
  UINTX Data;
} CORRECTION_DEBUG_CORR_DATA_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC2_DQ15_DQ0_MC1LMDP_REG                  0x0000043C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Swizzling for DQ Bits 15 to 0. 2 CSR bits per DQ lane
    // 
    // Bits[31:0], RW_LB, default = 0xE4E4E4E4
    //
    UINTX swizzle_ctl : 32;
  } Bits;
  UINTX Data;
} DDR4_WRCRC2_DQ15_DQ0_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC2_DQ31_DQ16_MC1LMDP_REG                 0x00000440
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Swizzling for DQ Bits 31 to 16. 2 CSR bits per DQ lane
    // 
    // Bits[31:0], RW_LB, default = 0xE4E4E4E4
    //
    UINTX swizzle_ctl : 32;
  } Bits;
  UINTX Data;
} DDR4_WRCRC2_DQ31_DQ16_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC2_DQ47_DQ32_MC1LMDP_REG                 0x00000444
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Swizzling for DQ Bits 47 to 32. 2 CSR bits per DQ lane
    // 
    // Bits[31:0], RW_LB, default = 0xE4E4E4E4
    //
    UINTX swizzle_ctl : 32;
  } Bits;
  UINTX Data;
} DDR4_WRCRC2_DQ47_DQ32_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC2_DQ63_DQ48_MC1LMDP_REG                 0x0000044C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Swizzling for DQ Bits 63 to 48. 2 CSR bits per DQ lane
    // 
    // Bits[31:0], RW_LB, default = 0xE4E4E4E4
    //
    UINTX swizzle_ctl : 32;
  } Bits;
  UINTX Data;
} DDR4_WRCRC2_DQ63_DQ48_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC2_CTL_MC1LMDP_REG                       0x00000450
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // Enable swizzling per nibble
    // 
    // Bits[12:4], RW_LB, default = 0x0
    //
    UINTX enable_nibble_swizzle : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Swizzling for DQ Bits 71 to 43. 2 CSR bits per DQ lane
    // 
    // Bits[31:16], RW_LB, default = 0xE4E4
    //
    UINTX dq71_dq64_swizzle_ctl : 16;
  } Bits;
  UINTX Data;
} DDR4_WRCRC2_CTL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC3_DQ15_DQ0_MC1LMDP_REG                  0x00000454
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Swizzling for DQ Bits 15 to 0. 2 CSR bits per DQ lane
    // 
    // Bits[31:0], RW_LB, default = 0xE4E4E4E4
    //
    UINTX swizzle_ctl : 32;
  } Bits;
  UINTX Data;
} DDR4_WRCRC3_DQ15_DQ0_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC3_DQ31_DQ16_MC1LMDP_REG                 0x00000458
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Swizzling for DQ Bits 31 to 16. 2 CSR bits per DQ lane
    // 
    // Bits[31:0], RW_LB, default = 0xE4E4E4E4
    //
    UINTX swizzle_ctl : 32;
  } Bits;
  UINTX Data;
} DDR4_WRCRC3_DQ31_DQ16_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC3_DQ47_DQ32_MC1LMDP_REG                 0x0000045C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Swizzling for DQ Bits 47 to 32. 2 CSR bits per DQ lane
    // 
    // Bits[31:0], RW_LB, default = 0xE4E4E4E4
    //
    UINTX swizzle_ctl : 32;
  } Bits;
  UINTX Data;
} DDR4_WRCRC3_DQ47_DQ32_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC3_DQ63_DQ48_MC1LMDP_REG                 0x00000460
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Swizzling for DQ Bits 63 to 48. 2 CSR bits per DQ lane
    // 
    // Bits[31:0], RW_LB, default = 0xE4E4E4E4
    //
    UINTX swizzle_ctl : 32;
  } Bits;
  UINTX Data;
} DDR4_WRCRC3_DQ63_DQ48_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC3_CTL_MC1LMDP_REG                       0x00000464
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // Enable swizzling per nibble
    // 
    // Bits[12:4], RW_LB, default = 0x0
    //
    UINTX enable_nibble_swizzle : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Swizzling for DQ Bits 71 to 43. 2 CSR bits per DQ lane
    // 
    // Bits[31:16], RW_LB, default = 0xE4E4
    //
    UINTX dq71_dq64_swizzle_ctl : 16;
  } Bits;
  UINTX Data;
} DDR4_WRCRC3_CTL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC0_DQ15_DQ0_MC1LMDP_REG                  0x00000468
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Swizzling for DQ Bits 15 to 0. 2 CSR bits per DQ lane
    // 
    // Bits[31:0], RW_LB, default = 0xE4E4E4E4
    //
    UINTX swizzle_ctl : 32;
  } Bits;
  UINTX Data;
} DDR4_WRCRC0_DQ15_DQ0_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC0_DQ31_DQ16_MC1LMDP_REG                 0x0000046C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Swizzling for DQ Bits 31 to 16. 2 CSR bits per DQ lane
    // 
    // Bits[31:0], RW_LB, default = 0xE4E4E4E4
    //
    UINTX swizzle_ctl : 32;
  } Bits;
  UINTX Data;
} DDR4_WRCRC0_DQ31_DQ16_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC0_DQ47_DQ32_MC1LMDP_REG                 0x00000470
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Swizzling for DQ Bits 47 to 32. 2 CSR bits per DQ lane
    // 
    // Bits[31:0], RW_LB, default = 0xE4E4E4E4
    //
    UINTX swizzle_ctl : 32;
  } Bits;
  UINTX Data;
} DDR4_WRCRC0_DQ47_DQ32_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC0_DQ63_DQ48_MC1LMDP_REG                 0x00000474
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Swizzling for DQ Bits 63 to 48. 2 CSR bits per DQ lane
    // 
    // Bits[31:0], RW_LB, default = 0xE4E4E4E4
    //
    UINTX swizzle_ctl : 32;
  } Bits;
  UINTX Data;
} DDR4_WRCRC0_DQ63_DQ48_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC0_CTL_MC1LMDP_REG                       0x00000478
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // Enable swizzling per nibble
    // 
    // Bits[12:4], RW_LB, default = 0x0
    //
    UINTX enable_nibble_swizzle : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Swizzling for DQ Bits 71 to 43. 2 CSR bits per DQ lane
    // 
    // Bits[31:16], RW_LB, default = 0xE4E4
    //
    UINTX dq71_dq64_swizzle_ctl : 16;
  } Bits;
  UINTX Data;
} DDR4_WRCRC0_CTL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC1_DQ15_DQ0_MC1LMDP_REG                  0x0000047C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Swizzling for DQ Bits 15 to 0. 2 CSR bits per DQ lane
    // 
    // Bits[31:0], RW_LB, default = 0xE4E4E4E4
    //
    UINTX swizzle_ctl : 32;
  } Bits;
  UINTX Data;
} DDR4_WRCRC1_DQ15_DQ0_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC1_DQ31_DQ16_MC1LMDP_REG                 0x00000480
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Swizzling for DQ Bits 31 to 16. 2 CSR bits per DQ lane
    // 
    // Bits[31:0], RW_LB, default = 0xE4E4E4E4
    //
    UINTX swizzle_ctl : 32;
  } Bits;
  UINTX Data;
} DDR4_WRCRC1_DQ31_DQ16_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC1_DQ47_DQ32_MC1LMDP_REG                 0x00000484
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Swizzling for DQ Bits 47 to 32. 2 CSR bits per DQ lane
    // 
    // Bits[31:0], RW_LB, default = 0xE4E4E4E4
    //
    UINTX swizzle_ctl : 32;
  } Bits;
  UINTX Data;
} DDR4_WRCRC1_DQ47_DQ32_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC1_DQ63_DQ48_MC1LMDP_REG                 0x00000488
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Swizzling for DQ Bits 63 to 48. 2 CSR bits per DQ lane
    // 
    // Bits[31:0], RW_LB, default = 0xE4E4E4E4
    //
    UINTX swizzle_ctl : 32;
  } Bits;
  UINTX Data;
} DDR4_WRCRC1_DQ63_DQ48_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC1_CTL_MC1LMDP_REG                       0x0000048C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // Enable swizzling per nibble
    // 
    // Bits[12:4], RW_LB, default = 0x0
    //
    UINTX enable_nibble_swizzle : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Swizzling for DQ Bits 71 to 43. 2 CSR bits per DQ lane
    // 
    // Bits[31:16], RW_LB, default = 0xE4E4
    //
    UINTX dq71_dq64_swizzle_ctl : 16;
  } Bits;
  UINTX Data;
} DDR4_WRCRC1_CTL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_WRCRC_RANK_CTL_MC1LMDP_REG                   0x00000490
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DDR4 WR CRC mask to use for Rank0
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX rank0 : 2;
    //
    // DDR4 WR CRC mask to use for Rank1
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX rank1 : 2;
    //
    // DDR4 WR CRC mask to use for Rank2
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX rank2 : 2;
    //
    // DDR4 WR CRC mask to use for Rank3
    // 
    // Bits[7:6], RW_LB, default = 0x0
    //
    UINTX rank3 : 2;
    //
    // DDR4 WR CRC mask to use for Rank4
    // 
    // Bits[9:8], RW_LB, default = 0x0
    //
    UINTX rank4 : 2;
    //
    // DDR4 WR CRC mask to use for Rank5
    // 
    // Bits[11:10], RW_LB, default = 0x0
    //
    UINTX rank5 : 2;
    //
    // DDR4 WR CRC mask to use for Rank6
    // 
    // Bits[13:12], RW_LB, default = 0x0
    //
    UINTX rank6 : 2;
    //
    // DDR4 WR CRC mask to use for Rank7
    // 
    // Bits[15:14], RW_LB, default = 0x0
    //
    UINTX rank7 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} DDR4_WRCRC_RANK_CTL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define PLUS1_RANK0_MC1LMDP_REG                           0x00000720
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                     This field specifies the failed device to be mapped out for
    // this rank, for portions of the rank not participating in an ADDDC region. 
    //                     Set by hardware at the beginning of a sparing flow.
    // 
    //                     Hardware will capture the fail device ID of the rank in the
    // FailDevice field upon successful correction from the ECC logic.  
    //                     After SDDC is enabled HW may not update this field.
    //                     Independent Channel x4: Valid Range is decimal 0-17 to indicate
    // which device has failed.  
    //                     Virtual Lockstep x8:    Valid Range is decimal 0-17 to indicate
    // which device has failed. 
    //                     Virtual Lockstep x4:    Valid Range is decimal 0-35 to indicate
    // which device has failed. 
    // 
    //                     Note that when DDDC has been enabled on the non-spare device,
    // and a subsequent failure of the spare device occurs, the value logged here will
    // be equal to the DDDC faildevice.  -- Is this still true for ADDDC? -- 
    //                 
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} PLUS1_RANK0_MC1LMDP_STRUCT;
#endif // ASM_INC

#define PLUS1_RANK1_MC1LMDP_REG                           0x00000721
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                     This field specifies the failed device to be mapped out for
    // this rank, for portions of the rank not participating in an ADDDC region. 
    //                     Set by hardware at the beginning of a sparing flow.
    // 
    //                     Hardware will capture the fail device ID of the rank in the
    // FailDevice field upon successful correction from the ECC logic.  
    //                     After SDDC is enabled HW may not update this field.
    //                     Independent Channel x4: Valid Range is decimal 0-17 to indicate
    // which device has failed.  
    //                     Virtual Lockstep x8:    Valid Range is decimal 0-17 to indicate
    // which device has failed. 
    //                     Virtual Lockstep x4:    Valid Range is decimal 0-35 to indicate
    // which device has failed. 
    // 
    //                     Note that when DDDC has been enabled on the non-spare device,
    // and a subsequent failure of the spare device occurs, the value logged here will
    // be equal to the DDDC faildevice.  -- Is this still true for ADDDC? -- 
    //                 
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} PLUS1_RANK1_MC1LMDP_STRUCT;
#endif // ASM_INC

#define PLUS1_RANK2_MC1LMDP_REG                           0x00000722
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                     This field specifies the failed device to be mapped out for
    // this rank, for portions of the rank not participating in an ADDDC region. 
    //                     Set by hardware at the beginning of a sparing flow.
    // 
    //                     Hardware will capture the fail device ID of the rank in the
    // FailDevice field upon successful correction from the ECC logic.  
    //                     After SDDC is enabled HW may not update this field.
    //                     Independent Channel x4: Valid Range is decimal 0-17 to indicate
    // which device has failed.  
    //                     Virtual Lockstep x8:    Valid Range is decimal 0-17 to indicate
    // which device has failed. 
    //                     Virtual Lockstep x4:    Valid Range is decimal 0-35 to indicate
    // which device has failed. 
    // 
    //                     Note that when DDDC has been enabled on the non-spare device,
    // and a subsequent failure of the spare device occurs, the value logged here will
    // be equal to the DDDC faildevice.  -- Is this still true for ADDDC? -- 
    //                 
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} PLUS1_RANK2_MC1LMDP_STRUCT;
#endif // ASM_INC

#define PLUS1_RANK3_MC1LMDP_REG                           0x00000723
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                     This field specifies the failed device to be mapped out for
    // this rank, for portions of the rank not participating in an ADDDC region. 
    //                     Set by hardware at the beginning of a sparing flow.
    // 
    //                     Hardware will capture the fail device ID of the rank in the
    // FailDevice field upon successful correction from the ECC logic.  
    //                     After SDDC is enabled HW may not update this field.
    //                     Independent Channel x4: Valid Range is decimal 0-17 to indicate
    // which device has failed.  
    //                     Virtual Lockstep x8:    Valid Range is decimal 0-17 to indicate
    // which device has failed. 
    //                     Virtual Lockstep x4:    Valid Range is decimal 0-35 to indicate
    // which device has failed. 
    // 
    //                     Note that when DDDC has been enabled on the non-spare device,
    // and a subsequent failure of the spare device occurs, the value logged here will
    // be equal to the DDDC faildevice.  -- Is this still true for ADDDC? -- 
    //                 
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} PLUS1_RANK3_MC1LMDP_STRUCT;
#endif // ASM_INC

#define PLUS1_RANK4_MC1LMDP_REG                           0x00000724
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                     This field specifies the failed device to be mapped out for
    // this rank, for portions of the rank not participating in an ADDDC region. 
    //                     Set by hardware at the beginning of a sparing flow.
    // 
    //                     Hardware will capture the fail device ID of the rank in the
    // FailDevice field upon successful correction from the ECC logic.  
    //                     After SDDC is enabled HW may not update this field.
    //                     Independent Channel x4: Valid Range is decimal 0-17 to indicate
    // which device has failed.  
    //                     Virtual Lockstep x8:    Valid Range is decimal 0-17 to indicate
    // which device has failed. 
    //                     Virtual Lockstep x4:    Valid Range is decimal 0-35 to indicate
    // which device has failed. 
    // 
    //                     Note that when DDDC has been enabled on the non-spare device,
    // and a subsequent failure of the spare device occurs, the value logged here will
    // be equal to the DDDC faildevice.  -- Is this still true for ADDDC? -- 
    //                 
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} PLUS1_RANK4_MC1LMDP_STRUCT;
#endif // ASM_INC

#define PLUS1_RANK5_MC1LMDP_REG                           0x00000725
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                     This field specifies the failed device to be mapped out for
    // this rank, for portions of the rank not participating in an ADDDC region. 
    //                     Set by hardware at the beginning of a sparing flow.
    // 
    //                     Hardware will capture the fail device ID of the rank in the
    // FailDevice field upon successful correction from the ECC logic.  
    //                     After SDDC is enabled HW may not update this field.
    //                     Independent Channel x4: Valid Range is decimal 0-17 to indicate
    // which device has failed.  
    //                     Virtual Lockstep x8:    Valid Range is decimal 0-17 to indicate
    // which device has failed. 
    //                     Virtual Lockstep x4:    Valid Range is decimal 0-35 to indicate
    // which device has failed. 
    // 
    //                     Note that when DDDC has been enabled on the non-spare device,
    // and a subsequent failure of the spare device occurs, the value logged here will
    // be equal to the DDDC faildevice.  -- Is this still true for ADDDC? -- 
    //                 
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} PLUS1_RANK5_MC1LMDP_STRUCT;
#endif // ASM_INC

#define PLUS1_RANK6_MC1LMDP_REG                           0x00000726
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                     This field specifies the failed device to be mapped out for
    // this rank, for portions of the rank not participating in an ADDDC region. 
    //                     Set by hardware at the beginning of a sparing flow.
    // 
    //                     Hardware will capture the fail device ID of the rank in the
    // FailDevice field upon successful correction from the ECC logic.  
    //                     After SDDC is enabled HW may not update this field.
    //                     Independent Channel x4: Valid Range is decimal 0-17 to indicate
    // which device has failed.  
    //                     Virtual Lockstep x8:    Valid Range is decimal 0-17 to indicate
    // which device has failed. 
    //                     Virtual Lockstep x4:    Valid Range is decimal 0-35 to indicate
    // which device has failed. 
    // 
    //                     Note that when DDDC has been enabled on the non-spare device,
    // and a subsequent failure of the spare device occurs, the value logged here will
    // be equal to the DDDC faildevice.  -- Is this still true for ADDDC? -- 
    //                 
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} PLUS1_RANK6_MC1LMDP_STRUCT;
#endif // ASM_INC

#define PLUS1_RANK7_MC1LMDP_REG                           0x00000727
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                     This field specifies the failed device to be mapped out for
    // this rank, for portions of the rank not participating in an ADDDC region. 
    //                     Set by hardware at the beginning of a sparing flow.
    // 
    //                     Hardware will capture the fail device ID of the rank in the
    // FailDevice field upon successful correction from the ECC logic.  
    //                     After SDDC is enabled HW may not update this field.
    //                     Independent Channel x4: Valid Range is decimal 0-17 to indicate
    // which device has failed.  
    //                     Virtual Lockstep x8:    Valid Range is decimal 0-17 to indicate
    // which device has failed. 
    //                     Virtual Lockstep x4:    Valid Range is decimal 0-35 to indicate
    // which device has failed. 
    // 
    //                     Note that when DDDC has been enabled on the non-spare device,
    // and a subsequent failure of the spare device occurs, the value logged here will
    // be equal to the DDDC faildevice.  -- Is this still true for ADDDC? -- 
    //                 
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} PLUS1_RANK7_MC1LMDP_STRUCT;
#endif // ASM_INC

#define ADDDC_REGION0_MC1LMDP_REG                         0x00000730
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                     This field specifies the failed device to be mapped out for
    // this adddc region. 
    //                     Valid range is 0-35, with values >=18 indicating the buddy
    // rank. 
    //  
    //                 
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} ADDDC_REGION0_MC1LMDP_STRUCT;
#endif // ASM_INC

#define ADDDC_REGION1_MC1LMDP_REG                         0x00000731
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                     This field specifies the failed device to be mapped out for
    // this adddc region. 
    //                     Valid range is 0-35, with values >=18 indicating the buddy
    // rank. 
    //  
    //                 
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} ADDDC_REGION1_MC1LMDP_STRUCT;
#endif // ASM_INC

#define ADDDC_REGION2_MC1LMDP_REG                         0x00000732
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                     This field specifies the failed device to be mapped out for
    // this adddc region. 
    //                     Valid range is 0-35, with values >=18 indicating the buddy
    // rank. 
    //  
    //                 
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} ADDDC_REGION2_MC1LMDP_STRUCT;
#endif // ASM_INC

#define ADDDC_REGION3_MC1LMDP_REG                         0x00000733
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                     This field specifies the failed device to be mapped out for
    // this adddc region. 
    //                     Valid range is 0-35, with values >=18 indicating the buddy
    // rank. 
    //                  
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX faildevice : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} ADDDC_REGION3_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR_TRACE_THROTTLE_CTL_MC1LMDP_REG                0x000000F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When the read data fifo has more than read_fifo_thresh entires, stall the scheduler.
    // To disable this function, set read_fifo_thresh to 
    // a value greater than decimal 39
    // 
    // Bits[5:0], RWS, default = 0x3F
    //
    UINTX read_fifo_thresh : 6;
    //
    // When the write data fifo has more than write_fifo_thresh entires, stall the scheduler.
    // To disable this function, set write_fifo_thresh to 
    // a value greater than decimal 39
    // 
    // Bits[11:6], RWS, default = 0x3F
    //
    UINTX write_fifo_thresh : 6;
    //
    // Use PWM with period of read_fifo_thresh+1 and a stall duty cycle of write_fifo_thresh
    // 
    // Bits[12:12], RWS, default = 0x0
    //
    UINTX pwm_mode : 1;
    //
    // Data tracing read FIFO has lost sample data
    // 
    // Bits[13:13], RO_V, default = 0x0
    //
    UINTX read_overflow : 1;
    //
    // Data tracing write FIFO has lost sample data
    // 
    // Bits[14:14], RO_V, default = 0x0
    //
    UINTX write_overflow : 1;
    //
    // Support IOT DDRIO loopback for tracing DDRIO data.
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX iotddrio_loopback : 1;
    //
    // When set to 0, IOT DDRIO loopback is for tracing DDR4 write data; when set to
    // 1, IOT DDRIO loopback is for tracing DDRT write data. This field should be set
    // to the same value as blegr_crdt_ctl.iotlb_ddrt. 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINTX iotlb_ddrt : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // The number of credits to start off with for the MC to HA BGF which is used for
    // data tracing. The valid range is 4 to 10. 
    // 
    // Bits[23:20], RWS, default = 0xA
    //
    UINTX trace_bgf_init_credits : 4;
    //
    // When tracing is finished, the iot satallite will turn off IotTraceEnDnn6H. This
    // field sets the number of cycles to delay after 
    // IotTraceEnDnn6H is turned off before flushing the WDB FIFO and transmitting a
    // footer. The value of this field should be large 
    // enough to account for the round trip delay of a read.
    // 
    // Bits[31:24], RWS, default = 0xFF
    //
    UINTX auto_flush_delay : 8;
  } Bits;
  UINTX Data;
} DDR_TRACE_THROTTLE_CTL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MCWDB_CHKN_BIT_MC1LMDP_REG                        0x000000F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Disable sending write data early to ddrio for anti cross talk logic; If 0, data
    // will be sent 
    // early one Dclock so ddrio has time to do cross talk cancelation logic.
    // If set to 1, write data will be sent with normal timing and ddrio will have no
    // time to do cross 
    // talk cancelation logic.
    // 
    // Bits[0:0], RW_LB, default = 0x1
    //
    UINTX dis_ddrio_earlywdata : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 31;
  } Bits;
  UINTX Data;
} MCWDB_CHKN_BIT_MC1LMDP_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK_MC1LMDP_REG     0x00000200
#ifndef ASM_INC
typedef union {
  struct {
    //
    // device 0 data inversion mask for error injection. Eight 4-bit values specify which
    // bits of the nibble are inverted on each data cycle of a BL8 write. Bits 3:0 correspond
    // to the first data cycle. 
    // In addition to LT lock, this register is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK
    // (uCR) AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR). 
    // 
    // Bits[31:0], RW_L, default = 0x0
    //
    UINTX dev0_xor_msk : 32;
  } Bits;
  UINTX Data;
} RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK_MC1LMDP_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK_MC1LMDP_REG     0x00000204
#ifndef ASM_INC
typedef union {
  struct {
    //
    // device 1 data inversion mask for error injection. Eight 4-bit values specify which
    // bits of the nibble are inverted on each data cycle of a BL8 write. Bits 3:0 correspond
    // to the first data cycle. 
    // In addition to LT lock, this register is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK
    // (uCR) AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR). 
    // 
    // Bits[31:0], RW_L, default = 0x0
    //
    UINTX dev1_xor_msk : 32;
  } Bits;
  UINTX Data;
} RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK_MC1LMDP_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_CRC_ERR_INJ_EXTRA_MC1LMDP_REG            0x00000208
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Error Injection Response Function on Address Match Write Data Error Injection.
    // Associating registers: RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK
    // and RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK 
    // Selects nibble of data bus for error injection. 0x0 selects DQ[3:0], 0x1 selects
    // DQ[7:4], 0x17 selects ECC[7:4] etc... 
    // 0x18 - 0x31 are reserved.
    // In addition to LT lock, this register is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK
    // (uCR) AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR). 
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX crc_err_inj_dev0_5_bits : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Error Injection Response Function on Address Match Write Data Error Injection.
    // Associating registers: RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK
    // and RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK 
    // Selects nibble of data bus for device 1 error injection. 0x0 selects DQ[3:0],
    // 0x1 selects DQ[7:4], 0x17 selects ECC[7:4] etc... 
    // 0x18 - 0x31 are reserved.
    // In addition to LT lock, this register is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK
    // (uCR) AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR). 
    // 
    // Bits[12:8], RW_L, default = 0x0
    //
    UINTX crc_err_inj_dev1_5_bits : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // Error Injection Response Function on Address Match Write Data Parity Error Injection.
    // Associating registers: RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_ADDR_MATCH_LO&HI, 
    // Internal Use only since this function require MBP/ASC DFx hooks. The following
    // triggers the error injection. 
    // 00 - Dont inject
    // 01 - Use Trigger-0 from MCGLBRSPCNTL.GlbRsp0
    // 10 - Use Trigger-1 from MCGLBRSPCNTL.GlbRsp1
    // 11 - Use Trigger-2 from MCGLBRSPCNTL.GlbRsp2
    // Please refer to Jaketown DFx related MAS document for further detail.
    // 
    // Bits[17:16], RW_L, default = 0x0
    //
    UINTX inj_ha_data_par_err_sel : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 6;
    //
    // Error Injection Response Function on Address Match Write Data Poison Pattern Injection.
    // Associating registers: RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_ADDR_MATCH_LO&HI, 
    // Internal Use only since this function require MBP/ASC DFx hooks. The following
    // triggers the error injection. 
    // 00 - Dont inject
    // 01 - Use Trigger-0 from MCGLBRSPCNTL.GlbRsp0
    // 10 - Use Trigger-1 from MCGLBRSPCNTL.GlbRsp1
    // 11 - Use Trigger-2 from MCGLBRSPCNTL.GlbRsp2
    // Please refer to Jaketown DFx related MAS document for further detail.
    // 
    // Bits[25:24], RW_L, default = 0x0
    //
    UINTX inj_ha_poison_err_sel : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 6;
  } Bits;
  UINTX Data;
} RSP_FUNC_CRC_ERR_INJ_EXTRA_MC1LMDP_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK_DDRT_MC1LMDP_REG0x0000020C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // device 0 data inversion mask for error injection. Eight 4-bit values specify which
    // bits of the nibble are inverted on each data cycle of a BL8 write. Bits 3:0 correspond
    // to the first data cycle. 
    // In addition to LT lock, this register is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK
    // (uCR) AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR). 
    // 
    // Bits[31:0], RW_L, default = 0x0
    //
    UINTX dev0_xor_msk : 32;
  } Bits;
  UINTX Data;
} RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK_DDRT_MC1LMDP_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK_DDRT_MC1LMDP_REG0x00000210
#ifndef ASM_INC
typedef union {
  struct {
    //
    // device 1 data inversion mask for error injection. Eight 4-bit values specify which
    // bits of the nibble are inverted on each data cycle of a BL8 write. Bits 3:0 correspond
    // to the first data cycle. 
    // In addition to LT lock, this register is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK
    // (uCR) AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR). 
    // 
    // Bits[31:0], RW_L, default = 0x0
    //
    UINTX dev1_xor_msk : 32;
  } Bits;
  UINTX Data;
} RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK_DDRT_MC1LMDP_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_CRC_ERR_INJ_EXTRA_DDRT_MC1LMDP_REG       0x00000214
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Error Injection Response Function on Address Match Write Data Error Injection.
    // Associating registers: RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK
    // and RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK 
    // Selects nibble of data bus for error injection. 0x0 selects DQ[3:0], 0x1 selects
    // DQ[7:4], 0x17 selects ECC[7:4] etc... 
    // 0x18 - 0x31 are reserved.
    // In addition to LT lock, this register is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK
    // (uCR) AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR). 
    // 
    // Bits[4:0], RW_L, default = 0x0
    //
    UINTX crc_err_inj_dev0_5_bits : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Error Injection Response Function on Address Match Write Data Error Injection.
    // Associating registers: RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK
    // and RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK 
    // Selects nibble of data bus for device 1 error injection. 0x0 selects DQ[3:0],
    // 0x1 selects DQ[7:4], 0x17 selects ECC[7:4] etc... 
    // 0x18 - 0x31 are reserved.
    // In addition to LT lock, this register is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK
    // (uCR) AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR). 
    // 
    // Bits[12:8], RW_L, default = 0x0
    //
    UINTX crc_err_inj_dev1_5_bits : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 19;
  } Bits;
  UINTX Data;
} RSP_FUNC_CRC_ERR_INJ_EXTRA_DDRT_MC1LMDP_STRUCT;
#endif // ASM_INC

#define WDB_INIT_PSN_CTL_MC1LMDP_REG                      0x00000218
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Setting this bit will poison all writes coming from WDB for this channel. This
    // bit is meant to be used during memory initialization for memory space that is
    // set aside for memory migration. 
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX poisonall : 1;
    //
    // Setting this bit will poison all DDRT writes coming from WDB for this channel.
    // This bit is meant to be used during memory initialization for memory space that
    // is set aside for memory migration. 
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX poisonall_ddrt : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
  } Bits;
  UINTX Data;
} WDB_INIT_PSN_CTL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define WDB_DDRT_WR_CTL_MC1LMDP_REG                       0x0000021C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Delay selection for DDRT write in WDB. A value above 25 is not valid.
    // 
    // Bits[4:0], RW_LB, default = 0x1
    //
    UINTX sel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
  } Bits;
  UINTX Data;
} WDB_DDRT_WR_CTL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MCWDBVISACFG_MC1LMDP_REG                          0x0000026C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RWS_L, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RWS_L, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RWS_L, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RWS_L, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RWS_L, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCWDBVISACFG_MC1LMDP_STRUCT;
#endif // ASM_INC

#define WDB_PAR_ERR_CTL_MC1LMDP_REG                       0x000004FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 16 bit mask for injection on WDB read parity value
    // 
    // Bits[15:0], RW_LB, default = 0x0
    //
    UINTX inj_mask : 16;
    //
    // Parity error will be injected according to inj_mask on the next WDB read after
    // this bit is set. Enable bit will be unset after injection. 
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 15;
  } Bits;
  UINTX Data;
} WDB_PAR_ERR_CTL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDBCLMUX_LMN_MC1LMDP_REG                  0x00000500
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0x0 = logic 0 must be driven during the initial L counter delay
    // 0x1=logic 1 must be driven during the initial L counter delay
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX l_datsel : 1;
    //
    // After L_Counter Chunk transfers are driven at the beginning of a test then periodic
    // pattern is continuously repeated depending on the value of Sweep Frequency. 
    // If Sweep_Frequency = 0 then the following pattern is continuously repeated:
    // 1) The opposite polarity as L (i.e. If L is high M is then Low) must be driven
    // for M+1 Qclk cycles 
    // 2) Followed immediately by the same polarity as L (i.e. If L is high N is then
    // High) must be driven for N+1 Qclk cycles 
    // 3) Repeat step 1)
    // If Sweep_Frequency = 0 and and if either L, M, or N = 0 then the the state will
    // freeze in whoever is programmed to 0 starting with L then M and then N in terms
    // of priority. 
    // If Sweep_Frequency =1 then the following pattern is continuously repeated:
    // 1) X = M
    // 2) X is driven opposite polarity as L (i.e. If L is high then the current polarity
    // is Low) for X Qclk cycles. 
    // 3) The same polarity as L (i.e. If L is high then the current polarity is High)
    // must be driven for X Qclk cycles. 
    // 4) The opposite polarity as L is driven for X Qclk cycles.
    // 5) X = X +1
    // 6) The Same polarity as L is driven for X Qclk cycles.
    // 7) If X = N then go to step 1 else go to step 2
    // L, M, and N must never be programmed to 0 if Sweep_Frequency = 1 and is considered
    // undefined. 
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX sweep_freq : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // After L_Counter Chunk transfers are driven at the beginning of a test then periodic
    // pattern is continuously repeated depending on 
    // the value of Sweep Frequency.
    // If Sweep_Frequency = 0 then a steady state frequency is driven (see Sweep_Frequency
    // for exact behavior) 
    // If Sweep_Frequency = 1 then a frequency sweep is continuously generated ranging
    // from 2*(M) to 2*(N) driven (see Sweep_Frequency for exact behavior) 
    // 
    // Bits[15:8], RW_LB, default = 0x1
    //
    UINTX l_cnt : 8;
    //
    // After L_Counter Chunk transfers are driven at the beginning of a test then periodic
    // pattern is continuously repeated depending on 
    // the value of Sweep Frequency.
    // If Sweep_Frequency = 0 then a steady state frequency is driven (see Sweep_Frequency
    // for exact behavior) 
    // If Sweep_Frequency = 1 then a frequency sweep is continuously generated ranging
    // from 2*(M) to 2*(N) driven (see Sweep_Frequency for exact behavior) 
    // 
    // Bits[23:16], RW_LB, default = 0x1
    //
    UINTX m_cnt : 8;
    //
    // After L_Counter Chunk transfers are driven at the beginning of a test then periodic
    // pattern is continuously repeated depending on 
    // the value of Sweep Frequency.
    // If Sweep_Frequency = 0 then a steady state frequency is driven (see Sweep_Frequency
    // for exact behavior) 
    // If Sweep_Frequency = 1 then a frequency sweep is continuously generated ranging
    // from 2*(M) to 2*(N) driven (see Sweep_Frequency for exact behavior) 
    // 
    // Bits[31:24], RW_LB, default = 0x1
    //
    UINTX n_cnt : 8;
  } Bits;
  UINTX Data;
} CPGC_PATWDBCLMUX_LMN_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDBCL_MUX0_PBWR_MC1LMDP_REG               0x0000050C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Used to program the initial value for of the Pattern/LFSR Buffer in the Read comparison
    // domain. 
    // If the LFSR reload and save registrers are being used then this register will
    // not hold the initial value, but instead will hold the 
    // last saved value.
    // 
    // Bits[23:0], RW_V, default = 0xAAAAAA
    //
    UINTX patbuffer : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} CPGC_PATWDBCL_MUX0_PBWR_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDBCL_MUX1_PBWR_MC1LMDP_REG               0x00000510
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Used to program the initial value for of the Pattern/LFSR Buffer in the Read comparison
    // domain. 
    // If the LFSR reload and save registrers are being used then this register will
    // not hold the initial value, but instead will hold the 
    // last saved value.
    // 
    // Bits[23:0], RW_V, default = 0xCCCCCC
    //
    UINTX patbuffer : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} CPGC_PATWDBCL_MUX1_PBWR_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDBCL_MUX2_PBWR_MC1LMDP_REG               0x00000514
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Used to program the initial value for of the Pattern/LFSR Buffer in the Read comparison
    // domain. 
    // If the LFSR reload and save registrers are being used then this register will
    // not hold the initial value, but instead will hold the 
    // last saved value.
    // 
    // Bits[23:0], RW_V, default = 0xF0F0F0
    //
    UINTX patbuffer : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} CPGC_PATWDBCL_MUX2_PBWR_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDBCL_MUX0_PBRD_MC1LMDP_REG               0x00000518
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Used to program the initial value for of the Pattern/LFSR Buffer in the Read comparison
    // domain. 
    // If the LFSR reload and save registrers are being used then this register will
    // not hold the initial value, but instead will hold the 
    // last saved value.
    // 
    // Bits[23:0], RW_V, default = 0xAAAAAA
    //
    UINTX patbuffer : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} CPGC_PATWDBCL_MUX0_PBRD_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDBCL_MUX1_PBRD_MC1LMDP_REG               0x0000051C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Used to program the initial value for of the Pattern/LFSR Buffer in the Read comparison
    // domain. 
    // If the LFSR reload and save registrers are being used then this register will
    // not hold the initial value, but instead will hold the 
    // last saved value.
    // 
    // Bits[23:0], RW_V, default = 0xCCCCCC
    //
    UINTX patbuffer : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} CPGC_PATWDBCL_MUX1_PBRD_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDBCL_MUX2_PBRD_MC1LMDP_REG               0x00000520
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Used to program the initial value for of the Pattern/LFSR Buffer in the Read comparison
    // domain. 
    // If the LFSR reload and save registrers are being used then this register will
    // not hold the initial value, but instead will hold the 
    // last saved value.
    // 
    // Bits[23:0], RW_V, default = 0xF0F0F0
    //
    UINTX patbuffer : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} CPGC_PATWDBCL_MUX2_PBRD_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDB_INV_MC1LMDP_REG                       0x00000524
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each bit in ECC_Inv_or_DC_Enable corresponds to a specific ECC Lane.
    // When any bit is set this indicates that the selected data lane must be inverted
    // or drive a DC signal based on Data_INV_or_DC_Control. 
    // When Enable_Inv_or_DC_Rotate is set the Data_Inv_or_DC_Enable and ECC_Inv_or_DC_Enable
    // are considered one continuous shift register with 
    // Data_Inv_or_DC_Enable making up bits bits 0:63 and ECC_Inv_or_DC_Enable making
    // up bits 64:71 
    // Bit 0 of ECC_Inv_or_DC_Enable corresponds to ECC 0.
    // 
    // Bits[7:0], RW_LB, default = 0x0
    //
    UINTX eccinv_or_dcenb : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
    //
    // If Inv_or_DC_Shift_Rate is enabled then the Data_Inv_or_DC_Enable and ECC_Inv_or_DC_Enable
    // will be left shifted every time 2^(Inv_or_DC_Shift_Rate) 
    // cachelines are executed.
    // When a rotation happens
    // Bit 0 of Data_Inv_or_DC_Enable rotates into Bit 1 of Data_Inv_or_DC_Enable
    // Bit 63 of Data_Inv_or_DC_Enable rotates into Bit 0 of the ECC_Inv_or_DC_Enable
    // Bit 7 of ECC_Inv_or_DC_Enable rotates into Bit 0 of the Data_Inv_or_DC_Enable
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX invordc_shft_rate : 4;
    //
    // DC_Polarity_Control indicates whether the polarity of the DC signal driven when
    // Inv_or_DC_Control = 1 will be logic high or logic low. 
    // DC_Polarity_Control = 0 indicates a logic low will be driven.
    // DC_Polarity_Control = 1 indicates a logic high will be driven.
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX dc_polarity : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 9;
    //
    // Inv_or_DC_Control controls whether a Lane is inverted in polarity or a DC signal
    // will be driven out for any bits set in the ECC_Inv_or_DC_Enable 
    // and Lane_Inv_or_DC_Enable.
    // Inv_or_DC_Control = 0 indicates the selected lane will be inverted
    // Inv_or_DC_Control = 1 indicates the selected lane will drive a DC signal with
    // a logic value dictated by the DC_Polarity. 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX invordc_ctl : 1;
    //
    // When Inv_or_DC_Shift_Enable is set to 1 then the Data_Inv_or_DC_Enable and ECC_Inv_or_DC_Enable
    // will be left shifted 
    // every time 2^(Inv_or_DC_Shift_Rate) cachelines are executed.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX datainv_or_dcshftenb : 1;
  } Bits;
  UINTX Data;
} CPGC_PATWDB_INV_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDB_INV0_MC1LMDP_REG                      0x00000528
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each bit in Data_Inv_or_DC_Enable corresponds to a specific data Lane. [31:0]
    // When any bit is set this indicates that the selected data lane must be inverted
    // or drive a DC signal based on Data_INV_or_DC_Control. 
    // When Enable_Inv_or_DC_Rotate is set the Data_Inv_or_DC_Enable and ECC_Inv_or_DC_Enable
    // are considered one continuous shift register with 
    // Data_Inv_or_DC_Enable making up bits bits 0:63 and ECC_Inv_or_DC_Enable making
    // up bits 64:71 
    // Bit 0 of Data_Inv_or_DC_Enable corresponds to lane 0.
    // 
    // Bits[31:0], RW_LB, default = 0x0
    //
    UINTX datainv_or_dcenb : 32;
  } Bits;
  UINTX Data;
} CPGC_PATWDB_INV0_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDB_INV1_MC1LMDP_REG                      0x0000052C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each bit in Data_Inv_or_DC_Enable corresponds to a specific data Lane. [63:32]
    // When any bit is set this indicates that the selected data lane must be inverted
    // or drive a DC signal based on Data_INV_or_DC_Control. 
    // When Enable_Inv_or_DC_Rotate is set the Data_Inv_or_DC_Enable and ECC_Inv_or_DC_Enable
    // are considered one continuous shift register with 
    // Data_Inv_or_DC_Enable making up bits bits 0:63 and ECC_Inv_or_DC_Enable making
    // up bits 64:71 
    // Bit 0 of Data_Inv_or_DC_Enable corresponds to lane 0.
    // 
    // Bits[31:0], RW_LB, default = 0x0
    //
    UINTX datainv_or_dcenb : 32;
  } Bits;
  UINTX Data;
} CPGC_PATWDB_INV1_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDB_RDWR_PNTR_MC1LMDP_REG                 0x00000530
#ifndef ASM_INC
typedef union {
  struct {
    //
    // WDB_Read_Write_Pointer indicates what cacheline in the WDB that is being indexed
    // in the REUT_CH#_PAT_WDB_PROG#.WDB_Data 
    // registers for writing of the contents of the WDB (See WDB_Data for more details).
    // Programming sequence : write a value to
    // PAT_WDB_RD_WR_PNTR;write a value to
    // CPGC_PATWDB_WR0; write a value to
    // CPGC_PATWDB_WR1; at this point the 64-bit value
    // {CPGC_PATWDB_WR1, CPGC_PATWDB_WR0} will be
    // transfered to the chunk Rdwr_Subpntr of
    // WDB_entry rdwr_pntr. Rdwr_subpntr will be
    // auto_incremented after each transfer like this
    // and rdwr_pntr will be auto_incremented after all
    // 8 chunks of a cacheline have been updated.
    // 
    // Bits[5:0], RW_V, default = 0x0
    //
    UINTX rdwr_pntr : 6;
    //
    // WDB_Read_Write_Sub_Pointer indicates what portion of a cacheline(64-bits) in the
    // WDB that is being indexed in the 
    // REUT_CH#_PAT_WDB_READ.WDB_Data and REUT_CH#_PAT_WDB_WRITE.WDB_Data registers for
    // writing of the contents of the WDB. 
    // 
    // Bits[8:6], RW_V, default = 0x0
    //
    UINTX rdwr_subpntr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
  } Bits;
  UINTX Data;
} CPGC_PATWDB_RDWR_PNTR_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDBCL_MUXCTL_MC1LMDP_REG                  0x00000534
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0x00 = Select LMN counter
    // 0x01 = Select 24 bit buffer
    // 0x10 = Select LFSR24
    // 0x11 = Reserved
    // 
    // Bits[1:0], RW_LB, default = 0x1
    //
    UINTX mux0 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 0x00 = Reserved
    // 0x01 = Select 24 bit buffer
    // 0x10 = Select LFSR24
    // 0x11 = Reserved
    // 
    // Bits[4:3], RW_LB, default = 0x1
    //
    UINTX mux1 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 0x00 = Reserved
    // 0x01 = Select 24 bit buffer
    // 0x10 = Select LFSR24
    // 0x11 = Reserved
    // 
    // Bits[7:6], RW_LB, default = 0x1
    //
    UINTX mux2 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 6;
    //
    // ecc_replace_byte will allow the capture ECC cacheline errors into the WDB when
    // Enable_WDB_Error_Capture is set to 1. 
    // ecc_replace_byte is used by the Read data path to Mux the received ECC byte into
    // the same byte group indicated by ecc_datasrc_sel. 
    // If ecc_replace_byte is set to 0 then ECC XOR data (expected vs. received) will
    // never be captured in the WDB. 
    // If ecc_replace_byte is set to 1 then ECC XOR data (expected vs. received) will
    // replace the XOR results of a selected data group 
    // (indicated by ecc_datasrc_sel) when cacheline errors are written into the WDB.
    // 
    // Bits[14:14], RW_LB, default = 0x1
    //
    UINTX ecc_replace_byte : 1;
    //
    // Indicates whether byte 0 (Dq0-Dq7) or byte 7 (dq56-dq63) is transmitted and compared
    // for the ECC byte. 
    // 0= byte group 0 will be transmitted and compared for the ECC byte.
    // 1= byte group 7 will be transmitted and compared for the ECC byte.
    // Hardware directs if ECC is included within Generation and Checking.
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX ecc_datasrc_sel : 1;
    //
    // save_lfsr_seedrate * ^(rld_lfsr_seedrate-1) defines the periodic cacheline interval
    // that the current LFSR value REUT#_CH#_PAT_CL_MUX#_PB_STATUS 
    // is saved into the REUT#_CH#_PAT_CL_MUX#_PB register.
    // When the save_lfsr_seedrate and rld_lfsr_seedrate is reached in the same cycle
    // only the saving of the LFSR seed takes place. 
    // Examples:
    // 0 = Disable - the REUT#_CH#_PAT_CL_MUX#_PB_STATUS is never saved into the REUT#_CH#_PAT_CL_MUX#_PB
    // register. 
    // 1 = The REUT#_CH#_PAT_CL_MUX#_PB_STATUS is saved into the REUT#_CH#_PAT_CL_MUX#_PB
    // register every 2^(Reload_LFSR_Seed_Rate-1) cachelines. 
    // 2 = The REUT#_CH#_PAT_CL_MUX#_PB_STATUS is saved into the REUT#_CH#_PAT_CL_MUX#_PB
    // register every other 2^(Reload_LFSR_Seed_Rate-1) cachelines. 
    // 3 = The REUT#_CH#_PAT_CL_MUX#_PB_STATUS is saved into the REUT#_CH#_PAT_CL_MUX#_PB
    // register every fourth 2^(Reload_LFSR_Seed_Rate-1) cachelines. 
    // 
    // Bits[21:16], RW_LB, default = 0x0
    //
    UINTX save_lfsr_seedrate : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
    //
    // 2^(rld_lfsr_seedrate-1) defines the periodic cacheline interval that the current
    // LFSR Seed is reloaded from REUT#_CH#_PAT_CL_MUX#_PB. 
    // When the save_lfsr_seedrate and rld_lfsr_seedrate is reached in the same cycle
    // only the saving of the LFSR seed takes place. 
    // Examples:
    // 0 = Disable - the REUT#_CH#_PAT_CL_MUX#_PB_STATUS is never reloaded into the REUT#_CH#_PAT_CL_MUX#_PB
    // register. 
    // 1 = The LFSR seed is reloaded every cacheline operation from REUT#_CH#_PAT_CL_MUX#_PB.
    // 2 = The LFSR seed is reloaded every other cacheline operation from REUT#_CH#_PAT_CL_MUX#_PB
    // 3 = The LFSR seed is reloaded every fourth cacheline operation from REUT#_CH#_PAT_CL_MUX#_PB
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX rld_lfsr_seedrate : 3;
    //
    // Set this bit fr CPGC training or DIMM testing under VMSE 2:1 LFSR mode. This bit
    // will allow the LFSR to generate 
    // 4 LFSR codes per DCLK. The default mode is 2 codes per DCLK. The default mode
    // is used in native mode and VMSE 1:1 
    // modes.
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX cpgc_lfsr_2code_mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 4;
  } Bits;
  UINTX Data;
} CPGC_PATWDBCL_MUXCTL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDBCLMUX0_PBSTS_WR_MC1LMDP_REG            0x00000538
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current Status of the Pattern/LFSR Buffer in the Write domain.
    // 
    // Bits[23:0], RO_V, default = 0x0
    //
    UINTX patbuffer : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} CPGC_PATWDBCLMUX0_PBSTS_WR_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDBCLMUX1_PBSTS_WR_MC1LMDP_REG            0x0000053C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current Status of the Pattern/LFSR Buffer in the Write domain.
    // 
    // Bits[23:0], RO_V, default = 0x0
    //
    UINTX patbuffer : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} CPGC_PATWDBCLMUX1_PBSTS_WR_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDBCLMUX2_PBSTS_WR_MC1LMDP_REG            0x00000540
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current Status of the Pattern/LFSR Buffer in the Write domain.
    // 
    // Bits[23:0], RO_V, default = 0x0
    //
    UINTX patbuffer : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} CPGC_PATWDBCLMUX2_PBSTS_WR_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDBCLMUX0_PBSTS_RD_MC1LMDP_REG            0x00000544
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current Status of the Pattern/LFSR Buffer in the Read comparison domain.
    // 
    // Bits[23:0], RO_V, default = 0x0
    //
    UINTX patbuffer : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} CPGC_PATWDBCLMUX0_PBSTS_RD_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDBCLMUX1_PBSTS_RD_MC1LMDP_REG            0x00000548
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current Status of the Pattern/LFSR Buffer in the Read comparison domain.
    // 
    // Bits[23:0], RO_V, default = 0x0
    //
    UINTX patbuffer : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} CPGC_PATWDBCLMUX1_PBSTS_RD_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDBCLMUX2_PBSTS_RD_MC1LMDP_REG            0x0000054C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current Status of the Pattern/LFSR Buffer in the Read comparison domain.
    // 
    // Bits[23:0], RO_V, default = 0x0
    //
    UINTX patbuffer : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} CPGC_PATWDBCLMUX2_PBSTS_RD_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDB_WR0_MC1LMDP_REG                       0x00000550
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Writes can only happen while in Loopback.Marker (Test Done is set) or (Enable_WDB_Error_Capture
    // is not set while in Loopback.Pattern). 
    // 
    // Bits[31:0], RW_LB, default = 0x0
    //
    UINTX wdb_data : 32;
  } Bits;
  UINTX Data;
} CPGC_PATWDB_WR0_MC1LMDP_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDB_WR1_MC1LMDP_REG                       0x00000554
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Writes can only happen while in Loopback.Marker (Test Done is set) or (Enable_WDB_Error_Capture
    // is not set while in Loopback.Pattern). 
    // 
    // Bits[31:0], RW_LB, default = 0x0
    //
    UINTX wdb_data : 32;
  } Bits;
  UINTX Data;
} CPGC_PATWDB_WR1_MC1LMDP_STRUCT;
#endif // ASM_INC

#define ADDDC_ERR_INJ_MC1LMDP_REG                         0x00000750
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                     This field specifies the error injection to device in primary
    // half of CL for mask0. 
    //                 
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX primary0 : 1;
    //
    // 
    //                     This field specifies the error injection to device in buddy
    // half of CL for mask0. 
    //                 
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX buddy0 : 1;
    //
    // 
    //                     This field specifies the error injection to device in primary
    // half of CL for mask1. 
    //                 
    // 
    // Bits[2:2], RW_LB, default = 0x0
    //
    UINTX primary1 : 1;
    //
    // 
    //                     This field specifies the error injection to device in buddy
    // half of CL for mask1. 
    //                 
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX buddy1 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
  } Bits;
  UINTX Data;
} ADDDC_ERR_INJ_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_ERROR_MC1LMDP_REG                            0x00000308
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The maximum delay (in DCLKs) between a command or data with an error and the observed
    // assertion of VMSE_ERR#. 
    // 
    // Bits[6:0], RWS_L, default = 0x20
    //
    UINTX vmse_err_latency : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 25;
  } Bits;
  UINTX Data;
} VMSE_ERROR_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_CFG_READ_1_MC1LMDP_REG                       0x00000324
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bits used to enable bug fixes.
    // Bit 0: Set to 1 only when running 2N mode under Intel SMI 2. This bit should not
    // be set 
    // for native mode or when MC is running Intel SMI 2 in 1N or 3N mode.
    // Bit 1: Set to 1 only when running 3N mode under Intel SMI 2. This bit should not
    // be set 
    // for native mode or when MC is running Intel SMI 2 in 1N or 2N mode.
    // Bit 2: If this bit is set to 1 then the MC will issue a Training Reset to DDRIO
    // after the Intel SMI 2 Error FSM issues a channel reset. This bit should be set
    // to 1 
    // when Intel SMI 2 is runnning in 2N or 3N mode.
    // Bit 3: Set this bit to to 1 monitor MA[15] instead of MC[14] on OCLA
    // bus OCLA_DPRD0_VMSE_SCH0_ENC_IN
    // Bit 4: Set this bit to to 1 monitor MA[15] instead of MC[14] on OCLA
    // bus OCLA_DPRD2_VMSE_SCH1_ENC_IN
    // Bit 5: Set to 1 only when running 2N mode under Intel SMI 2. This bit should not
    // be set 
    // for native mode or when MC is running Intel SMI 2 in 1N or 3N mode.
    // Bit 6: Set to 1 only when running 3N mode under Intel SMI 2. This bit should not
    // be set 
    // for native mode or when MC is running Intel SMI 2 in 1N or 2N mode.
    // Bit 7: Set to 1 to ignore patrol and spare fsm idle in DDR4 mode to exit DRAIN_RD
    // state 
    // for error flow
    // Bits [25:8] are unused and should be left at 0
    // Bit 26: to disable usage of sub device for handling DUE during sparing 
    // Bit 27: disable 1LM column correction
    // Bit 28: force the correction datapath for all transactions when set 1
    // Bit 29: Disable RRD RCB clock gating when set 1
    // Bit 30: Disable WDB RCB clock gating when set 1
    // Bit 31: Disable RT RCB clock gating when set 1
    //         
    // 
    // Bits[31:0], RW_LB, default = 0x0
    //
    UINTX read_data : 32;
  } Bits;
  UINTX Data;
} VMSE_CFG_READ_1_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDR4_CA_CTL_MC1LMDP_REG                           0x000003FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This should be set to 1 to enable error flow
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX erf_en0 : 1;
    //
    // This should be set to 1 if RDIMM/LRDIMMs are populated in the channel
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX erf_regpart0 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // largest ( tPAR_ALERT_ON + tPAR_ALERT_PW ) value of a rank populated in the channel
    // in DCLK. 
    // 
    // Bits[11:4], RW_LB, default = 0x0
    //
    UINTX tpar_recov_ch0 : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 20;
  } Bits;
  UINTX Data;
} DDR4_CA_CTL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_RETRY_SB_ERR_COUNT_MC1LMDP_REG               0x00000400
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Count of transient errors on the Intel SMI 2 Command/Address bus.
    // Cleared by hardware when the vmse_retry_sb_err_limit.sb_err_limit is reached and
    // persistent_err_cnt is incremented. 
    // Cleared by hardware when the vmse_retry_timer.sb_err_observation_time timer expires.
    // 
    // Bits[15:0], RO_V, default = 0x0
    //
    UINTX transient_err_cnt : 16;
    //
    // Count of persistent errors on the Intel SMI 2 Command/Address bus and Write Data
    // Bus errors. 
    // Counter saturates at 0xff.
    // 
    // Bits[23:16], RO_V, default = 0x0
    //
    UINTX persistent_err_cnt : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} VMSE_RETRY_SB_ERR_COUNT_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_RETRY_TIMER2_MC1LMDP_REG                     0x00000404
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Train reset duration.
    // 
    // Bits[7:0], RWS_L, default = 0xFF
    //
    UINTX train_reset_time : 8;
    //
    // Wait time in completion state (SUCCESS or FAILURE).
    // 
    // Bits[14:8], RWS_L, default = 0x7F
    //
    UINTX retry_cmpl_time : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 17;
  } Bits;
  UINTX Data;
} VMSE_RETRY_TIMER2_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_RETRY_ERR_LIMITS_MC1LMDP_REG                 0x0000040C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
    //
    // Number of Intel SMI 2 Cmd/Addr and Write Data transient errors (vmse_retry_sb_err_count.transient_err_cnt)
    // allowed before the SB error is declared persistent. 
    // The persistent error will trigger a link width change.
    // 
    // Bits[30:16], RWS_L, default = 0x10
    //
    UINTX sb_err_limit : 15;
    //
    // Enable NB persistent condition.
    // 
    // Bits[31:31], RWS_L, default = 0x0
    //
    UINTX sb_err_enable : 1;
  } Bits;
  UINTX Data;
} VMSE_RETRY_ERR_LIMITS_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_RETRY_TIMER_MC1LMDP_REG                      0x00000410
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Holds the 'tick' amount (specified in DCLKs) for the error observation window
    // timers. 
    // 
    // Bits[9:0], RWS_L, default = 0x0
    //
    UINTX vmse_err_flow_time_unit : 10;
    //
    // Enable the tick timer.
    // 
    // Bits[10:10], RWS_L, default = 0x1
    //
    UINTX tick_timer_en : 1;
    //
    // Error observation window (in units of vmse_err_flow_time_unit * 2^sb_err_observation_time)
    // during which Intel SMI 2 Command and SB Data transient errors are counted. 
    // 
    // Bits[15:11], RWS_L, default = 0x0
    //
    UINTX sb_err_observation_time : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
    //
    // Error observation window (in units of vmse_err_flow_time_unit * 2^link_fail_observation_time)
    // during which link fail events are counted. 
    // 
    // Bits[30:26], RWS_L, default = 0x0
    //
    UINTX link_fail_observation_time : 5;
    //
    // Hardware resets the SB and NB error transient and persistent counters as well
    // as the link fail 
    // counters when this bit changes from a 0 to 1.
    // 
    // Bits[31:31], RW_LB, default = 0x1
    //
    UINTX reset_verr_err_cnt : 1;
  } Bits;
  UINTX Data;
} VMSE_RETRY_TIMER_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_LINK_FAIL_MC1LMDP_REG                        0x00000414
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Count of persistent southbound errors observed.
    // 
    // Bits[7:0], RWS_V, default = 0x0
    //
    UINTX fail_count : 8;
    //
    // Threshold of vmse_link_fail.fail_count for which the link will go to the "Link
    // fail" state. 
    // fail_threshold = 0 means the first persistent failure in the "Half Width C - SB"
    // state will cause "Link Fail". 
    // 
    // Bits[15:8], RWS_L, default = 0x1
    //
    UINTX fail_threshold : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} VMSE_LINK_FAIL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_ERR_FSM_STATE_MC1LMDP_REG                    0x00000420
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The current state of the Intel SMI 2 Error flow FSM.
    // 
    // Bits[3:0], RO_V, default = 0x0
    //
    UINTX current_state : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 12;
    //
    // The state of the Intel SMI 2 Error flow FSM before the current state.
    // 
    // Bits[19:16], RO_V, default = 0x0
    //
    UINTX previous_state : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} VMSE_ERR_FSM_STATE_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_CMD_ERR_INJ_CTL_MC1LMDP_REG                  0x00000600
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field represents Bits [33:32] of the 34b Command error injection XOR mask
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX mask : 2;
    //
    // Command type to match for injection, even channel
    // 
    // Bits[6:2], RW_LB, default = 0x0
    //
    UINTX cmd_type_even : 5;
    //
    // Command type to match for injection, odd channel
    // 
    // Bits[11:7], RW_LB, default = 0x0
    //
    UINTX cmd_type_odd : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
    //
    // Fire a debug trigger error on next command that matches cmd_type_odd in odd channel
    // (0 or 2 depending on which Intel SMI 2 bus), hardware will clear after injection
    // 
    // Bits[28:28], RW_LBV, default = 0x0
    //
    UINTX dbg_trigger_odd_chnl : 1;
    //
    // Fire a debug trigger error on next command that matches cmd_type_even in even
    // channel (0 or 2 depending on which Intel SMI 2 bus), hardware will clear after
    // injection 
    // 
    // Bits[29:29], RW_LBV, default = 0x0
    //
    UINTX dbg_trigger_even_chnl : 1;
    //
    // Inject error on next command that matches cmd_type_even in even channel (0 or
    // 2 depending on which Intel SMI 2 bus), hardware will clear after injection 
    // 
    // Bits[30:30], RW_LBV, default = 0x0
    //
    UINTX inj_even_chnl : 1;
    //
    // Inject error on next command that matches cmd_type_odd in odd channel (1 or 3
    // depending on which Intel SMI 2 bus), hardware will clear after injection 
    // 
    // Bits[31:31], RW_LBV, default = 0x0
    //
    UINTX inj_odd_chnl : 1;
  } Bits;
  UINTX Data;
} VMSE_CMD_ERR_INJ_CTL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_CMD_ERR_INJ_CTL_LO_MC1LMDP_REG               0x00000604
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field represents Bits [31:0] of the 34b Command error injection XOR mask.
    // Field 
    // 
    // Bits[31:0], RW_LB, default = 0x0
    //
    UINTX mask : 32;
  } Bits;
  UINTX Data;
} VMSE_CMD_ERR_INJ_CTL_LO_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDDC_CNTL_0_MC1LMDP_REG                           0x00000608
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Hardware will capture the fail device ID on a correctable error until EN field
    // has been set, after which hardware may no longer update. Any further fail device
    // ID will be captured in DEVTAG_CNTL. Valid range is 0-35 decimal. Above 35 means
    // no device failure has occurred on this rank. 
    // Device ID mapping:
    // 35: Parity
    // 34: Spare
    // 33-18: Data
    // 17: CRC
    // 16: CRC
    // 15-0: Data
    // 
    // Bits[5:0], RWS_V, default = 0x3F
    //
    UINTX faildevice : 6;
    //
    // This field will be set by BIOS before the DDDC sparing flow begins to indicate
    // that this rank is currently in the sparing flow. The field is cleared by hardware
    // at the completion of DDDC sparing. SPARING and EN shall be mutually exclusive.
    // 
    // Bits[6:6], RWS_L, default = 0x0
    //
    UINTX sparing : 1;
    //
    // DDDC enable for this rank. When set, this rank will use the device mapping specified
    // by FAILDEVICE. This field is written by hardware at the completion of DDDC sparing.
    // SPARING and EN shall be mutually exclusive. 
    // 
    // Bits[7:7], RWS_L, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} DDDC_CNTL_0_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDDC_CNTL_1_MC1LMDP_REG                           0x00000609
#ifndef ASM_INC
typedef union {
  struct {
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[5:0], RWS_V, default = 0x3F
    //
    UINTX faildevice : 6;
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[6:6], RWS_L, default = 0x0
    //
    UINTX sparing : 1;
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[7:7], RWS_L, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} DDDC_CNTL_1_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDDC_CNTL_2_MC1LMDP_REG                           0x0000060A
#ifndef ASM_INC
typedef union {
  struct {
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[5:0], RWS_V, default = 0x3F
    //
    UINTX faildevice : 6;
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[6:6], RWS_L, default = 0x0
    //
    UINTX sparing : 1;
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[7:7], RWS_L, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} DDDC_CNTL_2_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDDC_CNTL_3_MC1LMDP_REG                           0x0000060B
#ifndef ASM_INC
typedef union {
  struct {
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[5:0], RWS_V, default = 0x3F
    //
    UINTX faildevice : 6;
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[6:6], RWS_L, default = 0x0
    //
    UINTX sparing : 1;
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[7:7], RWS_L, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} DDDC_CNTL_3_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDDC_CNTL_4_MC1LMDP_REG                           0x0000060C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[5:0], RWS_V, default = 0x3F
    //
    UINTX faildevice : 6;
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[6:6], RWS_L, default = 0x0
    //
    UINTX sparing : 1;
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[7:7], RWS_L, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} DDDC_CNTL_4_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDDC_CNTL_5_MC1LMDP_REG                           0x0000060D
#ifndef ASM_INC
typedef union {
  struct {
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[5:0], RWS_V, default = 0x3F
    //
    UINTX faildevice : 6;
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[6:6], RWS_L, default = 0x0
    //
    UINTX sparing : 1;
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[7:7], RWS_L, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} DDDC_CNTL_5_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDDC_CNTL_6_MC1LMDP_REG                           0x0000060E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[5:0], RWS_V, default = 0x3F
    //
    UINTX faildevice : 6;
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[6:6], RWS_L, default = 0x0
    //
    UINTX sparing : 1;
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[7:7], RWS_L, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} DDDC_CNTL_6_MC1LMDP_STRUCT;
#endif // ASM_INC

#define DDDC_CNTL_7_MC1LMDP_REG                           0x0000060F
#ifndef ASM_INC
typedef union {
  struct {
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[5:0], RWS_V, default = 0x3F
    //
    UINTX faildevice : 6;
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[6:6], RWS_L, default = 0x0
    //
    UINTX sparing : 1;
    //
    // See DDDC_CNTL_0 for description.
    // 
    // Bits[7:7], RWS_L, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} DDDC_CNTL_7_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_PC6_CNTL_0_MC1LMDP_REG                       0x00000620
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Minimum duration to wait for scalable memory buffers to put DRAM into self refresh
    // during scalable memory buffers clock stop enter process; in unit of dclk 
    // 
    // Bits[8:0], RWS_L, default = 0xFF
    //
    UINTX self_refresh_enter : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
    //
    // Time to wait after issuing sync command and before issuing scrambler sync command
    // during scalable memory buffers clock stop exit process; in unit of dclk 
    // 
    // Bits[24:16], RW_LB, default = 0x28
    //
    UINTX sync_wait : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // When this bit is set to 0, during Pkg C6, output clock is not disabled.
    // 
    // Bits[26:26], RW_LB, default = 0x1
    //
    UINTX pc6_dis_clk : 1;
    //
    // Hardware will inject the scalable memory buffers Clock Stop power down flow in
    // the 
    // MC when it detects a 0 to 1 transition on this bit.
    // Note that this bit controls only to the scalable memory buffers clock stop inside
    // the 
    // MC and none of the other actions initiated by the PCU PC6 flow are
    // initiated.
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX sw_inj_pc6_mxb_clkstp : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Criteria for entering Clock Stop mode.
    // Expectation is that this will always be 2.
    // 
    // Bits[30:29], RWS_L, default = 0x2
    //
    UINTX enter_pc6_cfg : 2;
    //
    // Disable Clock Stop function during PC6
    // 
    // Bits[31:31], RWS_L, default = 0x1
    //
    UINTX disble_vmse_pc6 : 1;
  } Bits;
  UINTX Data;
} VMSE_PC6_CNTL_0_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_PC6_CNTL_1_MC1LMDP_REG                       0x00000624
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Duration to issue NOPs, after issue Clock Stop command before disable scrambler
    // during scalable memory buffers clock stop enter process; in unit of dclk 
    // 
    // Bits[8:0], RWS_L, default = 0xFF
    //
    UINTX clk_stp_nop_duration : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
    //
    // Minimum duration for scalable memory buffers to enter Clock Stop; this counting
    // starts after all output buffers are disabled; in unit of dclk 
    // 
    // Bits[24:16], RWS_L, default = 0x28
    //
    UINTX clk_stp_duration : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 7;
  } Bits;
  UINTX Data;
} VMSE_PC6_CNTL_1_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_PC6_CNTL_2_MC1LMDP_REG                       0x00000628
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Duration to wait for DLL/PLL to be enabled before exit Clock Stop during scalable
    // memory buffers clock stop exit process; in unit of dclk 
    // 
    // Bits[8:0], RWS_L, default = 0xFF
    //
    UINTX en_dll_duration : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Time to wait for scrambler sync response starting from issuing a scrambler sync
    // command during scalable memory buffers clock stop exit process; in unit of dclk
    // 
    // Bits[18:10], RWS_L, default = 0x1FF
    //
    UINTX scr_sync_resp : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Duration to wait for DLL/PLL to be disabled after scalable memory buffers enters
    // Clock Stop during scalable memory buffers clock stop enter process; in unit of
    // dclk 
    // 
    // Bits[28:20], RWS_L, default = 0xFF
    //
    UINTX dis_dll_duration : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
  } Bits;
  UINTX Data;
} VMSE_PC6_CNTL_2_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_PC6_CNTL_3_MC1LMDP_REG                       0x0000062C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Duration to drive NOPs after asserting Intel SMI 2 Exit Lane during scalable memory
    // buffers clock stop exit process; in unit of dclk 
    // 
    // Bits[8:0], RWS_L, default = 0xC0
    //
    UINTX nop_duration : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Duration to assert Intel SMI 2 Exit Lane during scalable memory buffers clock
    // stop exit process; in unit of dclk 
    // 
    // Bits[18:10], RWS_L, default = 0x40
    //
    UINTX assert_exln_duration : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Duration to wait before command is stable at MXB; this is the time from deasserting
    // PARK1 signal to the time asserting exit lane; in unit of dclk 
    // 
    // Bits[28:20], RWS_L, default = 0xFF
    //
    UINTX mxb_stbl : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
  } Bits;
  UINTX Data;
} VMSE_PC6_CNTL_3_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_PC6_FSM_STATE_MC1LMDP_REG                    0x00000630
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The current state of the Intel SMI 2 scalable memory buffers clock stop flow FSM.
    // 
    // Bits[4:0], RO_V, default = 0x0
    //
    UINTX current_state : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 11;
    //
    // The state of the Intel SMI 2 scalable memory buffers clock stop flow FSM before
    // the current state. 
    // 
    // Bits[20:16], RO_V, default = 0x0
    //
    UINTX previous_state : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 11;
  } Bits;
  UINTX Data;
} VMSE_PC6_FSM_STATE_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MCDP_RCB_GATE_CTL_MC1LMDP_REG                     0x00000634
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Time clock keeps running after triggering events
    // 
    // Bits[9:0], RW_LB, default = 0x40
    //
    UINTX rcb_gate_mcdp_timer : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 22;
  } Bits;
  UINTX Data;
} MCDP_RCB_GATE_CTL_MC1LMDP_STRUCT;
#endif // ASM_INC

#define MC0_DP_CHKN_BIT_MC1LMDP_REG                       0x00000700
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Disable ECC checking
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX dis_ecc_chk : 1;
    //
    // Disable rdimm par check
    // 
    // Bits[1:1], RW_LB, default = 0x1
    //
    UINTX dis_rdimm_par_chk : 1;
    //
    // Disable HA par check
    // 
    // Bits[2:2], RW_LB, default = 0x0
    //
    UINTX dis_ha_par_chk : 1;
    //
    // Disable HA par gen
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX dis_ha_par_gen : 1;
    //
    // Switch Qclk for scan data
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX sw_qck_for_scn_data : 1;
    //
    // Force odd cycle RT delay
    // 
    // Bits[5:5], RW_LB, default = 0x0
    //
    UINTX frc_odd_cyc_rt_dly : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Disable error detection for partial write underfills
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX dis_err_det_prtl_wr_underfl : 1;
    //
    // Override training rank output to IO
    // 
    // Bits[8:8], RW_LB, default = 0x0
    //
    UINTX ovrd_trng_rank_to_io : 1;
    //
    // Error signaling to Home Agent when MC sees poison line and applies correction
    // trials during retry. 
    // 1: sending both poison and error indication (for poison line and correction trials).
    // 0: Don't send error indication for poison line when correction trials were applied.
    // Only assert poison. This behavior is necessary to correctly deal with poison lines
    // (in poison mode) under vmse error flows or under channel mirroring flows. 
    // Value of this bit is only relevant when in poison mode.
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX ena_err_when_poison : 1;
    //
    // Disable clock gating - read and write data path
    // 
    // Bits[10:10], RW_LB, default = 0x0
    //
    UINTX dis_ck_gate_dp : 1;
    //
    // Select training rank to be rank 0; not used yet
    // 
    // Bits[11:11], RW_LB, default = 0x0
    //
    UINTX sel_rank0_training : 1;
    //
    // Configure Err return to HA one cycle late
    // 
    // Bits[12:12], RW_LB, default = 0x0
    //
    UINTX cfglateerr : 1;
    //
    // Always force Receive enable to be on
    // 
    // Bits[13:13], RW_LB, default = 0x0
    //
    UINTX mcforcercvend3nnh : 1;
    //
    // Use one Qclk late for iscan read fifo read enable
    // 
    // Bits[14:14], RW_LB, default = 0x0
    //
    UINTX uselateqclkrfrdnnn : 1;
    //
    // Downgrades patrol scrubbing uncorrectable errors to correactable.
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX ign_ptrl_uc : 1;
    //
    // When set to 1, disables the MCA regular override mechanism and keeps current logs
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX ign_mca_ovrd : 1;
    //
    // When set to 1, Logs the error device from second codeword in a cacheline access
    // if both codewords are in error. By default, MC logs the first codeword device
    // as the failing device in a cacheline (because there are two code words in each
    // cacheline). 
    // 
    // Bits[17:17], RW_LB, default = 0x0
    //
    UINTX log_sec_err_dev : 1;
    //
    // Enables logging of uncorrectable read errors to MCA banks. When this field is
    // set to 1 along with en_corr_rd_err_log, MC is in mode-2 
    // 
    // Bits[18:18], RW_LB, default = 0x0
    //
    UINTX en_uc_err_log : 1;
    //
    // Enables logging of correctable read errors to MCA banks. When set to 1, this puts
    // MC in mode-1. 
    // 
    // Bits[19:19], RW_LB, default = 0x0
    //
    UINTX en_corr_err_log : 1;
    //
    // Disable Write Data Buffer parity checking
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX dis_wdb_par_chk : 1;
    //
    // Disable spare device directory storage.
    // 
    // Bits[21:21], RW_LB, default = 0x0
    //
    UINTX dis_spare_dir : 1;
    //
    // Set to 1 to avoid CE to override CE in MCA banks.
    // 
    // Bits[22:22], RW_LB, default = 0x0
    //
    UINTX no_over_ce : 1;
    //
    // Disable Intel SMI 2 Link Fail state. If this bit is state the Intel SMI 2 Error
    // FSM will never enter link 
    // fail state.
    // 
    // Bits[23:23], RW_LB, default = 0x0
    //
    UINTX dis_vmse_link_fail : 1;
    //
    // Enable RDIMM parity error logging.
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX en_rdimm_par_err_log : 1;
    //
    // Disable poison detection in the RRD.
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX dis_rrd_psn : 1;
    //
    // Set to 1 to disable ECC trials. The disable goes through the Intel SMI 2 Error
    // FSM and can be 
    // used only in Intel SMI 2 mode. The bit has not affect in native DDR3 mode.
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX dis_verr_ecc_trials : 1;
    //
    // Disable Intel SMI 2 NB half width mode
    // 
    // Bits[27:27], RW_LB, default = 0x1
    //
    UINTX dis_vmse_nb_hw : 1;
    //
    // Disable Intel SMI 2 SB half width mode
    // 
    // Bits[28:28], RW_LB, default = 0x0
    //
    UINTX dis_vmse_sb_hw : 1;
    //
    // Disable scrambling during Intel SMI 2 retry
    // 
    // Bits[29:29], RW_LB, default = 0x1
    //
    UINTX dis_verr_scramsync : 1;
    //
    // Disable Intel SMI 2 data scrambling
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX dis_vmse_data_scram : 1;
    //
    // Disable Intel SMI 2 command scrambling
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX dis_vmse_cmd_scram : 1;
  } Bits;
  UINTX Data;
} MC0_DP_CHKN_BIT_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_LFSR_SEED_RX_MC1LMDP_REG                     0x00000708
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[15:0], RW_LB, default = 0x4C7
    //
    UINTX ch02 : 16;
    //
    // N/A
    // 
    // Bits[31:16], RW_LB, default = 0x98E
    //
    UINTX ch13 : 16;
  } Bits;
  UINTX Data;
} VMSE_LFSR_SEED_RX_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_LFSR_SEED_TX_MC1LMDP_REG                     0x0000070C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[15:0], RW_LB, default = 0xFFFF
    //
    UINTX ch02 : 16;
    //
    // N/A
    // 
    // Bits[31:16], RW_LB, default = 0xEE37
    //
    UINTX ch13 : 16;
  } Bits;
  UINTX Data;
} VMSE_LFSR_SEED_TX_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_LFSR_SEED_CMD_MC1LMDP_REG                    0x00000710
#ifndef ASM_INC
typedef union {
  struct {
    //
    // LFSR seed for channel 0 or 2 Intel SMI 2 cmd
    // 
    // Bits[15:0], RW_LB, default = 0xFFFF
    //
    UINTX ch02 : 16;
    //
    // LFSR seed for channel 1 or 3 Intel SMI 2 cmd, unused in Intel SMI 2 1:1
    // 
    // Bits[31:16], RW_LB, default = 0xCDA7
    //
    UINTX ch13 : 16;
  } Bits;
  UINTX Data;
} VMSE_LFSR_SEED_CMD_MC1LMDP_STRUCT;
#endif // ASM_INC

#define VMSE_ERR_FSM_TRIGGER_CTL_MC1LMDP_REG              0x00000714
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Generate the Intel SMI 2 Error FSM PMON event if any of the programmed triggers
    // occur. 
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX ctl_enable_pmon : 1;
    //
    // Generate the Intel SMI 2 Error FSM trigger event if any of the programmed triggers
    // occur. 
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX ctl_enable_trigger : 1;
    //
    // Spare trigger control. Unused.
    // 
    // Bits[2:2], RW_LB, default = 0x0
    //
    UINTX trigger_spare : 1;
    //
    // Trigger if a NB persistent event is seen.
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX trigger_nb_pers_lmt : 1;
    //
    // Trigger if a SB persistent event is seen.
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX trigger_sb_pers_lmt : 1;
    //
    // Trigger if a NB persistent errors hit the NB uncorrectable limit.
    // 
    // Bits[5:5], RW_LB, default = 0x0
    //
    UINTX trigger_nb_uncorr_lmt : 1;
    //
    // Trigger if a SB persistent errors hit the SB uncorrectable limit.
    // 
    // Bits[6:6], RW_LB, default = 0x0
    //
    UINTX trigger_sb_uncorr_lmt : 1;
    //
    // Trigger if Intel SMI 2 Error FSM sees a NB transient error
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX trigger_nb_trns_err : 1;
    //
    // Trigger if Intel SMI 2 Error FSM sees a SB transient error
    // 
    // Bits[8:8], RW_LB, default = 0x0
    //
    UINTX trigger_sb_trns_err : 1;
    //
    // Trigger if a Intel SMI 2 error is injected by the MC
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX trigger_inj_vmse_err : 1;
    //
    // Trigger if the Intel SMI 2 Error FSM enter a specific state of the Intel SMI 2
    // error FSM. 
    // trigger_vmse_state_1 and trigger_vmse_state_2 provide the ability to trigger on
    // two different states. The encoding for the states is shown below. Since encoding
    // of 0b1000 is unused, the field must be programmed to 0x8 to disable matching
    // with the IDLE state.
    // IDLE : 0000
    // DRAIN_RD : 0010
    // DRAIN_WR_INIT : 0011
    // RESTART : 0100
    // WAKE_DRAM : 0101
    // DRAIN_WR : 0110
    // POST_DRAIN_WR : 0111
    // LINK_FAIL : 1001
    // TRIAL : 1010
    // SCRAMBLE_SYNC : 1011
    // SUCCESS : 1101
    // FAILURE : 1111
    // 
    // Bits[13:10], RW_LB, default = 0x8
    //
    UINTX trigger_vmse_state_1 : 4;
    //
    // Trigger if the Intel SMI 2 Error FSM enter a specific state of the Intel SMI 2
    // error FSM. 
    // trigger_vmse_state_1 and trigger_vmse_state_2 provide the ability to trigger on
    // two different states. The encoding for the states is shown below. Since encoding
    // of 0b1000 is unused, the field must be programmed to 0x8 to disable matching
    // with the IDLE state.
    // IDLE : 0000
    // DRAIN_RD : 0010
    // DRAIN_WR_INIT : 0011
    // RESTART : 0100
    // WAKE_DRAM : 0101
    // DRAIN_WR : 0110
    // POST_DRAIN_WR : 0111
    // LINK_FAIL : 1001
    // TRIAL : 1010
    // SCRAMBLE_SYNC : 1011
    // SUCCESS : 1101
    // FAILURE : 1111
    // 
    // Bits[17:14], RW_LB, default = 0x8
    //
    UINTX trigger_vmse_state_2 : 4;
    //
    // Trigger when MC sees Intel SMI 2 error asserted.
    // 
    // Bits[18:18], RW_LB, default = 0x0
    //
    UINTX triger_vmse_err_assert : 1;
    //
    // Trigger when MC sees Intel SMI 2 error de-asserted.
    // 
    // Bits[19:19], RW_LB, default = 0x0
    //
    UINTX triger_vmse_err_deassert : 1;
    //
    // Trigger when Intel SMI 2 Error FSM Active timer expires.
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX trigger_verr_tmr_exp : 1;
    //
    // Trigger when the channel restart status return valid is seen in Intel SMI 2 error
    // FSM. The MC 
    // captures the restart status packet when this valid fires.
    // 
    // Bits[21:21], RW_LB, default = 0x0
    //
    UINTX trigger_chnlrst_status_ret : 1;
    //
    // Trigger when the Channel restart return indicates that scalable memory buffers
    // has seen 
    // a DRAM parity error on either DDR Bus 0 or DDR Bus 1.
    // 
    // Bits[22:22], RW_LB, default = 0x0
    //
    UINTX trigger_dram_par_err : 1;
    //
    // Trigger when the Channel restart return indicates that scalable memory buffers
    // has seen 
    // a Command CRC error.
    // 
    // Bits[23:23], RW_LB, default = 0x0
    //
    UINTX trigger_cmd_crc_err : 1;
    //
    // Trigger when the Channel restart return indicates that scalable memory buffers
    // has seen 
    // a ECC error on the write push data.
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX trigger_wp_ecc_err : 1;
    //
    // Trigger when the Channel restart return indicates that scalable memory buffers
    // has seen 
    // a Software Error (ERR bit in Power Management command).
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX trigger_sw_err : 1;
    //
    // Trigger if the Intel SMI 2 Error FSM switches to a specifc half width state.
    // See usage of ctl_en_trig_halfwidth
    // The encoding of the states is as follows. Since the encoding of
    // 0b100 is not used, the field must be programmed to 0x4 to
    // prevent matching with Full Width lane width.
    // 000 Full Width
    // 011 Half Width A - SB
    // 010 Half Width B - SB
    // 001 Half Width C - SB
    // 111 Half Width A - NB
    // 110 Half Width B - NB
    // 101 Half Width C - NB
    // 
    // Bits[28:26], RW_LB, default = 0x4
    //
    UINTX trigger_half_width_state : 3;
    //
    // Set this bit to a 1 if the triggers (other than trigger_half_width_state)
    // in the register must fire only when the FSM is in the half width state
    // programmed in field trigger_half_width_state. If this bit is set, then the FSM
    // will not trigger when the half width changes to the one mentioned in
    // trigger_half_width_state but will fire only if one of the additional triggers
    // also occurs. If the intent is to have a trigger, then the FSM transition to the
    // state programmed in trigger_half_width_state, then this bit should not be set.
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX ctl_en_trig_halfwidth : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} VMSE_ERR_FSM_TRIGGER_CTL_MC1LMDP_STRUCT;
#endif // ASM_INC


#endif // _MC1LMDP_H_
