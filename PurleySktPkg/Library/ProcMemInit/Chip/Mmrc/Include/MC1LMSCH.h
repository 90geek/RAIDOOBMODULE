/*++

Copyright (c) 2005-2015 Intel Corporation. All rights reserved
This software and associated documentation (if any) is furnished
under a license and may only be used or copied in accordance
with the terms of the license. Except as permitted by such
license, no part of this software or documentation may be
reproduced, stored in a retrieval system, or transmitted in any
form or by any means without the express written consent of
Intel Corporation.

Module Name:

    File name:    MC1LMSCH.h
    Input File:   SKX_MRC_for CTE updt-2015ww15.3.xlsx

Abstract:

    THIS FILE IS AUTO-GENERATED BY THE MMRC TOOL. DO NOT CHANGE THIS CODE.

    If edits are needed in this file, they must be done via the MMRC tool.

    If there is additional project-specific data required by the MMRC, it
    can be placed in MC1LMSCH.h, which is used for non-tool-generated
    data

    Includes register defines specific to a project.

--*/
#ifndef _MC1LMSCH_H_
#define _MC1LMSCH_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define VID_MC1LMSCH_REG                                  0x00000000
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The value is assigned by PCI-SIG to Intel.
    // 
    // Bits[15:0], RO, default = 0x8086
    //
    UINTX vendor_identification_number : 16;
  } Bits;
  UINTX Data;
} VID_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define DID_MC1LMSCH_REG                                  0x00000002
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  
    // Start (h)	End (h)	Device
    // 0x203F		0x203F	
    // 0x2040		0x204B	MC
    // 0x204C		0x204F	M3KTI
    // 0x2054		0x2054	CHASADALL
    // 0x2055		0x2055	CHAUTILALL
    // 0x2056		0x2056	CHAUTILALL1
    // 0x2057		0x2057	CHAPMAALL
    // 0x2058		0x205B	KTI
    // 0x2066		0x2067	M2MEM
    // 0x2068		0x206F	MC DDRIO
    // 0x2078		0x207F	VCU
    // 0x2080		0x2087	PCU
    // 0x2088		0x2088	
    // 0x2089		0x2089	
    // 0x208A		0x208A	
    // 0x208B		0x208B	
    // 0x208C		0x208C	
    // 0x208D		0x208D	CHAUTIL
    // 0x208E		0x208E	CHASAD
    // 0x208F		0x208F	CMSCHA
    // 0x2090		0x209F	RSVD FOR PCU FUNCTION 3
    // 	
    // 
    // Bits[15:0], RO, default = 0x2042
    //
    UINTX device_identification_number : 16;
  } Bits;
  UINTX Data;
} DID_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PCICMD_MC1LMSCH_REG                               0x00000004
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Hardwired to 0 since these devices don't decode any IO BARs
    // 
    // Bits[0:0], RO, default = 0x0
    //
    UINTX io_space_enable : 1;
    //
    // Hardwired to 0 since these devices don't decode any memory BARs
    // 
    // Bits[1:1], RO, default = 0x0
    //
    UINTX memory_space_enable : 1;
    //
    // Hardwired to 0 since these devices don't generate any transactions
    // 
    // Bits[2:2], RO, default = 0x0
    //
    UINTX bus_master_enable : 1;
    //
    // Not applicable. Hardwired to 0.
    // 
    // Bits[3:3], RO, default = 0x0
    //
    UINTX special_cycle_enable : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[4:4], RO, default = 0x0
    //
    UINTX memory_write_and_invalidate_enable : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[5:5], RO, default = 0x0
    //
    UINTX vga_palette_snoop_enable : 1;
    //
    // This bit has no impact on error reporting from these devices
    // 
    // Bits[6:6], RO, default = 0x0
    //
    UINTX parity_error_response : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX idsel_stepping_wait_cycle_control : 1;
    //
    // This bit has no impact on error reporting from these devices
    // 
    // Bits[8:8], RO, default = 0x0
    //
    UINTX serr_enable : 1;
    //
    // Not applicable to PCI Express and is hardwired to 0
    // 
    // Bits[9:9], RO, default = 0x0
    //
    UINTX fast_back_to_back_enable : 1;
    //
    // N/A for these devices
    // 
    // Bits[10:10], RO, default = 0x0
    //
    UINTX intx_disable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
  } Bits;
  UINTX Data;
} PCICMD_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PCISTS_MC1LMSCH_REG                               0x00000006
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Reflects the state of the INTA# signal at the input of the enable/disable circuit.
    //  This bit is set by HW to 1 when the INTA# is asserted.  This bit is reset by
    // HW to 0 after the interrupt is cleared (independent of the state of the Interrupt
    // Disable bit in the 0.4.0.PCICMD register). 
    // Hardwired to 0 on the processor
    // 
    // Bits[3:3], RO, default = 0x0
    //
    UINTX intx_status : 1;
    //
    // This bit indicates the presence of a capabilities list structure. When set to
    // 1, indicates the register at 34h provides an offset into the function. 
    // 
    // Bits[4:4], RO, default = 0x1
    //
    UINTX capabilities_list : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[5:5], RO, default = 0x0
    //
    UINTX x66mhz_capable : 1;
    //
    // Reserved
    // 
    // Bits[6:6], RO, default = 0x0
    //
    UINTX reserved : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX fast_back_to_back : 1;
    //
    // Hardwired to 0
    // 
    // Bits[8:8], RO, default = 0x0
    //
    UINTX master_data_parity_error : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[10:9], RO, default = 0x0
    //
    UINTX devsel_timing : 2;
    //
    // Hardwired to 0
    // 
    // Bits[11:11], RO, default = 0x0
    //
    UINTX signaled_target_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[12:12], RO, default = 0x0
    //
    UINTX received_target_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[13:13], RO, default = 0x0
    //
    UINTX received_master_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[14:14], RO, default = 0x0
    //
    UINTX signaled_system_error : 1;
    //
    // This bit is set when the device receives a packet on the primary side with an
    // uncorrectable data error (including a packet with poison bit set) or an uncorrectable
    // address/control parity error. The setting of this bit is regardless of the Parity
    // Error Response bit (PERRE) in the PCICMD register. 
    // 
    // Bits[15:15], RO_V, default = 0x0
    //
    UINTX detected_parity_error : 1;
  } Bits;
  UINTX Data;
} PCISTS_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define RID_MC1LMSCH_REG                                  0x00000008
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reflects the Uncore Revision ID after reset.
    // Reflects the Compatibility Revision ID after BIOS writes 0x69 to any RID register
    // in the processor uncore. 
    //         
    // 
    // Bits[7:0], RO_V, default = 0x0
    //
    UINTX revision_id : 8;
  } Bits;
  UINTX Data;
} RID_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CCR_MC1LMSCH_REG                                  0x00000009
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[7:0], RO_V, default = 0x0
    //
    UINTX register_level_programming_interface : 8;
    //
    // The value changes dependent upon the dev/func accessed. A table of the values
    // can be found in the Class-code tab of the msgch spread-sheet  
    // 	  Most dev-func will return 8'h80 for this field except for the following dev-func0,func1,...
    // combinations. The following exceptions will return 8'h01. Please refer to /src/uncore/ncu/f_ccr_reg.vh
    // for the full lookingup table. 
    //           bus-0, dev-8 func-1 
    //           bus-3, dev-14 to 16, func-0
    //           bus-3, dev-18, func-0, 1, 4, 5
    //         
    // 
    // Bits[15:8], RO_V, default = 0x80
    //
    UINTX sub_class : 8;
    //
    // The value changes dependent upon the dev-func accessed. A table of the values
    // can be found in the Class-code tab of the msgch spread-sheet  
    // 	  Most bus-dev-func will return 8'h08 for this field except for the following
    // bus-dev-func0,func1,... combinations. The following exceptions will return 8'h11.
    // Please refer to /src/uncore/ncu/f_ccr_reg.vhfor the full lookingup table. 
    //           bus-0, dev-8 func-1 
    //           bus-3, dev-14 to 16, func-0
    //           bus-3, dev-18, func-0, 1, 4, 5
    //         
    // 
    // Bits[23:16], RO_V, default = 0x8
    //
    UINTX base_class : 8;
  } Bits;
  UINTX Data;
} CCR_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CLSR_MC1LMSCH_REG                                 0x0000000C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Size of Cacheline
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX cacheline_size : 8;
  } Bits;
  UINTX Data;
} CLSR_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PLAT_MC1LMSCH_REG                                 0x0000000D
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Not applicable to PCI-Express. Hardwired to 00h.
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX primary_latency_timer : 8;
  } Bits;
  UINTX Data;
} PLAT_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define HDR_MC1LMSCH_REG                                  0x0000000E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Type 0 header
    // 
    // Bits[6:0], RO, default = 0x0
    //
    UINTX configuration_layout : 7;
    //
    // This bit defaults to 1b since all these devices are multi-function
    // 
    // Bits[7:7], RO, default = 0x1
    //
    UINTX multi_function_device : 1;
  } Bits;
  UINTX Data;
} HDR_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define BIST_MC1LMSCH_REG                                 0x0000000F
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Not supported. Hardwired to 00h
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX bist_tests : 8;
  } Bits;
  UINTX Data;
} BIST_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CAPPTR_MC1LMSCH_REG                               0x00000034
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Points to the first capability structure for the device which is the PCIe capability.
    // 
    // Bits[7:0], RO, default = 0x40
    //
    UINTX capability_pointer : 8;
  } Bits;
  UINTX Data;
} CAPPTR_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define INTL_MC1LMSCH_REG                                 0x0000003C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A for these devices
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX interrupt_line : 8;
  } Bits;
  UINTX Data;
} INTL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define INTPIN_MC1LMSCH_REG                               0x0000003D
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A since these devices do not generate any interrupt on their own
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX interrupt_pin : 8;
  } Bits;
  UINTX Data;
} INTPIN_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MINGNT_MC1LMSCH_REG                               0x0000003E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The device does not burst as a PCI compliant master.
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX mgv : 8;
  } Bits;
  UINTX Data;
} MINGNT_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MAXLAT_MC1LMSCH_REG                               0x0000003F
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The device has no specific requirements for how often it needs to access the PCI
    // bus. 
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX mlv : 8;
  } Bits;
  UINTX Data;
} MAXLAT_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MCINITVISACFG_MC1LMSCH_REG                        0x00000344
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RWS_L, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RWS_L, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RWS_L, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RWS_L, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RWS_L, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCINITVISACFG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDBCLCTL_MC1LMSCH_REG                     0x000004A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // WDB_Increment_Rate indicates how many cachelines before the WDB_Current_Read_Pointer
    // is incremented. 
    // 
    // Bits[4:0], RW_LB, default = 0x0
    //
    UINTX incr_rate : 5;
    //
    // 1= WDB Increment Rate is a linear number, 0 = WDB Increment Rate is an exponential
    // number 
    // 
    // Bits[5:5], RW_LB, default = 0x0
    //
    UINTX incr_scale : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Indicates the starting cacheline out of the WDB when a test is started.
    // 
    // Bits[13:8], RW_LB, default = 0x0
    //
    UINTX start_pntr : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Indicates the ending Cacheline out of the WDB where upon the next increment the
    // WDB_Pointer will be reset to the WDB_Start_Pointer. 
    // 
    // Bits[21:16], RW_LB, default = 0x27
    //
    UINTX end_pntr : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 10;
  } Bits;
  UINTX Data;
} CPGC_PATWDBCLCTL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_MISCREFCTL_MC1LMSCH_REG                      0x00000538
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Refresh_Rank_Mask is a 8-bit field, one bit per Rank.
    // The LSB relates to Rank0 and the MSB relates to the highest Rank.
    // If the per Rank bit of the Refresh_Rank_Mask is set to 1, then the REUT engine
    // will disable 
    // executing any refresh to that rank while in REUT mode.
    // If the per rank bit of the Refresh_Rank_Mask is set to 0 and then the REUT engine
    // will 
    // enable executing a refresh (assuming the MC has refreshes enabled) to that Rank
    // while in REUT mode based on the Panic_Refresh_Only value.
    // 
    // Bits[7:0], RW_LB, default = 0x0
    //
    UINTX ref_rankmask : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
    //
    // If Panick_Refresh_Only is set to 1 then opportunistic and high priority auto refreshes
    // will be 
    // disabled for all ranks and refreshes will only occur when the panic refresh watermark
    // has been exceeded. 
    // If Panic_Refresh_Only is set to 0 then refreshes will occur using the existing
    // MC functional refresh logic. 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX panic_ref_only : 1;
  } Bits;
  UINTX Data;
} CPGC_MISCREFCTL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_MISCZQCTL_MC1LMSCH_REG                       0x0000053C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ZQ Mask is a per rank field. The LSB relates to Rank0 and the MSB relates to the
    // highest Rank. 
    // If the per rank bit of the ZQ Mask is set to 1, then the REUT engine will disable
    // executing ZQ operations to that Rank. 
    // Note: that if the Refresh_Rank_Mask for the same rank is set to 1 then the ZQ
    // Mask will have no effect and 
    // ZQ will disabled to that rank.
    // If the per rank bit of the ZQ mask is set to 0 and refreshes are being issued
    // to the corresponding Rank, 
    // ZQ will be issued at a rate equal to 128*ZQCS_period programmed inside the channel
    // TC_ZQCAL CR, 
    // always occurring after refreshes occur.
    // 
    // Bits[7:0], RW_LB, default = 0x0
    //
    UINTX zq_rankmask : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
    //
    // If Always_Do_ZQ is set to 1 a ZQ operation will always take place after a refresh
    // occurs as long as 
    // the ZQ_Rank_Mask for that rank is set to 0.
    // If Always_Do_ZQ is set to 0 a ZQ operation will take place at the normal programmed
    // 128*ZQCS_period after 
    // a refresh occurs as long as the ZQ_Rank_Mask for that rank is set to 0.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX always_do_zq : 1;
  } Bits;
  UINTX Data;
} CPGC_MISCZQCTL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_MISCCKECTL_MC1LMSCH_REG                      0x00000544
#ifndef ASM_INC
typedef union {
  struct {
    //
    // CKE_Override is a 8-bit field, one bit per logical rank. The LSB relates to Rank0
    // and the MSB relates 
    // to the highest Rank.
    // When CKE_Override is set to 1 for a rank, the CKE functional logic will be bypassed
    // and the CKE_On 
    // value for that rank will be used.
    // When CKE_Override is set to 0 for a rank, the CKE functional logic will drive
    // the CKE value for that rank. 
    // 
    // Bits[7:0], RW_LB, default = 0x0
    //
    UINTX cke_override : 8;
    //
    // Per Channel Refresh enable
    // If cold reset, this bit should be set by bios after
    // 1) Initializing the refresh timing parameters
    // 2) Running DDR through reset and init sequence
    // If warm reset or S3 exit, this bit should be set immediately after SR exit
    // 
    // Bits[8:8], RW_L, default = 0x0
    //
    UINTX refresh_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // CKE_on is a 8-bit field, one bit per rank.
    // The LSB relates to Rank0 and the MSB relates to the highest Rank.
    // In REUT mode when the per rank bit is set CKE will be always on for that rank.
    // 
    // Bits[22:15], RW_LB, default = 0x0
    //
    UINTX cke_on : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 9;
  } Bits;
  UINTX Data;
} CPGC_MISCCKECTL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define RPQAGE_MC1LMSCH_REG                               0x0000025C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The name is misleading. Instead, it is RPQ Age Counter for the High priority (VCP)
    // transactions and Critical priority (VC1) isoch transactions issued from M2M. The
    // counter is increased by one every time there's a CAS command sent. When the RPQ
    // Age Counter is equal to this configured field value, the isoch transaction is
    // aged to the next priority level according to HAS Section 6.3.1. BIOS must set
    // this field to non-zero value before setting the MCMTR.NORMAL=1. Recommended settings:
    // 40h but subject to revision based from post-silicon application specific performance
    // tuning. 
    // 
    // Bits[9:0], RW, default = 0x0
    //
    UINTX cpugtcount : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // The name is misleading. It is RPQ Age Counter for the Medium and Low priority
    // (VC0) non-isoch transactions issued from M2M. The counter is increased by one
    // every time there's a CAS command sent. When the RPQ Age Counter is equal to this
    // configured field value, the non-isoch transaction is aged to the next priority
    // level BIOS must set this field to non-zero value before setting the MCMTR.NORMAL=1.
    // Recommended settings: 100h but subject to revision based from post-silicon application
    // specific performance tuning. 
    // 
    // Bits[25:16], RW, default = 0x0
    //
    UINTX iocount : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 6;
  } Bits;
  UINTX Data;
} RPQAGE_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PWMM_STARV_CNTR_PRESCALER_MC1LMSCH_REG            0x00000304
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Partial Write Starvation Counter Pre-Scaler
    // When the counter increment to the STARV_CNTR_PRESCALER value, the STARV_CNTR_PRESCALER
    // counter will be roll over back to zero and start counting. There is a 3b partial
    // write starvation counter for each partial write in the write queue. 
    // At the roll over, all 3b partial write starvation counters will be incremented
    // by 1. The 3b pwr starvation counter will saturated at its max value to indicate
    // the partial write starvation condition. The 3b counter will be cleared when the
    // partial write is served. 
    // 
    // Bits[7:0], RW, default = 0x40
    //
    UINTX starv_cntr_prescaler : 8;
    //
    // Page miss partial write progess counter limit. Number of cycles with one or more
    // PWR with a PM status in the WPQ to trigger a preempt. 
    // 
    // Bits[23:8], RW, default = 0x80
    //
    UINTX pmpwr_wm : 16;
    //
    // When WDB level reaches this WM, the MC is in Isoch mode
    // Value must be greater than WMM_ENTER and between (RPQ size + 5) and 29.
    // 
    // Bits[29:24], RW, default = 0x1D
    //
    UINTX wpq_is : 6;
    //
    // N/A
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX wmm_exit_in_wim : 1;
    //
    // N/A
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX dis_wim_exit_block : 1;
  } Bits;
  UINTX Data;
} PWMM_STARV_CNTR_PRESCALER_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define WDBWM_MC1LMSCH_REG                                0x00000308
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When WDB reaches the level defined by this pointer, channel goes into WMM, value
    // must be between 2 and (WPQ_IS - 1). 
    // // For JKT A0 bug#3078705 workaround/patch, please set the WMM_ENTER <= WPQ_IS
    // - 6 instead. 
    // 
    // Bits[7:0], RW_LB, default = 0x19
    //
    UINTX wmm_enter : 8;
    //
    // When channel is in WMM, when WDB level gets to this level the MC goes back to
    // RMM. 
    // The value must be between 1 and (WMM_Enter - 1). Initial value is 22
    // 
    // Bits[15:8], RW_LB, default = 0x15
    //
    UINTX wmm_exit : 8;
    //
    // This count is used for the starvation switch. If after the WMM transaction count
    // reaches the value in this field and WDB did not go under WMMExit WM, MC returns
    // to RMM for the same number of DCLK and returns back to WMM. 
    // 
    // Bits[31:16], RW_LB, default = 0x20
    //
    UINTX starve_cnt : 16;
  } Bits;
  UINTX Data;
} WDBWM_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define WDAR_MODE_MC1LMSCH_REG                            0x0000030C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0 - Not enabled, 1 -Enabled
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX wdarmode : 1;
    //
    // 0 = legacy wdar mode. 1 = no folding of address space is allowed ; i.e. reads
    // from address "a" 
    // will be returned from WDB only if address "a" is already in WDB.
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX wdarnofold : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 30;
  } Bits;
  UINTX Data;
} WDAR_MODE_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define WPQ_DUMP_REG_MC1LMSCH_REG                         0x00000310
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Arraycontents[31:0]
    // This register is GATED by the WPQ_DUMP_CFG2.VALID. When the VALID bit is 0, this
    // register is forced to zero. 
    // 
    // Bits[31:0], RO_V, default = 0x0
    //
    UINTX arraycontent : 32;
  } Bits;
  UINTX Data;
} WPQ_DUMP_REG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define WPQ_DUMP_CFG0_MC1LMSCH_REG                        0x00000314
#ifndef ASM_INC
typedef union {
  struct {
    //
    // setting a bit to 1 makes the trigger component a don't care
    // 
    // Bits[15:0], RW, default = 0x0
    //
    UINTX trigmask : 16;
    //
    // bank 2:0 match value
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX bank : 4;
    //
    // logical rank 2:0 match value
    // 
    // Bits[22:20], RW, default = 0x0
    //
    UINTX rank : 3;
    //
    // entry select override
    // 
    // Bits[27:23], RW, default = 0x0
    //
    UINTX widoverride : 5;
    //
    // selects 32 bit portion of entry to dump to RPQ dump reg 0
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINTX subentryselect : 2;
    //
    // continuous dump to RPQ dump reg 0 after trigger
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX cont : 1;
    //
    // clear trigger count
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX clear : 1;
  } Bits;
  UINTX Data;
} WPQ_DUMP_CFG0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define WPQ_DUMP_CFG1_MC1LMSCH_REG                        0x00000318
#ifndef ASM_INC
typedef union {
  struct {
    //
    // row address 17:0 match value
    // 
    // Bits[19:0], RW, default = 0x0
    //
    UINTX row : 20;
    //
    // col address 13:2 match value
    // 
    // Bits[31:20], RW, default = 0x0
    //
    UINTX col : 12;
  } Bits;
  UINTX Data;
} WPQ_DUMP_CFG1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define WPQ_DUMP_CFG2_MC1LMSCH_REG                        0x0000031C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // number of triggers to count before dump to WPQ dump reg 0
    // 
    // Bits[29:0], RW, default = 0x0
    //
    UINTX trigcount : 30;
    //
    // trigger count hit and WPQ dump reg 0 contents are valid
    // Locked by MC_ARRAY_DUMP_LCK bit in EPMCMAIN_DFX_LCK_CNTL uCR register. When locked,
    // the VALID bit is cleared and the WPQ dump is disabled. 
    // 
    // Bits[30:30], RW_LV, default = 0x0
    //
    UINTX valid : 1;
    //
    // entry select override. This is bit 5 of widoverride filed in wpq_dump_cfg0.widoverride.
    // HAd to expand to 40 entries somehow 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX widoverride5 : 1;
  } Bits;
  UINTX Data;
} WPQ_DUMP_CFG2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define RPQ_DUMP_REG_MC1LMSCH_REG                         0x00000320
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Arraycontents[31:0]
    // This register is GATED by the RPQ_DUMP_CFG2.VALID. When the VALID bit is 0, this
    // register is forced to zero. 
    // 
    // Bits[31:0], RO_V, default = 0x0
    //
    UINTX arraycontent : 32;
  } Bits;
  UINTX Data;
} RPQ_DUMP_REG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define RPQ_DUMP_CFG0_MC1LMSCH_REG                        0x00000324
#ifndef ASM_INC
typedef union {
  struct {
    //
    // setting a bit to 1 makes the trigger component a don't care
    // 
    // Bits[15:0], RW, default = 0x0
    //
    UINTX trigmask : 16;
    //
    // bank 2:0 match value
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX bank : 4;
    //
    // logical rank 2:0 match value
    // 
    // Bits[22:20], RW, default = 0x0
    //
    UINTX rank : 3;
    //
    // entry select override
    // 
    // Bits[27:23], RW, default = 0x0
    //
    UINTX ridoverride : 5;
    //
    // selects 32 bit portion of entry to dump to RPQ dump reg 0
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINTX subentryselect : 2;
    //
    // continuous dump to RPQ dump reg 0 after trigger
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX cont : 1;
    //
    // clear trigger count
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX clear : 1;
  } Bits;
  UINTX Data;
} RPQ_DUMP_CFG0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define RPQ_DUMP_CFG1_MC1LMSCH_REG                        0x00000328
#ifndef ASM_INC
typedef union {
  struct {
    //
    // subrank address 2:0 match value
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINTX subrank : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[17:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 15;
    //
    // col address 13:2 match value
    // 
    // Bits[29:18], RW, default = 0x0
    //
    UINTX col : 12;
    //
    // select dump from RPQ0 (when set to 0) or RPQ1 (when set to 1)
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX dump_rpq_sel : 1;
    //
    // select debug signal from RPQ0 (when set to 0) or RPQ1 (when set to 1)
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX debug_rpq_sel : 1;
  } Bits;
  UINTX Data;
} RPQ_DUMP_CFG1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define RPQ_DUMP_CFG2_MC1LMSCH_REG                        0x0000032C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // number of triggers to count before dump to RPQ dump reg 0
    // 
    // Bits[29:0], RW, default = 0x0
    //
    UINTX trigcount : 30;
    //
    // trigger count hit and RPQ dump reg 0 contents are valid
    // Locked by MC_ARRAY_DUMP_LCK bit in EPMCMAIN_DFX_LCK_CNTL uCR register. When locked,
    // the VALID bit is cleared and the RPQ dump is disabled. 
    // 
    // Bits[30:30], RW_LV, default = 0x0
    //
    UINTX valid : 1;
    //
    // trigger count hit and RPQ dump reg 0 contents from rpax are valid
    // Locked by MC_ARRAY_DUMP_LCK bit in EPMCMAIN_DFX_LCK_CNTL uCR register. When locked,
    // the VALID bit is cleared and the RPQ dump is disabled. 
    // 
    // Bits[31:31], RW_LV, default = 0x0
    //
    UINTX valid_rpax : 1;
  } Bits;
  UINTX Data;
} RPQ_DUMP_CFG2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PGT_DUMP_REG_MC1LMSCH_REG                         0x00000330
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Arraycontents[31:0]
    // Locked by MC_ARRAY_DUMP_LCK. When Locked, this register is forced to zero to prevent
    // user data being read-accessed via this register. 
    // 
    // Bits[31:0], RW_LV, default = 0x0
    //
    UINTX arraycontents : 32;
  } Bits;
  UINTX Data;
} PGT_DUMP_REG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PGT_DUMP_CFG_MC1LMSCH_REG                         0x00000334
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX entryid : 6;
    //
    // N/A
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINTX subentryselect : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // This field is used to select the contents of the rank from the safe logic to be
    // driven on the debug ring. 
    // 
    // Bits[10:8], RW, default = 0x0
    //
    UINTX dbg_safe_rank_sel : 3;
    //
    // Along with dbg_safe_rank_sel, this field is used to select the contents of the
    // dummycassafe signal to be 
    // driven on the debug ring. dummycas is 16 bits wide because of subrank tracking.
    // if this bit is zero, 
    // rank_sel will select one of the bits in dummycas[7:0]. If this bit is 1, rank_sel
    // will select one of the 
    // bits in dummycas[15:8]. Note that although there is a known and fixed mapping
    // between logical rank 
    // number and subrank numbers, that mapping is not figured out in this logic and
    // it is user's reponsibility 
    // to select the correct bit.
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX dbg_safe_upperdummy_sel : 1;
    //
    // Along with dbg_safe_rank_sel, this field is used to select the contents of the
    // bank_open signal to be 
    // driven on the debug ring. bank_open is 128 bits wide because of ddr4 support of
    // 16 banks. if this bit is 
    // zero, bank_open[7:0] for that rank_sel will be selected. If this bit is 1, bank_open[15:8]
    // for that 
    // rank_sel will be selected.
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX dbg_safe_upperbank_sel : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 19;
  } Bits;
  UINTX Data;
} PGT_DUMP_CFG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define SPARING_MC1LMSCH_REG                              0x00000338
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Number of WPQ credits to withold from M2M while sparing is in progress.
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX sparecrdts : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Maximum number of merged write isoch transactions allowed in a channel. When this
    // level is exceeded write credits will not be returned. A value of 0 disables this
    // feature and allows any number of merged write isoch transactions, which can lead
    // to unexpected behavior. 
    // 
    // Bits[13:8], RW_LB, default = 0x5
    //
    UINTX wrfifohwm : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 18;
  } Bits;
  UINTX Data;
} SPARING_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define RPQ_DUMP_CFG3_MC1LMSCH_REG                        0x0000033C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // row address 19:0 match value
    // 
    // Bits[19:0], RW, default = 0x0
    //
    UINTX row : 20;
    //
    // This is really for wpq not rpq. ran out of room in the wpq_dump registers. If
    // this bit is 1 , it will select some vmse realted bits instead of some Precharge
    // and subrank related fileds added to wpq fo the upper bits of 128 bit wpqdump bus.
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX wpq_dump_extension : 1;
    //
    // This is really for wpq not rpq. ran out of room in the wpq_dump registers. Subrank
    // address 2:0 match value for wpq_dump 
    // 
    // Bits[23:21], RW, default = 0x0
    //
    UINTX wpq_dump_subrank : 3;
    //
    // This is really for wpq not rpq. ran out of room in the wpq_dump registers. trigger
    // count hit and WPQ dump reg 0 contents from wpax are valid 
    // Locked by MC_ARRAY_DUMP_LCK bit in EPMCMAIN_DFX_LCK_CNTL uCR register. When locked,
    // the VALID bit is cleared and the WPQ dump is disabled. 
    // 
    // Bits[24:24], RW_LV, default = 0x0
    //
    UINTX valid_wpax : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} RPQ_DUMP_CFG3_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define DDR4_WR_STARVE_CTL_MC1LMSCH_REG                   0x00000354
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Threshold for number of cycles of in base timer. The threshold field is incremented
    // every (2^timer) DCLK ticks. 
    // 
    // Bits[5:0], RW_LB, default = 0x12
    //
    UINTX timer : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
    //
    // Threshold for the base timer to wrap around. When the wrap around happens, if
    // any write that was in WPQ from last time the timer wrapped around is not issued,
    // entry into WMM is triggered. Program to 0 to disable mechanism. 
    // 
    // Bits[23:16], RW_LB, default = 0x4
    //
    UINTX threshold : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 8;
  } Bits;
  UINTX Data;
} DDR4_WR_STARVE_CTL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MCSCHEDDBGSEL_MC1LMSCH_REG                        0x00000360
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RW_LB, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RW_LB, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RW_LB, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX clken : 1;
    //
    // This bit is used to place one bit of directory data on bit 6 of the data trace
    // footer ID fields. Note 
    // that in this mode one bit of read ID will be missing but no bits of write ID will
    // be missing as the write 
    // ID is only 6 bits wide so a forced zero will have the directory bit. In lockstep
    // mode bit 6 will have the 
    // first directory bit and bit 5 will have the 2nd directory bit.
    // Independent channel mode {Read,Dir0,Id[5:0]} followed by {Read,Dir1,Id[5:0]}
    // Lockstep channel mode {Read,Dir0,Dir1,Id[4:0]}
    // 
    // Bits[25:25], RWS_L, default = 0x0
    //
    UINTX data_trace_dir : 1;
    //
    // This bit enables this channel for data tracing. The channel will be placed in
    // a debug mode which will capture data from 
    // another
    // active channel into the WDB so that it can be streamed to the M2M where a waiting
    // IOT will save it to cache. 
    // 
    // Bits[26:26], RWS_L, default = 0x0
    //
    UINTX data_trace_en : 1;
    //
    // This bit is used to flush the remainder footer at the end of data tracing.
    // 
    // Bits[27:27], RWS_L, default = 0x0
    //
    UINTX data_trace_flush : 1;
    //
    // This bit is used to place ECC data on the data trace bits 15:0
    // 
    // Bits[28:28], RWS_L, default = 0x0
    //
    UINTX data_trace_ecc : 1;
    //
    // This bit is used to place read ECC data on the write data trace bits 15:0.
    // write DDR data tracing will be disabled and just 16 of the 128 write data
    // bits will be used to hold the received ECC data. The upper 112 bits will
    // be invalid. The footer records will indicate the reads and writes like normal
    // except the write data is ECC data and the write ID will match the corresponding
    // read ID.
    // 
    // Bits[29:29], RWS_L, default = 0x0
    //
    UINTX data_trace_ecc_on_wr_data : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} MCSCHEDDBGSEL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define LA_READ_QUAL_MC1LMSCH_REG                         0x00000380
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Select xxDDR[3:0]_MA[15] as the read qualifier
    // Locked by EPMCCTRL_DFX_LCK_CNTL.DBGBUSLCK
    // 
    // Bits[0:0], RWS_L, default = 0x0
    //
    UINTX rd_qual_on_ma15 : 1;
    //
    // Select xxDDR[3:0]_PAR as the read qualifier
    // Locked by EPMCCTRL_DFX_LCK_CNTL.DBGBUSLCK
    // Note: When using this option, please set the corresponding MCx_DP_UCR_CHKN_BIT.DIS_RDIMM_PAR_CHK=1
    // via ITP. 
    // 
    // Bits[1:1], RWS_L, default = 0x0
    //
    UINTX rd_qual_on_parity : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 30;
  } Bits;
  UINTX Data;
} LA_READ_QUAL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define WMM_READ_CONFIG_MC1LMSCH_REG                      0x00000400
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Disable issuing read commands opportunistically during WMM.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX dis_opp_rd : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
    //
    // Disable issuing activate commands for reads opportunistically during WMM.
    // 
    // Bits[8:8], RW_LB, default = 0x1
    //
    UINTX act_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 7;
    //
    // Disable issuing precharge commands for reads opportunistically during WMM.
    // 
    // Bits[16:16], RW_LB, default = 0x1
    //
    UINTX pre_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:17], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 7;
    //
    // Max number of Read CAS commands that may be issued from the RPQ during a single
    // visit to WMM. 
    // 
    // Bits[27:24], RW_LB, default = 0x4
    //
    UINTX max_rpq_cas : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 4;
  } Bits;
  UINTX Data;
} WMM_READ_CONFIG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define BL_EGRESS_CREDIT_MC1LMSCH_REG                     0x00000404
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //         Maximum number of BL egress credits reserved for DDR4 reads. 
    //         
    // 
    // Bits[5:0], RW_LB, default = 0x10
    //
    UINTX ddr4_egcrdt : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Maximum number of BL egress credits reserved for DDRT GNTs.
    // 
    // Bits[13:8], RW_LB, default = 0x10
    //
    UINTX ddrt_egcrdt : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // 
    //         Min number of BL egress credits that must be available to
    //         schedule a DDR4 read. This field can be set to 1 for 1LM mode
    //         but needs to be at least 2 for 2LM mode. 
    //         
    // 
    // Bits[18:16], RW_LB, default = 0x2
    //
    UINTX min_ddr4_egrcrdt : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
    //
    // 
    //         The slot number to allow read CAS for current channel. This feature is
    // only enabled when uclk is slower than dclk, and NGN DIMMs are used. When this
    // feature is enabled (mcmtr.enable_slot_use = 1), early completion for channel 0
    // should only be sent in slot 0, and channel 1 should only use slot 2, while channel
    // 2 should only use slot 4. A value between 0 and 5 should be programmed in this
    // field to allow the above result. This field should be programmed such that (du_slot_number
    // + read CAS to early completion delay) mod 6 = (2 * current channel number). 
    //         
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX du_slot_number : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 5;
  } Bits;
  UINTX Data;
} BL_EGRESS_CREDIT_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define IOTHUB_CREDIT_MC1LMSCH_REG                        0x00000408
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Avaliable IOT Hub credit.
    // 
    // Bits[5:0], RW_LB, default = 0x38
    //
    UINTX iotcrdt : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 0: each credit returned from IOT hub represents 1 credit; 1: each credit returned
    // from IOT hub represents 4 credits. 
    // 
    // Bits[8:8], RW_LB, default = 0x0
    //
    UINTX iotcrdt_cfg : 1;
    //
    // Enable blocking in DDR4 scheduler when IOT hub ran out of credit.
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX iotcrdt_blk_en : 1;
    //
    // Enable blocking in DDRT scheduler when IOT hub ran out of credit.
    // 
    // Bits[10:10], RW_LB, default = 0x0
    //
    UINTX iotcrdt_ddrt_blk_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 21;
  } Bits;
  UINTX Data;
} IOTHUB_CREDIT_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_INORDER_MC1LMSCH_REG                         0x000004A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 29;
    //
    // If rpq0_Inorder_En is set to 1, RPQ0 CAS selection order will be in order between
    // entries 23 and 22 in CPGC mode. 
    // This should be cleared only if there is a bug involved with this logic.
    // If rpq0_Inorder_En is set to 0, RPQ cas selection behaviour will not change
    // 
    // Bits[29:29], RW_LB, default = 0x1
    //
    UINTX rpq0_inorder_en : 1;
    //
    // If rpq1_Inorder_En is set to 1, RPQ0 CAS selection order will be in order between
    // entries 23 and 22 in CPGC mode. 
    // THis should not be set to 1; for test only
    // If rpq1_Inorder_En is set to 0, RPQ cas selection behaviour will not change.
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX rpq1_inorder_en : 1;
    //
    // If Wpq_Inorder_En is set to 1, WPQ allocation and write push, CAS selection order
    // will be round robin 
    // If Wpq_Inorder_En is set to 0, WPQ allocation and write push, CAS selection will
    // be in normal operation mode; i.e., the first available entry will be selected.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX wpq_inorder_en : 1;
  } Bits;
  UINTX Data;
} CPGC_INORDER_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CMD_PAR_INJ_CTL_MC1LMSCH_REG                      0x000004A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable single injection on DDR4 Command. HW will self clear on injection.
    // 
    // Bits[0:0], RW_LBV, default = 0x0
    //
    UINTX en_ddr4 : 1;
    //
    // Enable single injection on DDRT Comnmand, UI0. HW will self clear on injection.
    // 
    // Bits[1:1], RW_LBV, default = 0x0
    //
    UINTX en_ddrt_ui0 : 1;
    //
    // Enable single injection on DDRT Command, UI1. HW will self clear on injection.
    // 
    // Bits[2:2], RW_LBV, default = 0x0
    //
    UINTX en_ddrt_ui1 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 27;
    //
    // Enable safe command injection
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX ddr4safe : 1;
    //
    // Enable safe command injection
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX ddrtsafe : 1;
  } Bits;
  UINTX Data;
} CMD_PAR_INJ_CTL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CMD_PAR_INJ_MATCH_MC1LMSCH_REG                    0x000004AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             Match mapping for DDR4: ACT_b, C[2:0], BG[1:0], BA[1:0], A[17:0]
    //             Match mapping for DDRT: ACT_b, RAS_b, CAS_b, WE_b, BG[1:0], BA[1:0],
    // A[17:0] 
    //         
    // 
    // Bits[25:0], RW, default = 0x0
    //
    UINTX cmd : 26;
    //
    // Match Value for Rank
    // 
    // Bits[28:26], RW, default = 0x0
    //
    UINTX rank : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
  } Bits;
  UINTX Data;
} CMD_PAR_INJ_MATCH_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CMD_PAR_INJ_MASK_MC1LMSCH_REG                     0x000004B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             Mask mapping for DDR4: ACT_b, C[2:0], BG[1:0], BA[1:0], A[17:0]
    //             Mask mapping for DDRT: ACT_b, RAS_b, CAS_b, WE_b, BG[1:0], BA[1:0],
    // A[17:0] 
    //         
    // 
    // Bits[25:0], RW, default = 0x3FFFFFF
    //
    UINTX cmd : 26;
    //
    // Mask Value for Rank
    // 
    // Bits[28:26], RW, default = 0x7
    //
    UINTX rank : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
  } Bits;
  UINTX Data;
} CMD_PAR_INJ_MASK_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define RPA_WPA_PAR_ERR_CTL_MC1LMSCH_REG                  0x000004B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Parity error will be injected on the next RPA read after this bit is set. Enable
    // bit will be unset after injection. 
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rpq0_enable : 1;
    //
    // Parity error will be injected on the next RPA read after this bit is set. Enable
    // bit will be unset after injection. 
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX rpq1_enable : 1;
    //
    // Parity error will be injected on the next WPA read after this bit is set. Enable
    // bit will be unset after injection. 
    // 
    // Bits[2:2], RW_LB, default = 0x0
    //
    UINTX wpq_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 29;
  } Bits;
  UINTX Data;
} RPA_WPA_PAR_ERR_CTL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_PATCADBCTL_MC1LMSCH_REG                      0x00000500
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable_CADB_on_Deselect enables whether CADB will be driven out during all deselects
    // packets on the bus. 
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX enable_cadb_on_deselect : 1;
    //
    // Enable_CADB_Always_On enables the CADB to be driven out on all command and address
    // pins every Dclk while a test is Loopback.Pattern. 
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX enable_cadb_always_on : 1;
    //
    // If 1, cadb_parity will be driven on same clock as CMD/Address (i.e. N timing for
    // udimm 
    // ddr4 only). If 0, cadb_parity will be driven on the clock after CMD/Address (i.e.
    // N+1 
    // timing for all other devices)
    // 
    // Bits[2:2], RW_LB, default = 0x0
    //
    UINTX enable_cadb_parityntiming : 1;
    //
    // If this bit is on, mdodifies the behaviour of cad_always_on mode by stopping the
    // test 
    // automatically after all 16 entries have been issued out of CADB. If this bit is
    // zero, 
    // cadb_always_on_mode behaviour doe snot change; i.e. once we enter this mode, the
    // only 
    // exit criteria is if software stops the tese.
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX enable_onepasscadb_always_on : 1;
    //
    // 
    //                 If this bit is one, any PBA(Per Buffer Addressable)/PDA(Per dram
    // addressable) Writes issued from CADB will 
    // 				be double length (i.e. if lockstep is not enabled, 16 UI instead of 8 UI.
    // If lockstep is enabled, 8 UI instead 
    // 				of 4 UI). This is added to allow more setup up time for PBA accesses during
    // training. 
    // 				If 0, PBA/PDA writes will look exactly the saem as normal writes.
    //         
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX enable_pda_doublelength : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 27;
  } Bits;
  UINTX Data;
} CPGC_PATCADBCTL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_PATCADBMRS_MC1LMSCH_REG                      0x00000504
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 2^MRS_Gap is the number of D clocks to wait before continuing to the next CADB
    // entry. 
    // 
    // Bits[3:0], RW_LB, default = 0x2
    //
    UINTX mrs_gap : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // CADB_Start_Pointer describes which entry out of the Command Address Data Buffer
    // (CADB) will be used when a test is started that enables the CADB. 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX mrs_start_pointer : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
    //
    // CADB_End_Pointer indicates which entry out of the Command Address Data Buffer
    // the Data generation will end the MRS test and will cause a trnisiton back to Loopack.Marker.
    // 
    // Bits[19:16], RW_LB, default = 0xF
    //
    UINTX mrs_end_pointer : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
    //
    // Indicates the current value of the CADB pointer.
    // 
    // Bits[27:24], RO_V, default = 0x0
    //
    UINTX mrs_current_pointer : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 4;
  } Bits;
  UINTX Data;
} CPGC_PATCADBMRS_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_PATCADBMUXCTL_MC1LMSCH_REG                   0x00000508
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0x10=Select LFSR16 0x01=Select 16 bit buffer 0x00=Select LMN counter
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX mux0_control : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 0x10=Select LFSR16 0x01=Select 16 bit buffer 0x00=Select LMN counter
    // 
    // Bits[5:4], RW_LB, default = 0x0
    //
    UINTX mux1_control : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // 0x10=Select LFSR16 0x01=Select 16 bit buffer 0x00=Select LMN counter
    // 
    // Bits[9:8], RW_LB, default = 0x0
    //
    UINTX mux2_control : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // 0x10=Select LFSR16 0x01=Select 16 bit buffer 0x00=Select LMN counter
    // 
    // Bits[13:12], RW_LB, default = 0x0
    //
    UINTX mux3_control : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 18;
  } Bits;
  UINTX Data;
} CPGC_PATCADBMUXCTL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_PATCADBMUX0PB_MC1LMSCH_REG                   0x0000050C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Used to program the initial value of the CADB Mux# Pattern/LFSR Buffer.
    // 
    // Bits[15:0], RW_V, default = 0x0
    //
    UINTX pattern_buffer : 16;
    //
    // 0: Initial seed used for Multiplicative LFSR during Intel SMI 2 Fine Cmd is 1'b0.
    // 1: Initial seed used for Multiplicative LFSR during Intel SMI 2 Fine Cmd is 1'b1.
    // 
    // Bits[16:16], RW_LB, default = 0x1
    //
    UINTX mptive_lfsr_seed : 1;
    //
    // 0: LFSR used as Classic Galois polynomial for CADB De-select and Always-on operation
    // 1: LFSR used as Fibonacci polynomial for Intel SMI 2 Fine Cmd training
    // 
    // Bits[17:17], RW_LB, default = 0x0
    //
    UINTX vmse_cmd_trng_mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
  } Bits;
  UINTX Data;
} CPGC_PATCADBMUX0PB_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_PATCADBMUX1PB_MC1LMSCH_REG                   0x00000510
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Used to program the initial value of the CADB Mux# Pattern/LFSR Buffer.
    // 
    // Bits[15:0], RW_V, default = 0x0
    //
    UINTX pattern_buffer : 16;
    //
    // 0: Initial seed used for Multiplicative LFSR during Intel SMI 2 Fine Cmd is 1'b0.
    // 1: Initial seed used for Multiplicative LFSR during Intel SMI 2 Fine Cmd is 1'b1.
    // 
    // Bits[16:16], RW_LB, default = 0x1
    //
    UINTX mptive_lfsr_seed : 1;
    //
    // 0: LFSR used as Classic Galois polynomial for CADB De-select and Always-on operation
    // 1: LFSR used as Fibonacci polynomial for Intel SMI 2 Fine Cmd training
    // 
    // Bits[17:17], RW_LB, default = 0x0
    //
    UINTX vmse_cmd_trng_mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
  } Bits;
  UINTX Data;
} CPGC_PATCADBMUX1PB_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_PATCADBMUX2PB_MC1LMSCH_REG                   0x00000514
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Used to program the initial value of the CADB Mux# Pattern/LFSR Buffer.
    // 
    // Bits[15:0], RW_V, default = 0x0
    //
    UINTX pattern_buffer : 16;
    //
    // 0: Initial seed used for Multiplicative LFSR during Intel SMI 2 Fine Cmd is 1'b0.
    // 1: Initial seed used for Multiplicative LFSR during Intel SMI 2 Fine Cmd is 1'b1.
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX mptive_lfsr_seed : 1;
    //
    // 0: LFSR used as Classic Galois polynomial for CADB De-select and Always-on operation
    // 1: LFSR used as Fibonacci polynomial for Intel SMI 2 Fine Cmd training
    // 
    // Bits[17:17], RW_LB, default = 0x0
    //
    UINTX vmse_cmd_trng_mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
  } Bits;
  UINTX Data;
} CPGC_PATCADBMUX2PB_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_PATCADBMUX3PB_MC1LMSCH_REG                   0x00000518
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Used to program the initial value of the CADB Mux# Pattern/LFSR Buffer.
    // 
    // Bits[15:0], RW_V, default = 0x0
    //
    UINTX pattern_buffer : 16;
    //
    // 0: Initial seed used for Multiplicative LFSR during Intel SMI 2 Fine Cmd is 1'b0.
    // 1: Initial seed used for Multiplicative LFSR during Intel SMI 2 Fine Cmd is 1'b1.
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX mptive_lfsr_seed : 1;
    //
    // 0: LFSR used as Classic Galois polynomial for CADB De-select and Always-on operation
    // 1: LFSR used as Fibonacci polynomial for Intel SMI 2 Fine Cmd training
    // 
    // Bits[17:17], RW_LB, default = 0x0
    //
    UINTX vmse_cmd_trng_mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
  } Bits;
  UINTX Data;
} CPGC_PATCADBMUX3PB_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_PATCADBCLMUX0LMN_MC1LMSCH_REG                0x0000051C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0x0 = logic 0 must be driven during the initial L counter delay
    // 0x1=logic 1 must be driven during the initial L counter delay
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX l_data_select : 1;
    //
    // After L_Counter Dclk cycles are driven at the beginning of a test then periodic
    // pattern is continuously repeated 
    // depending on the value of Sweep Frequency.
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX sweep_freq : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // After L_Counter Dclk cycles are driven at the beginning of a test then periodic
    // pattern is continuously repeated 
    // depending on the value of Sweep Frequency.
    // 
    // Bits[15:8], RW_LB, default = 0x1
    //
    UINTX l_counter : 8;
    //
    // If Sweep_Frequency = 0 then a steady state frequency is driven (see Sweep_Frequency
    // for exact behavior) 
    // If Sweep_Frequency = 1 then a frequency sweep is continuously generated ranging
    // from 2*(M) to 2*(N) driven (see Sweep_Frequency for exact behavior) 
    // 
    // Bits[23:16], RW_LB, default = 0x1
    //
    UINTX m_counter : 8;
    //
    // If Sweep_Frequency = 0 then a steady state frequency is driven (see Sweep_Frequency
    // for exact behavior) 
    // If Sweep_Frequency = 1 then a frequency sweep is continuously generated ranging
    // from 2*(M)to 2*(N) driven (see Sweep_Frequency for exact behavior) 
    // 
    // Bits[31:24], RW_LB, default = 0x1
    //
    UINTX n_counter : 8;
  } Bits;
  UINTX Data;
} CPGC_PATCADBCLMUX0LMN_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_PATCADBCLMUX1LMN_MC1LMSCH_REG                0x00000520
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0x0 = logic 0 must be driven during the initial L counter delay
    // 0x1=logic 1 must be driven during the initial L counter delay
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX l_data_select : 1;
    //
    // After L_Counter Dclk cycles are driven at the beginning of a test then periodic
    // pattern is continuously repeated 
    // depending on the value of Sweep Frequency.
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX sweep_freq : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // After L_Counter Dclk cycles are driven at the beginning of a test then periodic
    // pattern is continuously repeated 
    // depending on the value of Sweep Frequency.
    // 
    // Bits[15:8], RW_LB, default = 0x1
    //
    UINTX l_counter : 8;
    //
    // If Sweep_Frequency = 0 then a steady state frequency is driven (see Sweep_Frequency
    // for exact behavior) 
    // If Sweep_Frequency = 1 then a frequency sweep is continuously generated ranging
    // from 2*(M) to 2*(N) driven (see Sweep_Frequency for exact behavior) 
    // 
    // Bits[23:16], RW_LB, default = 0x1
    //
    UINTX m_counter : 8;
    //
    // If Sweep_Frequency = 0 then a steady state frequency is driven (see Sweep_Frequency
    // for exact behavior) 
    // If Sweep_Frequency = 1 then a frequency sweep is continuously generated ranging
    // from 2*(M)to 2*(N) driven (see Sweep_Frequency for exact behavior) 
    // 
    // Bits[31:24], RW_LB, default = 0x1
    //
    UINTX n_counter : 8;
  } Bits;
  UINTX Data;
} CPGC_PATCADBCLMUX1LMN_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_PATCADBCLMUX2LMN_MC1LMSCH_REG                0x00000524
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0x0 = logic 0 must be driven during the initial L counter delay
    // 0x1=logic 1 must be driven during the initial L counter delay
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX l_data_select : 1;
    //
    // After L_Counter Dclk cycles are driven at the beginning of a test then periodic
    // pattern is continuously repeated 
    // depending on the value of Sweep Frequency.
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX sweep_freq : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // After L_Counter Dclk cycles are driven at the beginning of a test then periodic
    // pattern is continuously repeated 
    // depending on the value of Sweep Frequency.
    // 
    // Bits[15:8], RW_LB, default = 0x1
    //
    UINTX l_counter : 8;
    //
    // If Sweep_Frequency = 0 then a steady state frequency is driven (see Sweep_Frequency
    // for exact behavior) 
    // If Sweep_Frequency = 1 then a frequency sweep is continuously generated ranging
    // from 2*(M) to 2*(N) driven (see Sweep_Frequency for exact behavior) 
    // 
    // Bits[23:16], RW_LB, default = 0x1
    //
    UINTX m_counter : 8;
    //
    // If Sweep_Frequency = 0 then a steady state frequency is driven (see Sweep_Frequency
    // for exact behavior) 
    // If Sweep_Frequency = 1 then a frequency sweep is continuously generated ranging
    // from 2*(M)to 2*(N) driven (see Sweep_Frequency for exact behavior) 
    // 
    // Bits[31:24], RW_LB, default = 0x1
    //
    UINTX n_counter : 8;
  } Bits;
  UINTX Data;
} CPGC_PATCADBCLMUX2LMN_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_PATCADBCLMUX3LMN_MC1LMSCH_REG                0x00000528
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 0x0 = logic 0 must be driven during the initial L counter delay
    // 0x1=logic 1 must be driven during the initial L counter delay
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX l_data_select : 1;
    //
    // After L_Counter Dclk cycles are driven at the beginning of a test then periodic
    // pattern is continuously repeated 
    // depending on the value of Sweep Frequency.
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX sweep_freq : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // After L_Counter Dclk cycles are driven at the beginning of a test then periodic
    // pattern is continuously repeated 
    // depending on the value of Sweep Frequency.
    // 
    // Bits[15:8], RW_LB, default = 0x1
    //
    UINTX l_counter : 8;
    //
    // If Sweep_Frequency = 0 then a steady state frequency is driven (see Sweep_Frequency
    // for exact behavior) 
    // If Sweep_Frequency = 1 then a frequency sweep is continuously generated ranging
    // from 2*(M) to 2*(N) driven (see Sweep_Frequency for exact behavior) 
    // 
    // Bits[23:16], RW_LB, default = 0x1
    //
    UINTX m_counter : 8;
    //
    // If Sweep_Frequency = 0 then a steady state frequency is driven (see Sweep_Frequency
    // for exact behavior) 
    // If Sweep_Frequency = 1 then a frequency sweep is continuously generated ranging
    // from 2*(M)to 2*(N) driven (see Sweep_Frequency for exact behavior) 
    // 
    // Bits[31:24], RW_LB, default = 0x1
    //
    UINTX n_counter : 8;
  } Bits;
  UINTX Data;
} CPGC_PATCADBCLMUX3LMN_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_PATCADBWRPNTR_MC1LMSCH_REG                   0x0000052C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Indicates what entry in the CADB is being
    // indexed.
    // In order to program CADB, this register should
    // be programmed to a value followed by a 32-bit
    // write to cpgc_patcadbprog0 followed by a 32-bit
    // write to cpgc_patcadbprog1. Upon the last write
    // in this sequence, this register will be
    // autoincrmented; so thoretically one can continue
    // sequences of write_to_cpgc_patcadbprog0
    // followed by write_to_cpgc_patcadbprog1 16 times
    // if initital value of this register is zero in
    // order to program all entries in CADB.
    // 
    // Bits[3:0], RW_LBV, default = 0x0
    //
    UINTX write_pointer : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 28;
  } Bits;
  UINTX Data;
} CPGC_PATCADBWRPNTR_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_PATCADBPROG0_MC1LMSCH_REG                    0x00000530
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Used to read or write the Address CADB data.
    // 
    // Bits[17:0], RW_LB, default = 0x0
    //
    UINTX address : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Used to read or write the Cid CADB data.
    // This field is used for ddr4 devices which require Cbits;
    // For HDRL ddr3 devices which require address[17], cid[0] maps to address[17]
    // since address field is only [16:0].
    // 
    // Bits[22:20], RW_LB, default = 0x0
    //
    UINTX cid : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Used to read or write the Bank CADB data. maps to {BG[1:0],BA[1:0]} for ddr4 and
    // {dontcare,BA[2:0]} for ddr3.
    // 
    // Bits[27:24], RW_LB, default = 0x0
    //
    UINTX bank : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Used to read or write the Bank CADB data. this field does not map to any pins.
    // Instead it controls 
    // entry and exit from PDA/PBA mode.
    // 00: no change in pda/pba mode
    // 01: entr pda/pba mode.
    // Should be used when cadb_entry= "MRS to MR3 with A4=1" (for PDA)
    // or when cadb_entry= "MRS to MR7 with A[12:4]=RC06, A[3:0]=write" (for PBA)
    // after MRS to MR7 with A[12:8]=RC6X,A[0]=1 and
    // MRS to MR7 with A[12:8]=RC4X,A[7:0]=F0BC1X;
    // 10: exit pda/pba mode.
    // Should be used when cadb_entry= "MRS to MR3 with A4=0" (for PDA)
    // or when cadb_entry= "MRS to MR7 with A[12:4]=RC06, A[3:0]=write" (for PBA)
    // after MRS to MR7 with A[12:8]=RC6X,A[0]=0 and
    // MRS to MR7 with A[12:8]=RC4X,A[7:0]=F0BC1X;
    // 11: illegal
    // 
    // Bits[31:30], RW_LB, default = 0x0
    //
    UINTX pdatag : 2;
  } Bits;
  UINTX Data;
} CPGC_PATCADBPROG0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_PATCADBPROG1_MC1LMSCH_REG                    0x00000534
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Used to read or write the CS CADB data.
    // 
    // Bits[9:0], RW_LB, default = 0x0
    //
    UINTX cs : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Used to read or write the Control CADB data.
    // Bit-map: [15] - ACTb(ddr4), [14] - RASb, [13] - CASb, [12] - WEb
    // 
    // Bits[15:12], RW_LB, default = 0x0
    //
    UINTX control : 4;
    //
    // Used to read or write the ODT CADB data.
    // 
    // Bits[21:16], RW_LB, default = 0x0
    //
    UINTX odt : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Used to read or write the CKE CADB data.
    // 
    // Bits[29:24], RW_LB, default = 0x0
    //
    UINTX cke : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Used to read or write the PAR CADB data.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX par : 1;
  } Bits;
  UINTX Data;
} CPGC_PATCADBPROG1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_MISCODTCTL_MC1LMSCH_REG                      0x00000540
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ODT_Override is a 6-bit field, one bit per rank.
    // The LSB relates to Rank0 and the MSB relates to the highest Rank. When ODT_Override
    // is set to 
    // 1 for a rank, the ODT functional logic will be bypassed and the ODT_On value for
    // that 
    // rank will be used.
    // When ODT_Override is set to 0 for a rank, the ODT functional logic will drive
    // the ODT value for that rank. 
    // 
    // Bits[5:0], RW_LB, default = 0x0
    //
    UINTX odt_override : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
    //
    // ODT_on is a 6-bit field, one bit per rank.
    // The LSB relates to Rank0 and the MSB relates to the highest Rank. When ODT_Override
    // is set to 1 
    // for a rank the value in ODT_On will be used as the ODT value for that rank.
    // 
    // Bits[20:15], RW_LB, default = 0x0
    //
    UINTX odt_on : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 10;
    //
    // This bit is to be set during DDR training. The MPR pattern (Hardcoded 0101 pattern)
    // from the DRAM will be used to initially train the read timing. This MPR pattern
    // is accessed via the MR3 DRAM register and, per the JEDEC spec, the mode comes
    // with two key limitations: 
    // 1. Before entering this mode, all pages must be precharges.
    // 2. Once in this mode, the MC can only issue RD or RDA commands.
    // When this CR bit is set, the RAS# and WE# will always drive high. This will morph
    // any command from the scheduler into either READ or DESELECT. 
    // The flow is as follows:
    // 1. MRS Mode to write MR3
    // 2. Set MPR_Train_DDR_On
    // 3. Set REUT Mode
    // 4. Wait for all pages to close (page table idle counter to expire)
    // 5. Run REUT Test
    // 6. Stop Test, clear MPR_Train_DDR_On bit, clear MR3 register
    // 7. Continue with other REUT tests
    // Note that ZQ, CKE and Refresh should be disabled using the appropriate CR settings
    // during MPR_Train_DDR_On 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX mpr_train_ddr_on : 1;
  } Bits;
  UINTX Data;
} CPGC_MISCODTCTL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CTL_MC1LMSCH_REG                         0x00000548
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When Stop_On_Err_Control is set to 0x1 then the test will stop after the Stop_on_Nth_Err.
    // 
    // Bits[5:0], RW_LB, default = 0x1
    //
    UINTX stop_on_ntherr : 6;
    //
    // Controls if byte group counters are working in x4 mode or x8 mode.
    // 0: x4 mode
    // 1: x8 mode
    // 
    // Bits[6:6], RW_LB, default = 0x0
    //
    UINTX cpgc_cntr_x8_mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // Defines what type of err is will Stop a test:
    // 00: Never Stop On Any Err - Prevents any err from causing a test to stop on this
    // channel. 
    // 01: Stop on the Nth Any Lane Err - If any lane(s) sees an err in a comparison
    // cycle for (Stop_on_Nth_Err) times then stop test. 
    // 10: Stop on All Byte Groups Err - If Byte_Group_Err_Status indicates an err has
    // happpened in all byte groups then a test is stopped. 
    // 11: Stop on All Lanes Err - If all data lanes see an err (Data_ Err_Status and
    // ECC_Err_Status) then a test is stopped. 
    // 
    // Bits[14:12], RW_LB, default = 0x0
    //
    UINTX stop_on_errcontrol : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Bit mask to enable any checking on any specific chunk
    // within the Cache Line. There are only 4 128 bit chunks in a
    // cache line. A 1 in a position enables error checking on
    // that chunk of the cache line. So 0xf checks the whole
    // cache line.
    // 
    // Bits[23:16], RW_LB, default = 0x0
    //
    UINTX selective_err_enb_chunk : 8;
    //
    // Bit mask to enable what Cachelines are checked within each group of 8 received.
    // Any 1 bit set indicates that the selected Cacheline must be checked.
    // 
    // Bits[31:24], RW_LB, default = 0x0
    //
    UINTX selective_err_enb_cl : 8;
  } Bits;
  UINTX Data;
} CPGC_ERR_CTL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_DATA0_MC1LMSCH_REG                       0x0000054C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each bit in Data_Err_Mask corresponds to a specific data lane (Bits 31:0).
    // 
    // Bits[31:0], RW_LB, default = 0x0
    //
    UINTX mask : 32;
  } Bits;
  UINTX Data;
} CPGC_ERR_DATA0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_DATA1_MC1LMSCH_REG                       0x00000550
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each bit in Data_Err_Mask corresponds to a specific data lane (Bits 63:32).
    // 
    // Bits[31:0], RW_LB, default = 0x0
    //
    UINTX mask : 32;
  } Bits;
  UINTX Data;
} CPGC_ERR_DATA1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_ECC_MC1LMSCH_REG                         0x00000554
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each bit in ECC_Err_Mask corresponds to a specific ECC lane (Bits 7:0).
    // 
    // Bits[7:0], RW_LB, default = 0x0
    //
    UINTX mask : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 24;
  } Bits;
  UINTX Data;
} CPGC_ERR_ECC_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_DATA0_S_MC1LMSCH_REG                     0x00000558
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each bit in Data_Err_Status corresponds to a specific data lane.
    // 
    // Bits[31:0], RW_V, default = 0x0
    //
    UINTX status : 32;
  } Bits;
  UINTX Data;
} CPGC_ERR_DATA0_S_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_DATA1_S_MC1LMSCH_REG                     0x0000055C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each bit in Data_Err_Status corresponds to a specific data lane.
    // 
    // Bits[31:0], RW_V, default = 0x0
    //
    UINTX status : 32;
  } Bits;
  UINTX Data;
} CPGC_ERR_DATA1_S_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_DATA2_S_MC1LMSCH_REG                     0x00000560
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each bit in Data_Err_Status corresponds to a specific data lane.
    // 
    // Bits[31:0], RW_V, default = 0x0
    //
    UINTX status : 32;
  } Bits;
  UINTX Data;
} CPGC_ERR_DATA2_S_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_DATA3_S_MC1LMSCH_REG                     0x00000564
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each bit in Data_Err_Status corresponds to a specific data lane.
    // 
    // Bits[31:0], RW_V, default = 0x0
    //
    UINTX status : 32;
  } Bits;
  UINTX Data;
} CPGC_ERR_DATA3_S_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_CHUNK_MC1LMSCH_REG                       0x00000568
#ifndef ASM_INC
typedef union {
  struct {
    //
    // A one hot field with each bit corresponding to a specific Chunk
    // 
    // Bits[7:0], RW_V, default = 0x0
    //
    UINTX status : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 24;
  } Bits;
  UINTX Data;
} CPGC_ERR_CHUNK_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_BYTE_MC1LMSCH_REG                        0x0000056C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // A one hot field with each bit corresponding to a specific Byte Group (Data byte
    // groups 0-7 and ECC = 8). 
    // 
    // Bits[17:0], RW_V, default = 0x0
    //
    UINTX grp_status : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
  } Bits;
  UINTX Data;
} CPGC_ERR_BYTE_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_ADDR0_MC1LMSCH_REG                       0x00000570
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current c-bits (bits 20:18) and Row Address (bits 17:0) of the last cacheline
    // to experince an err. 
    // 
    // Bits[20:0], RW_V, default = 0x0
    //
    UINTX row : 21;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Current rank Address of the last cacheline to experince an err.
    // 
    // Bits[26:24], RW_V, default = 0x0
    //
    UINTX rank : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} CPGC_ERR_ADDR0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_ADDR1_MC1LMSCH_REG                       0x00000574
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Current Column Address of the last cacheline to experince an err.
    // 
    // Bits[13:2], RW_V, default = 0x0
    //
    UINTX column : 12;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 10;
    //
    // Current Bank Address of the last cacheline to experince an err.
    // 
    // Bits[27:24], RW_V, default = 0x0
    //
    UINTX bank : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} CPGC_ERR_ADDR1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER_OVERFLOW_MC1LMSCH_REG            0x00000578
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Counter_Overflow_Status contains the overflow flags for the various REUT_CH#_ERR_COUNTER#_STATUS
    // fileds. 
    // 
    // Bits[8:0], RW_V, default = 0x0
    //
    UINTX status : 9;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER_OVERFLOW_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_NTH_MC1LMSCH_REG                         0x0000057C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Nth_Err indicates the current Nth Err that has occurred while in Loopback.Pattern.
    // 
    // Bits[5:0], RO_V, default = 0x0
    //
    UINTX status : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 26;
  } Bits;
  UINTX Data;
} CPGC_ERR_NTH_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_WDB_CAPTURE_STATUS_MC1LMSCH_REG          0x00000580
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The WDB_Current_Err_Pointer starts equal to the WDB_Starting_Pointer and every
    // cachline that experinces an err 
    // will casue the WDB_Current_Err_Pointer to increment by 1 until it exceeds the
    // WDB_Ending_Err_Pointer where 
    // the WDB_Current_Err_Pointer will become equal again tothe WDB_Starting_Err_Pointer.
    // 
    // Bits[5:0], RO_V, default = 0x0
    //
    UINTX err_pntr : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 26;
  } Bits;
  UINTX Data;
} CPGC_ERR_WDB_CAPTURE_STATUS_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_WDB_CAPTURE_CTL_MC1LMSCH_REG             0x00000584
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Setting Enable_WDB_Err_Capture will cause all cachelines that experience any err
    // to be written in the WDB. 
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX enable : 1;
    //
    // This bit is intended to be used by VCU only. IF set to 1, it will log all reads
    // from ddr 
    // into WDB regardless of whether it has an error or not. All other CPGC related
    // programming should be adhered to.
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX vcuenable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // The WDB Starting Err Pointer is used to indicate where the first cacheline that
    // experiences a miscompare is written into the WDB. 
    // 
    // Bits[13:8], RW_LB, default = 0x0
    //
    UINTX start_pntr : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // WDB Ending Pointer is used to indicate where the pointer will wrap around to the
    // WDB Starting Pointer after 
    // writing an a cacheline that experiences a miscompare into the WDB using the WDB
    // Enfing Pointer. 
    // 
    // Bits[21:16], RW_LB, default = 0x0
    //
    UINTX end_pntr : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 10;
  } Bits;
  UINTX Data;
} CPGC_ERR_WDB_CAPTURE_CTL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_PATWDBCL_RDSTS_MC1LMSCH_REG                  0x0000058C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Indicates the current value of the WDB_Pointer for Read Comparison.
    // 
    // Bits[5:0], RO_V, default = 0x0
    //
    UINTX cur_rdpntr : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 26;
  } Bits;
  UINTX Data;
} CPGC_PATWDBCL_RDSTS_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER0_MC1LMSCH_REG                    0x000005C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Counter_Pointer is used in conjunction with Counter_Control to indicate what lane
    // or byte group is desired for tracking err. 
    // 
    // Bits[6:0], RW_LB, default = 0x7F
    //
    UINTX pntr : 7;
    //
    // Counter_Control determines what get counted by REUT_CH#_ERR_COUNTER#_VALUE.Counter_Value
    // 
    // Bits[8:7], RW_LB, default = 0x0
    //
    UINTX ctl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER0_S_MC1LMSCH_REG                  0x000005CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // REUT_CH#_ERR_COUNTER_STATUS indicates the current err counter value which is configured
    // by REUT_CH#_ERR_COUNTER#_CTL. 
    // 
    // Bits[22:0], RW_V, default = 0x0
    //
    UINTX status : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER0_S_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER1_MC1LMSCH_REG                    0x000005D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Counter_Pointer is used in conjunction with Counter_Control to indicate what lane
    // or byte group is desired for tracking err. 
    // 
    // Bits[6:0], RW_LB, default = 0x7F
    //
    UINTX pntr : 7;
    //
    // Counter_Control determines what get counted by REUT_CH#_ERR_COUNTER#_VALUE.Counter_Value
    // 
    // Bits[8:7], RW_LB, default = 0x0
    //
    UINTX ctl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER1_S_MC1LMSCH_REG                  0x000005D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // REUT_CH#_ERR_COUNTER_STATUS indicates the current err counter value which is configured
    // by REUT_CH#_ERR_COUNTER#_CTL. 
    // 
    // Bits[22:0], RW_V, default = 0x0
    //
    UINTX status : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER1_S_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER2_MC1LMSCH_REG                    0x000005D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Counter_Pointer is used in conjunction with Counter_Control to indicate what lane
    // or byte group is desired for tracking err. 
    // 
    // Bits[6:0], RW_LB, default = 0x7F
    //
    UINTX pntr : 7;
    //
    // Counter_Control determines what get counted by REUT_CH#_ERR_COUNTER#_VALUE.Counter_Value
    // 
    // Bits[8:7], RW_LB, default = 0x0
    //
    UINTX ctl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER2_S_MC1LMSCH_REG                  0x000005DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // REUT_CH#_ERR_COUNTER_STATUS indicates the current err counter value which is configured
    // by REUT_CH#_ERR_COUNTER#_CTL. 
    // 
    // Bits[22:0], RW_V, default = 0x0
    //
    UINTX status : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER2_S_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER3_MC1LMSCH_REG                    0x000005E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Counter_Pointer is used in conjunction with Counter_Control to indicate what lane
    // or byte group is desired for tracking err. 
    // 
    // Bits[6:0], RW_LB, default = 0x7F
    //
    UINTX pntr : 7;
    //
    // Counter_Control determines what get counted by REUT_CH#_ERR_COUNTER#_VALUE.Counter_Value
    // 
    // Bits[8:7], RW_LB, default = 0x0
    //
    UINTX ctl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER3_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER3_S_MC1LMSCH_REG                  0x000005E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // REUT_CH#_ERR_COUNTER_STATUS indicates the current err counter value which is configured
    // by REUT_CH#_ERR_COUNTER#_CTL. 
    // 
    // Bits[22:0], RW_V, default = 0x0
    //
    UINTX status : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER3_S_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER4_MC1LMSCH_REG                    0x000005E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Counter_Pointer is used in conjunction with Counter_Control to indicate what lane
    // or byte group is desired for tracking err. 
    // 
    // Bits[6:0], RW_LB, default = 0x7F
    //
    UINTX pntr : 7;
    //
    // Counter_Control determines what get counted by REUT_CH#_ERR_COUNTER#_VALUE.Counter_Value
    // 
    // Bits[8:7], RW_LB, default = 0x0
    //
    UINTX ctl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER4_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER4_S_MC1LMSCH_REG                  0x000005EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // REUT_CH#_ERR_COUNTER_STATUS indicates the current err counter value which is configured
    // by REUT_CH#_ERR_COUNTER#_CTL. 
    // 
    // Bits[22:0], RW_V, default = 0x0
    //
    UINTX status : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER4_S_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER5_MC1LMSCH_REG                    0x000005F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Counter_Pointer is used in conjunction with Counter_Control to indicate what lane
    // or byte group is desired for tracking err. 
    // 
    // Bits[6:0], RW_LB, default = 0x7F
    //
    UINTX pntr : 7;
    //
    // Counter_Control determines what get counted by REUT_CH#_ERR_COUNTER#_VALUE.Counter_Value
    // 
    // Bits[8:7], RW_LB, default = 0x0
    //
    UINTX ctl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER5_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER5_S_MC1LMSCH_REG                  0x000005F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // REUT_CH#_ERR_COUNTER_STATUS indicates the current err counter value which is configured
    // by REUT_CH#_ERR_COUNTER#_CTL. 
    // 
    // Bits[22:0], RW_V, default = 0x0
    //
    UINTX status : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER5_S_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER6_MC1LMSCH_REG                    0x000005F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Counter_Pointer is used in conjunction with Counter_Control to indicate what lane
    // or byte group is desired for tracking err. 
    // 
    // Bits[6:0], RW_LB, default = 0x7F
    //
    UINTX pntr : 7;
    //
    // Counter_Control determines what get counted by REUT_CH#_ERR_COUNTER#_VALUE.Counter_Value
    // 
    // Bits[8:7], RW_LB, default = 0x0
    //
    UINTX ctl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER6_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER6_S_MC1LMSCH_REG                  0x000005FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // REUT_CH#_ERR_COUNTER_STATUS indicates the current err counter value which is configured
    // by REUT_CH#_ERR_COUNTER#_CTL. 
    // 
    // Bits[22:0], RW_V, default = 0x0
    //
    UINTX status : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER6_S_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER7_MC1LMSCH_REG                    0x00000600
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Counter_Pointer is used in conjunction with Counter_Control to indicate what lane
    // or byte group is desired for tracking err. 
    // 
    // Bits[6:0], RW_LB, default = 0x7F
    //
    UINTX pntr : 7;
    //
    // Counter_Control determines what get counted by REUT_CH#_ERR_COUNTER#_VALUE.Counter_Value
    // 
    // Bits[8:7], RW_LB, default = 0x0
    //
    UINTX ctl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER7_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER7_S_MC1LMSCH_REG                  0x00000604
#ifndef ASM_INC
typedef union {
  struct {
    //
    // REUT_CH#_ERR_COUNTER_STATUS indicates the current err counter value which is configured
    // by REUT_CH#_ERR_COUNTER#_CTL. 
    // 
    // Bits[22:0], RW_V, default = 0x0
    //
    UINTX status : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER7_S_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER8_MC1LMSCH_REG                    0x00000608
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Counter_Pointer is used in conjunction with Counter_Control to indicate what lane
    // or byte group is desired for tracking err. 
    // 
    // Bits[6:0], RW_LB, default = 0x7F
    //
    UINTX pntr : 7;
    //
    // Counter_Control determines what get counted by REUT_CH#_ERR_COUNTER#_VALUE.Counter_Value
    // 
    // Bits[8:7], RW_LB, default = 0x0
    //
    UINTX ctl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER8_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_COUNTER8_S_MC1LMSCH_REG                  0x0000060C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // REUT_CH#_ERR_COUNTER_STATUS indicates the current err counter value which is configured
    // by REUT_CH#_ERR_COUNTER#_CTL. 
    // 
    // Bits[22:0], RW_V, default = 0x0
    //
    UINTX status : 23;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
  } Bits;
  UINTX Data;
} CPGC_ERR_COUNTER8_S_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_ERR_ECC_S_MC1LMSCH_REG                       0x00000610
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Each bit corresponds to a specific ECC lane.
    // 
    // Bits[15:0], RW_V, default = 0x0
    //
    UINTX status : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} CPGC_ERR_ECC_S_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define DDR4_CBIT_PARITY_MC1LMSCH_REG                     0x00000614
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per bit inclusion control for ddr4 Cbits in command/address parity generation.
    // i.e. if enable[0]=1, C[0] will be included in parity calculation. if enable[1]=1,
    // C[1] 
    // will be included; etc.
    // 
    // Bits[2:0], RW_LB, default = 0x0
    //
    UINTX enable : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 29;
  } Bits;
  UINTX Data;
} DDR4_CBIT_PARITY_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define BLEGR_CRDT_CTL_MC1LMSCH_REG                       0x00000618
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable use of reserved credit for transgress underfill read. Enable this reserved
    // credit means the credits in bl_egress_credit needs to be reduced by 1. 
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX enable_tgr_cr : 1;
    //
    // Enable use of reserved credit for IOT loopback write. Enable this reserved credit
    // means the credits in bl_egress_credit needs to be reduced by 1. 
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX enable_iot_cr : 1;
    //
    // Time (in number of DCLKs) after the reserved transgress credit is used that a
    // returned BL egress credit isn't destined for this reserved credit. Set to 0 to
    // disable the delay. 
    // 
    // Bits[13:2], RW_LB, default = 0x0
    //
    UINTX thresh_tgr_cr : 12;
    //
    // Time (in number of DCLKs) after the reserved iot write credit is used that a returned
    // BL egress credit isn't destined for this reserved credit. Set to 0 to disable
    // the delay. 
    // 
    // Bits[25:14], RW_LB, default = 0x0
    //
    UINTX thresh_iot_cr : 12;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // When set to 0, IOT DDRIO loopback is for tracing DDR4 write data; when set to
    // 1, IOT DDRIO loopback is for tracing DDRT write data. This field should be set
    // the same value as ddr_trace_throttle_ctl.iotlb_ddrt. 
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX iotlb_ddrt : 1;
  } Bits;
  UINTX Data;
} BLEGR_CRDT_CTL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MASK_RPQ0_MC1LMSCH_REG                            0x00000630
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Set a bit to 1 in this field to prevent the RPQ from allocating into the entry.
    // Each bit in the 24b field corresponds to one of the RPQ entry in Entries 23 to
    // 0 respectively. 
    // Bit 0 blocks RPQ entry 0 and Bit 23 masks RPQ entry 23 and so on.
    // 
    // Bits[23:0], RW_LB, default = 0x0
    //
    UINTX mask : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} MASK_RPQ0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MASK_RPQ1_MC1LMSCH_REG                            0x00000634
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Set a bit to 1 in this field to prevent the RPQ from allocating into the entry.
    // Each bit in the 24b field corresponds to one of the RPQ entry in Entries 47 to
    // 24 respectively. 
    // Bit 0 blocks RPQ entry 24 and Bit 23 masks RPQ entry 47 and so on.
    // 
    // Bits[23:0], RW_LB, default = 0x0
    //
    UINTX mask : 24;
    //
    // Set a bit to 1 in this field to prevent the WPQ from allocating into the entry
    // plus 32. 
    // Each bit in the 8 bit field corresponds to one of the upper WPQ Entries 39 to
    // 32 respectively. 
    // Bit 0 blocks WPQ entry 32 and Bit 7 masks WPQ entry 39 and so on.
    // 
    // Bits[31:24], RW_LB, default = 0x0
    //
    UINTX wpq_upper_mask : 8;
  } Bits;
  UINTX Data;
} MASK_RPQ1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MASK_WPQ_MC1LMSCH_REG                             0x00000638
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Set a bit to 1 in this field to prevent the WPQ from allocating into the entry.
    // Each bit in the 32b field corresponds to one of the 32 WPQ entries.
    // Bit 0 blocks WPQ entry 0 and Bit 31 masks WPQ entry 32 and so on. Note that
    // mask_rpq1 has a field named wpq_upper_mask to control the upper 8 entries of
    // the WPQ.
    // 
    // Bits[31:0], RW_LB, default = 0x0
    //
    UINTX mask : 32;
  } Bits;
  UINTX Data;
} MASK_WPQ_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MCSCHED_CHKN_BIT_MC1LMSCH_REG                     0x00000704
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Disable 2cyc bypass
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX dis_2cyc_byp : 1;
    //
    // Disable 1cyc bypass
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX dis_1cyc_byp : 1;
    //
    // Disable opp isoch cas
    // 
    // Bits[2:2], RW_LB, default = 0x0
    //
    UINTX dis_opp_isoc_cas : 1;
    //
    // Disable opp isoch ras
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX dis_opp_isoc_ras : 1;
    //
    // Disable opp cas
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX dis_opp_cas : 1;
    //
    // Disable Opportunity RAS
    // 
    // Bits[5:5], RW_LB, default = 0x0
    //
    UINTX dis_opp_ras : 1;
    //
    // Disable partial write starvation
    // 
    // Bits[6:6], RW_LB, default = 0x0
    //
    UINTX dis_prtl_wr_strvn : 1;
    //
    // Disable block ph
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX dis_blck_ph : 1;
    //
    // Disable block pe
    // 
    // Bits[8:8], RW_LB, default = 0x0
    //
    UINTX dis_blck_pe : 1;
    //
    // Disable block pm
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX dis_blck_pm : 1;
    //
    // Command Output Enable is always off
    // 
    // Bits[10:10], RW_LB, default = 0x0
    //
    UINTX cmd_oe_alwy_off : 1;
    //
    // Cmd output enable always on
    // 
    // Bits[11:11], RW_LB, default = 0x0
    //
    UINTX cmd_oe_alwy_on : 1;
    //
    // Enable One-shot ECC injection for VMSE
    // 
    // Bits[12:12], RW_LB, default = 0x0
    //
    UINTX defeature_2 : 1;
    //
    // 0: Poison entire cacheline when any CW is poisoned. Recommended operation.
    //                      1: Poison only CW which has poison bit set.
    //         
    // 
    // Bits[13:13], RW_LB, default = 0x0
    //
    UINTX defeature_3 : 1;
    //
    // Disable aom
    // 
    // Bits[14:14], RW_LB, default = 0x0
    //
    UINTX dis_aom : 1;
    //
    // Override ODT output to IO
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX ovrd_odt_to_io : 1;
    //
    // Disable rdimm DDR4 Command Parity Generation
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX dis_rdimm_par_gen : 1;
    //
    // Disable Partial Write Major Mode
    // Note: this chicken bit should not be enabled when mirror mode is enabled - it
    // will cause a deadlock. 
    // 
    // Bits[17:17], RW_LB, default = 0x0
    //
    UINTX dis_pwmm : 1;
    //
    // Never cancel
    // 
    // Bits[18:18], RW_LB, default = 0x0
    //
    UINTX never_cancel : 1;
    //
    // Disable Clock Gate in Scheduler
    // 
    // Bits[19:19], RW_LB, default = 0x0
    //
    UINTX dis_ck_gate_sched : 1;
    //
    // Disable dummy CAS short latency
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX dep_rd_latency_opt : 1;
    //
    // N/A
    // 
    // Bits[21:21], RW_LB, default = 0x0
    //
    UINTX rpq_ring_cntr_dis : 1;
    //
    // Disable RPQ SA age tracking counter
    // 
    // Bits[22:22], RW_LB, default = 0x0
    //
    UINTX rpq_sa_cntr_dis : 1;
    //
    // Set this bit to exit WMM when there are no further starved partial writes if we
    // entered WMM due to starved partials (as opposed to entering WMM due to a high
    // level of writes in the WPQ). 
    // 
    // Bits[23:23], RW_LB, default = 0x0
    //
    UINTX dis_pwr_wmm_exit : 1;
    //
    // Write Isoch and starvation priority. When set to 1, isoch is the hightest priority
    // write priority. When set to 0, partial write major mode and write major mode starvation
    // are higher priorities than write isoch. 
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX pri_starvation_wim : 1;
    //
    // Disable page table idle counters.
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX dis_pgt_tmr : 1;
    //
    // Disable special code to use last entry of RPQ0
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX dis_rpq0_last_entry : 1;
    //
    // Disable use of RPQ1
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX dis_rpq1 : 1;
    //
    // Disable sharing of WMM state between 2 schedulers in Intel SMI 2 2:1 mode
    // 
    // Bits[28:28], RW_LB, default = 0x0
    //
    UINTX dis_wmm2to1 : 1;
    //
    // Disable rdimm DDRT Command Parity Generation
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX dis_ddrt_par_gen : 1;
    //
    // Reserved for future use.
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX def_0 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX def_1 : 1;
  } Bits;
  UINTX Data;
} MCSCHED_CHKN_BIT_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MCSCHED_CHKN_BIT2_MC1LMSCH_REG                    0x00000708
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Disable ddrio powr down due to Channel in selfrefresh (bit 1) or channel in cke
    // powerdown (bit 0) 
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX dis_ddrio_pwdn : 2;
    //
    // Disable ddrio anti resonance logic; bit 0 is for receive path; bit 1 is for transmit
    // path. 
    // If set to 1, path will be enabled all the time; IF cleared to 0, An op in 311H
    // will set the 
    // enable and expirtion of a counter will clear the enable; each path has its own
    // counter. 
    // 
    // Bits[3:2], RW_LB, default = 0x3
    //
    UINTX dis_ddrio_ares : 2;
    //
    // Disable use of starve counter in WPQ for full writes.
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX dis_wr_starve : 1;
    //
    // Disable PRE blocking one cycle after new request for PHExist condition.
    // 
    // Bits[5:5], RW_LB, default = 0x0
    //
    UINTX dis_ph_block : 1;
    //
    // Disable RCB Clock Gate in RPQ
    // 
    // Bits[6:6], RW_LB, default = 0x0
    //
    UINTX dis_rpq_pri_rcb_gate : 1;
    //
    // Disable RCB Clock Gate in WPQ
    // 
    // Bits[7:7], RW_LB, default = 0x0
    //
    UINTX dis_wpq_pri_rcb_gate : 1;
    //
    // Disable RCB Clock Gate in GS
    // 
    // Bits[8:8], RW_LB, default = 0x0
    //
    UINTX dis_gs_pri_rcb_gate : 1;
    //
    // Disable RCB Clock Gate in PGT
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX dis_pgt_pri_rcb_gate : 1;
    //
    // Disable RCB Clock Gate in ODT
    // 
    // Bits[10:10], RW_LB, default = 0x0
    //
    UINTX dis_odt_pri_rcb_gate : 1;
    //
    // Disable RCB Clock Gate in Safe
    // 
    // Bits[11:11], RW_LB, default = 0x0
    //
    UINTX dis_safe_pri_rcb_gate : 1;
    //
    // Disable RCB Clock Gate in Misc
    // 
    // Bits[12:12], RW_LB, default = 0x0
    //
    UINTX dis_misc_pri_rcb_gate : 1;
    //
    // Disable merged write into a preempted WPQ entry from not setting pagetable WPQPH.
    // When this bit is one the machine will set the WPQPH bit in the page table even
    // though there may be no page hit in the WPQ. This will result in the rank being
    // locked up until a refresh event comes along. 
    // 
    // Bits[13:13], RW_LB, default = 0x0
    //
    UINTX dis_wpqpp_on_preempt_merge : 1;
    //
    // Disable the fix for ODT when enable_pda_doublelength is 1 (HSX HSD273201)
    // 
    // Bits[14:14], RW_LB, default = 0x0
    //
    UINTX dis_odt_pda_dl : 1;
    //
    // 
    //          Set to 1 to force DDR4 scheduler to issue an Ack for a pcommit 
    //         
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX force_pcommit_ack : 1;
    //
    // 
    //          Set to 1 to for DDR4 scheduler to ignore pcommit command
    //         
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX ignore_pcommit : 1;
    //
    // 
    //          Default behavior is for pcommit acks to be blocked once a
    //          channel hits link fail condition. If this bit is set, MC will send an
    //          ACK for pcommit even in link fail condition. This bit is used
    //          for pcommits directed to NVDIMMs.
    //         
    // 
    // Bits[17:17], RW_LB, default = 0x0
    //
    UINTX pcommit_ack_for_linkfail : 1;
    //
    // Delay between primary and buddy command from WPQ in ADDDC mode; actual delay is
    // programmed value + 6 
    // 
    // Bits[21:18], RW_LB, default = 0x4
    //
    UINTX adddc_wpq_dly : 4;
    //
    // Delay between primary and buddy command from WPQ in x8 SDDC mode; actual delay
    // is programmed value + 6 
    // 
    // Bits[25:22], RW_LB, default = 0x8
    //
    UINTX x8_wpq_dly : 4;
    //
    // 
    //          Set to 1 to enable full write starvation when pcommit is not pending
    //         
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX enable_fwstarve : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    //  Set to 1 to not allow patrol to be issued during PmRsBlock
    // 
    // Bits[28:28], RW_LB, default = 0x0
    //
    UINTX dis_pat_pmrsblock : 1;
    //
    //  Set to 1 to clear the ADDDCPlusOneEn signal that results in 2 cycle delay in
    // read datapath; software need to clear this bit to 0 after setting it to 1 
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX clear_adddc_plusone_en : 1;
    //
    //  Set to 1 to clear the dev_sub_en signal that results in 1 cycle delay in read
    // datapath; software need to clear this bit to 0 after setting it to 1 
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX clear_dev_sub_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
  } Bits;
  UINTX Data;
} MCSCHED_CHKN_BIT2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MCSCHED_RCB_GATE_CTL_MC1LMSCH_REG                 0x0000070C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Time clock keeps running after triggering events
    // 
    // Bits[9:0], RW_LB, default = 0x40
    //
    UINTX rcb_gate_mcsched_timer : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 22;
  } Bits;
  UINTX Data;
} MCSCHED_RCB_GATE_CTL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define SVID_MC1LMSCH_REG                                 0x0000002C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The default value specifies Intel but can be set to any value once after reset.
    // 
    // Bits[15:0], RW_O, default = 0x8086
    //
    UINTX subsystem_vendor_identification_number : 16;
  } Bits;
  UINTX Data;
} SVID_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define SDID_MC1LMSCH_REG                                 0x0000002E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Assigned by the subsystem vendor to uniquely identify the subsystem
    // 
    // Bits[15:0], RW_O, default = 0x0
    //
    UINTX subsystem_device_identification_number : 16;
  } Bits;
  UINTX Data;
} SDID_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PXPCAP_MC1LMSCH_REG                               0x00000040
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Provides the PCI Express capability ID assigned by PCI-SIG.
    // 
    // Bits[7:0], RO, default = 0x10
    //
    UINTX capability_id : 8;
    //
    // Pointer to the next capability. Set to 0 to indicate there are no more capability
    // structures. 
    // 
    // Bits[15:8], RO, default = 0x0
    //
    UINTX next_ptr : 8;
    //
    // PCI Express Capability is Compliant with Version 1.0 of the PCI Express Spec.
    // Note:
    // This capability structure is not compliant with Versions beyond 1.0, since they
    // require additional capability registers to be reserved. The only purpose for this
    // capability structure is to make enhanced configuration space available. Minimizing
    // the size of this structure is accomplished by reporting version 1.0 compliancy
    // and reporting that this is an integrated root port device. As such, only three
    // Dwords of configuration space are required for this structure. 
    // 
    // Bits[19:16], RO, default = 0x1
    //
    UINTX capability_version : 4;
    //
    // Device type is Root Complex Integrated Endpoint
    // 
    // Bits[23:20], RO, default = 0x9
    //
    UINTX device_port_type : 4;
    //
    // N/A for integrated endpoints
    // 
    // Bits[24:24], RO, default = 0x0
    //
    UINTX slot_implemented : 1;
    //
    // N/A for this device
    // 
    // Bits[29:25], RO, default = 0x0
    //
    UINTX interrupt_message_number : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} PXPCAP_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PXPENHCAP_MC1LMSCH_REG                            0x00000100
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Indicates there are no capability structures in the enhanced configuration space.
    // 
    // Bits[15:0], RO, default = 0x0
    //
    UINTX capability_id : 16;
    //
    // Indicates there are no capability structures in the enhanced configuration space.
    // 
    // Bits[19:16], RO, default = 0x0
    //
    UINTX capability_version : 4;
    //
    // N/A
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX next_capability_offset : 12;
  } Bits;
  UINTX Data;
} PXPENHCAP_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define SCRATCHPAD_MC1LMSCH_REG                           0x000001CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SCRATCHPAD
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX scratchpad : 32;
  } Bits;
  UINTX Data;
} SCRATCHPAD_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MC_TERM_RNK_MSK_MC1LMSCH_REG                      0x000001D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Physical Rank Mask to select which rank is used in the termination rank. BIOS
    // program the PHYSICAL rank select for the termination rank from each DIMM. It is
    // important to note that this is the PHYSICAL CS# mapping instead of the LOGICAL
    // rank mapping. 
    // Here is the recommended programming method:
    // Deciding and selecting the termination rank on each populated DIMM. For simplicity,
    // BIOS can always select rank 0 of each populated DIMM as the termination rank unless
    // rank 0 is marked as bad rank. 
    // Note: BIOS may also optionally enable rank interleaving to separate the termination
    // ranks and non-termination ranks so OS can map more frequently used address ranges
    // into the RIR with termination ranks while mapping less frequently used address
    // ranges into RIR with non-termination ranks. This mapping enables a better power
    // optimization to exploit our PPD-S capability. 
    // BIOS must also keep RD_ODT_TBL0-2 and WR_ODT_TBL0-2 consistent. Please refer to
    // those registers for further details. 
    // This field CAN NOT be set as all zeros for populated channel. Min one termination
    // rank per DIMM. It has match rank occupancy for the ranks set as '1'. 
    // 
    // 
    // Bits[9:0], RW, default = 0x111
    //
    UINTX term_rnk_msk : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // PPDS idle counter after all rank's rank idle counters (PDWN_IDEL_CNTR) have been
    // expired. 
    // 
    // Bits[31:16], RW, default = 0x1FF
    //
    UINTX ch_ppds_idle_timer : 16;
  } Bits;
  UINTX Data;
} MC_TERM_RNK_MSK_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PM_ADR_MC1LMSCH_REG                               0x000001E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Configures the number of power fail commands are sent on DDR-T to the FMC during
    // a DDR-T ADR Event. 
    // 
    // Bits[3:0], RW, default = 0x3
    //
    UINTX num_pwr_fail_cmds : 4;
    //
    //  When set, channel will enter DDR-T ADR flow when in 1LM Mode when ADR event seen.
    // Note: must be set when in 2LM Mode. Channel should always do DDR-T ADR in 2LM
    // mode. 
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX ddrt_adr_en : 1;
    //
    //  Specifies the S-state for DDR-T S-State command that should be sent as an early
    // warning to FMC. Default value is 001 = ADR.  
    // 
    // Bits[7:5], RW, default = 0x1
    //
    UINTX ddrt_early_warning_s_state : 3;
    //
    //  Specifies how long to wait after wpq entries are stale and no wpq command has
    // won arbitration before considering the wpq drained. Used for both DDR ADR and
    // DDR-T ADR.  
    // 
    // Bits[15:8], RW, default = 0xFF
    //
    UINTX drain_wpq_wait : 8;
    //
    //  Specifies the minimum amount of time to wait between scheduling power fail commands
    // on the same rank. A value of 0 disables this feature.  
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX t_between_power_fail_cmds : 4;
    //
    //  This field defines number of DCLK of wait time after PCU asserts AsyncSR before
    // telling the refresh FSMs to start a DDR-T ADR flow.  
    // 
    // Bits[24:20], RW, default = 0x0
    //
    UINTX ddrt_adr_sref_timer : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} PM_ADR_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TCRFP_MC1LMSCH_REG                                0x00000210
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rank idle period that defines an opportunity for refresh, in DCLK cycles
    // 
    // Bits[7:0], RW, default = 0x3F
    //
    UINTX orefni : 8;
    //
    // tREFI count level that turns the refresh priority to high (default is 8)
    // 
    // Bits[14:8], RW, default = 0x8
    //
    UINTX ref_hi_wm : 7;
    //
    // tREFI count level in which the refresh priority is panic (default is 9)
    // It is recommended to set the panic WM at least to 9, in order to utilize the maximum
    // no-refresh period possible 
    // 
    // Bits[21:15], RW, default = 0x9
    //
    UINTX ref_panic_wm : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
    //
    // When set to 1, this field will disable the reload of the remaining refresh counter
    // to at least 3dsref_stack_size during native C/A parity recovery. 
    // 
    // Bits[30:30], RW, default = 0x1
    //
    UINTX dis_reload_err_recov : 1;
    //
    // When set to 1, this field will disable the reload of the high water mark value
    // into the remaining refresh counter during native C/A parity recovery. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX dis_reload_hi_wm_err_recov : 1;
  } Bits;
  UINTX Data;
} TCRFP_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TCRFTP_MC1LMSCH_REG                               0x00000214
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Defines the average period between refreshes in DCLK cycles. This register defines
    // the upper 15b of the 16b tREFI counter limit. The least significant bit of the
    // counter limit is always zero. 
    // Here are the recommended T_REFI[14:0] setting for 7.8 usec:
    // 0800MT/s : 0C30h
    // 1067MT/s : 1040h
    // 1333MT/s : 1450h
    // 1600MT/s : 1860h
    // 1867MT/s : 1C70h
    // 
    // Bits[14:0], RW, default = 0x62C
    //
    UINTX t_refi : 15;
    //
    // Time of refresh - from beginning of refresh until next ACT or refresh is allowed
    // (in DCLK cycles) 
    // Here are the recommended T_RFC for 2Gb DDR3:
    // 0800MT/s : 040h
    // 1067MT/s : 056h
    // 1333MT/s : 06Bh
    // 1600MT/s : 080h
    // 1867MT/s : 096h
    // 
    // Bits[24:15], RW, default = 0x80
    //
    UINTX t_rfc : 10;
    //
    // period of min between 9*T_REFI and tRAS maximum (normally 70 us) in 1024 * DCLK
    // cycles.The default value will need to reduce 100 DCLK cycles - uncertainty on
    // timing of panic refresh 
    // 
    // Bits[31:25], RW, default = 0x9
    //
    UINTX t_refix9 : 7;
  } Bits;
  UINTX Data;
} TCRFTP_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TCSRFTP_MC1LMSCH_REG                              0x00000218
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Exit Self Refresh to commands requiring a locked DLL in the range of 128 to 4095
    // DCLK cycles 
    // 
    // Bits[11:0], RW, default = 0x100
    //
    UINTX t_xsdll : 12;
    //
    // tXS = T_RFC+10ns. Setup of T_XSOFFSET is # of cycles for 10 ns. Range is between
    // 3 and 11 DCLK cycles 
    // 
    // Bits[15:12], RW, default = 0xB
    //
    UINTX t_xsoffset : 4;
    //
    // Normal operation Full calibration time
    // 
    // Bits[25:16], RW, default = 0x100
    //
    UINTX t_zqoper : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[26:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Mode Register Set command update delay.
    // 
    // Bits[31:27], RW, default = 0xC
    //
    UINTX t_mod : 5;
  } Bits;
  UINTX Data;
} TCSRFTP_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TCMR2SHADOW_MC1LMSCH_REG                          0x0000021C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Copy of MR2 A[5:0] shadow
    // 
    // Bits[5:0], RW, default = 0x18
    //
    UINTX mr2_shdw_a5to0 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Copy of MR2 A[6] shadow which defines per DIMM availability of ASR mode - set
    // if Auto Self-Refresh (ASR) is supported, otherwise cleared 
    // Bit 10: Dimm 2
    // Bit 9: Dimm 1
    // Bit 8: Dimm 0
    // 
    // Bits[10:8], RW, default = 0x0
    //
    UINTX mr2_shdw_a6_asr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Copy of MR2 A[7] shadow which defines per DIMM availability of SRT mode - set
    // if extended temperature range and ASR is not supported, otherwise cleared 
    // Bit 14: Dimm 2
    // Bit 13: Dimm 1
    // Bit 12: Dimm 0
    // 
    // Bits[14:12], RW, default = 0x0
    //
    UINTX mr2_shdw_a7_srt : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Copy of MR2 A[15:8] shadow.
    // Bit 23-19: zero, copy of MR2 A[15:11], reserved for future JEDEC use
    // Bit 18-17: Rtt_WR, i.e. copy of MR2 A[10:9]
    // Bit 16: zero, copy of MR2 A[8], reserved for future JEDEC use
    // 
    // Bits[23:16], RW, default = 0x2
    //
    UINTX mr2_shdw_a15to8 : 8;
    //
    // Each bit is set in case of the corresponding 2-rank UDIMM or certain LRDIMM requires
    // address mirroring/swizzling. It indicates that some of the address bits are swizzled
    // for rank 1 (or rank 3), and this has to be considerred in MRS command. The address
    // swizzling bits: 
    // A3 and A4
    // A5 and A6
    // A7 and A8
    // A11 and A13 (ddr4 only)
    // BA0 and BA1
    // BG0 and BG1 (ddr4 only)
    // Bit 24 refers to DIMM 0
    // Bit 25 refers to DIMM 1
    // Bit 26 refers to DIMM 2
    // 
    // Bits[26:24], RW_LV, default = 0x0
    //
    UINTX addr_bit_swizzle : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 4;
    //
    // THis bit is added for ddr4 rdimm,lrdimm,3ds support. Unlike ddr3 and udimm ddr4;
    // these devices use Address inversion which requires host 
    // to issue 2 MRS to support these devices. THis bit only affects MR0/MR2/MR5 issued
    // by RTL as a partof normal operation. Those MRS issued by 
    // CPGC engine are not affected by this bit.
    // If this bit =0, only one MRS will be sent to the target chip_select. If 1, two
    // back to back MRS will be sent to the traget chip_select once 
    // for A-side and once for B-side.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX two_mrs_en : 1;
  } Bits;
  UINTX Data;
} TCMR2SHADOW_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TCZQCAL_MC1LMSCH_REG                              0x00000220
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Time between ZQ-FSM initiated ZQCS operations in tREFI*128 (2 to 255, default
    // is 128). 
    // Note: ZQCx is issued at SRX.
    // 
    // Bits[7:0], RW, default = 0x80
    //
    UINTX zqcsperiod : 8;
    //
    // tZQCS in DCLK cycles (32 to 255, default is 64)
    // 
    // Bits[15:8], RW, default = 0x40
    //
    UINTX t_zqcs : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} TCZQCAL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TCSTAGGER_REF_MC1LMSCH_REG                        0x00000224
#ifndef ASM_INC
typedef union {
  struct {
    //
    // tRFC like timing constraint parameter except it is a timing constraint applicable
    // to REF-REF separation between different ranks on a channel. 
    // It is recommended to set T_STAGGER_REF equal or less than the TRFC parameter which
    // is defined as: 
    // 0800MT/s : 040h
    // 1067MT/s : 056h
    // 1333MT/s : 06Bh
    // 1600MT/s : 080h
    // 1867MT/s : 096h
    // For 3DS DIMMs, it should be programmed with mimimum 3DCLKs
    // 
    // Bits[9:0], RW, default = 0x80
    //
    UINTX t_stagger_ref : 10;
    //
    // 3DS specific field.tRFC like timing constraint parameter except it is a timing
    // constraint applicable to REF-REF separation between different sub-ranks/slices
    // within a stack of a 3DS DIMM. Typical value is tRFC/3 on a channel. 
    // 
    // 
    // Bits[19:10], RW, default = 0x80
    //
    UINTX t_shrtloop_stagger_ref : 10;
    //
    // 3DS specific field. Number of short loop with the time gap of t_shrtloop_stagger_ref
    // in a single full loop of refresh FSM. 
    // 
    // Bits[22:20], RW, default = 0x0
    //
    UINTX t_shrtloop_num : 3;
    //
    // N/A
    // 
    // Bits[25:23], RW, default = 0x0
    //
    UINTX maxnum_active_reffsm : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
  } Bits;
  UINTX Data;
} TCSTAGGER_REF_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TCMR0SHADOW_MC1LMSCH_REG                          0x0000022C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // BIOS programs this field for MR0 register A12:A0 for all DIMMs in this channel.
    // IMC hardware is dynamically issuing MRS to MR0 to control the fast and slow exit
    // PPD (MRS MR0 A12). Other address bits (A[11:0]) are defined by this register field.
    // A15:A13 are always zero. 
    // 
    // Bits[12:0], RW, default = 0x0
    //
    UINTX mr0_shadow : 13;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 19;
  } Bits;
  UINTX Data;
} TCMR0SHADOW_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TCMR5SHADOW_MC1LMSCH_REG                          0x00000230
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This CR holds a copy of MR5 register value programmed during MRC. This gets written
    // by BIOS. This is is to support the C/A parity error flag clearing in DRAMs. In
    // DDR4 mode(Both Native and Intel SMI 2), C/A Errors involves a error flow and end
    // of that flow requires MR5 to be updated with 0 in A[4]. A[12:5} and A[3:0] should
    // remain what it was during MRC. 
    // 
    // Bits[12:0], RW, default = 0x0
    //
    UINTX mr5_shadow : 13;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 19;
  } Bits;
  UINTX Data;
} TCMR5SHADOW_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TCMR3SHADOW_MC1LMSCH_REG                          0x00000234
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This CR holds a copy of MR3 register (or F0BC1X register for ddr4 lrdimm devices).
    // This register is not 
    // used by hardware directly. THe intent is that MRC writes the value of MR3 or F0B1CX
    // into this register 
    // such that EV params utilities can read this and modify only PDA bit (or PBA for
    // lrdimms) and write it 
    // into CADB as part of Vref margining algorithms used while os is running. DDR4
    // and DDR4 buffer specs 
    // should be referenced to get the latest bit position for PDA/PBA.
    // 
    // Bits[12:0], RW, default = 0x0
    //
    UINTX mr3_shadow : 13;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 19;
  } Bits;
  UINTX Data;
} TCMR3SHADOW_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define RDIMMTIMINGCNTL_MC1LMSCH_REG                      0x0000023C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Command word to command word programming delay in DCLK
    // 
    // Bits[3:0], RW, default = 0x8
    //
    UINTX t_mrd : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 12;
    //
    // Stablizing time in number of DCLK, i.e. the DCLK must be stable for T_STAB before
    // any access to the device take place. 
    // tCKSRX is included in the T_STAB programming since there is not a separate tCKSRX
    // parameter control to delay self-refresh exit latency from clock stopped conditions.
    // zero value in T_STAB is reserved and it is important to AVOID programming a zero
    // value in the T_STAB. 
    // Recommended settings (Note: contains stretch goal and/or over-clock frequency
    // examples): 
    // FREQ T_STAB for RDIMM (including tCKSRX value)
    // 0800 0960h+5h=0965h
    // 1067 0C80h+5h=0c85h
    // 1333 0FA0h+7h=0FA7h
    // 1600 12C0h+8h=12C8h
    // 1867 15E0h+Ah=15EAh
    // 2133 1900h+Bh=190Bh
    // FREQ T_STAB for UDIMM (i.e. tCKSRX value)
    // 0800 5h
    // 1067 5h
    // 1333 7h
    // 1600 8h
    // 1867 Ah
    // 2133 Bh
    // 
    // Bits[28:16], RW, default = 0x12C0
    //
    UINTX t_stab : 13;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
  } Bits;
  UINTX Data;
} RDIMMTIMINGCNTL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define RDIMMTIMINGCNTL2_MC1LMSCH_REG                     0x00000240
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // Input buffers (DCKE0 and DCKE1) disable time (float) after Ck/CK# = LOW
    // (not needed since DDRIO cannot program the CKE to be tristated.
    // 
    // Bits[7:4], RW, default = 0x2
    //
    UINTX t_ckev : 4;
    //
    // tCKOFF timing parameter:
    // Number of tCK required for both DCKE0 and DCKE1 to remain LOW before both CK/CK#
    // are driven Low 
    // Old minimum setting is 2.
    // With cmd/address parity error recovery enabled. THis shold be set a number large
    // enough to assure that parity error 
    // on a self refresh entry has enough time to get back into MC and start the recovery
    // before clocks are turned off 
    //         
    // 
    // Bits[12:8], RW, default = 0x5
    //
    UINTX t_ckoff : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 19;
  } Bits;
  UINTX Data;
} RDIMMTIMINGCNTL2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TCMRS_MC1LMSCH_REG                                0x00000244
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DDR3 tMRD timing parameter. MRS to MRS minimum delay in number of DCLK.
    // 
    // Bits[3:0], RW, default = 0x8
    //
    UINTX tmrd_ddr3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 28;
  } Bits;
  UINTX Data;
} TCMRS_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CPGC_PDA_SHADOW_MC1LMSCH_REG                      0x00000248
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 20;
    //
    // This field is the logical rank select for PDA transaction and should match the
    // same field 
    // in CPGC_PDA register and should be set to match Chip Select fields programmed
    // into 
    // CADB for this transaction.
    // 
    // Bits[22:20], RW_LB, default = 0x0
    //
    UINTX rank_select : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 9;
  } Bits;
  UINTX Data;
} CPGC_PDA_SHADOW_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ERF_DDR4_CMD_REG0_MC1LMSCH_REG                    0x0000024C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field holds the command field which goes through address(A) pins of DDR4
    // interface . 
    // 
    // Bits[12:0], RW, default = 0x0
    //
    UINTX ad : 13;
    //
    // This field holds the command field which goes through BA pins of DDR4 interface
    // . 
    // 
    // Bits[16:13], RW, default = 0x0
    //
    UINTX bank : 4;
    //
    // This field holds the RAS#,CAS#,WE# fields of DDR4 interface
    // 
    // Bits[19:17], RW, default = 0x0
    //
    UINTX rcw : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
    //
    // If this field is set to 1, the content of this register should be given to register
    // part of the dimm OR only one rank of the dimm. Other wise the command should be
    // given to all the ranks of the channel. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX rdimm : 1;
    //
    // This field enables this register. The Error flow FSM uses the contents of this
    // register only if en bit is set. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} ERF_DDR4_CMD_REG0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ERF_DDR4_CMD_REG1_MC1LMSCH_REG                    0x00000250
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field holds the command field which goes through address(A) pins of DDR4
    // interface . 
    // 
    // Bits[12:0], RW, default = 0x0
    //
    UINTX ad : 13;
    //
    // This field holds the command field which goes through BA pins of DDR4 interface
    // . 
    // 
    // Bits[16:13], RW, default = 0x0
    //
    UINTX bank : 4;
    //
    // This field holds the RAS#,CAS#,WE# fields of DDR4 interface
    // 
    // Bits[19:17], RW, default = 0x0
    //
    UINTX rcw : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
    //
    // If this field is set to 1, the content of this register should be given to register
    // part of the dimm OR only one rank of the dimm. Other wise the command should be
    // given to all the ranks of the channel. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX rdimm : 1;
    //
    // This field enables this register. The Error flow FSM uses the contents of this
    // register only if en bit is set. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} ERF_DDR4_CMD_REG1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ERF_DDR4_CMD_REG2_MC1LMSCH_REG                    0x00000254
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field holds the command field which goes through address(A) pins of DDR4
    // interface . 
    // 
    // Bits[12:0], RW, default = 0x0
    //
    UINTX ad : 13;
    //
    // This field holds the command field which goes through BA pins of DDR4 interface
    // . 
    // 
    // Bits[16:13], RW, default = 0x0
    //
    UINTX bank : 4;
    //
    // This field holds the RAS#,CAS#,WE# fields of DDR4 interface
    // 
    // Bits[19:17], RW, default = 0x0
    //
    UINTX rcw : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
    //
    // If this field is set to 1, the content of this register should be given to register
    // part of the dimm OR only one rank of the dimm. Other wise the command should be
    // given to all the ranks of the channel. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX rdimm : 1;
    //
    // This field enables this register. The Error flow FSM uses the contents of this
    // register only if en bit is set. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} ERF_DDR4_CMD_REG2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ERF_DDR4_CMD_REG3_MC1LMSCH_REG                    0x00000258
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field holds the command field which goes through address(A) pins of DDR4
    // interface . 
    // 
    // Bits[12:0], RW, default = 0x0
    //
    UINTX ad : 13;
    //
    // This field holds the command field which goes through BA pins of DDR4 interface
    // . 
    // 
    // Bits[16:13], RW, default = 0x0
    //
    UINTX bank : 4;
    //
    // This field holds the RAS#,CAS#,WE# fields of DDR4 interface
    // 
    // Bits[19:17], RW, default = 0x0
    //
    UINTX rcw : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
    //
    // If this field is set to 1, the content of this register should be given to register
    // part of the dimm OR only one rank of the dimm. Other wise the command should be
    // given to all the ranks of the channel. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX rdimm : 1;
    //
    // This field enables this register. The Error flow FSM uses the contents of this
    // register only if en bit is set. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} ERF_DDR4_CMD_REG3_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ERF_DDR4_CMD_REG4_MC1LMSCH_REG                    0x0000026C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[12:0], RW, default = 0x0
    //
    UINTX ad : 13;
    //
    // N/A
    // 
    // Bits[16:13], RW, default = 0x0
    //
    UINTX bank : 4;
    //
    // N/A
    // 
    // Bits[19:17], RW, default = 0x0
    //
    UINTX rcw : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
    //
    // N/A
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX rdimm : 1;
    //
    // N/A
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} ERF_DDR4_CMD_REG4_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ERF_DDR4_CMD_REG5_MC1LMSCH_REG                    0x000002A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[12:0], RW, default = 0x0
    //
    UINTX ad : 13;
    //
    // N/A
    // 
    // Bits[16:13], RW, default = 0x0
    //
    UINTX bank : 4;
    //
    // N/A
    // 
    // Bits[19:17], RW, default = 0x0
    //
    UINTX rcw : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
    //
    // N/A
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX rdimm : 1;
    //
    // N/A
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} ERF_DDR4_CMD_REG5_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ERF_DDR4_CMD_REG6_MC1LMSCH_REG                    0x000002A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[12:0], RW, default = 0x0
    //
    UINTX ad : 13;
    //
    // N/A
    // 
    // Bits[16:13], RW, default = 0x0
    //
    UINTX bank : 4;
    //
    // N/A
    // 
    // Bits[19:17], RW, default = 0x0
    //
    UINTX rcw : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
    //
    // N/A
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX rdimm : 1;
    //
    // N/A
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} ERF_DDR4_CMD_REG6_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ERF_DDR4_CMD_REG7_MC1LMSCH_REG                    0x000002AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[12:0], RW, default = 0x0
    //
    UINTX ad : 13;
    //
    // N/A
    // 
    // Bits[16:13], RW, default = 0x0
    //
    UINTX bank : 4;
    //
    // N/A
    // 
    // Bits[19:17], RW, default = 0x0
    //
    UINTX rcw : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 10;
    //
    // N/A
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX rdimm : 1;
    //
    // N/A
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} ERF_DDR4_CMD_REG7_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MCCKEVISACFG_MC1LMSCH_REG                         0x00000340
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RWS_L, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RWS_L, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RWS_L, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RWS_L, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RWS_L, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCCKEVISACFG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MCMNTVISACFG_MC1LMSCH_REG                         0x00000348
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RWS_L, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RWS_L, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RWS_L, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RWS_L, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RWS_L, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCMNTVISACFG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MCREFVISACFG_MC1LMSCH_REG                         0x0000034C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RWS_L, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RWS_L, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RWS_L, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RWS_L, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RWS_L, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCREFVISACFG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MCMNT_CHKN_BIT2_MC1LMSCH_REG                      0x00000620
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Disable RCB Clock Gate in CKE
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX dis_cke_pri_rcb_gate : 1;
    //
    // Disable RCB Clock Gate in THR
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX dis_thr_pri_rcb_gate : 1;
    //
    // Disable RCB Clock Gate in REF
    // 
    // Bits[2:2], RW_LB, default = 0x0
    //
    UINTX dis_ref_pri_rcb_gate : 1;
    //
    // Disable blocking of aliased rank during PREALL states
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX dis_alias_preall_blk : 1;
    //
    // Disable blocking of high priority refresh due to tstagger_ref.maxnum_active_reffsm
    // is reached 
    // 
    // Bits[4:4], RW_LB, default = 0x1
    //
    UINTX dis_hpref_blk : 1;
    //
    // Disable blocking of panic refresh due to tstagger_ref.maxnum_active_reffsm is
    // reached 
    // 
    // Bits[5:5], RW_LB, default = 0x1
    //
    UINTX dis_panicref_blk : 1;
    //
    // Disable blocking of stolen refresh due to tstagger_ref.maxnum_active_reffsm is
    // reached 
    // 
    // Bits[6:6], RW_LB, default = 0x1
    //
    UINTX dis_stolenref_blk : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 25;
  } Bits;
  UINTX Data;
} MCMNT_CHKN_BIT2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MCMNT_RCB_GATE_CTL_MC1LMSCH_REG                   0x00000624
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Time clock keeps running after triggering events
    // 
    // Bits[9:0], RW_LB, default = 0x40
    //
    UINTX rcb_gate_mcmnt_timer : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 22;
  } Bits;
  UINTX Data;
} MCMNT_RCB_GATE_CTL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define SREF_STATIC2_MC1LMSCH_REG                         0x0000063C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                 This field defines delay from PM Idle to CKE low to make sure
    // FNV decodes the 
    //                 command. This CSR should cover the round trip latency to decode
    // the 
    //                 command, check for Error and drive the Error signal back to the
    // host. 
    //                 
    // 
    // Bits[7:0], RW_LB, default = 0x3
    //
    UINTX idle_cmd_to_cke_drops_timer : 8;
    //
    // CKE minimum pulse width (must be at least the larger value of 3 DCLK or 5ns)
    // 
    // Bits[11:8], RW_LB, default = 0x3
    //
    UINTX t_ngn_cke : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // 
    //                 This field defines delay from SREnter to CKE low to make sure
    // SREnter command doesn't have parity error. 
    //                 This CSR should cover the round trip latency to decode the
    //                 command, check for Error and drive the Error signal back to the
    // host. 
    //                 
    // 
    // Bits[23:16], RW_LB, default = 0x7
    //
    UINTX sre_cmd_to_cke_drops_timer : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 8;
  } Bits;
  UINTX Data;
} SREF_STATIC2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define SREF_STATIC_MC1LMSCH_REG                          0x00000644
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field defines number of DCLK of wait time after all pending writes have been
    // drained from WPQ before entering self-refresh.  
    // 
    // Bits[4:0], RW, default = 0x1F
    //
    UINTX adr_sref_timer : 5;
    //
    // This is an idle timer (5-bit) to cover the corner case when Mesh2Mem may have
    // no pending transactions to iMC, but may be preparing to send something to the
    // iMC, but iMC enters SR seeing that it has nothing in its queues. In such a case,
    // MC could potentially enter SR and then exit temporarily and then enter into SR
    // again. This happens primarily because it is hard for Pcode to observe the Mesh2Mem
    // block_ack, since the GV block_ack goes to the hardware and does not generate a
    // fastpath to the Pcode. 
    // 
    // Bits[9:5], RWS, default = 0x1F
    //
    UINTX ufs_sref_idle_timer : 5;
    //
    // Master DLL wake up timer (delay in DCLK).  The MDLL lock time after the DLL Enable
    // is issued, approximately 500ns.  
    //                     This field is defaulted to 533MHz DCLK initial boot setting.
    // BIOS should reprogram this register for ~500ns equivalent at target speed. Here
    // is the set of the recommended setting for each DCLK speed: 
    //                     DDR Speed Setting
    //                     ddr4-1600 190h
    //                     ddr4-1867 1D3h
    //                     ddr4-2133 258h
    //                     ddr4-2667 29Ch
    //                 
    // 
    // Bits[21:10], RW, default = 0xFFF
    //
    UINTX mdll_timer : 12;
    //
    // 
    //                     Bit23: driven on DA4 during the RC9 control word access. Reserved
    // in non-LR-DIMM. In LR-DIMM, For LR-DIMM, DA4=1 for DQ clocking disable in CKE
    // power down. 
    //                     Bit22: driven on DA3 during the RC9 control word access. For
    // non-LR-DIMM, when set (default), register is in weak drive mode; otherwise, the
    // register is in float mode. 
    // 
    // Bits[23:22], RW, default = 0x1
    //
    UINTX pdwn_rdimm_rc9_a4_a3 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[25:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Bits to send as part of the DDR-T PM Idle command to indicate the exit latency.
    //  Encoding is as per the DDR-T spec.   
    // 
    // Bits[29:26], RW, default = 0x0
    //
    UINTX ddrt_idle_l : 4;
    //
    // Defeature to make sure we have a way to not go into Self Refresh during the PkgC
    // flow for survivability.  
    // 
    // Bits[30:30], RW, default = 0x1
    //
    UINTX pkgc_sref_en : 1;
    //
    //  Reserved for future use.  
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX reserved : 1;
  } Bits;
  UINTX Data;
} SREF_STATIC_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define POWER_STATUS_MC1LMSCH_REG                         0x0000064C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Hardware sets this bit to 1 when PCU asserts ForceSrEnter and resets this bit
    // to 0 when PCU asserts ForceSrExit bit. 
    // 
    // Bits[0:0], RWS_V, default = 0x0
    //
    UINTX in_pkgc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 31;
  } Bits;
  UINTX Data;
} POWER_STATUS_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define SREF_LL0_MC1LMSCH_REG                             0x00000670
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                     This field defines the rank idle period that causes self-refresh
    // entrance. This value is used when the 'SREF_EN' field is set. It defines the number
    // of idle cycles (in DCLKs) after the command issue that there should not be any
    // transaction in order to enter self-refresh for DDR4 DIMMs or PM Idle for DDR-T
    // DIMMs. It is programmable 1 to 1M-1 dynamically.  FFFFEh is a reserved value and
    // should not be used in normal operation. 
    //                     The min setting needs to allow for a refresh, a zqcal, a retry
    // read, and a handfull of cycles for Mesh2Mem to issue a demand scrub write: 
    //                     TCZQCAL.T_ZQCS + TCRFTP.T_RFC + 100 decimal. In reality, the
    // idle counter should be much larger in order avoid unnecessary SRE+SRX overhead.
    //                     This register field can be updated dynamically.
    // 
    //                 
    // 
    // Bits[19:0], RWS, default = 0xFFFFF
    //
    UINTX sref_idle_timer : 20;
    //
    // 
    //                     When set, this bit enables opportunistic Self Refresh entry
    // based on the SREF_IDLE_TIMER expiration.  
    //                     FORCE_SR and AsyncSR are other sources of SR entry independent
    // of the setting of SREF_EN. 
    //                     When 0, Opportunistic SR Entry is disabled and SR can only
    // be entered on Force_SR_Entry assertion or AsyncSR. 
    // 
    //                     A write to this register must be respected by iMC. If iMC
    // has entered self-refresh opportunistically, it must return to the state specified
    // by this register. PCU however needs to ensure that modifications happen only under
    // legal conditions. For example clocks must be available before asking iMC to return
    // to DLL on and SR exit state. 
    // 
    //                 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX opp_sref_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[21:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //                     When 0 Master DLLs (MDLL) cannot be turned off. When 1 MDLLs
    // can be turned off in Self Refresh.  
    //                     A write to this register must be respected by IMC. If IMC
    // is already in a deeper state, it must return to the state specified by this register.
    // PCU however needs to ensure that the modifications happen only under legal conditions.
    // For example clocks must be available, before asking MC to return to MDLL on and
    // SR exit state. 
    //                 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX mdll_off_en : 1;
    //
    // Enable IBT_OFF Register Power Down Mode when set; otherwise, IBT_ON is enabled.
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX ibt_off_en : 1;
    //
    // 
    //                     The field defines how CK and CK# are turned off during Self
    // Refresh: 
    // 
    //                     CK_MODE=00, CK_ON: In this mode CK continues to be driven
    // during self-refresh. 
    //                     CK_MODE=01, CK_TRI-STATE_AFTER_PULL_LOW_MODE: after tCKEoff
    // timing delay from SRE CKE de-assertion, iMC waits for tCKoff before dropping CK-ALIGN
    // and CK#-ALIGN (internal signal to DDRIO) to low. The CK-ALIGN and CK#-ALIGN control
    // the CK/CK# clock outputs directly. iMC will wait for tCKEv before de-asserting
    // CKOutputEnable to DDRIO, i.e. tri-stating CK and CK#. Note: DDRIO will have additional
    // 5 QCLK delay of the CK/CK# tri-state.  
    //                     CK_MODE=10, CK_PULL_LOW_MODE: after tCKEoff timing delay from
    // SRE CKE de-assertion, IMC wait for tCKoff before dropping CK-ALIGN and CK#-ALIGN
    // (internal signal to DDRIO) to LOW thoughout the self-refresh.  
    //                     CK_MODE=11, CK_PULL_HIGH_MODE: after tCKEoff timing delay
    // from SRE CKE de-assertion, iMC will wait for tCKoff before pulling both CK-ALIGN
    // and CK#-ALIGN (internal signal to DDRIO) to HIGH thoughout the self-refresh. 
    // 
    // 
    //                     CKE tri-state is under separate control in DDRIO. 
    //                     All other signals (except DDR_RESET#) are tri-stated after
    // tCKEv delay. 
    // 
    //                     A write to this register must be respected by iMC. If iMC
    // is already in a deeper state, it must return to the state specified by this register.
    // PCU however needs to ensure that the modifications happen only under legal conditions.
    // For example clocks must be available, before asking MC to return to DLL on and
    // SR exit state. 
    //                     Note: CK_MODE defines whether CK is turn off during any self-refresh;
    // however, it does not control how CK is turn off based on the RDIMM/UDIMM configuration.
    //  If PSMI initiated CK on self-refresh is triggered, the effect of non-zero CK_MODE
    // is also overridden. 
    //                 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINTX ck_mode : 2;
    //
    // 
    //                     Bits to send as part of the DDR-T PM Idle command to indicate
    // the specific command to be executed.  Encoding is as per the DDR-T spec. 
    //                 
    // 
    // Bits[27:26], RW, default = 0x2
    //
    UINTX ddrt_idle_cmd : 2;
    //
    // Reserved for future use.
    // 
    // Bits[31:28], RW, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} SREF_LL0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define SREF_LL1_MC1LMSCH_REG                             0x00000674
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                     This field defines the rank idle period that causes self-refresh
    // entrance. This value is used when the 'SREF_EN' field is set. It defines the number
    // of idle cycles (in DCLKs) after the command issue that there should not be any
    // transaction in order to enter self-refresh for DDR4 DIMMs or PM Idle for DDR-T
    // DIMMs. It is programmable 1 to 1M-1 dynamically.  FFFFEh is a reserved value and
    // should not be used in normal operation. 
    //                     The min setting needs to allow for a refresh, a zqcal, a retry
    // read, and a handfull of cycles for Mesh2Mem to issue a demand scrub write: 
    //                     TCZQCAL.T_ZQCS + TCRFTP.T_RFC + 100 decimal. In reality, the
    // idle counter should be much larger in order avoid unnecessary SRE+SRX overhead.
    //                     This register field can be updated dynamically.
    // 
    //                 
    // 
    // Bits[19:0], RWS, default = 0xFFFFF
    //
    UINTX sref_idle_timer : 20;
    //
    // 
    //                     When set, this bit enables opportunistic Self Refresh entry
    // based on the SREF_IDLE_TIMER expiration.  
    //                     FORCE_SR and AsyncSR are other sources of SR entry independent
    // of the setting of SREF_EN. 
    //                     When 0, Opportunistic SR Entry is disabled and SR can only
    // be entered on Force_SR_Entry assertion or AsyncSR. 
    // 
    //                     A write to this register must be respected by iMC. If iMC
    // has entered self-refresh opportunistically, it must return to the state specified
    // by this register. PCU however needs to ensure that modifications happen only under
    // legal conditions. For example clocks must be available before asking iMC to return
    // to DLL on and SR exit state. 
    // 
    //                 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX opp_sref_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[21:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //                     When 0 Master DLLs (MDLL) cannot be turned off. When 1 MDLLs
    // can be turned off in Self Refresh.  
    //                     A write to this register must be respected by IMC. If IMC
    // is already in a deeper state, it must return to the state specified by this register.
    // PCU however needs to ensure that the modifications happen only under legal conditions.
    // For example clocks must be available, before asking MC to return to MDLL on and
    // SR exit state. 
    //                 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX mdll_off_en : 1;
    //
    // Enable IBT_OFF Register Power Down Mode when set; otherwise, IBT_ON is enabled.
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX ibt_off_en : 1;
    //
    // 
    //                     The field defines how CK and CK# are turned off during Self
    // Refresh: 
    // 
    //                     CK_MODE=00, CK_ON: In this mode CK continues to be driven
    // during self-refresh. 
    //                     CK_MODE=01, CK_TRI-STATE_AFTER_PULL_LOW_MODE: after tCKEoff
    // timing delay from SRE CKE de-assertion, iMC waits for tCKoff before dropping CK-ALIGN
    // and CK#-ALIGN (internal signal to DDRIO) to low. The CK-ALIGN and CK#-ALIGN control
    // the CK/CK# clock outputs directly. iMC will wait for tCKEv before de-asserting
    // CKOutputEnable to DDRIO, i.e. tri-stating CK and CK#. Note: DDRIO will have additional
    // 5 QCLK delay of the CK/CK# tri-state.  
    //                     CK_MODE=10, CK_PULL_LOW_MODE: after tCKEoff timing delay from
    // SRE CKE de-assertion, IMC wait for tCKoff before dropping CK-ALIGN and CK#-ALIGN
    // (internal signal to DDRIO) to LOW thoughout the self-refresh.  
    //                     CK_MODE=11, CK_PULL_HIGH_MODE: after tCKEoff timing delay
    // from SRE CKE de-assertion, iMC will wait for tCKoff before pulling both CK-ALIGN
    // and CK#-ALIGN (internal signal to DDRIO) to HIGH thoughout the self-refresh. 
    // 
    // 
    //                     CKE tri-state is under separate control in DDRIO. 
    //                     All other signals (except DDR_RESET#) are tri-stated after
    // tCKEv delay. 
    // 
    //                     A write to this register must be respected by iMC. If iMC
    // is already in a deeper state, it must return to the state specified by this register.
    // PCU however needs to ensure that the modifications happen only under legal conditions.
    // For example clocks must be available, before asking MC to return to DLL on and
    // SR exit state. 
    //                     Note: CK_MODE defines whether CK is turn off during any self-refresh;
    // however, it does not control how CK is turn off based on the RDIMM/UDIMM configuration.
    //  If PSMI initiated CK on self-refresh is triggered, the effect of non-zero CK_MODE
    // is also overridden. 
    //                 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINTX ck_mode : 2;
    //
    // 
    //                     Bits to send as part of the DDR-T PM Idle command to indicate
    // the specific command to be executed.  Encoding is as per the DDR-T spec. 
    //                 
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINTX ddrt_idle_cmd : 2;
    //
    // Reserved for future use.
    // 
    // Bits[31:28], RW, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} SREF_LL1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define SREF_LL2_MC1LMSCH_REG                             0x00000678
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                     This field defines the rank idle period that causes self-refresh
    // entrance. This value is used when the 'SREF_EN' field is set. It defines the number
    // of idle cycles (in DCLKs) after the command issue that there should not be any
    // transaction in order to enter self-refresh for DDR4 DIMMs or PM Idle for DDR-T
    // DIMMs. It is programmable 1 to 1M-1 dynamically.  FFFFEh is a reserved value and
    // should not be used in normal operation. 
    //                     The min setting needs to allow for a refresh, a zqcal, a retry
    // read, and a handfull of cycles for Mesh2Mem to issue a demand scrub write: 
    //                     TCZQCAL.T_ZQCS + TCRFTP.T_RFC + 100 decimal. In reality, the
    // idle counter should be much larger in order avoid unnecessary SRE+SRX overhead.
    //                     This register field can be updated dynamically.
    // 
    //                 
    // 
    // Bits[19:0], RWS, default = 0xFFFFF
    //
    UINTX sref_idle_timer : 20;
    //
    // 
    //                     When set, this bit enables opportunistic Self Refresh entry
    // based on the SREF_IDLE_TIMER expiration.  
    //                     FORCE_SR and AsyncSR are other sources of SR entry independent
    // of the setting of SREF_EN. 
    //                     When 0, Opportunistic SR Entry is disabled and SR can only
    // be entered on Force_SR_Entry assertion or AsyncSR. 
    // 
    //                     A write to this register must be respected by iMC. If iMC
    // has entered self-refresh opportunistically, it must return to the state specified
    // by this register. PCU however needs to ensure that modifications happen only under
    // legal conditions. For example clocks must be available before asking iMC to return
    // to DLL on and SR exit state. 
    // 
    //                 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX opp_sref_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[21:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //                     When 0 Master DLLs (MDLL) cannot be turned off. When 1 MDLLs
    // can be turned off in Self Refresh.  
    //                     A write to this register must be respected by IMC. If IMC
    // is already in a deeper state, it must return to the state specified by this register.
    // PCU however needs to ensure that the modifications happen only under legal conditions.
    // For example clocks must be available, before asking MC to return to MDLL on and
    // SR exit state. 
    //                 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX mdll_off_en : 1;
    //
    // Enable IBT_OFF Register Power Down Mode when set; otherwise, IBT_ON is enabled.
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX ibt_off_en : 1;
    //
    // 
    //                     The field defines how CK and CK# are turned off during Self
    // Refresh: 
    // 
    //                     CK_MODE=00, CK_ON: In this mode CK continues to be driven
    // during self-refresh. 
    //                     CK_MODE=01, CK_TRI-STATE_AFTER_PULL_LOW_MODE: after tCKEoff
    // timing delay from SRE CKE de-assertion, iMC waits for tCKoff before dropping CK-ALIGN
    // and CK#-ALIGN (internal signal to DDRIO) to low. The CK-ALIGN and CK#-ALIGN control
    // the CK/CK# clock outputs directly. iMC will wait for tCKEv before de-asserting
    // CKOutputEnable to DDRIO, i.e. tri-stating CK and CK#. Note: DDRIO will have additional
    // 5 QCLK delay of the CK/CK# tri-state.  
    //                     CK_MODE=10, CK_PULL_LOW_MODE: after tCKEoff timing delay from
    // SRE CKE de-assertion, IMC wait for tCKoff before dropping CK-ALIGN and CK#-ALIGN
    // (internal signal to DDRIO) to LOW thoughout the self-refresh.  
    //                     CK_MODE=11, CK_PULL_HIGH_MODE: after tCKEoff timing delay
    // from SRE CKE de-assertion, iMC will wait for tCKoff before pulling both CK-ALIGN
    // and CK#-ALIGN (internal signal to DDRIO) to HIGH thoughout the self-refresh. 
    // 
    // 
    //                     CKE tri-state is under separate control in DDRIO. 
    //                     All other signals (except DDR_RESET#) are tri-stated after
    // tCKEv delay. 
    // 
    //                     A write to this register must be respected by iMC. If iMC
    // is already in a deeper state, it must return to the state specified by this register.
    // PCU however needs to ensure that the modifications happen only under legal conditions.
    // For example clocks must be available, before asking MC to return to DLL on and
    // SR exit state. 
    //                     Note: CK_MODE defines whether CK is turn off during any self-refresh;
    // however, it does not control how CK is turn off based on the RDIMM/UDIMM configuration.
    //  If PSMI initiated CK on self-refresh is triggered, the effect of non-zero CK_MODE
    // is also overridden. 
    //                 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINTX ck_mode : 2;
    //
    // 
    //                     Bits to send as part of the DDR-T PM Idle command to indicate
    // the specific command to be executed.  Encoding is as per the DDR-T spec. 
    //                 
    // 
    // Bits[27:26], RW, default = 0x2
    //
    UINTX ddrt_idle_cmd : 2;
    //
    // Reserved for future use.
    // 
    // Bits[31:28], RW, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} SREF_LL2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define SREF_LL3_MC1LMSCH_REG                             0x0000067C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //                     This field defines the rank idle period that causes self-refresh
    // entrance. This value is used when the 'SREF_EN' field is set. It defines the number
    // of idle cycles (in DCLKs) after the command issue that there should not be any
    // transaction in order to enter self-refresh for DDR4 DIMMs or PM Idle for DDR-T
    // DIMMs. It is programmable 1 to 1M-1 dynamically.  FFFFEh is a reserved value and
    // should not be used in normal operation. 
    //                     The min setting needs to allow for a refresh, a zqcal, a retry
    // read, and a handfull of cycles for Mesh2Mem to issue a demand scrub write: 
    //                     TCZQCAL.T_ZQCS + TCRFTP.T_RFC + 100 decimal. In reality, the
    // idle counter should be much larger in order avoid unnecessary SRE+SRX overhead.
    //                     This register field can be updated dynamically.
    // 
    //                 
    // 
    // Bits[19:0], RWS, default = 0xFFFFF
    //
    UINTX sref_idle_timer : 20;
    //
    // 
    //                     When set, this bit enables opportunistic Self Refresh entry
    // based on the SREF_IDLE_TIMER expiration.  
    //                     FORCE_SR and AsyncSR are other sources of SR entry independent
    // of the setting of SREF_EN. 
    //                     When 0, Opportunistic SR Entry is disabled and SR can only
    // be entered on Force_SR_Entry assertion or AsyncSR. 
    // 
    //                     A write to this register must be respected by iMC. If iMC
    // has entered self-refresh opportunistically, it must return to the state specified
    // by this register. PCU however needs to ensure that modifications happen only under
    // legal conditions. For example clocks must be available before asking iMC to return
    // to DLL on and SR exit state. 
    // 
    //                 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINTX opp_sref_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[21:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //                     When 0 Master DLLs (MDLL) cannot be turned off. When 1 MDLLs
    // can be turned off in Self Refresh.  
    //                     A write to this register must be respected by IMC. If IMC
    // is already in a deeper state, it must return to the state specified by this register.
    // PCU however needs to ensure that the modifications happen only under legal conditions.
    // For example clocks must be available, before asking MC to return to MDLL on and
    // SR exit state. 
    //                 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINTX mdll_off_en : 1;
    //
    // Enable IBT_OFF Register Power Down Mode when set; otherwise, IBT_ON is enabled.
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINTX ibt_off_en : 1;
    //
    // 
    //                     The field defines how CK and CK# are turned off during Self
    // Refresh: 
    // 
    //                     CK_MODE=00, CK_ON: In this mode CK continues to be driven
    // during self-refresh. 
    //                     CK_MODE=01, CK_TRI-STATE_AFTER_PULL_LOW_MODE: after tCKEoff
    // timing delay from SRE CKE de-assertion, iMC waits for tCKoff before dropping CK-ALIGN
    // and CK#-ALIGN (internal signal to DDRIO) to low. The CK-ALIGN and CK#-ALIGN control
    // the CK/CK# clock outputs directly. iMC will wait for tCKEv before de-asserting
    // CKOutputEnable to DDRIO, i.e. tri-stating CK and CK#. Note: DDRIO will have additional
    // 5 QCLK delay of the CK/CK# tri-state.  
    //                     CK_MODE=10, CK_PULL_LOW_MODE: after tCKEoff timing delay from
    // SRE CKE de-assertion, IMC wait for tCKoff before dropping CK-ALIGN and CK#-ALIGN
    // (internal signal to DDRIO) to LOW thoughout the self-refresh.  
    //                     CK_MODE=11, CK_PULL_HIGH_MODE: after tCKEoff timing delay
    // from SRE CKE de-assertion, iMC will wait for tCKoff before pulling both CK-ALIGN
    // and CK#-ALIGN (internal signal to DDRIO) to HIGH thoughout the self-refresh. 
    // 
    // 
    //                     CKE tri-state is under separate control in DDRIO. 
    //                     All other signals (except DDR_RESET#) are tri-stated after
    // tCKEv delay. 
    // 
    //                     A write to this register must be respected by iMC. If iMC
    // is already in a deeper state, it must return to the state specified by this register.
    // PCU however needs to ensure that the modifications happen only under legal conditions.
    // For example clocks must be available, before asking MC to return to DLL on and
    // SR exit state. 
    //                     Note: CK_MODE defines whether CK is turn off during any self-refresh;
    // however, it does not control how CK is turn off based on the RDIMM/UDIMM configuration.
    //  If PSMI initiated CK on self-refresh is triggered, the effect of non-zero CK_MODE
    // is also overridden. 
    //                 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINTX ck_mode : 2;
    //
    // 
    //                     Bits to send as part of the DDR-T PM Idle command to indicate
    // the specific command to be executed.  Encoding is as per the DDR-T spec. 
    //                 
    // 
    // Bits[27:26], RW, default = 0x2
    //
    UINTX ddrt_idle_cmd : 2;
    //
    // Reserved for future use.
    // 
    // Bits[31:28], RW, default = 0x0
    //
    UINTX reserved : 4;
  } Bits;
  UINTX Data;
} SREF_LL3_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CKE_LL0_MC1LMSCH_REG                              0x000006A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This defines the rank idle period that causes CKE power-down entrance. The number
    // of idle cycles (in DCLKs) are based from command CS assertion. It is important
    // to program this parameter to be greater than roundtrip latency parameter in order
    // to avoid the CKE de-assertion sooner than data return. 
    //                         This register field can be updated dynamically.
    //                     
    // 
    // Bits[7:0], RW, default = 0x80
    //
    UINTX cke_idle_timer : 8;
    //
    // 
    //                         CKE Active Power Down Mode for DDR4 DIMMs:
    //                         When 0, APD is disabled
    //                         When 1, APD is enabled
    //                         This register field can be updated dynamically.
    //                     
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX apd_en : 1;
    //
    // 
    //                         CKE Precharge Power Down (PPD):
    //                         When 0, PPD is disabled
    //                         When 1, PPD is enabled
    //                         This register field can be updated dynamically.
    //                     
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX ppd_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
    //
    // 
    //                         CKE Active Power Down Mode for DDR-T DIMMs:
    //                         When 0, APD is disabled
    //                         When 1, APD is enabled
    //                         This register field can be updated dynamically.
    //                     
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX ddrt_cke_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    //  Reserved for future use. 
    // 
    // Bits[29:28], RW, default = 0x1
    //
    UINTX reserved : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
  } Bits;
  UINTX Data;
} CKE_LL0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CKE_LL1_MC1LMSCH_REG                              0x000006A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This defines the rank idle period that causes CKE power-down entrance. The number
    // of idle cycles (in DCLKs) are based from command CS assertion. It is important
    // to program this parameter to be greater than roundtrip latency parameter in order
    // to avoid the CKE de-assertion sooner than data return. 
    //                         This register field can be updated dynamically.
    //                     
    // 
    // Bits[7:0], RW, default = 0x80
    //
    UINTX cke_idle_timer : 8;
    //
    // 
    //                         CKE Active Power Down Mode for DDR4 DIMMs:
    //                         When 0, APD is disabled
    //                         When 1, APD is enabled
    //                         This register field can be updated dynamically.
    //                     
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX apd_en : 1;
    //
    // 
    //                         CKE Precharge Power Down (PPD):
    //                         When 0, PPD is disabled
    //                         When 1, PPD is enabled
    //                         This register field can be updated dynamically.
    //                     
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX ppd_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
    //
    // 
    //                         CKE Active Power Down Mode for DDR-T DIMMs:
    //                         When 0, APD is disabled
    //                         When 1, APD is enabled
    //                         This register field can be updated dynamically.
    //                     
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX ddrt_cke_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    //  Reserved for future use. 
    // 
    // Bits[29:28], RW, default = 0x1
    //
    UINTX reserved : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
  } Bits;
  UINTX Data;
} CKE_LL1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CKE_LL2_MC1LMSCH_REG                              0x000006A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This defines the rank idle period that causes CKE power-down entrance. The number
    // of idle cycles (in DCLKs) are based from command CS assertion. It is important
    // to program this parameter to be greater than roundtrip latency parameter in order
    // to avoid the CKE de-assertion sooner than data return. 
    //                         This register field can be updated dynamically.
    //                     
    // 
    // Bits[7:0], RW, default = 0x80
    //
    UINTX cke_idle_timer : 8;
    //
    // 
    //                         CKE Active Power Down Mode for DDR4 DIMMs:
    //                         When 0, APD is disabled
    //                         When 1, APD is enabled
    //                         This register field can be updated dynamically.
    //                     
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX apd_en : 1;
    //
    // 
    //                         CKE Precharge Power Down (PPD):
    //                         When 0, PPD is disabled
    //                         When 1, PPD is enabled
    //                         This register field can be updated dynamically.
    //                     
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX ppd_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
    //
    // 
    //                         CKE Active Power Down Mode for DDR-T DIMMs:
    //                         When 0, APD is disabled
    //                         When 1, APD is enabled
    //                         This register field can be updated dynamically.
    //                     
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX ddrt_cke_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    //  Reserved for future use. 
    // 
    // Bits[29:28], RW, default = 0x1
    //
    UINTX reserved : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
  } Bits;
  UINTX Data;
} CKE_LL2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CKE_LL3_MC1LMSCH_REG                              0x000006AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This defines the rank idle period that causes CKE power-down entrance. The number
    // of idle cycles (in DCLKs) are based from command CS assertion. It is important
    // to program this parameter to be greater than roundtrip latency parameter in order
    // to avoid the CKE de-assertion sooner than data return. 
    //                         This register field can be updated dynamically.
    //                     
    // 
    // Bits[7:0], RW, default = 0x80
    //
    UINTX cke_idle_timer : 8;
    //
    // 
    //                         CKE Active Power Down Mode for DDR4 DIMMs:
    //                         When 0, APD is disabled
    //                         When 1, APD is enabled
    //                         This register field can be updated dynamically.
    //                     
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINTX apd_en : 1;
    //
    // 
    //                         CKE Precharge Power Down (PPD):
    //                         When 0, PPD is disabled
    //                         When 1, PPD is enabled
    //                         This register field can be updated dynamically.
    //                     
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINTX ppd_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
    //
    // 
    //                         CKE Active Power Down Mode for DDR-T DIMMs:
    //                         When 0, APD is disabled
    //                         When 1, APD is enabled
    //                         This register field can be updated dynamically.
    //                     
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINTX ddrt_cke_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    //  Reserved for future use. 
    // 
    // Bits[29:28], RW, default = 0x1
    //
    UINTX reserved : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
  } Bits;
  UINTX Data;
} CKE_LL3_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MCMNT_CHKN_BIT_MC1LMSCH_REG                       0x00000700
#ifndef ASM_INC
typedef union {
  struct {
    //
    // RDIMM_CW_BDCAST
    // When rdimm_cw_bdcast is set, dis_srl_rdimm_cw_issue must be ONE.
    // When rdimm_cw_bdcast is zero, software can decided to stagger the CW issue by
    // tMRD (for control word issue, dis_srl_rdimm_cw_issue = 0), or allow CW to be issue
    // one after another one (dis_srl_rdimm_cw_issue = 1). 
    // dis_srl_rdimm_cw_issue is more for DIMM to DIMM CW issue control, where rdimm_cw_bdcast
    // allows the whole channel to issue CW at the same time. 
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX rdimm_cw_bdcast : 1;
    //
    // Disable Clock Gating at MNTS.
    // 
    // Bits[1:1], RW_LB, default = 0x1
    //
    UINTX dis_ck_gate_mnts : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // When this bit is set, MC will never issue a refresh unless either HP or Panic
    // refresh is triggered. For example, if we only have panic refresh enabled, if IMC
    // has reached panic refresh watermark and issue one refresh to get out of panic.
    // When the next tREFI expires, the IMC will enter panic refresh again. The pattern
    // will repeat every tREFI and remain at constant panic mode. Therefore, this is
    // not very useful mode for normal usage. Setting this bit is recommended only for
    // bug workaround in opportunistic refresh flows. 
    // Setting this bit will not affect AsyncSR or ForceSR since these signals are OR'ed
    // with opp_ref_enabled in RTL so that we will be able to drain all refreshes and
    // enter the power savings mode. 
    // Limitations: If this bit is set, we will never be able to enter self refresh via
    // idle timer since the refreshes are not drained. 
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX dis_opp_ref : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Enabling the memory controller to issue two auto-refreshes upon exiting self-refresh.
    // It also serialize the ZQCx between ranks upon self-refresh exit when set. 
    // 
    // Bits[6:6], RW_LB, default = 0x1
    //
    UINTX zqlsrl : 1;
    //
    // This bit should be cleared to zero Only for QR lrdimm used in encoded_chip select
    // mode in order to issue ZQCS/L to all 4 chip selects. Otherwise, in encode chip
    // select mode, only chip_select[0] (cid 0 and 1) will get ZQCS/L. 
    // 
    // Bits[7:7], RW_LB, default = 0x1
    //
    UINTX dis_2zq_qr_2cs : 1;
    //
    // Disable slave dll off
    // 
    // Bits[8:8], RW_LB, default = 0x0
    //
    UINTX dis_sdll_off : 1;
    //
    // Disable ZQCAL.
    // Note: If DIS_ZQCAL=1 and DIS_SRX_EX_ZQ=1, IMC will not issue any ZQCx.
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX dis_zqcal : 1;
    //
    // 1: IMC issues ZQCL instead of ZQCS in the subsequent ZQ calibration after the
    // initial ZQ 
    // 0: IMC issues ZQCS instead of ZQCL in the subsequent ZQ calibration after the
    // initial ZQ 
    // 
    // Bits[10:10], RW_LB, default = 0x0
    //
    UINTX long_zq : 1;
    //
    // Disable srx ex zq
    // disable ZQ calibration upon exiting self-refresh if set
    // 
    // Bits[11:11], RW_LB, default = 0x0
    //
    UINTX dis_srx_ex_zq : 1;
    //
    // enable fast zq
    // tczqcal_zqcsperiod is divided by 16 when fst_zq is set.
    // 
    // Bits[12:12], RW_LB, default = 0x0
    //
    UINTX fst_zq : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // DIS_SRL_RDIMM_CW_ISSUE
    // When rdimm_cw_bdcast is set, dis_srl_rdimm_cw_issue must be zero.
    // When rdimm_cw_bdcast is zero, software can decided to stagger the CW issue by
    // tMRD (for control word issue, dis_srl_rdimm_cw_issue = 1), or allow CW to be issue
    // one after another one (dis_srl_rdimm_cw_issue = 0). 
    // dis_srl_rdimm_cw_issue is more for DIMM to DIMM CW issue control, where rdimm_cw_bdcast
    // allows the whole channel to issue CW at the same time. 
    // 
    // Bits[15:15], RW_LB, default = 0x0
    //
    UINTX dis_srl_rdimm_cw_issue : 1;
    //
    // Do not set this defeature bit. MRS concurrent broadcast function is no longer
    // supported. 
    // 
    // Bits[16:16], RW_LB, default = 0x0
    //
    UINTX dis_srl_mrs_issue : 1;
    //
    // Disable turnoff CKE during throttle
    // Important Note: Setting DIS_CKE_OFF_DURG_THR=1will cause ACT to be issued during
    // throttling which will cause additional power consumption. 
    // 
    // Bits[17:17], RW_LB, default = 0x0
    //
    UINTX dis_cke_off_durg_thr : 1;
    //
    // 0b: When IMC is in CKE IBT OFF mode or Slow CKE mode, only Panic Refresh will
    // be able to bring MC out of those modes. 
    // 1b: By setting this bit, MC will come out of those modes when High Priority Refresh
    // is due; however, it is important that the CHN_TEMP_CFG.THRT_ALLOW_ISOCH must not
    // be set to zero; otherw-lbise, panic refresh will be dropped!!! 
    // 
    // Bits[18:18], RW_LB, default = 0x0
    //
    UINTX exit_cke_use_hp_refresh : 1;
    //
    // Stagger Refresh Enable, When set, the T_STAGGER_REF timing parameter becomes effective
    // to stagger the REF command 
    // 
    // Bits[19:19], RW_LB, default = 0x0
    //
    UINTX stagger_ref_en : 1;
    //
    // Disable self-refresh exit due to WPQ going non-empty.
    // 
    // Bits[20:20], RW_LB, default = 0x0
    //
    UINTX dis_wpq_sref_exit : 1;
    //
    // Reserved Unused, the IOSAV subseq repeat infinite mode bit is now in an IOSAV
    // register 
    // 
    // Bits[21:21], RW_LB, default = 0x0
    //
    UINTX defeature_12 : 1;
    //
    // Force DDRIO master DLL off, and de-assert MCActive signal to the MC PMA.
    // 
    // Bits[22:22], RW_LB, default = 0x0
    //
    UINTX frc_mdll_off : 1;
    //
    // Force DDRIO master DLL on, and assert MCActive signal to the MC PMA. Takes priority
    // over frc_mdll_off. 
    // 
    // Bits[23:23], RW_LB, default = 0x0
    //
    UINTX frc_mdll_on : 1;
    //
    // Disables IBTOff and PPDS entry.
    // 
    // Bits[24:24], RW_LB, default = 0x0
    //
    UINTX dis_ppds : 1;
    //
    // Disables channel idle counter for IBTOff and PPDS entry.
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX dis_ppds_idle_cntr : 1;
    //
    // Reserved Unused
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX defeature_13 : 1;
    //
    // Reserved Unused
    // 
    // Bits[27:27], RW_LB, default = 0x0
    //
    UINTX defeature_14 : 1;
    //
    // Reserved Unused
    // 
    // Bits[28:28], RW_LB, default = 0x0
    //
    UINTX defeature_15 : 1;
    //
    // N/A
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX dis_ch_thrt_done : 1;
    //
    // Blocks throttle signal for panic refresh
    // 
    // Bits[30:30], RW_LB, default = 0x0
    //
    UINTX block_thr_1 : 1;
    //
    // Blocks throttle signal and throttle signal for isoch panic refresh
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX block_thr_2 : 1;
  } Bits;
  UINTX Data;
} MCMNT_CHKN_BIT_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define REFRESH_FSM_STATE_0_MC1LMSCH_REG                  0x00000710
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current encoded state of rank 0 refresh FSM
    // 
    // Bits[5:0], RO_V, default = 0x3F
    //
    UINTX rank0_current_state : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Previous encoded state of rank 0 refresh FSM
    // 
    // Bits[13:8], RO_V, default = 0x3F
    //
    UINTX rank0_previous_state : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Current encoded state of rank 1 refresh FSM
    // 
    // Bits[21:16], RO_V, default = 0x3F
    //
    UINTX rank1_current_state : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Previous encoded state of rank 1 refresh FSM
    // 
    // Bits[29:24], RO_V, default = 0x3F
    //
    UINTX rank1_previous_state : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} REFRESH_FSM_STATE_0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define REFRESH_FSM_STATE_1_MC1LMSCH_REG                  0x00000714
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current encoded state of rank 2 refresh FSM
    // 
    // Bits[5:0], RO_V, default = 0x3F
    //
    UINTX rank2_current_state : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Previous encoded state of rank 2 refresh FSM
    // 
    // Bits[13:8], RO_V, default = 0x3F
    //
    UINTX rank2_previous_state : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Current encoded state of rank 3 refresh FSM
    // 
    // Bits[21:16], RO_V, default = 0x3F
    //
    UINTX rank3_current_state : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Previous encoded state of rank 3 refresh FSM
    // 
    // Bits[29:24], RO_V, default = 0x3F
    //
    UINTX rank3_previous_state : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} REFRESH_FSM_STATE_1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define REFRESH_FSM_STATE_2_MC1LMSCH_REG                  0x00000718
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current encoded state of rank 4 refresh FSM
    // 
    // Bits[5:0], RO_V, default = 0x3F
    //
    UINTX rank4_current_state : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Previous encoded state of rank 4 refresh FSM
    // 
    // Bits[13:8], RO_V, default = 0x3F
    //
    UINTX rank4_previous_state : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Current encoded state of rank 5 refresh FSM
    // 
    // Bits[21:16], RO_V, default = 0x3F
    //
    UINTX rank5_current_state : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Previous encoded state of rank 5 refresh FSM
    // 
    // Bits[29:24], RO_V, default = 0x3F
    //
    UINTX rank5_previous_state : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} REFRESH_FSM_STATE_2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define REFRESH_FSM_STATE_3_MC1LMSCH_REG                  0x0000071C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current encoded state of rank 6 refresh FSM
    // 
    // Bits[5:0], RO_V, default = 0x3F
    //
    UINTX rank6_current_state : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Previous encoded state of rank 6 refresh FSM
    // 
    // Bits[13:8], RO_V, default = 0x3F
    //
    UINTX rank6_previous_state : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Current encoded state of rank 7 refresh FSM
    // 
    // Bits[21:16], RO_V, default = 0x3F
    //
    UINTX rank7_current_state : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Previous encoded state of rank 7 refresh FSM
    // 
    // Bits[29:24], RO_V, default = 0x3F
    //
    UINTX rank7_previous_state : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} REFRESH_FSM_STATE_3_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define RD_ODT_TBL0_MC1LMSCH_REG                          0x00000260
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rank 0 Read ODT pins
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX rd_odt_rank0 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Rank 1 Read ODT pins
    // 
    // Bits[13:8], RW, default = 0x0
    //
    UINTX rd_odt_rank1 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Rank 2 Read ODT pins
    // 
    // Bits[21:16], RW, default = 0x0
    //
    UINTX rd_odt_rank2 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Rank 3 Read ODT pins
    // 
    // Bits[29:24], RW, default = 0x0
    //
    UINTX rd_odt_rank3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} RD_ODT_TBL0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define RD_ODT_TBL1_MC1LMSCH_REG                          0x00000264
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rank 4 Read ODT pins
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX rd_odt_rank4 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Rank 5 Read ODT pins
    // 
    // Bits[13:8], RW, default = 0x0
    //
    UINTX rd_odt_rank5 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Rank 6 Read ODT pins
    // 
    // Bits[21:16], RW, default = 0x0
    //
    UINTX rd_odt_rank6 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Rank 7 Read ODT pins
    // 
    // Bits[29:24], RW, default = 0x0
    //
    UINTX rd_odt_rank7 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} RD_ODT_TBL1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define RD_ODT_TBL2_MC1LMSCH_REG                          0x00000268
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rank 8 Read ODT pins
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX rd_odt_rank8 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Rank 9 Read ODT pins
    // 
    // Bits[13:8], RW, default = 0x0
    //
    UINTX rd_odt_rank9 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Extra Leading ODT cycles
    // 
    // Bits[17:16], RW, default = 0x0
    //
    UINTX extraleadingodt : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Extra Trailing ODT cycles
    // 
    // Bits[21:20], RW, default = 0x0
    //
    UINTX extratrailingodt : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 10;
  } Bits;
  UINTX Data;
} RD_ODT_TBL2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define WR_ODT_TBL0_MC1LMSCH_REG                          0x00000270
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rank 0 Write ODT
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX wr_odt_rank0 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Rank 1 Write ODT
    // 
    // Bits[13:8], RW, default = 0x0
    //
    UINTX wr_odt_rank1 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Rank 2 Write ODT
    // 
    // Bits[21:16], RW, default = 0x0
    //
    UINTX wr_odt_rank2 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Rank 3 Write ODT
    // 
    // Bits[29:24], RW, default = 0x0
    //
    UINTX wr_odt_rank3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} WR_ODT_TBL0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define WR_ODT_TBL1_MC1LMSCH_REG                          0x00000274
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rank 4 Write ODT
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX wr_odt_rank4 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Rank 5 Write ODT
    // 
    // Bits[13:8], RW, default = 0x0
    //
    UINTX wr_odt_rank5 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Rank 6 Write ODT
    // 
    // Bits[21:16], RW, default = 0x0
    //
    UINTX wr_odt_rank6 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Rank 7 Write ODT
    // 
    // Bits[29:24], RW, default = 0x0
    //
    UINTX wr_odt_rank7 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} WR_ODT_TBL1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define WR_ODT_TBL2_MC1LMSCH_REG                          0x00000278
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Rank 8 Write ODT
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINTX wr_odt_rank8 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Rank 9 Write ODT
    // 
    // Bits[13:8], RW, default = 0x0
    //
    UINTX wr_odt_rank9 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Extra Leading ODT cycles. Only value of 0 or 1 should be used.
    // 
    // Bits[17:16], RW, default = 0x0
    //
    UINTX extra_leading_odt : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Extra Trailing ODT cycles
    // 
    // Bits[21:20], RW, default = 0x0
    //
    UINTX extra_trailing_odt : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 10;
  } Bits;
  UINTX Data;
} WR_ODT_TBL2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MCODTVISACFG_MC1LMSCH_REG                         0x000002B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RWS_L, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RWS_L, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RWS_L, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RWS_L, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RWS_L, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCODTVISACFG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define DENGATECASCNTR_MC1LMSCH_REG                       0x00000080
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If 1, this counter will count. If 0, it will not.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX enable : 1;
    //
    // note: even if this filed is marked as rw-lv, it is is rw_lb_v but there is no
    // such thing supported by critter. 
    // This is the current value of the counter. It counts Read or write CAS commands
    // issued as a 
    // measure of MC bandwidth consumption. This is a saturating counter.
    // 
    // Bits[36:1], RW_LV, default = 0x0
    //
    UINTX value : 36;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:37], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 27;
  } Bits;
  UINTX Data;
} DENGATECASCNTR_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMONCNTR_0_MC1LMSCH_REG                           0x000000A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[47:0], RW_V, default = 0x0
    //
    UINTX countervalue : 48;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:48], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} PMONCNTR_0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMONCNTR_1_MC1LMSCH_REG                           0x000000A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[47:0], RW_V, default = 0x0
    //
    UINTX countervalue : 48;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:48], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} PMONCNTR_1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMONCNTR_2_MC1LMSCH_REG                           0x000000B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[47:0], RW_V, default = 0x0
    //
    UINTX countervalue : 48;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:48], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} PMONCNTR_2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMONCNTR_3_MC1LMSCH_REG                           0x000000B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[47:0], RW_V, default = 0x0
    //
    UINTX countervalue : 48;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:48], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} PMONCNTR_3_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMONCNTR_4_MC1LMSCH_REG                           0x000000C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[47:0], RW_V, default = 0x0
    //
    UINTX countervalue : 48;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:48], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} PMONCNTR_4_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMONDBGCNTRESETVAL_MC1LMSCH_REG                   0x000000C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The value to reset the counter to.
    // 
    // Bits[47:0], RW_L, default = 0x0
    //
    UINTX resetval : 48;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:48], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} PMONDBGCNTRESETVAL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMONCNTR_FIXED_MC1LMSCH_REG                       0x000000D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is the current value of the counter.
    // 
    // Bits[47:0], RW_V, default = 0x0
    //
    UINTX countervalue : 48;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:48], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
  } Bits;
  UINTX Data;
} PMONCNTR_FIXED_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMONCNTRCFG_0_MC1LMSCH_REG                        0x000000D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field is used to decode the PerfMon event which is selected. The encodings
    // for each of the valid UnCore PerfMon events can be found in the respective performance
    // monitoring sections. 
    // 
    // Bits[7:0], RW_V, default = 0x0
    //
    UINTX eventselect : 8;
    //
    // This mask selects the sub-events to be selected for creation of the event. The
    // selected sub-events are bitwise OR-ed together to create event. At least one sub-event
    // must be selected otherwise the PerfMon event signals will not ever get asserted.
    // Events with no sub-events listed effectively have only one sub-event =event -1
    // bit 8 must be set to 1 in this case. 
    // 
    // Bits[15:8], RW_V, default = 0x0
    //
    UINTX unitmask : 8;
    //
    // This write only bit causes the queue occupancy counter of the PerfMon counter
    // for which this Perf event select register is associated to be cleared to all zeroes
    // when a '1' is written to it. No action is taken when a '0' is written. Note: Since
    // the queue occupancy counters never drop below zero, it is possible for the counters
    // to 'catch up' with the real occupancy of the queue in question when the real occupancy
    // drop to zero. 
    // 
    // Bits[16:16], WO, default = 0x0
    //
    UINTX queueoccupancyreset : 1;
    //
    // When this bit is set, the corresponding counter will be reset to 0. This allows
    // for a quick reset of the counter when changing event encodings. 
    // 
    // Bits[17:17], WO, default = 0x0
    //
    UINTX counterreset : 1;
    //
    // Edge Detect allows one to count either 0 to 1 or 1 to 0 transitions of a given
    // event. For example, we have an event that counts the number of cycles in L1 mode
    // in Intel QPI. By using edge detect, one can count the number of times that we
    // entered L1 mode (by detecting the rising edge). 
    // Edge detect only works in conjunction with threshholding. This is true even for
    // events that can only increment by 1 in a given cycle (like the L1 example above).
    // In this case, one should set a threshhold of 1. One can also use Edge Detect with
    // queue occupancy events. For example, if one wanted to count the number of times
    // when the TOR occupancy was larger than 5, one would selet the TOR occupancy event
    // with a threshold of 5 and set the Edge Detect bit. 
    // Edge detect can also be used with the invert. This is generally not particularly
    // useful, as the count of falling edges compared to rising edges will always on
    // differ by 1. 
    // 
    // Bits[18:18], RW_V, default = 0x0
    //
    UINTX edgedetect : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Setting this bit will enable the counter to send an overflow signal. If this bit
    // is not set, the counter will wrap around when it overflows without triggering
    // anything. If this bit is set and the Unit's configuration register has Overflow
    // enabled, then a signal will be transmitted to the Ubox. 
    // 
    // Bits[20:20], RW_V, default = 0x0
    //
    UINTX overflowenable : 1;
    //
    // This bit needs to be asserted if the event which needs to be selected is an internal
    // event. 
    // Internal events are events that are only accessible on unlocked parts. One can
    // basically think of the internal bit as an extension of the event select bits [7:0],
    // as it allows the use to gain access to additional events. It will not be possible
    // to use these events on locked parts. For perfmons that exist in MSR space, the
    // MSR write mask is set on this bit, and the ucode handler will trigger a GP fault
    // if one attempts to write to these bits. Writing to these bits is controlled in
    // other ways in the other units. 
    // 
    // Bits[21:21], RW_V, default = 0x0
    //
    UINTX internal : 1;
    //
    // This field is the local enable for the PerfMon Counter. This bit must be asserted
    // in order for the PerfMon counter to begin counting the events selected by the
    // event select, unit mask, and internal bits (see the fields below). There is one
    // bit per PerfMon Counter. Note that if this bit is set to 1 but the Unit Control
    // Registers have determined that counting is disabled, then the counter will not
    // count. 
    // 
    // Bits[22:22], RW_V, default = 0x0
    //
    UINTX counterenable : 1;
    //
    // This bit indicates how the threshold field will be compared to the incoming event.
    // When 0, the comparison that will be done is threshold >= event. When set to 1,
    // the comparison that will be done is inverted from the case where this bit is set
    // to 0, i.e., threshold < event. The invert bit only works when Threshhold != 0.
    // So, if one would like to invert a non-occupancy event (like LLC Hit), one needs
    // to set the threshhold to 1. 
    // 
    // Bits[23:23], RW_V, default = 0x0
    //
    UINTX invert : 1;
    //
    // This field is compared directly against an incoming event value for events that
    // can increment by 1 or more in a given cycle. Since the widest event from the UnCore
    // is 7bits (queue occupancy), bit 31 is unused. The result of the comparison is
    // effectively a 1 bit wide event, i.e., the counter will be incremented by 1 when
    // the comparison is true (the type of comparison depends on the setting of the 'invert'
    // bit - see bit 23 below) no matter how wide the original event was. When this field
    // is zero, threshold comparison is disabled and the event is passed without modification.
    // 
    // Bits[31:24], RW_V, default = 0x0
    //
    UINTX threshold : 8;
  } Bits;
  UINTX Data;
} PMONCNTRCFG_0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMONCNTRCFG_1_MC1LMSCH_REG                        0x000000DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field is used to decode the PerfMon event which is selected. The encodings
    // for each of the valid UnCore PerfMon events can be found in the respective performance
    // monitoring sections. 
    // 
    // Bits[7:0], RW_V, default = 0x0
    //
    UINTX eventselect : 8;
    //
    // This mask selects the sub-events to be selected for creation of the event. The
    // selected sub-events are bitwise OR-ed together to create event. At least one sub-event
    // must be selected otherwise the PerfMon event signals will not ever get asserted.
    // Events with no sub-events listed effectively have only one sub-event =event -1
    // bit 8 must be set to 1 in this case. 
    // 
    // Bits[15:8], RW_V, default = 0x0
    //
    UINTX unitmask : 8;
    //
    // This write only bit causes the queue occupancy counter of the PerfMon counter
    // for which this Perf event select register is associated to be cleared to all zeroes
    // when a '1' is written to it. No action is taken when a '0' is written. Note: Since
    // the queue occupancy counters never drop below zero, it is possible for the counters
    // to 'catch up' with the real occupancy of the queue in question when the real occupancy
    // drop to zero. 
    // 
    // Bits[16:16], WO, default = 0x0
    //
    UINTX queueoccupancyreset : 1;
    //
    // When this bit is set, the corresponding counter will be reset to 0. This allows
    // for a quick reset of the counter when changing event encodings. 
    // 
    // Bits[17:17], WO, default = 0x0
    //
    UINTX counterreset : 1;
    //
    // Edge Detect allows one to count either 0 to 1 or 1 to 0 transitions of a given
    // event. For example, we have an event that counts the number of cycles in L1 mode
    // in Intel QPI. By using edge detect, one can count the number of times that we
    // entered L1 mode (by detecting the rising edge). 
    // Edge detect only works in conjunction with threshholding. This is true even for
    // events that can only increment by 1 in a given cycle (like the L1 example above).
    // In this case, one should set a threshhold of 1. One can also use Edge Detect with
    // queue occupancy events. For example, if one wanted to count the number of times
    // when the TOR occupancy was larger than 5, one would selet the TOR occupancy event
    // with a threshold of 5 and set the Edge Detect bit. 
    // Edge detect can also be used with the invert. This is generally not particularly
    // useful, as the count of falling edges compared to rising edges will always on
    // differ by 1. 
    // 
    // Bits[18:18], RW_V, default = 0x0
    //
    UINTX edgedetect : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Setting this bit will enable the counter to send an overflow signal. If this bit
    // is not set, the counter will wrap around when it overflows without triggering
    // anything. If this bit is set and the Unit's configuration register has Overflow
    // enabled, then a signal will be transmitted to the Ubox. 
    // 
    // Bits[20:20], RW_V, default = 0x0
    //
    UINTX overflowenable : 1;
    //
    // This bit needs to be asserted if the event which needs to be selected is an internal
    // event. 
    // Internal events are events that are only accessible on unlocked parts. One can
    // basically think of the internal bit as an extension of the event select bits [7:0],
    // as it allows the use to gain access to additional events. It will not be possible
    // to use these events on locked parts. For perfmons that exist in MSR space, the
    // MSR write mask is set on this bit, and the ucode handler will trigger a GP fault
    // if one attempts to write to these bits. Writing to these bits is controlled in
    // other ways in the other units. 
    // 
    // Bits[21:21], RW_V, default = 0x0
    //
    UINTX internal : 1;
    //
    // This field is the local enable for the PerfMon Counter. This bit must be asserted
    // in order for the PerfMon counter to begin counting the events selected by the
    // event select, unit mask, and internal bits (see the fields below). There is one
    // bit per PerfMon Counter. Note that if this bit is set to 1 but the Unit Control
    // Registers have determined that counting is disabled, then the counter will not
    // count. 
    // 
    // Bits[22:22], RW_V, default = 0x0
    //
    UINTX counterenable : 1;
    //
    // This bit indicates how the threshold field will be compared to the incoming event.
    // When 0, the comparison that will be done is threshold >= event. When set to 1,
    // the comparison that will be done is inverted from the case where this bit is set
    // to 0, i.e., threshold < event. The invert bit only works when Threshhold != 0.
    // So, if one would like to invert a non-occupancy event (like LLC Hit), one needs
    // to set the threshhold to 1. 
    // 
    // Bits[23:23], RW_V, default = 0x0
    //
    UINTX invert : 1;
    //
    // This field is compared directly against an incoming event value for events that
    // can increment by 1 or more in a given cycle. Since the widest event from the UnCore
    // is 7bits (queue occupancy), bit 31 is unused. The result of the comparison is
    // effectively a 1 bit wide event, i.e., the counter will be incremented by 1 when
    // the comparison is true (the type of comparison depends on the setting of the 'invert'
    // bit - see bit 23 below) no matter how wide the original event was. When this field
    // is zero, threshold comparison is disabled and the event is passed without modification.
    // 
    // Bits[31:24], RW_V, default = 0x0
    //
    UINTX threshold : 8;
  } Bits;
  UINTX Data;
} PMONCNTRCFG_1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMONCNTRCFG_2_MC1LMSCH_REG                        0x000000E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field is used to decode the PerfMon event which is selected. The encodings
    // for each of the valid UnCore PerfMon events can be found in the respective performance
    // monitoring sections. 
    // 
    // Bits[7:0], RW_V, default = 0x0
    //
    UINTX eventselect : 8;
    //
    // This mask selects the sub-events to be selected for creation of the event. The
    // selected sub-events are bitwise OR-ed together to create event. At least one sub-event
    // must be selected otherwise the PerfMon event signals will not ever get asserted.
    // Events with no sub-events listed effectively have only one sub-event =event -1
    // bit 8 must be set to 1 in this case. 
    // 
    // Bits[15:8], RW_V, default = 0x0
    //
    UINTX unitmask : 8;
    //
    // This write only bit causes the queue occupancy counter of the PerfMon counter
    // for which this Perf event select register is associated to be cleared to all zeroes
    // when a '1' is written to it. No action is taken when a '0' is written. Note: Since
    // the queue occupancy counters never drop below zero, it is possible for the counters
    // to 'catch up' with the real occupancy of the queue in question when the real occupancy
    // drop to zero. 
    // 
    // Bits[16:16], WO, default = 0x0
    //
    UINTX queueoccupancyreset : 1;
    //
    // When this bit is set, the corresponding counter will be reset to 0. This allows
    // for a quick reset of the counter when changing event encodings. 
    // 
    // Bits[17:17], WO, default = 0x0
    //
    UINTX counterreset : 1;
    //
    // Edge Detect allows one to count either 0 to 1 or 1 to 0 transitions of a given
    // event. For example, we have an event that counts the number of cycles in L1 mode
    // in Intel QPI. By using edge detect, one can count the number of times that we
    // entered L1 mode (by detecting the rising edge). 
    // Edge detect only works in conjunction with threshholding. This is true even for
    // events that can only increment by 1 in a given cycle (like the L1 example above).
    // In this case, one should set a threshhold of 1. One can also use Edge Detect with
    // queue occupancy events. For example, if one wanted to count the number of times
    // when the TOR occupancy was larger than 5, one would selet the TOR occupancy event
    // with a threshold of 5 and set the Edge Detect bit. 
    // Edge detect can also be used with the invert. This is generally not particularly
    // useful, as the count of falling edges compared to rising edges will always on
    // differ by 1. 
    // 
    // Bits[18:18], RW_V, default = 0x0
    //
    UINTX edgedetect : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Setting this bit will enable the counter to send an overflow signal. If this bit
    // is not set, the counter will wrap around when it overflows without triggering
    // anything. If this bit is set and the Unit's configuration register has Overflow
    // enabled, then a signal will be transmitted to the Ubox. 
    // 
    // Bits[20:20], RW_V, default = 0x0
    //
    UINTX overflowenable : 1;
    //
    // This bit needs to be asserted if the event which needs to be selected is an internal
    // event. 
    // Internal events are events that are only accessible on unlocked parts. One can
    // basically think of the internal bit as an extension of the event select bits [7:0],
    // as it allows the use to gain access to additional events. It will not be possible
    // to use these events on locked parts. For perfmons that exist in MSR space, the
    // MSR write mask is set on this bit, and the ucode handler will trigger a GP fault
    // if one attempts to write to these bits. Writing to these bits is controlled in
    // other ways in the other units. 
    // 
    // Bits[21:21], RW_V, default = 0x0
    //
    UINTX internal : 1;
    //
    // This field is the local enable for the PerfMon Counter. This bit must be asserted
    // in order for the PerfMon counter to begin counting the events selected by the
    // event select, unit mask, and internal bits (see the fields below). There is one
    // bit per PerfMon Counter. Note that if this bit is set to 1 but the Unit Control
    // Registers have determined that counting is disabled, then the counter will not
    // count. 
    // 
    // Bits[22:22], RW_V, default = 0x0
    //
    UINTX counterenable : 1;
    //
    // This bit indicates how the threshold field will be compared to the incoming event.
    // When 0, the comparison that will be done is threshold >= event. When set to 1,
    // the comparison that will be done is inverted from the case where this bit is set
    // to 0, i.e., threshold < event. The invert bit only works when Threshhold != 0.
    // So, if one would like to invert a non-occupancy event (like LLC Hit), one needs
    // to set the threshhold to 1. 
    // 
    // Bits[23:23], RW_V, default = 0x0
    //
    UINTX invert : 1;
    //
    // This field is compared directly against an incoming event value for events that
    // can increment by 1 or more in a given cycle. Since the widest event from the UnCore
    // is 7bits (queue occupancy), bit 31 is unused. The result of the comparison is
    // effectively a 1 bit wide event, i.e., the counter will be incremented by 1 when
    // the comparison is true (the type of comparison depends on the setting of the 'invert'
    // bit - see bit 23 below) no matter how wide the original event was. When this field
    // is zero, threshold comparison is disabled and the event is passed without modification.
    // 
    // Bits[31:24], RW_V, default = 0x0
    //
    UINTX threshold : 8;
  } Bits;
  UINTX Data;
} PMONCNTRCFG_2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMONCNTRCFG_3_MC1LMSCH_REG                        0x000000E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field is used to decode the PerfMon event which is selected. The encodings
    // for each of the valid UnCore PerfMon events can be found in the respective performance
    // monitoring sections. 
    // 
    // Bits[7:0], RW_V, default = 0x0
    //
    UINTX eventselect : 8;
    //
    // This mask selects the sub-events to be selected for creation of the event. The
    // selected sub-events are bitwise OR-ed together to create event. At least one sub-event
    // must be selected otherwise the PerfMon event signals will not ever get asserted.
    // Events with no sub-events listed effectively have only one sub-event =event -1
    // bit 8 must be set to 1 in this case. 
    // 
    // Bits[15:8], RW_V, default = 0x0
    //
    UINTX unitmask : 8;
    //
    // This write only bit causes the queue occupancy counter of the PerfMon counter
    // for which this Perf event select register is associated to be cleared to all zeroes
    // when a '1' is written to it. No action is taken when a '0' is written. Note: Since
    // the queue occupancy counters never drop below zero, it is possible for the counters
    // to 'catch up' with the real occupancy of the queue in question when the real occupancy
    // drop to zero. 
    // 
    // Bits[16:16], WO, default = 0x0
    //
    UINTX queueoccupancyreset : 1;
    //
    // When this bit is set, the corresponding counter will be reset to 0. This allows
    // for a quick reset of the counter when changing event encodings. 
    // 
    // Bits[17:17], WO, default = 0x0
    //
    UINTX counterreset : 1;
    //
    // Edge Detect allows one to count either 0 to 1 or 1 to 0 transitions of a given
    // event. For example, we have an event that counts the number of cycles in L1 mode
    // in Intel QPI. By using edge detect, one can count the number of times that we
    // entered L1 mode (by detecting the rising edge). 
    // Edge detect only works in conjunction with threshholding. This is true even for
    // events that can only increment by 1 in a given cycle (like the L1 example above).
    // In this case, one should set a threshhold of 1. One can also use Edge Detect with
    // queue occupancy events. For example, if one wanted to count the number of times
    // when the TOR occupancy was larger than 5, one would selet the TOR occupancy event
    // with a threshold of 5 and set the Edge Detect bit. 
    // Edge detect can also be used with the invert. This is generally not particularly
    // useful, as the count of falling edges compared to rising edges will always on
    // differ by 1. 
    // 
    // Bits[18:18], RW_V, default = 0x0
    //
    UINTX edgedetect : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Setting this bit will enable the counter to send an overflow signal. If this bit
    // is not set, the counter will wrap around when it overflows without triggering
    // anything. If this bit is set and the Unit's configuration register has Overflow
    // enabled, then a signal will be transmitted to the Ubox. 
    // 
    // Bits[20:20], RW_V, default = 0x0
    //
    UINTX overflowenable : 1;
    //
    // This bit needs to be asserted if the event which needs to be selected is an internal
    // event. 
    // Internal events are events that are only accessible on unlocked parts. One can
    // basically think of the internal bit as an extension of the event select bits [7:0],
    // as it allows the use to gain access to additional events. It will not be possible
    // to use these events on locked parts. For perfmons that exist in MSR space, the
    // MSR write mask is set on this bit, and the ucode handler will trigger a GP fault
    // if one attempts to write to these bits. Writing to these bits is controlled in
    // other ways in the other units. 
    // 
    // Bits[21:21], RW_V, default = 0x0
    //
    UINTX internal : 1;
    //
    // This field is the local enable for the PerfMon Counter. This bit must be asserted
    // in order for the PerfMon counter to begin counting the events selected by the
    // event select, unit mask, and internal bits (see the fields below). There is one
    // bit per PerfMon Counter. Note that if this bit is set to 1 but the Unit Control
    // Registers have determined that counting is disabled, then the counter will not
    // count. 
    // 
    // Bits[22:22], RW_V, default = 0x0
    //
    UINTX counterenable : 1;
    //
    // This bit indicates how the threshold field will be compared to the incoming event.
    // When 0, the comparison that will be done is threshold >= event. When set to 1,
    // the comparison that will be done is inverted from the case where this bit is set
    // to 0, i.e., threshold < event. The invert bit only works when Threshhold != 0.
    // So, if one would like to invert a non-occupancy event (like LLC Hit), one needs
    // to set the threshhold to 1. 
    // 
    // Bits[23:23], RW_V, default = 0x0
    //
    UINTX invert : 1;
    //
    // This field is compared directly against an incoming event value for events that
    // can increment by 1 or more in a given cycle. Since the widest event from the UnCore
    // is 7bits (queue occupancy), bit 31 is unused. The result of the comparison is
    // effectively a 1 bit wide event, i.e., the counter will be incremented by 1 when
    // the comparison is true (the type of comparison depends on the setting of the 'invert'
    // bit - see bit 23 below) no matter how wide the original event was. When this field
    // is zero, threshold comparison is disabled and the event is passed without modification.
    // 
    // Bits[31:24], RW_V, default = 0x0
    //
    UINTX threshold : 8;
  } Bits;
  UINTX Data;
} PMONCNTRCFG_3_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMONCNTRCFG_4_MC1LMSCH_REG                        0x000000E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field is used to decode the PerfMon event which is selected. The encodings
    // for each of the valid UnCore PerfMon events can be found in the respective performance
    // monitoring sections. 
    // 
    // Bits[7:0], RW_V, default = 0x0
    //
    UINTX eventselect : 8;
    //
    // This mask selects the sub-events to be selected for creation of the event. The
    // selected sub-events are bitwise OR-ed together to create event. At least one sub-event
    // must be selected otherwise the PerfMon event signals will not ever get asserted.
    // Events with no sub-events listed effectively have only one sub-event =event -1
    // bit 8 must be set to 1 in this case. 
    // 
    // Bits[15:8], RW_V, default = 0x0
    //
    UINTX unitmask : 8;
    //
    // This write only bit causes the queue occupancy counter of the PerfMon counter
    // for which this Perf event select register is associated to be cleared to all zeroes
    // when a '1' is written to it. No action is taken when a '0' is written. Note: Since
    // the queue occupancy counters never drop below zero, it is possible for the counters
    // to 'catch up' with the real occupancy of the queue in question when the real occupancy
    // drop to zero. 
    // 
    // Bits[16:16], WO, default = 0x0
    //
    UINTX queueoccupancyreset : 1;
    //
    // When this bit is set, the corresponding counter will be reset to 0. This allows
    // for a quick reset of the counter when changing event encodings. 
    // 
    // Bits[17:17], WO, default = 0x0
    //
    UINTX counterreset : 1;
    //
    // Edge Detect allows one to count either 0 to 1 or 1 to 0 transitions of a given
    // event. For example, we have an event that counts the number of cycles in L1 mode
    // in Intel QPI. By using edge detect, one can count the number of times that we
    // entered L1 mode (by detecting the rising edge). 
    // Edge detect only works in conjunction with threshholding. This is true even for
    // events that can only increment by 1 in a given cycle (like the L1 example above).
    // In this case, one should set a threshhold of 1. One can also use Edge Detect with
    // queue occupancy events. For example, if one wanted to count the number of times
    // when the TOR occupancy was larger than 5, one would selet the TOR occupancy event
    // with a threshold of 5 and set the Edge Detect bit. 
    // Edge detect can also be used with the invert. This is generally not particularly
    // useful, as the count of falling edges compared to rising edges will always on
    // differ by 1. 
    // 
    // Bits[18:18], RW_V, default = 0x0
    //
    UINTX edgedetect : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Setting this bit will enable the counter to send an overflow signal. If this bit
    // is not set, the counter will wrap around when it overflows without triggering
    // anything. If this bit is set and the Unit's configuration register has Overflow
    // enabled, then a signal will be transmitted to the Ubox. 
    // 
    // Bits[20:20], RW_V, default = 0x0
    //
    UINTX overflowenable : 1;
    //
    // This bit needs to be asserted if the event which needs to be selected is an internal
    // event. 
    // Internal events are events that are only accessible on unlocked parts. One can
    // basically think of the internal bit as an extension of the event select bits [7:0],
    // as it allows the use to gain access to additional events. It will not be possible
    // to use these events on locked parts. For perfmons that exist in MSR space, the
    // MSR write mask is set on this bit, and the ucode handler will trigger a GP fault
    // if one attempts to write to these bits. Writing to these bits is controlled in
    // other ways in the other units. 
    // 
    // Bits[21:21], RW_V, default = 0x0
    //
    UINTX internal : 1;
    //
    // This field is the local enable for the PerfMon Counter. This bit must be asserted
    // in order for the PerfMon counter to begin counting the events selected by the
    // event select, unit mask, and internal bits (see the fields below). There is one
    // bit per PerfMon Counter. Note that if this bit is set to 1 but the Unit Control
    // Registers have determined that counting is disabled, then the counter will not
    // count. 
    // 
    // Bits[22:22], RW_V, default = 0x0
    //
    UINTX counterenable : 1;
    //
    // This bit indicates how the threshold field will be compared to the incoming event.
    // When 0, the comparison that will be done is threshold >= event. When set to 1,
    // the comparison that will be done is inverted from the case where this bit is set
    // to 0, i.e., threshold < event. The invert bit only works when Threshhold != 0.
    // So, if one would like to invert a non-occupancy event (like LLC Hit), one needs
    // to set the threshhold to 1. 
    // 
    // Bits[23:23], RW_V, default = 0x0
    //
    UINTX invert : 1;
    //
    // This field is compared directly against an incoming event value for events that
    // can increment by 1 or more in a given cycle. Since the widest event from the UnCore
    // is 7bits (queue occupancy), bit 31 is unused. The result of the comparison is
    // effectively a 1 bit wide event, i.e., the counter will be incremented by 1 when
    // the comparison is true (the type of comparison depends on the setting of the 'invert'
    // bit - see bit 23 below) no matter how wide the original event was. When this field
    // is zero, threshold comparison is disabled and the event is passed without modification.
    // 
    // Bits[31:24], RW_V, default = 0x0
    //
    UINTX threshold : 8;
  } Bits;
  UINTX Data;
} PMONCNTRCFG_4_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMONDBGCTRL_MC1LMSCH_REG                          0x000000EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[0:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // When this is set, the counter's enable bit will be set to 0 whenever the partner
    // counter's event occurs. This should be used with the Pulse Width and A after B
    // usage models. 
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX othereventstopen : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // When this bit is set, the counter's enable bit will be set to 1 whenever the partner
    // counter's event occurs. This is an optional event, which is generally intended
    // for cases when we need to use the queue occupancy counter, which only exists on
    // counter 3. 
    // 
    // Bits[5:5], RW_L, default = 0x0
    //
    UINTX othereventstarten : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // When this is set, the counter's enable bit will automatically be set to 1 whenever
    // the event occurs. It is generally used with the ClockedIncEn bit. It is used in
    // the Pulse Widge, A after B, and Inactivity usage models. 
    // 
    // Bits[7:7], RW_L, default = 0x0
    //
    UINTX myeventstarten : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[8:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // When this bit is set, the counter will reset whenever the partner counter's event
    // occurs. This is used by the Pulse Width and A after B usage models. 
    // 
    // Bits[9:9], RW_L, default = 0x0
    //
    UINTX othereventreseten : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[10:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // When this is enabled, the counter will reset whenever the counter's event is triggered.
    // This is used by the Inactivity usage model. 
    // 
    // Bits[11:11], RW_L, default = 0x0
    //
    UINTX myeventreseten : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // Changes when the counter increments. Rather than incrementing based on the event,
    // the counter will increment by 1 in each cycle. This is used by the Pulse Widge,
    // A after B, and Inactivity usage models. 
    // 
    // Bits[13:13], RW_L, default = 0x0
    //
    UINTX clockedincenable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 18;
  } Bits;
  UINTX Data;
} PMONDBGCTRL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMONCNTRCFGFIXED_MC1LMSCH_REG                     0x000000F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 19;
    //
    // When this bit is set, the corresponding counter will be reset to 0. This allows
    // for a quick reset of the counter when changing event encodings. 
    // 
    // Bits[19:19], WO, default = 0x0
    //
    UINTX counterreset : 1;
    //
    // Setting this bit will enable the counter to send an overflow signal. If this bit
    // is not set, the counter will wrap around when it overflows without triggering
    // anything. If this bit is set and the Unit's configuration register has Overflow
    // enabled, then a signal will be transmitted to the Ubox. 
    // 
    // Bits[20:20], RW_V, default = 0x0
    //
    UINTX overflowenable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[21:21], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // This field is the local enable for the PerfMon Counter. This bit must be asserted
    // in order for the PerfMon counter to begin counting the events selected by the
    // 'event select', 'unit mask', and 'internal' bits (see the fields below). There
    // is one bit per PerfMon Counter. Note that if this bit is set to 1 but the Unit
    // Control Registers have determined that counting is disabled, then the counter
    // will not count. 
    // 
    // Bits[22:22], RW_V, default = 0x0
    //
    UINTX counterenable : 1;
    //
    // This bit indicates how the threshold field will be compared to the incoming event.
    // When '0', the comparison that will be done is threshold >= event. When set to
    // '1', the comparison that will be done is inverted from the case where this bit
    // is set to '0', i.e., threshold < event. If the threshold is set to 0 on an event
    // that only has one bit (for example LLC Hit), and the invert bit is enabled, the
    // counter will increment by 1 in every cycle when the event is not true (for example,
    // every cycle when there is not an llc hit). 
    // 
    // Bits[23:23], RW_V, default = 0x0
    //
    UINTX invert : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 8;
  } Bits;
  UINTX Data;
} PMONCNTRCFGFIXED_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMONUNITCTRL_MC1LMSCH_REG                         0x000000F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // When this bit is written to, the counter configuration registers will be reset.
    // This does not effect the values in the counters. 
    // 
    // Bits[0:0], WO, default = 0x0
    //
    UINTX resetcounterconfigs : 1;
    //
    // When this bit is written to, the counters data fields will be reset. The configuration
    // values will not be reset. 
    // 
    // Bits[1:1], WO, default = 0x0
    //
    UINTX resetcounters : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // This bit is written to when the counters should be frozen. If this bit is written
    // to and freeze is enabled, the counters in the unit will stop counting. 
    // 
    // Bits[8:8], RW_V, default = 0x0
    //
    UINTX freezecounters : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 7;
    //
    // This bit controls what the counters in the unit will do when they receive a freeze
    // signal. When set, the counters will be allowed to freeze. When not set, the counters
    // will ignore the freeze signal. 
    // 
    // Bits[16:16], RW_LB, default = 0x1
    //
    UINTX freezeenable : 1;
    //
    // This bit controls the behavior of counters when they overflow. When set, the system
    // will trigger the overflow handling process throughout the rest of the uncore,
    // potentially triggering a PMI and freezing counters. When it is not set, the counters
    // will simply wrap around and continue to count. 
    // 
    // Bits[17:17], RW_LB, default = 0x1
    //
    UINTX overflowenable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 14;
  } Bits;
  UINTX Data;
} PMONUNITCTRL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMONUNITSTATUS_MC1LMSCH_REG                       0x000000F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This is a bitmask that specifies which counter (or counters) have overflowed.
    // If the unit has a fixed counter, it's corresponding bitmask will be stored at
    // position 0. 
    // 
    // Bits[6:0], RW1C, default = 0x0
    //
    UINTX counteroverflowbitmask : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 25;
  } Bits;
  UINTX Data;
} PMONUNITSTATUS_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TCDBP_MC1LMSCH_REG                                0x00000200
#ifndef ASM_INC
typedef union {
  struct {
    //
    // tRCD. ACT to internal read or write delay time in DCLK (must be at least 5)
    // 
    // Bits[4:0], RW, default = 0xA
    //
    UINTX t_rcd : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[8:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // CAS Read Latency (tCL) (must be at least 9) Note: RL=tAL+tCL, but AL is not supported.
    // 
    // Bits[13:9], RW, default = 0xA
    //
    UINTX t_cl : 5;
    //
    // CAS Write Latency (tCWL)  (must be at least 9) Note: WL=tAL+tCWL, but AL is not
    // supported  
    // 
    // Bits[18:14], RW, default = 0x7
    //
    UINTX t_cwl : 5;
    //
    // tRAS.  ACT to PRE command period 
    // 
    // Bits[24:19], RW, default = 0x1C
    //
    UINTX t_ras : 6;
    //
    // N/A
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINTX cmd_oe_on : 1;
    //
    // N/A
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINTX cmd_oe_cs : 1;
    //
    // tRP.  PRE command period. 
    // 
    // Bits[31:27], RW, default = 0xA
    //
    UINTX t_rp : 5;
  } Bits;
  UINTX Data;
} TCDBP_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TCRAP_MC1LMSCH_REG                                0x00000204
#ifndef ASM_INC
typedef union {
  struct {
    //
    // tRRD_S.  ACTIVE to ACTIVE command period.
    // 
    // Bits[2:0], RW, default = 0x5
    //
    UINTX t_rrd : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // tRTP.  Internal READ Command to PRECHARGE Command delay. 
    // 
    // Bits[7:4], RW, default = 0xA
    //
    UINTX t_rtp : 4;
    //
    // tCKE.  CKE minimum pulse width. 
    // 
    // Bits[11:8], RW, default = 0x3
    //
    UINTX t_cke : 4;
    //
    // tWTR_S.  DCLK delay from start of internal write transaction to internal read
    // command. 
    // iMC's Write to Read Same Rank (T_WRSR) is automatically calulated based from TCDBP.T_CWL
    // + 4 + T_WTR. 
    // For LRDIMM running in rank multiplication mode, IMC will continue to use the above
    // equation for T_WRSR even if the WRITE and READ are targeting same logical rank
    // but at different physical ranks behind the LRDIMM buffer, In the other word, IMC
    // will not be able to dynamically switch to T_WRDR timing. In order to avoid timing
    // violation in this scenario, BIOS must configure the T_WTR parameter to be the
    // MAX(T_WTR of LRDIMM, (T_WRDR' - T_CL + 2)). Note: Due to the lighter electrical
    // loading behind the LRDIMM buffer, further optimization can be tuned during post-silicon
    // to reduce the T_WRDR' paraemeter instead of directly using the TCRWP.T_WRDR parameter.
    // 
    // Bits[15:12], RW, default = 0x6
    //
    UINTX t_wtr : 4;
    //
    // tFAW.  Four activate window (must be at least 4*tRRD and at most 63)
    // 
    // Bits[21:16], RW, default = 0x20
    //
    UINTX t_faw : 6;
    //
    // tPRPDEN, tACTPDEN, tREFPDEN needs to have value of 2 for 2133+. All 3 values will
    // use this single value. 
    // 
    // Bits[23:22], RW, default = 0x1
    //
    UINTX t_prpden : 2;
    //
    // tWR.  Bits 4:0 of WRITE recovery time (must be at least 15ns equivalent). Bit
    // 6:5 is in tcothp2.t_wr_upper. 
    // 
    // Bits[28:24], RW, default = 0xC
    //
    UINTX t_wr : 5;
    //
    // Do not use; logic is not hook up. Please use MCSCHED_UCR_CHKN_BIT.CMD_OE_ALWY_ON
    // uCR bit instead. 
    // When cleared, command and address is driving only when required. When set, command
    // and address are driving always, and the value when no valid command is the last
    // command and address 
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX cmd_3st : 1;
    //
    // defines for how many cycles the command is stretched
    // 00: 1N operation
    // 01: Reserved
    // 10: 2N operation
    // 11: 3N operation
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINTX cmd_stretch : 2;
  } Bits;
  UINTX Data;
} TCRAP_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TCRWP_MC1LMSCH_REG                                0x00000208
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Back to back READ to READ from different RANK separation parameter. The actual
    // READ to READ command separation is T_RRDR + 5 DCLKs measured between the clock
    // assertion edges of the two corresponding asserted command CS#. Please note that
    // the minimum setting of the field must meet the DDRIO requirement for READ to READ
    // turnaround time to be at least 5 DClk at the DDRIO pin. 
    // The maximum design range from the above calculation is 31.
    // 
    // Bits[2:0], RW, default = 0x2
    //
    UINTX t_rrdr : 3;
    //
    // Back to back READ to READ from different DIMM separation parameter. The actual
    // READ to READ command separation is T_RRDD + 5 DCLKs measured between the clock
    // assertion edges of the two corresponding asserted command CS#. Please note that
    // the minimum setting of the field must meet the DDRIO requirement for READ to READ
    // turnaround time to be at least 5 DClk at the DDRIO pin. 
    // The maximum design range from the above calculation is 31.
    // 
    // Bits[5:3], RW, default = 0x2
    //
    UINTX t_rrdd : 3;
    //
    // Back to back WRITE to WRITE from different RANK separation parameter. The actual
    // WRITE to WRITE command separation is 
    // T_WWDR + 5 DCLKs measured between the clock assertion edges of the two corresponding
    // asserted command CS#. Please note that the minimum setting of the field must meet
    // the DDRIO requirement for WRITE to WRITE turnaround time to be at least 6 DClk
    // at the DDRIO pin. 
    // The maximum design range from the above calculation is 15.
    // 
    // Bits[8:6], RW, default = 0x2
    //
    UINTX t_wwdr : 3;
    //
    // Back to back WRITE to WRITE from different DIMM separation parameter. The actual
    // WRITE to WRITE command separation is 
    // T_WWDD + 5 DCLKs measured between the clock assertion edges of the two corresponding
    // asserted command CS#. Please note that the minimum setting of the field must meet
    // the DDRIO requirement for WRITE to WRITE turnaround time to be at least 6 DClk
    // at the DDRIO pin. 
    // The maximum design range from the above calculation is 15.
    // 
    // Bits[11:9], RW, default = 0x2
    //
    UINTX t_wwdd : 3;
    //
    // This field is not used. Please refer to TCOTHP2 for the new register field location.
    // 
    // Bits[14:12], RW, default = 0x2
    //
    UINTX t_rwdr : 3;
    //
    // This field is not used. Please refer to TCOTHP2 for the new register field location.
    // 
    // Bits[17:15], RW, default = 0x2
    //
    UINTX t_rwdd : 3;
    //
    // Back to back WRITE to READ from different RANK separation parameter.The actual
    // WRITE to READ command separation is 
    // TCDBP.T_CWL - TCDBP.T_CL + T_WRDR + 6 DCLKs measured between the clock assertion
    // edges of the two corresponding asserted command CS#. 
    // 
    // Bits[20:18], RW, default = 0x2
    //
    UINTX t_wrdr : 3;
    //
    // Back to back WRITE to READ from different DIMM separation parameter.The actual
    // WRITE to READ command separation is 
    // TCDBP.T_CWL - TCDBP.T_CL + T_WRDD + 6 DCLKs measured between the clock assertion
    // edges of the two corresponding asserted command CS#. 
    // 
    // Bits[23:21], RW, default = 0x2
    //
    UINTX t_wrdd : 3;
    //
    // This field is not used. Please refer to TCOTHP2 for the new register field location.
    // 
    // Bits[26:24], RW, default = 0x2
    //
    UINTX t_rwsr : 3;
    //
    // back to back READ to READ CAS to CAS from same rank separation parameter.The actual
    // JEDEC CAS to CAS command separation is (T_CCD + 4) DCLKs measured between the
    // clock assertion edges of the two corresponding asserted command CS#. 
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINTX t_ccd : 3;
    //
    // Upper 2 bits (bits 4:3) of t_wrdr field.
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINTX t_wrdr_upper : 2;
  } Bits;
  UINTX Data;
} TCRWP_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TCOTHP_MC1LMSCH_REG                               0x0000020C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Exit Power Down with DLL on to any valid command; Exit Precharge Power Down with
    // DLL frozen to commands not requiring a locked DLL. 
    // 
    // Bits[5:0], RW, default = 0x3
    //
    UINTX t_xp : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // This register defines additional WR data delay per channel in order to overcome
    // the WR-flyby issue. 
    // The total CAS write latency that the DDR sees is the sum of T_CWL and the T_CWL_ADJ
    // minus T_CWL_ADJ_NEG. 
    // 000 - no added latency (default)
    // 001 to 111 - 1 to 7 Dclk of added latency
    // 
    // Bits[10:8], RW, default = 0x0
    //
    UINTX t_cwl_adj : 3;
    //
    // This shifts the ODT waveform one cycle early relative to the timing set up in
    // the ODT_TBL2 register, when in 2N or 3N mode. 
    // This bit has no effect in 1N mode.
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINTX shift_odt_early : 1;
    //
    // N/A
    // 
    // Bits[15:12], RW, default = 0x2
    //
    UINTX t_rwdr : 4;
    //
    // Do not use.
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINTX t_rwdd : 4;
    //
    // Do not use.
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINTX t_rwsr : 4;
    //
    // When t_odt_oe=0, ODT will not tri-state
    // Otherwise, this field defines delay in Dclks to disable ODT output after all CKE
    // pins are low and either in self-refresh or in IBTOff mode 
    // 
    // Bits[27:24], RW, default = 0x6
    //
    UINTX t_odt_oe : 4;
    //
    // When t_cs_oe=0, CS[9:0]# will not tri-state
    // Otherwise, this field defines delay in Dclks to disable CS output after all CKE
    // pins are low 
    // 
    // Bits[31:28], RW, default = 0x6
    //
    UINTX t_cs_oe : 4;
  } Bits;
  UINTX Data;
} TCOTHP_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TCMR4SHADOW_MC1LMSCH_REG                          0x00000228
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[11:0], RW, default = 0x0
    //
    UINTX mr4_shdw_bit11to0 : 12;
    //
    // If 0, write preamble=1tck. If 1, write_preamble=2tck. This bit field has to be
    // set consistantly in MC, ddrio and DDR devices. 
    // When set to 1, MC modifies it behavior to send dqsoutenable to ddrio 1 clock earlier
    // as well as 
    // increasing RD->WR timing by 1 clock in order to meet ddr4 requirements.
    // When set to 1, MC modifies its behavior to block a command spacing of 5 clocks
    // between all combinations of CAS and/or GNT commands in addition 
    // to meeting all other timing requirements.
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINTX write_preamble : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 19;
  } Bits;
  UINTX Data;
} TCMR4SHADOW_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define IDLETIME_MC1LMSCH_REG                             0x00000238
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Idle Counter Reset Value (RV): This is the value that effectively adapts. It determines
    // what value the various ICs are set to whenever they are reset. It therefore controls
    // the number of cycles before an automatic page close is triggered for an entire
    // channel. 
    //             
    //             OPCs drive the RV down to 6'b000000, whereas PPCs drive the RV up
    // to 6'b111111.  The RV value is sticky at these two lower and upper levels and
    // does not rollover.  Idle counter in page tables are loaded with ?[(idle_page_rst_val
    // * 4) + 3]? 
    //         
    // 
    // Bits[5:0], RW, default = 0x8
    //
    UINTX idle_page_rst_val : 6;
    //
    // Window Size (WS): The number of requests that we track before making a decision
    // to adapt the RV. 
    //             The actual WS count (i.e. the number of requests in the window) is
    // equal to [(win_size * 16) + 15] 
    //         
    // 
    // Bits[13:6], RW, default = 0x40
    //
    UINTX win_size : 8;
    //
    // Premature Page Close (PPC) Threshold
    //             If the number of PPCs in a given window is larger than this threshold,
    // we increase the RV 
    //             The actual PPC threshold count (i.e. the number of PPC requests) is
    // equal to [(ppc_th * 16) + 15] 
    //         
    // 
    // Bits[20:14], RW, default = 0x6
    //
    UINTX ppc_th : 7;
    //
    // Overdue Page Close (OPC) Threshold
    //             If the number of OPCs in a given window is larger than this threshold,
    // we decrease the RV. 
    //             The actual OPC threshold count (i.e. the number of OPC requests) is
    // equal to [(opc_th * 16) + 15] 
    //         
    // 
    // Bits[27:21], RW, default = 0x6
    //
    UINTX opc_th : 7;
    //
    // This register is programmed in conjunction with MCMTR.CLOSE_PG to enable three
    // different modes: 
    // - Closed Page Mode =Mode -1 MCMTR.CLOSE_PG = 1 and ADAPT_PG_CLSE= 0. (EX processor
    // only supports closed page) 
    // - Adaptive Open =Open -1 MCMTR.CLOSE_PG = 0 and ADAPT_PG_CLSE= 1.
    // - All others reserved.
    // When ADAPT_PG_CLSE=0, the page close idle timer gets set with IDLE_PAGE_RST_VAL
    // times 4. 
    // 
    // Bits[28:28], RW, default = 0x1
    //
    UINTX adapt_pg_clse : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
  } Bits;
  UINTX Data;
} IDLETIME_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ROWHAMCONFIG_MC1LMSCH_REG                         0x00000280
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Row activate Limit per timewindow.
    // 
    // Bits[14:0], RW_LB, default = 0x0
    //
    UINTX limit : 15;
    //
    // Enable. 00 = disabled, other = enabled
    // 
    // Bits[16:15], RW_LB, default = 0x0
    //
    UINTX enable : 2;
    //
    // FIFO count at which the MC will throttle to avoid missing activates.
    // 
    // Bits[21:17], RW_LB, default = 0xC
    //
    UINTX throttle_thresh : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 6;
    //
    // If set to one will disable throttle of scheduler due to exceeding throttle_thresh.
    // 
    // Bits[28:28], RW_LB, default = 0x0
    //
    UINTX throttle_disable : 1;
    //
    // If set to one will disable Pass Gate tracking but will allow inject_refresh to
    // be used. 
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX disable2 : 1;
    //
    // Set to one to inject a Pass Gate refresh. The low 13 bits of the limit field are
    // repurposed to provide the CID,rank,bank and upper row bits to inject.   
    // [13:11] Cid
    // [10:8] Rank
    // [7:4] if DDR4 device then {Bank,BankGroup} otherwise {1'b0,Bank}
    // [3:0] Row[17:14]
    // Row[13:0] is hard coded to be 0x100. When using this feature, the Pass Gate logic
    // needs to be enabled by setting the enable field to 3 but the tracker needs to
    // be disabled by setting the disable2 bit to 1. There is no need to write the Trigger
    // bit to configure this operation. After the refresh has been injected, this bit
    // will clear back to zero. 
    // 
    // Bits[30:30], RW_LV, default = 0x0
    //
    UINTX inject_refresh : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
  } Bits;
  UINTX Data;
} ROWHAMCONFIG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ROWHAMCONFIG2_MC1LMSCH_REG                        0x00000284
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This field is used in TRR mode to specify the value of tMOD used at the end of
    // the refresh. This should be written with the value of (tcsrftp.t_mod + tcdbp.t_rp).
    // Since there is a delay in the logic it is possible to write a value 5 less than
    // the result of the addition. 
    // 
    // Bits[7:0], RW_LB, default = 0x0
    //
    UINTX trr_tmod : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[16:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 9;
    //
    // One half the value of t_ras rounded up. This is only used for TRR mode Pass Gate
    // refresh. 
    // 
    // Bits[22:17], RW_LB, default = 0x0
    //
    UINTX half_t_ras : 6;
    //
    // When this bit is set the machine will block the entire rank when doing the Pass
    // Gate refresh instead of just the banks required. 
    // 
    // Bits[23:23], RW_LB, default = 0x0
    //
    UINTX safe_mode : 1;
    //
    // The number of Dclk cycles to wait after finishing a Pass Gate refresh before starting
    // another. Note that this must be set to a value larger than PRE to ACT to RD/WR
    // to avoid forward progress issues. 
    // 
    // Bits[31:24], RW_LB, default = 0x0
    //
    UINTX restart_delay : 8;
  } Bits;
  UINTX Data;
} ROWHAMCONFIG2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ROWHAMCONFIG3_MC1LMSCH_REG                        0x0000028C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Which bits of the Row address should not be modified for DIMM0 when sweeping the
    // row. 3:0 corresponds to [17:14] of the row address. 
    // 
    // Bits[3:0], RW_LB, default = 0x0
    //
    UINTX pass_mask0 : 4;
    //
    // Which bits of the Row address should not be modified for DIMM1 when sweeping the
    // row. 3:0 corresponds to [17:14] of the row address. 
    // 
    // Bits[7:4], RW_LB, default = 0x0
    //
    UINTX pass_mask1 : 4;
    //
    // Which bits of the Row address should not be modified for DIMM1 when sweeping the
    // row. 3:0 corresponds to [17:14] of the row address. 
    // 
    // Bits[11:8], RW_LB, default = 0x0
    //
    UINTX pass_mask2 : 4;
    //
    // Specifies which ranks use mirroring on the address.
    // 
    // Bits[19:12], RW_LB, default = 0x0
    //
    UINTX mirror : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 12;
  } Bits;
  UINTX Data;
} ROWHAMCONFIG3_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TCLRDP_MC1LMSCH_REG                               0x00000290
#ifndef ASM_INC
typedef union {
  struct {
    //
    // This register controls timing between different subranks of the same logical rank.
    // Timings between CAS commands to the same subrank of a logical rank use the existing
    // non-LRDIMM same-rank timings. 
    // Back to back READ to READ from different subranks within the same logical rank
    // separation parameter for LRDIMM. 
    // The actual READ-READ command separation is (T_CCD + 4) + (T_RRDS + 1)) in DCLK
    // measured between the clock assertion edges of the two corresponding asserted command
    // CS#. 
    // Note: T_RRDS + 1 is the actual separation and the T_CCD + 4 is the actual T_CCD
    // on JEDEC spec.dges of the two corresponding asserted command CS#. 
    // 
    // Bits[2:0], RW_LB, default = 0x2
    //
    UINTX t_rrds : 3;
    //
    // This register controls timing between different subranks of the same logical rank.
    // Timings between CAS commands to the same subrank of a logical rank use the existing
    // non-LRDIMM same-rank timings. 
    // Back to back WRITE to WRITE from different subranks within the same logical rank
    // separation parameter for LRDIMM. 
    // The actual WRITE to WRITE command separation is (T_CCD + 4) + (T_WWDS + 1)) in
    // DCLK measured between the clock assertion edges of the two corresponding asserted
    // command CS#. 
    // Note: T_WWDS + 1 is the actual separation and the T_CCD + 4 is the actual T_CCD
    // on JEDEC spec. 
    // 
    // Bits[5:3], RW_LB, default = 0x2
    //
    UINTX t_wwds : 3;
    //
    // This register controls timing between different subranks of the same logical rank.
    // Timings between CAS commands to the same subrank of a logical rank use the existing
    // non-LRDIMM same-rank timings. 
    // Back to back READ to WRITE from different subranks within the same logical rank
    // separation parameter for LRDIMM. 
    // The actual READ to WRITE command separation is (T_CCD + 4) + (T_RWDS + 1)) in
    // DCLK measured between the clock assertion edges of the two corresponding asserted
    // command CS#. 
    // Note: T_RWDS + 1 is the actual separation and the T_CCD + 4 is the actual T_CCD
    // on JEDEC spec. 
    // 
    // Bits[10:6], RW_LB, default = 0x2
    //
    UINTX t_rwds : 5;
    //
    // back to back WRITE to READ from different subranks within the same logical rank
    // separation parameter for LRDIMM. The actual WRITE to READ command separation is
    // (T_CCD + 4) + (T_WRDS + 1)) in DCLK measured between the clock assertion edges
    // of the two corresponding asserted command CS#. 
    // This register controls timing between different subranks of the same logical rank.
    // Timings between CAS commands to the same subrank of a logical rank use the existing
    // non-LRDIMM same-rank timings. 
    // Back to back WRITE to READ from different subranks within the same logical rank
    // separation parameter for LRDIMM. 
    // The actual WRITE to READ command separation is (T_CCD + 4) + (T_WRDS + 1)) in
    // DCLK measured between the clock assertion edges of the two corresponding asserted
    // command CS#. 
    // Note: T_WRDS + 1 is the actual separation and the T_CCD + 4 is the actual T_CCD
    // on JEDEC spec. 
    // 
    // Bits[15:11], RW_LB, default = 0x2
    //
    UINTX t_wrds : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[17:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Enable 3DS DIMM/LRDIMM support
    // 
    // Bits[18:18], RW_LB, default = 0x0
    //
    UINTX en_3ds : 1;
    //
    // This bit field is used for dimm0 subrank tracking timing support and it needs
    // to be programmed consistantly with respect to 
    // ddr4_3dsnumranks_cs (for ddr4) and other fields which determine Rank Multiplication
    // for ddr3. 
    // When subrank tracking is turned on, read->read, read->write,write->read,write->write
    // timings between subranks will be controlled by 
    // t_rrds,t_rwds,t_wrds,t_wwds timing registers for different bankgroups and *_l_ds
    // registers for same bankgroup 
    // otherwise version of registers which are not *ds(different sub rank), *dr(different
    // rank), or *dd(different dimm) will be used 
    // 00: subrank tracking is turned off; this hould be used if there are no subranks
    // in this slot 
    // 01: subrank tracking is turned on assuming that number of subranks per chip select
    // is 2. 
    // 10: subrank tracking is turned on assuming that number of subranks per chip select
    // is 4. 
    // 11: subrank tracking is turned on assuming that number of subranks per chip select
    // is 8. 
    // 
    // Bits[20:19], RW_LB, default = 0x0
    //
    UINTX rm2x0 : 2;
    //
    // Same as rm2x0 except this is for dimm slot 1.
    // Since subrank tracking does not support 8 subranks per chip select in slot 1 in
    // a 3dim configuration, value of 11 for this filed is illegal for 3 dimm configs
    // and hardware will turn off sub rank tracking for all slots if this illegal value
    // is programmed. 
    // 
    // Bits[22:21], RW_LB, default = 0x0
    //
    UINTX rm2x1 : 2;
    //
    // Reserved Unused. DIMM 2 not supported for SKX.
    // 
    // Bits[24:23], RW_LB, default = 0x0
    //
    UINTX rm2x2 : 2;
    //
    // Enable page table aliasing on rank bit 2. If this bit is 1, page table entries
    // will alias on rank bit 2; if this bit is 0, page table entries will alias on rank
    // bit 1. (Aliasing on rank bit 2 will impact performance for 2DPC or 3DPC; aliasing
    // on rank bit 1 will impact performance for QR DIMMs or 3DPC.) 
    // 
    // Bits[25:25], RW_LB, default = 0x0
    //
    UINTX en_pgta2 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[26:26], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Back to back WRITE to WRITE CAS to CAS from same rank separation parameter.
    // The actual JEDEC CAS to CAS command separation for writes is (T_CCD_WR + 4) DCLKs
    // measured between the clock assertion edges of the two corresponding asserted command
    // CS#. 
    // 
    // Bits[29:27], RW_LB, default = 0x0
    //
    UINTX t_ccd_wr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Enable BL4 timing support. This is only intended to be used for Intel SMI 2 1:1
    // mode, where it allows 
    // values for the CAS2CAS turnarounds that are smaller by 2 DCLKs.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX en_bl4 : 1;
  } Bits;
  UINTX Data;
} TCLRDP_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TCLRDP1_MC1LMSCH_REG                              0x00000294
#ifndef ASM_INC
typedef union {
  struct {
    //
    // In ddr4 mode when sub rank tracking is turned on, this field will determine RD->RD
    // spacing when accesses are to different sub_ranks but same_bankgroup; 
    // where as tclrdp.t_rrds will be used when accesses are to different sub_ranks but
    // different_bankgroups. Spec is in flux so we add a register. 
    // 
    // Bits[2:0], RW_LB, default = 0x2
    //
    UINTX t_rr_l_ds : 3;
    //
    // In ddr4 mode when sub rank tracking is turned on, this field will determine WR->WR
    // spacing when accesses are to different sub_ranks but same_bankgroup; 
    // where as tclrdp.t_wwds will be used when accesses are to different sub_ranks but
    // different_bankgroups. Spec is in flux so we add a register. 
    // 
    // Bits[5:3], RW_LB, default = 0x2
    //
    UINTX t_ww_l_ds : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 26;
  } Bits;
  UINTX Data;
} TCLRDP1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TCOTHP2_MC1LMSCH_REG                              0x00000298
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Read to write different rank dead cycles
    // Back to back READ to WRITE from different RANK separation parameter. The actual
    // READ to WRITE command separation is 
    // TCDBP.T_CL - TCDBP.T_CWL + T_RWDR + 6 DCLKs measured between the clock assertion
    // edges of the two corresponding asserted command CS#. 
    // The maximum design range from the above calculation is 30.
    // 
    // Bits[4:0], RW_LB, default = 0x2
    //
    UINTX t_rwdr : 5;
    //
    // Read to write different dimm dead cycles
    // Back to back READ to WRITE from different DIMM separation parameter. The actual
    // READ to WRITE command separation is 
    // TCDBP.T_CL - TCDBP.T_CWL + T_RWDD + 6 DCLKs measured between the clock assertion
    // edges of the two corresponding asserted command CS#. 
    // The maximum design range from the above calculation is 30.
    // 
    // Bits[9:5], RW_LB, default = 0x2
    //
    UINTX t_rwdd : 5;
    //
    // Read to write same rank dead cycles
    // Back to back READ to WRITE from same rank separation parameter. The actual READ
    // to WRITE command separation targetting same rank is 
    // TCDBP.T_CL - TCDBP.T_CWL + T_RWSR + 6 DCLKs measured between the clock assertion
    // edges of the two corresponding asserted command CS#. 
    // The maximum design range from the above calculation is 30.
    // For LRDIMM running in rank multiplication mode, IMC will continue to use the above
    // equation for T_RWSR even if the READ and WRITE are targeting same logical rank
    // but at different physical ranks behind the LRDIMM buffer, i.e. IMC will not be
    // able to dynamically switch to T_RWDR timing. In order to avoid timing violation
    // in this scenario, BIOS must configure the T_RWSR parameter to be the MAX(T_RWSR
    // of LRDIMM, T_RWDR'). Note: Due to the lighter electrical loading behind the LRDIMM
    // buffer, further optimization can be tuned during post-silicon to reduce the T_RWDR'
    // paraemeter instead of directly using the TCOTHP2.T_RWDR parameter. 
    // 
    // 
    // Bits[14:10], RW_LB, default = 0x2
    //
    UINTX t_rwsr : 5;
    //
    // Back to back WRITE to READ from different DIMM separation parameter.The actual
    // WRITE to READ command separation is 
    // TCDBP.T_CWL - TCDBP.T_CL + T_WRDD + 6 DCLKs measured between the clock assertion
    // edges of the two corresponding asserted command CS#. 
    // 
    // Bits[19:15], RW_LB, default = 0x2
    //
    UINTX t_wrdd : 5;
    //
    // This register defines reduction of WR data delay per channel in order to overcome
    // the WR-flyby issue. 
    // The total CAS write latency that the DDR sees is the sum of T_CWL and the T_CWL_ADJ
    // minus T_CWL_ADJ_NEG. 
    // 00 - no latency reduction (default)
    // 01 - reduce latency by 1 Dclk
    // 10 - reduce latency by 2 Dclk
    // 11 - reduce latency by 3 Dclk
    // The total t_cwl (T_CWL + T_CWL_ADJ - T_CWL_ADJ_NEG) should not be less than 6
    // 
    // Bits[21:20], RW_LB, default = 0x0
    //
    UINTX t_cwl_adj_neg : 2;
    //
    // Bits 6:5 of WRITE recovery time (must be at least 15ns equivalent)
    // 
    // Bits[23:22], RW_LB, default = 0x0
    //
    UINTX t_wr_upper : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} TCOTHP2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CAPARINJ_MC1LMSCH_REG                             0x0000029C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[7:0], RW_LB, default = 0x1
    //
    UINTX count : 8;
    //
    // N/A
    // 
    // Bits[8:8], RW_LV, default = 0x0
    //
    UINTX enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
  } Bits;
  UINTX Data;
} CAPARINJ_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define TDDR4_MC1LMSCH_REG                                0x000002A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ACTIVE to ACTIVE command period, different bank group (must be at least the larger
    // value of 4 DCLK or 6ns) 
    // 
    // Bits[2:0], RW, default = 0x5
    //
    UINTX t_rrd_l : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:3], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // DCLK delay from start of internal write transaction to internal read command (must
    // be at least the larger value of 4 DCLK or 7.5ns) 
    // 
    // 
    // Bits[11:8], RW, default = 0x6
    //
    UINTX t_wtr_l : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 4;
    //
    // back to back CAS to CAS (READ to READ), same bank group separation parameter.The
    // actual JEDEC CAS to CAS command separation is (T_CCD + 4) DCLKs measured between
    // the clock assertion edges of the two corresponding asserted command CS#. 
    // 
    // Bits[18:16], RW, default = 0x0
    //
    UINTX t_ccd_l : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
    //
    // back to back CAS to CAS (WRITE to WRITE), same bank group separation parameter.The
    // actual JEDEC CAS to CAS command separation is (T_CCD + 4) DCLKs measured between
    // the clock assertion edges of the two corresponding asserted command CS#. 
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINTX t_ccd_wr_l : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
    //
    // Set to one for DDR4 quad rank LRDIMM with 2 chip selects. Bit 2 is DIMM2. Bit
    // 1 is DIMM1. Bit 0 is DIMM0. 
    // 
    // Bits[31:29], RW, default = 0x0
    //
    UINTX qrlrdimm2cs : 3;
  } Bits;
  UINTX Data;
} TDDR4_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MCGSVISACFG_MC1LMSCH_REG                          0x000002B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RWS_L, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RWS_L, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RWS_L, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RWS_L, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RWS_L, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCGSVISACFG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MCPGTVISACFG_MC1LMSCH_REG                         0x000002B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RWS_L, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RWS_L, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RWS_L, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RWS_L, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RWS_L, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCPGTVISACFG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MCRPQVISACFG_MC1LMSCH_REG                         0x000002BC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RWS_L, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RWS_L, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RWS_L, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RWS_L, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RWS_L, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCRPQVISACFG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MCSAFEVISACFG_MC1LMSCH_REG                        0x000002C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RWS_L, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RWS_L, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RWS_L, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RWS_L, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RWS_L, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCSAFEVISACFG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MCWPQVISACFG_MC1LMSCH_REG                         0x000002C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RWS_L, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RWS_L, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RWS_L, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RWS_L, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RWS_L, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCWPQVISACFG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ROWHAM_THRESHOLD0_MC1LMSCH_REG                    0x000002D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable the compare control defined in this register.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX thrshld0_enable : 1;
    //
    // 15 bit value to check to determine if TRR is injected or not.
    // 
    // Bits[15:1], RW_LB, default = 0x0
    //
    UINTX thrshld0 : 15;
    //
    // 15 bit mask to ignore each bit of thrshld0 field.
    // 
    // Bits[30:16], RW_LB, default = 0x0
    //
    UINTX thrshld0_mask : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} ROWHAM_THRESHOLD0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ROWHAM_THRESHOLD1_MC1LMSCH_REG                    0x000002D4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable the compare control defined in this register.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX thrshld1_enable : 1;
    //
    // 15 bit value to check to determine if TRR is injected or not.
    // 
    // Bits[15:1], RW_LB, default = 0x0
    //
    UINTX thrshld1 : 15;
    //
    // 15 bit mask to ignore each bit of thrshld1 field.
    // 
    // Bits[30:16], RW_LB, default = 0x0
    //
    UINTX thrshld1_mask : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} ROWHAM_THRESHOLD1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ROWHAM_SEED_LO_MC1LMSCH_REG                       0x000002D8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Lower 32b of initial value.
    // 
    // Bits[31:0], RW_LB, default = 0x0
    //
    UINTX seed_lo : 32;
  } Bits;
  UINTX Data;
} ROWHAM_SEED_LO_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ROWHAM_SEED_HI_MC1LMSCH_REG                       0x000002DC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Upper 31b of initial value.
    // 
    // Bits[30:0], RW_LB, default = 0x0
    //
    UINTX seed_hi : 31;
    //
    // Intial value is loaded on a 0->1 transition in this field.
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX seed_load : 1;
  } Bits;
  UINTX Data;
} ROWHAM_SEED_HI_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ROWHAM_CTL_MC1LMSCH_REG                           0x000002E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // If this bit is set to 1 then the hardware that triggers the TRR injection is disabled.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX reset_lfsr : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // If this bit is set to 1, then all the outstanding TRR commands are flushed.
    // 
    // Bits[2:2], RW_LB, default = 0x0
    //
    UINTX reset_trr_fifo : 1;
    //
    // Disable use of last entry of TRR FIFO. Should set reset_trr_fifo before set this
    // bit. 
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX dis_rhfifo_lastentry : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 28;
  } Bits;
  UINTX Data;
} ROWHAM_CTL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ROWHAM_LOG_MC1LMSCH_REG                           0x000002E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable logging of TRR information rowwam_log and rowham_log2.
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX enable_trr_log : 1;
    //
    // Injections in window.
    // 
    // Bits[13:1], RW_LV, default = 0x0
    //
    UINTX num_injects : 13;
    //
    // Injections in window.
    // 
    // Bits[29:14], RW_LV, default = 0x0
    //
    UINTX num_between : 16;
    //
    // Injections in window.
    // 
    // Bits[30:30], RW_LV, default = 0x0
    //
    UINTX fifo_empty : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} ROWHAM_LOG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ROWHAM_LOG2_MC1LMSCH_REG                          0x000002E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Dropped cmds in window.
    // 
    // Bits[12:0], RW_LV, default = 0x0
    //
    UINTX num_drops : 13;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 19;
  } Bits;
  UINTX Data;
} ROWHAM_LOG2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_MCCTRL_ERR_INJ_MC1LMSCH_REG              0x00000300
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 00 - Dont inject
    // 01 - Use Trigger-0
    // 10 - Use Trigger-1
    // 11 - Use Trigger-2
    // 
    // Bits[1:0], RWS_L, default = 0x0
    //
    UINTX thr_sel : 2;
    //
    // 00 - RSVD
    // 01 - Throttle reads only
    // 10 - Throttle writes only
    // 11 - Throttle reads and writes
    // 
    // Bits[3:2], RWS_L, default = 0x1
    //
    UINTX thr_function : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // 00 - Dont inject
    // 01 - Use Trigger-0
    // 10 - Use Trigger-1
    // 11 - Use Trigger-2
    // 
    // Bits[9:8], RWS_L, default = 0x0
    //
    UINTX inj_addr_par_err_sel : 2;
    //
    // 00 - Don't throttle
    // 01 - Use Trigger-0
    // 10 - Use Trigger-1
    // 11 - Use Trigger-2
    // 
    // Bits[11:10], RWS_L, default = 0x0
    //
    UINTX wr_crdt_thr_sel : 2;
    //
    // 00 - Don't throttle
    // 01 - Use Trigger-0
    // 10 - Use Trigger-1
    // 11 - Use Trigger-2
    // 
    // Bits[13:12], RWS_L, default = 0x0
    //
    UINTX rd_crdt_thr_sel : 2;
    //
    // This field is deprecated.
    // 
    // Bits[15:14], RWS_L, default = 0x0
    //
    UINTX rd_retry_inj_sel : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 16;
  } Bits;
  UINTX Data;
} RSP_FUNC_MCCTRL_ERR_INJ_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define DDRT_TIMING_MC1LMSCH_REG                          0x00000358
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Controls turn-around from DDRT GNT to DDR4 Read
    // 
    // Bits[5:0], RW_LB, default = 0x10
    //
    UINTX ddrtrd_to_ddr4rd : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // Controls turn-around from DDRT GNT to DDR4 Write
    // 
    // Bits[13:8], RW_LB, default = 0x10
    //
    UINTX ddrtrd_to_ddr4wr : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 2;
    //
    // Controls turn-around from DDRT Write to DDR4 Read
    // 
    // Bits[21:16], RW_LB, default = 0x10
    //
    UINTX ddrtwr_to_ddr4rd : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 2;
    //
    // Controls turn-around from DDRT Write to DDR4 Write
    // 
    // Bits[29:24], RW_LB, default = 0x18
    //
    UINTX ddrtwr_to_ddr4wr : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 2;
  } Bits;
  UINTX Data;
} DDRT_TIMING_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ET_CFG_MC1LMSCH_REG                               0x00000104
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Energy calculation sample period (in number of DCLK). This value is loaded onto
    // the corresponding ETSAMPLEPERIOD count-down counter. The counter is reload with
    // the ETSAMPLEPERIOD count after it counted zero.PSMI ET Quiecense will wait until
    // the ETSAMPLEPERIOD counter is decremented to zero before freezing the counter
    // and acknowledge the quiecense. PSMI wipe or the clearing the Quiecense bit will
    // resume the count-down counter from ETSAMPLEPERIOD count. 
    // When ET_EN is zero (disable electrical throttling), ET_SMPL_PRD should be set
    // to zero to avoid the corresponding PSMI ET quiecense ack bit (CH_FRZE_ET_CNTR_ACK)
    // never asserted. 
    // Here is the recommended setting when ET_EN is enabled:
    // DCLK Setting
    // 400MHz 0x33
    // 533MHz 0x44
    // 667MHz 0x55
    // 800MHz 0x66
    // 933MHz 0x77
    // However, the setting is subject to change per platform power delivery recommendation.
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX et_smpl_prd : 8;
    //
    // Energy equation divider control
    // 00: divider=2 (the energy counter is right shift by 1 bit)
    // 01: divider=4 (the energy counter is right shift by 2 bit)
    // 10: divider=8 (the energy counter is right shift by 3 bit)
    // 11: divider=16 (the energy counter is right shift by 4 bit)
    // 
    // Bits[9:8], RW, default = 0x1
    //
    UINTX et_div : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // Enable Electrical Throttling
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX et_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 16;
  } Bits;
  UINTX Data;
} ET_CFG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CHN_TEMP_CFG_MC1LMSCH_REG                         0x00000108
#ifndef ASM_INC
typedef union {
  struct {
    //
    // BW Throttle Window Size in DCLK
    // 
    // Bits[10:0], RW, default = 0x3FF
    //
    UINTX bw_limit_tf : 11;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // When this bit is zero, MC will lower CKE during Thermal Throttling, and ISOCH
    // is blocked. When this bit is one, MC will NOT lower CKE during Thermal Throttling,
    // and ISOCH will be allowed base on bandwidth throttling setting. However, setting
    // this bit would mean more power consumption due to CKE is asserted during thermal
    // or power throttling. 
    // 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX thrt_allow_isoch : 1;
    //
    // Max number of throttled transactions to be issued during BWLIMITTF due to externally
    // asserted MEMHOT#. 
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX thrt_ext : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[26:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
    //
    // N/A
    // 
    // Bits[27:27], RW, default = 0x1
    //
    UINTX bw_limit_thrt_en : 1;
    //
    // lock bit of DIMMTEMPSTAT_[0:3][7:0]:Set this lock bit to disable configuration
    // write to DIMMTEMPSTAT_[0:3][7:0]. When this bit is clear, system debug/test software
    // can update the DIMMTEMPSTAT_[0:3][7:0] to verify various temperature scenerios.
    // 
    // Bits[28:28], RW_O, default = 0x1
    //
    UINTX cltt_debug_disable_lock : 1;
    //
    // The TEMP_STAT byte update mux select control to direct the source to update DIMMTEMPSTAT_[0:3][7:0]:0:
    // Corresponding to the DIMM TEMP_STAT byte from PCODE_TEMP_OUTPUT. 
    // 1: TSOD temperature reading from CLTT logic.
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINTX cltt_or_pcode_temp_mux_sel : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Enable OLTT temperature tracking
    // 
    // Bits[31:31], RW, default = 0x1
    //
    UINTX oltt_en : 1;
  } Bits;
  UINTX Data;
} CHN_TEMP_CFG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define CHN_TEMP_STAT_MC1LMSCH_REG                        0x0000010C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Event Asserted on DIMM ID 0
    // 
    // Bits[0:0], RW1C, default = 0x0
    //
    UINTX ev_asrt_dimm0 : 1;
    //
    // Event Asserted on DIMM ID 1
    // 
    // Bits[1:1], RW1C, default = 0x0
    //
    UINTX ev_asrt_dimm1 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 30;
  } Bits;
  UINTX Data;
} CHN_TEMP_STAT_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define DIMM_TEMP_OEM_0_MC1LMSCH_REG                      0x00000110
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Lower Threshold Value - TCase threshold at which to Initiate System Interrupt
    // (SMI or MEMHOT#) at a - going rate. Note: the default value is listed in decimal.valid
    // range: 32 - 127 in degree C. 
    // Others: reserved.
    // 
    // Bits[7:0], RW, default = 0x4B
    //
    UINTX temp_oem_lo : 8;
    //
    // Upper Threshold value - TCase threshold at which to Initiate System Interrupt
    // (SMI or MEMHOT#) at a + going rate. Note: the default value is listed in decimal.valid
    // range: 32 - 127 in degree C. 
    // Others: reserved.
    // 
    // Bits[15:8], RW, default = 0x50
    //
    UINTX temp_oem_hi : 8;
    //
    // Negative going Threshold Hysteresis Value. This value is added to TEMPOEMLO to
    // determine the point where the asserted status for that threshold will clear. Set
    // to 00h if sensor does not support negative-going threshold hysteresis. 
    // 
    // Bits[18:16], RW, default = 0x0
    //
    UINTX temp_oem_lo_hyst : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // Positive going Threshold Hysteresis Value. This value is subtracted from TEMPOEMHI
    // to determine the point where the asserted status for that threshold will clear.
    // Set to 00h if sensor does not support positive-going threshold hysteresis 
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINTX temp_oem_hi_hyst : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} DIMM_TEMP_OEM_0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define DIMM_TEMP_OEM_1_MC1LMSCH_REG                      0x00000114
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Lower Threshold Value - TCase threshold at which to Initiate System Interrupt
    // (SMI or MEMHOT#) at a - going rate. Note: the default value is listed in decimal.valid
    // range: 32 - 127 in degree C. 
    // Others: reserved.
    // 
    // Bits[7:0], RW, default = 0x4B
    //
    UINTX temp_oem_lo : 8;
    //
    // Upper Threshold value - TCase threshold at which to Initiate System Interrupt
    // (SMI or MEMHOT#) at a + going rate. Note: the default value is listed in decimal.valid
    // range: 32 - 127 in degree C. 
    // Others: reserved.
    // 
    // Bits[15:8], RW, default = 0x50
    //
    UINTX temp_oem_hi : 8;
    //
    // Negative going Threshold Hysteresis Value. This value is added to TEMPOEMLO to
    // determine the point where the asserted status for that threshold will clear. Set
    // to 00h if sensor does not support negative-going threshold hysteresis. 
    // 
    // Bits[18:16], RW, default = 0x0
    //
    UINTX temp_oem_lo_hyst : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // Positive going Threshold Hysteresis Value. This value is subtracted from TEMPOEMHI
    // to determine the point where the asserted status for that threshold will clear.
    // Set to 00h if sensor does not support positive-going threshold hysteresis 
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINTX temp_oem_hi_hyst : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} DIMM_TEMP_OEM_1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define DIMM_TEMP_TH_0_MC1LMSCH_REG                       0x00000120
#ifndef ASM_INC
typedef union {
  struct {
    //
    // TCase threshold at which to Initiate 2x refresh and/or THRTMID and initiate Interrupt
    // (MEMHOT#). 
    // Note: the default value is listed in decimal.valid range: 32 - 127 in degree C.
    // FF: Disabled
    // Others: reserved.
    // TEMP_LO should be programmed so it is less than TEMP_MID
    // 
    // Bits[7:0], RW, default = 0x55
    //
    UINTX temp_lo : 8;
    //
    // TCase threshold at which to Initiate THRTHI and assert valid range: 32 - 127 in
    // degree C. 
    // Note: the default value is listed in decimal.
    // FF: Disabled
    // Others: reserved.
    // TEMP_MID should be programmed so it is less than TEMP_HI
    // 
    // Bits[15:8], RW, default = 0x5A
    //
    UINTX temp_mid : 8;
    //
    // TCase threshold at which to Initiate THRTCRIT and assert THERMTRIP# valid range:
    // 32 - 127 in degree C. Note: the default value is listed in decimal. 
    // FF: Disabled
    // Others: reserved.
    // TEMP_HI should be programmed so it is greater than TEMP_MID
    // 
    // Bits[23:16], RW_LB, default = 0x5F
    //
    UINTX temp_hi : 8;
    //
    // Positive going Threshold Hysteresis Value. Set to 00h if sensor does not support
    // positive-going threshold hysteresis. This value is subtracted from TEMP_THRT_XX
    // to determine the point where the asserted status for that threshold will clear.
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX temp_thrt_hyst : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
  } Bits;
  UINTX Data;
} DIMM_TEMP_TH_0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define DIMM_TEMP_TH_1_MC1LMSCH_REG                       0x00000124
#ifndef ASM_INC
typedef union {
  struct {
    //
    // TCase threshold at which to Initiate 2x refresh and/or THRTMID and initiate Interrupt
    // (MEMHOT#). 
    // Note: the default value is listed in decimal.valid range: 32 - 127 in degree C.
    // FF: Disabled
    // Others: reserved.
    // TEMP_LO should be programmed so it is less than TEMP_MID
    // 
    // Bits[7:0], RW, default = 0x55
    //
    UINTX temp_lo : 8;
    //
    // TCase threshold at which to Initiate THRTHI and assert valid range: 32 - 127 in
    // degree C. 
    // Note: the default value is listed in decimal.
    // FF: Disabled
    // Others: reserved.
    // TEMP_MID should be programmed so it is less than TEMP_HI
    // 
    // Bits[15:8], RW, default = 0x5A
    //
    UINTX temp_mid : 8;
    //
    // TCase threshold at which to Initiate THRTCRIT and assert THERMTRIP# valid range:
    // 32 - 127 in degree C. Note: the default value is listed in decimal. 
    // FF: Disabled
    // Others: reserved.
    // TEMP_HI should be programmed so it is greater than TEMP_MID
    // 
    // Bits[23:16], RW_LB, default = 0x5F
    //
    UINTX temp_hi : 8;
    //
    // Positive going Threshold Hysteresis Value. Set to 00h if sensor does not support
    // positive-going threshold hysteresis. This value is subtracted from TEMP_THRT_XX
    // to determine the point where the asserted status for that threshold will clear.
    // 
    // Bits[26:24], RW_LB, default = 0x0
    //
    UINTX temp_thrt_hyst : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
  } Bits;
  UINTX Data;
} DIMM_TEMP_TH_1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define DIMM_TEMP_THRT_LMT_0_MC1LMSCH_REG                 0x00000130
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Max number of throttled transactions (ACT, READ, WRITE) to be issued during BWLIMITTF.
    // 
    // Bits[7:0], RW, default = 0xFF
    //
    UINTX thrt_mid : 8;
    //
    // Max number of throttled transactions (ACT, READ, WRITE) to be issued during BWLIMITTF.
    // 
    // Bits[15:8], RW_LB, default = 0xF
    //
    UINTX thrt_hi : 8;
    //
    // Max number of throttled transactions (ACT, READ, WRITE) to be issued during BWLIMITTF.
    // 
    // Bits[23:16], RW_LB, default = 0x0
    //
    UINTX thrt_crit : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} DIMM_TEMP_THRT_LMT_0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define DIMM_TEMP_THRT_LMT_1_MC1LMSCH_REG                 0x00000134
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Max number of throttled transactions (ACT, READ, WRITE) to be issued during BWLIMITTF.
    // 
    // Bits[7:0], RW, default = 0xFF
    //
    UINTX thrt_mid : 8;
    //
    // Max number of throttled transactions (ACT, READ, WRITE) to be issued during BWLIMITTF.
    // 
    // Bits[15:8], RW_LB, default = 0xF
    //
    UINTX thrt_hi : 8;
    //
    // Max number of throttled transactions (ACT, READ, WRITE) to be issued during BWLIMITTF.
    // 
    // Bits[23:16], RW_LB, default = 0x0
    //
    UINTX thrt_crit : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} DIMM_TEMP_THRT_LMT_1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define DIMM_TEMP_EV_OFST_0_MC1LMSCH_REG                  0x00000140
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit 3-0 - Temperature Offset Register
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX dimm_temp_offset : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // Assert MEMHOT# Event on TEMPOEMLO
    // 
    // Bits[8:8], RW_LB, default = 0x0
    //
    UINTX ev_mh_tempoemlo_en : 1;
    //
    // Assert MEMHOT# Event on TEMPOEMHI
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX ev_mh_tempoemhi_en : 1;
    //
    // Assert MEMHOT# Event on TEMPLO
    // 
    // Bits[10:10], RW_LB, default = 0x0
    //
    UINTX ev_mh_templo_en : 1;
    //
    // Assert MEMHOT# Event on TEMPMID
    // 
    // Bits[11:11], RW_LB, default = 0x0
    //
    UINTX ev_mh_tempmid_en : 1;
    //
    // Assert MEMHOT# Event on TEMPHI
    // 
    // Bits[12:12], RW_LB, default = 0x0
    //
    UINTX ev_mh_temphi_en : 1;
    //
    // Initiate 2X refresh on TEMPLO
    // DIMM with extended temperature range capability will need double refresh rate
    // in order to avoid data lost when DIMM temperature is above 85C but below 95C.
    // Warning: If the 2x refresh is disable with extended temperature range DIMM configuration,
    // system cooling and power thermal throttling scheme must guarantee the DIMM temperature
    // will not exceed 85C. 
    // 
    // Bits[13:13], RW, default = 0x1
    //
    UINTX ev_2x_ref_templo_en : 1;
    //
    // Initiate THRTMID on TEMPLO
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX ev_thrtmid_templo : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 9;
    //
    // Temperature data is averaged over this period. At the end of averaging period
    // (ms) , averaging process starts again. 0x1 - 0xFF = Averaging data is read via
    // TEMPDIMM STATUSREGISTER (Byte 1/2) as well as used for generating hysteresis based
    // interrupts. 
    // 00 = Instantaneous Data (non-averaged) is read via TEMPDIMM STATUSREGISTER (Byte
    // 1/2) as well as used for generating hysteresis based interrupts. 
    // Note: The processor does not support temp averaging.
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX temp_avg_intrvl : 8;
  } Bits;
  UINTX Data;
} DIMM_TEMP_EV_OFST_0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define DIMM_TEMP_EV_OFST_1_MC1LMSCH_REG                  0x00000144
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bit 3-0 - Temperature Offset Register
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX dimm_temp_offset : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 4;
    //
    // Assert MEMHOT# Event on TEMPOEMLO
    // 
    // Bits[8:8], RW_LB, default = 0x0
    //
    UINTX ev_mh_tempoemlo_en : 1;
    //
    // Assert MEMHOT# Event on TEMPOEMHI
    // 
    // Bits[9:9], RW_LB, default = 0x0
    //
    UINTX ev_mh_tempoemhi_en : 1;
    //
    // Assert MEMHOT# Event on TEMPLO
    // 
    // Bits[10:10], RW_LB, default = 0x0
    //
    UINTX ev_mh_templo_en : 1;
    //
    // Assert MEMHOT# Event on TEMPMID
    // 
    // Bits[11:11], RW_LB, default = 0x0
    //
    UINTX ev_mh_tempmid_en : 1;
    //
    // Assert MEMHOT# Event on TEMPHI
    // 
    // Bits[12:12], RW_LB, default = 0x0
    //
    UINTX ev_mh_temphi_en : 1;
    //
    // Initiate 2X refresh on TEMPLO
    // DIMM with extended temperature range capability will need double refresh rate
    // in order to avoid data lost when DIMM temperature is above 85C but below 95C.
    // Warning: If the 2x refresh is disable with extended temperature range DIMM configuration,
    // system cooling and power thermal throttling scheme must guarantee the DIMM temperature
    // will not exceed 85C. 
    // 
    // Bits[13:13], RW, default = 0x1
    //
    UINTX ev_2x_ref_templo_en : 1;
    //
    // Initiate THRTMID on TEMPLO
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINTX ev_thrtmid_templo : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 9;
    //
    // Temperature data is averaged over this period. At the end of averaging period
    // (ms) , averaging process starts again. 0x1 - 0xFF = Averaging data is read via
    // TEMPDIMM STATUSREGISTER (Byte 1/2) as well as used for generating hysteresis based
    // interrupts. 
    // 00 = Instantaneous Data (non-averaged) is read via TEMPDIMM STATUSREGISTER (Byte
    // 1/2) as well as used for generating hysteresis based interrupts. 
    // Note: The processor does not support temp averaging.
    // 
    // Bits[31:24], RO, default = 0x0
    //
    UINTX temp_avg_intrvl : 8;
  } Bits;
  UINTX Data;
} DIMM_TEMP_EV_OFST_1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define DIMMTEMPSTAT_0_MC1LMSCH_REG                       0x00000150
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current DIMM Temperature for thermal throttling
    // 
    // Bits[7:0], RW_LV, default = 0x55
    //
    UINTX dimm_temp : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
    //
    // Event Asserted on TEMPOEMHI Going High
    // It is assumed that each of the event assertion is going to trigger
    // Configurable interrupt (Either MEMHOT# only or both SMI and
    // MEMHOT#) defined in bit 30 of ÂCHN_TEMP_CFGÂ
    // 
    // Bits[24:24], RW1C, default = 0x0
    //
    UINTX ev_asrt_tempoemhi : 1;
    //
    // Event Asserted on TEMPOEMLO Going Low
    // It is assumed that each of the event assertion is going to trigger
    // Configurable interrupt (Either MEMHOT# only or both SMI and
    // MEMHOT#) defined in bit 30 of ÂCHN_TEMP_CFGÂ
    // 
    // Bits[25:25], RW1C, default = 0x0
    //
    UINTX ev_asrt_tempoemlo : 1;
    //
    // Event Asserted on TEMPLO Going High
    // It is assumed that each of the event assertion is going to trigger
    // Configurable interrupt (Either MEMHOT# only or both SMI and
    // MEMHOT#) defined in bit 30 of ÂCHN_TEMP_CFGÂ
    // 
    // Bits[26:26], RW1C, default = 0x0
    //
    UINTX ev_asrt_templo : 1;
    //
    // Event Asserted on TEMPMID going High
    // It is assumed that each of the event assertion is going to trigger
    // Configurable interrupt (Either MEMHOT# only or both SMI and
    // MEMHOT#) defined in bit 30 of ÂCHN_TEMP_CFGÂ
    // 
    // Bits[27:27], RW1C, default = 0x0
    //
    UINTX ev_asrt_tempmid : 1;
    //
    // Event Asserted on TEMPHI going HIGH
    // It is assumed that each of the event assertion is going to trigger
    // Configurable interrupt (Either MEMHOT# only or both SMI and
    // MEMHOT#) defined in bit 30 of ÂCHN_TEMP_CFGÂ
    // 
    // Bits[28:28], RW1C, default = 0x0
    //
    UINTX ev_asrt_temphi : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
  } Bits;
  UINTX Data;
} DIMMTEMPSTAT_0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define DIMMTEMPSTAT_1_MC1LMSCH_REG                       0x00000154
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Current DIMM Temperature for thermal throttling
    // 
    // Bits[7:0], RW_LV, default = 0x55
    //
    UINTX dimm_temp : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
    //
    // Event Asserted on TEMPOEMHI Going High
    // It is assumed that each of the event assertion is going to trigger
    // Configurable interrupt (Either MEMHOT# only or both SMI and
    // MEMHOT#) defined in bit 30 of CHN_TEMP_CFG
    // 
    // Bits[24:24], RW1C, default = 0x0
    //
    UINTX ev_asrt_tempoemhi : 1;
    //
    // Event Asserted on TEMPOEMLO Going Low
    // It is assumed that each of the event assertion is going to trigger
    // Configurable interrupt (Either MEMHOT# only or both SMI and
    // MEMHOT#) defined in bit 30 of ÂCHN_TEMP_CFGÂ
    // 
    // Bits[25:25], RW1C, default = 0x0
    //
    UINTX ev_asrt_tempoemlo : 1;
    //
    // Event Asserted on TEMPLO Going High
    // It is assumed that each of the event assertion is going to trigger
    // Configurable interrupt (Either MEMHOT# only or both SMI and
    // MEMHOT#) defined in bit 30 of ÂCHN_TEMP_CFGÂ
    // 
    // Bits[26:26], RW1C, default = 0x0
    //
    UINTX ev_asrt_templo : 1;
    //
    // Event Asserted on TEMPMID going High
    // It is assumed that each of the event assertion is going to trigger
    // Configurable interrupt (Either MEMHOT# only or both SMI and
    // MEMHOT#) defined in bit 30 of ÂCHN_TEMP_CFGÂ
    // 
    // Bits[27:27], RW1C, default = 0x0
    //
    UINTX ev_asrt_tempmid : 1;
    //
    // Event Asserted on TEMPHI going HIGH
    // It is assumed that each of the event assertion is going to trigger
    // Configurable interrupt (Either MEMHOT# only or both SMI and
    // MEMHOT#) defined in bit 30 of ÂCHN_TEMP_CFGÂ
    // 
    // Bits[28:28], RW1C, default = 0x0
    //
    UINTX ev_asrt_temphi : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 3;
  } Bits;
  UINTX Data;
} DIMMTEMPSTAT_1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define THRT_PWR_CHNL_MC1LMSCH_REG                        0x0000015C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Max amount of transaction energy to be allowed (per channel) during the 1 usec
    // throttling timeframe per power throttling. 
    // PCODE can update this register dynamically. Expect PCODE will stop issuing update
    // to this field during PSMI quiecense. 
    // No additional hardware preservation of this field is necessary for PSMI. Note
    // that the machine shifts this field left by one so the 
    // number written to the register is multiplied by 2 before being used.
    // 
    // Bits[14:0], RW, default = 0x7FFF
    //
    UINTX chnl_thrt_pwr : 15;
    //
    // bit[15]: set to one to enable the power throttling for the channel.
    // 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINTX chnl_thrt_pwr_en : 1;
  } Bits;
  UINTX Data;
} THRT_PWR_CHNL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define THRT_COUNT_CHNL_MC1LMSCH_REG                      0x0000015E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Upper 16b of 23b per channel throttling demand counter, i.e. bit[22:7]: counting
    // number of DCLK being throttled at this channel. 
    // This 23b counter is monotonic increment counter with auto wrap back to zero after
    // overflow. PCODE calculate the delta change 
    // from the previous reading in order to determine how many cycles are being throttled.
    // PSMI wipe will clear this counter.
    // 
    // Bits[15:0], RO_V, default = 0x0
    //
    UINTX chnl_thrt_count : 16;
  } Bits;
  UINTX Data;
} THRT_COUNT_CHNL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PM_CMD_PWR_0_MC1LMSCH_REG                         0x00000160
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Power contribution of CAS RD/RDS4 command in both OLTT and ET energy counters.
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX pwrcasr_dimm : 4;
    //
    // Power contribution of CAS WR/WRS4 command in both OLTT and ET energy counters.
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX pwrcasw_dimm : 4;
    //
    // Power contribution of ACT command in both OLTT and ET energy counters.
    // 
    // Bits[13:8], RW, default = 0x0
    //
    UINTX pwract_dimm : 6;
    //
    // Power contribution of 1x REF or SRE command. The 8b refresh weight defined here
    // is actually being multplied by 8 (shift left by 3 bits) before being accumulated
    // in the electrical throttling and OLTT counters. 
    // 
    // Bits[21:14], RW, default = 0x0
    //
    UINTX pwrref_dimm : 8;
    //
    // Defines number of DCLK of CKE-assertion to increase the OLTT and ET energy counters
    // (i.e. corresponding PMSUMPCCXRY, ET_DIMMSUM and ET_CH_SUM) by 4. Hardware provides
    // internal CKE counters (two per DIMM slot) to track each CKE. When the internal
    // count decrement to zero, the corresponding OLTT and ET energy counters are increment
    // by 4 and the internal CKE counter is loaded with the content of this register
    // field. 
    // PSMI wipe will clear the internal CKE counters.
    // Valid Range of the register field : 1 - 31. Others: reserved.
    // Due to the energy accumulator width limitation, we have imposed additional programming
    // limitation - this field must be programmed equal or greater than 4 DCLKs 
    // Programming below 4 is not validated and may jeopardize missing thermal event
    // or proper electrical/power throttling during certain corner cases due to energy
    // accumulator over-flow. 
    // 
    // Bits[26:22], RW, default = 0x10
    //
    UINTX active_idle_dimm : 5;
    //
    // Defines number of DCLK of ODT-assertion to increase the OLTT and ET energy counters
    // (i.e. corresponding PMSUMPCCXRY, ET_DIMMSUM and ET_CH_SUM) by 16. Hardware provides
    // internal ODT counters (two per DIMM slot) to track each ODT. When the internal
    // count decrement to zero, the corresponding OLTT and ET energy counters are incremented
    // by 16 and the internal ODT counter is loaded with the content of this register
    // field. 
    // PSMI wipe will clear the internal ODT counters.
    // Possible Valid Range of the register field : 1 - 31. Others: reserved.
    // Due to the energy accumulator width limitation, we have imposed additional programming
    // limitation - this field must be programmed equal or greater than 4 DCLKs 
    // Programming below 4 is not validated and may jeopardize missing thermal event
    // or proper electrical/power throttling during certain corner cases due to energy
    // accumulator over-flow. 
    // 
    // Bits[31:27], RW, default = 0x10
    //
    UINTX pwrodt_cnt_dimm : 5;
  } Bits;
  UINTX Data;
} PM_CMD_PWR_0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PM_CMD_PWR_1_MC1LMSCH_REG                         0x00000164
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Power contribution of CAS RD/RDS4 command in both OLTT and ET energy counters.
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX pwrcasr_dimm : 4;
    //
    // Power contribution of CAS WR/WRS4 command in both OLTT and ET energy counters.
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINTX pwrcasw_dimm : 4;
    //
    // Power contribution of ACT command in both OLTT and ET energy counters.
    // 
    // Bits[13:8], RW, default = 0x0
    //
    UINTX pwract_dimm : 6;
    //
    // Power contribution of 1x REF or SRE command. The 8b refresh weight defined here
    // is actually being multplied by 8 (shift left by 3 bits) before being accumulated
    // in the electrical throttling and OLTT counters. 
    // 
    // Bits[21:14], RW, default = 0x0
    //
    UINTX pwrref_dimm : 8;
    //
    // Defines number of DCLK of CKE-assertion to increase the OLTT and ET energy counters
    // (i.e. corresponding PMSUMPCCXRY, ET_DIMMSUM and ET_CH_SUM) by 4. Hardware provides
    // internal CKE counters (two per DIMM slot) to track each CKE. When the internal
    // count decrement to zero, the corresponding OLTT and ET energy counters are increment
    // by 4 and the internal CKE counter is loaded with the content of this register
    // field. 
    // PSMI wipe will clear the internal CKE counters.
    // Valid Range of the register field : 1 - 31. Others: reserved.
    // Due to the energy accumulator width limitation, we have imposed additional programming
    // limitation - this field must be programmed equal or greater than 4 DCLKs 
    // Programming below 4 is not validated and may jeopardize missing thermal event
    // or proper electrical/power throttling during certain corner cases due to energy
    // accumulator over-flow. 
    // 
    // Bits[26:22], RW, default = 0x10
    //
    UINTX active_idle_dimm : 5;
    //
    // Defines number of DCLK of ODT-assertion to increase the OLTT and ET energy counters
    // (i.e. corresponding PMSUMPCCXRY, ET_DIMMSUM and ET_CH_SUM) by 16. Hardware provides
    // internal ODT counters (two per DIMM slot) to track each ODT. When the internal
    // count decrement to zero, the corresponding OLTT and ET energy counters are incremented
    // by 16 and the internal ODT counter is loaded with the content of this register
    // field. 
    // PSMI wipe will clear the internal ODT counters.
    // Possible Valid Range of the register field : 1 - 31. Others: reserved.
    // Due to the energy accumulator width limitation, we have imposed additional programming
    // limitation - this field must be programmed equal or greater than 4 DCLKs 
    // Programming below 4 is not validated and may jeopardize missing thermal event
    // or proper electrical/power throttling during certain corner cases due to energy
    // accumulator over-flow. 
    // 
    // Bits[31:27], RW, default = 0x10
    //
    UINTX pwrodt_cnt_dimm : 5;
  } Bits;
  UINTX Data;
} PM_CMD_PWR_1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define THRT_CHNL_MC1LMSCH_REG                            0x0000016C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Max amount of transaction energy to be allowed (per channel) during the 1 usec
    // throttling timeframe per power throttling. 
    // PCODE can update this register dynamically. Expect PCODE will stop issuing update
    // to this field during PSMI quiecense. 
    // No additional hardware preservation of this field is necessary for PSMI. Note
    // that the machine shifts this field left by one so the 
    // number written to the register is multiplied by 2 before being used.
    // 
    // Bits[30:0], RW, default = 0x7FFFFFFF
    //
    UINTX pwr : 31;
    //
    // bit[31]: set to one to enable the power throttling for the channel.
    // 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX pwr_en : 1;
  } Bits;
  UINTX Data;
} THRT_CHNL_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ET_DIMM_AVG_SUM_0_MC1LMSCH_REG                    0x00000170
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DIMM energy current sum counter. When the ET_SAMPLE_PERIOD counter is counting
    // zero, the current sum (i.e. sum(i)) is used in the above Avg(i) calculation. The
    // ET_DIMM_SUM is reset in the next DCLK. This counter is sized to be sufficient
    // for all scenario and should not overlapped within valid ET_SAMPLE_PERIOD range.
    // 
    // Bits[15:0], RW_V, default = 0x0
    //
    UINTX et_dimm_sum : 16;
    //
    // DIMM Average EnergyAvg(i)=Sum(i)/ET_DIV+Avg(i-1)-Avg(i-1)/ET_DIV
    // PSMI ET Quiecense will freeze the counter for PSMI handler to read/update/restore.
    // PSMI handler code should clear this counter to prevent PSMI induced deadlock when
    // the current counter value is exceeding the threshold but the counter is frozen
    // by the quiesce. PSMI wipe or the clearing the Quiecense bit will resume the counter.
    // 
    // Bits[31:16], RW_V, default = 0x0
    //
    UINTX et_dimm_avg : 16;
  } Bits;
  UINTX Data;
} ET_DIMM_AVG_SUM_0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ET_DIMM_AVG_SUM_1_MC1LMSCH_REG                    0x00000174
#ifndef ASM_INC
typedef union {
  struct {
    //
    // DIMM energy current sum counter. When the ET_SAMPLE_PERIOD counter is counting
    // zero, the current sum (i.e. sum(i)) is used in the above Avg(i) calculation. The
    // ET_DIMM_SUM is reset in the next DCLK. This counter is sized to be sufficient
    // for all scenario and should not overlapped within valid ET_SAMPLE_PERIOD range.
    // 
    // Bits[15:0], RW_V, default = 0x0
    //
    UINTX et_dimm_sum : 16;
    //
    // DIMM Average EnergyAvg(i)=Sum(i)/ET_DIV+Avg(i-1)-Avg(i-1)/ET_DIV
    // PSMI ET Quiecense will freeze the counter for PSMI handler to read/update/restore.
    // PSMI handler code should clear this counter to prevent PSMI induced deadlock when
    // the current counter value is exceeding the threshold but the counter is frozen
    // by the quiesce. PSMI wipe or the clearing the Quiecense bit will resume the counter.
    // 
    // Bits[31:16], RW_V, default = 0x0
    //
    UINTX et_dimm_avg : 16;
  } Bits;
  UINTX Data;
} ET_DIMM_AVG_SUM_1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ET_DIMM_TH_0_MC1LMSCH_REG                         0x00000180
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Deassert electrical throttling when ET_DIMM_AVG is less than or equal to ET_DIMM_LO_TH.Note:
    // pcode may dynamically change and restore the programmed threshold. Updating the
    // threshold should take effect in the next DCLK. 
    // 
    // Bits[15:0], RW, default = 0xFFFF
    //
    UINTX et_dimm_lo_th : 16;
    //
    // Assert electrical throttling when ET_DIMM_AVG is greater than ET_DIMM_HI_TH.Note:
    // pcode may dynamically change and restore the programmed threshold. Updating the
    // threshold should take effect in the next DCLK. 
    // 
    // Bits[31:16], RW, default = 0xFFFF
    //
    UINTX et_dimm_hi_th : 16;
  } Bits;
  UINTX Data;
} ET_DIMM_TH_0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ET_DIMM_TH_1_MC1LMSCH_REG                         0x00000184
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Deassert electrical throttling when ET_DIMM_AVG is less than or equal to ET_DIMM_LO_TH.Note:
    // pcode may dynamically change and restore the programmed threshold. Updating the
    // threshold should take effect in the next DCLK. 
    // 
    // Bits[15:0], RW, default = 0xFFFF
    //
    UINTX et_dimm_lo_th : 16;
    //
    // Assert electrical throttling when ET_DIMM_AVG is greater than ET_DIMM_HI_TH.Note:
    // pcode may dynamically change and restore the programmed threshold. Updating the
    // threshold should take effect in the next DCLK. 
    // 
    // Bits[31:16], RW, default = 0xFFFF
    //
    UINTX et_dimm_hi_th : 16;
  } Bits;
  UINTX Data;
} ET_DIMM_TH_1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define THRT_PWR_DIMM_0_MC1LMSCH_REG                      0x00000190
#ifndef ASM_INC
typedef union {
  struct {
    //
    // bit[11:0]: Max number of transactions (ACT, READ, WRITE) to be allowed (per DIMM)
    // during the 1 usec throttling timeframe per power throttling. 
    // PCODE can update this register dynamically.
    // We expect PCODE will stop issuing update to this field during PSMI quiecense.
    // No additional hardware preservation of this field is necessary for PSMI. 
    // 
    // Bits[11:0], RW, default = 0xFFF
    //
    UINTX thrt_pwr : 12;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // bit[15]: set to one to enable the power throttling for the DIMM.
    // 
    // 
    // Bits[15:15], RW, default = 0x1
    //
    UINTX thrt_pwr_en : 1;
  } Bits;
  UINTX Data;
} THRT_PWR_DIMM_0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define THRT_PWR_DIMM_1_MC1LMSCH_REG                      0x00000192
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Max number of transactions (ACT, READ, WRITE) to be allowed (per DIMM) during
    // the 1 usec throttling timeframe per power throttling. 
    // PCODE can update this register dynamically.
    // 
    // 
    // Bits[11:0], RW, default = 0xFFF
    //
    UINTX thrt_pwr : 12;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // bit[15]: set to one to enable the power throttling for the DIMM.
    // 
    // 
    // Bits[15:15], RW, default = 0x1
    //
    UINTX thrt_pwr_en : 1;
  } Bits;
  UINTX Data;
} THRT_PWR_DIMM_1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define THRT_COUNT_DIMM_0_MC1LMSCH_REG                    0x00000198
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Upper 16b of 23b per DIMM throttling demand counter, i.e. bit[22:7]: counting
    // number of DCLK being throttled at this DIMM. 
    // This 23b counter is monotonic increment counter with auto wrap back to zero after
    // overflow. PCODE calculate the delta change 
    // from the previous reading in order to determine how many cycles are being throttled.
    // PSMI wipe will clear this counter.
    // 
    // Bits[15:0], RO_V, default = 0x0
    //
    UINTX thrt_count : 16;
  } Bits;
  UINTX Data;
} THRT_COUNT_DIMM_0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define THRT_COUNT_DIMM_1_MC1LMSCH_REG                    0x0000019A
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Upper 16b of 23b per DIMM throttling demand counter, i.e. bit[22:7]: counting
    // number of DCLK being throttled at this DIMM. This 23b counter is monotonic increment
    // counter with auto wrap back to zero after overflow. PCODE calculate the delta
    // change from the previous reading in order to determine how many cycles are being
    // throttled. 
    // PSMI wipe will clear this counter.
    // 
    // Bits[15:0], RO_V, default = 0x0
    //
    UINTX thrt_count : 16;
  } Bits;
  UINTX Data;
} THRT_COUNT_DIMM_1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMSUMPCCXRY_0_MC1LMSCH_REG                        0x000001A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per rank energy counter including CKE (active idle), ODT, REF (and SRE), ACT,
    // any read and any write command weight accumulation. PCODE should read this field
    // every ~1ms. 
    // Please note that during self-refresh, CKE power down, IMC will not be able to
    // perform the energy tracking for the SR, PPD-Fast or PPD-Slow. 
    // This register is paused after CH_FRZE_OLTT_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register after setting the CH_FORCERW bit
    // in EPMCCTRL_PSMI_QSC_CNTL register. 
    // Lock is the inverse of the CH_FORCERW.
    // 
    // Bits[31:0], RW_LV, default = 0x0
    //
    UINTX pmsumpccxry : 32;
  } Bits;
  UINTX Data;
} PMSUMPCCXRY_0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMSUMPCCXRY_1_MC1LMSCH_REG                        0x000001A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per rank energy counter including CKE (active idle), ODT, REF (and SRE), ACT,
    // any read and any write command weight accumulation. PCODE should read this field
    // every ~1ms. 
    // Please note that during self-refresh, CKE power down, IMC will not be able to
    // perform the energy tracking for the SR, PPD-Fast or PPD-Slow. 
    // This register is paused after CH_FRZE_OLTT_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register after setting the CH_FORCERW bit
    // in EPMCCTRL_PSMI_QSC_CNTL register. 
    // Lock is the inverse of the CH_FORCERW.
    // 
    // Bits[31:0], RW_LV, default = 0x0
    //
    UINTX pmsumpccxry : 32;
  } Bits;
  UINTX Data;
} PMSUMPCCXRY_1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMSUMPCCXRY_2_MC1LMSCH_REG                        0x000001A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per rank energy counter including CKE (active idle), ODT, REF (and SRE), ACT,
    // any read and any write command weight accumulation. PCODE should read this field
    // every ~1ms. 
    // Please note that during self-refresh, CKE power down, IMC will not be able to
    // perform the energy tracking for the SR, PPD-Fast or PPD-Slow. 
    // This register is paused after CH_FRZE_OLTT_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register after setting the CH_FORCERW bit
    // in EPMCCTRL_PSMI_QSC_CNTL register. 
    // Lock is the inverse of the CH_FORCERW.
    // 
    // Bits[31:0], RW_LV, default = 0x0
    //
    UINTX pmsumpccxry : 32;
  } Bits;
  UINTX Data;
} PMSUMPCCXRY_2_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMSUMPCCXRY_3_MC1LMSCH_REG                        0x000001AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per rank energy counter including CKE (active idle), ODT, REF (and SRE), ACT,
    // any read and any write command weight accumulation. PCODE should read this field
    // every ~1ms. 
    // Please note that during self-refresh, CKE power down, IMC will not be able to
    // perform the energy tracking for the SR, PPD-Fast or PPD-Slow. 
    // This register is paused after CH_FRZE_OLTT_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register after setting the CH_FORCERW bit
    // in EPMCCTRL_PSMI_QSC_CNTL register. 
    // Lock is the inverse of the CH_FORCERW.
    // 
    // Bits[31:0], RW_LV, default = 0x0
    //
    UINTX pmsumpccxry : 32;
  } Bits;
  UINTX Data;
} PMSUMPCCXRY_3_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMSUMPCCXRY_4_MC1LMSCH_REG                        0x000001B0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per rank energy counter including CKE (active idle), ODT, REF (and SRE), ACT,
    // any read and any write command weight accumulation. PCODE should read this field
    // every ~1ms. 
    // Please note that during self-refresh, CKE power down, IMC will not be able to
    // perform the energy tracking for the SR, PPD-Fast or PPD-Slow. 
    // This register is paused after CH_FRZE_OLTT_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register after setting the CH_FORCERW bit
    // in EPMCCTRL_PSMI_QSC_CNTL register. 
    // Lock is the inverse of the CH_FORCERW.
    // 
    // Bits[31:0], RW_LV, default = 0x0
    //
    UINTX pmsumpccxry : 32;
  } Bits;
  UINTX Data;
} PMSUMPCCXRY_4_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMSUMPCCXRY_5_MC1LMSCH_REG                        0x000001B4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per rank energy counter including CKE (active idle), ODT, REF (and SRE), ACT,
    // any read and any write command weight accumulation. PCODE should read this field
    // every ~1ms. 
    // Please note that during self-refresh, CKE power down, IMC will not be able to
    // perform the energy tracking for the SR, PPD-Fast or PPD-Slow. 
    // This register is paused after CH_FRZE_OLTT_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register after setting the CH_FORCERW bit
    // in EPMCCTRL_PSMI_QSC_CNTL register. 
    // Lock is the inverse of the CH_FORCERW.
    // 
    // Bits[31:0], RW_LV, default = 0x0
    //
    UINTX pmsumpccxry : 32;
  } Bits;
  UINTX Data;
} PMSUMPCCXRY_5_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMSUMPCCXRY_6_MC1LMSCH_REG                        0x000001B8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per rank energy counter including CKE (active idle), ODT, REF (and SRE), ACT,
    // any read and any write command weight accumulation. PCODE should read this field
    // every ~1ms. 
    // Please note that during self-refresh, CKE power down, IMC will not be able to
    // perform the energy tracking for the SR, PPD-Fast or PPD-Slow. 
    // This register is paused after CH_FRZE_OLTT_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register after setting the CH_FORCERW bit
    // in EPMCCTRL_PSMI_QSC_CNTL register. 
    // Lock is the inverse of the CH_FORCERW.
    // 
    // Bits[31:0], RW_LV, default = 0x0
    //
    UINTX pmsumpccxry : 32;
  } Bits;
  UINTX Data;
} PMSUMPCCXRY_6_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMSUMPCCXRY_7_MC1LMSCH_REG                        0x000001BC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per rank energy counter including CKE (active idle), ODT, REF (and SRE), ACT,
    // any read and any write command weight accumulation. PCODE should read this field
    // every ~1ms. 
    // Please note that during self-refresh, CKE power down, IMC will not be able to
    // perform the energy tracking for the SR, PPD-Fast or PPD-Slow. 
    // This register is paused after CH_FRZE_OLTT_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register after setting the CH_FORCERW bit
    // in EPMCCTRL_PSMI_QSC_CNTL register. 
    // Lock is the inverse of the CH_FORCERW.
    // 
    // Bits[31:0], RW_LV, default = 0x0
    //
    UINTX pmsumpccxry : 32;
  } Bits;
  UINTX Data;
} PMSUMPCCXRY_7_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMSUMPCCXRY_8_MC1LMSCH_REG                        0x000001C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per rank energy counter including CKE (active idle), ODT, REF (and SRE), ACT,
    // any read and any write command weight accumulation. PCODE should read this field
    // every ~1ms. 
    // Please note that during self-refresh, CKE power down, IMC will not be able to
    // perform the energy tracking for the SR, PPD-Fast or PPD-Slow. 
    // This register is paused after CH_FRZE_OLTT_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register after setting the CH_FORCERW bit
    // in EPMCCTRL_PSMI_QSC_CNTL register. 
    // Lock is the inverse of the CH_FORCERW.
    // 
    // Bits[31:0], RW_LV, default = 0x0
    //
    UINTX pmsumpccxry : 32;
  } Bits;
  UINTX Data;
} PMSUMPCCXRY_8_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMSUMPCCXRY_9_MC1LMSCH_REG                        0x000001C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per rank energy counter including CKE (active idle), ODT, REF (and SRE), ACT,
    // any read and any write command weight accumulation. PCODE should read this field
    // every ~1ms. 
    // Please note that during self-refresh, CKE power down, IMC will not be able to
    // perform the energy tracking for the SR, PPD-Fast or PPD-Slow. 
    // This register is paused after CH_FRZE_OLTT_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register after setting the CH_FORCERW bit
    // in EPMCCTRL_PSMI_QSC_CNTL register. 
    // Lock is the inverse of the CH_FORCERW.
    // 
    // Bits[31:0], RW_LV, default = 0x0
    //
    UINTX pmsumpccxry : 32;
  } Bits;
  UINTX Data;
} PMSUMPCCXRY_9_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMREQCOUNT_MC1LMSCH_REG                           0x000001E4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // counts every IMC request
    // //
    // // This register is paused after CH_FRZE_PM_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register before the WIPE. 
    // 
    // Bits[31:0], RW_V, default = 0x0
    //
    UINTX pwm_req_count : 32;
  } Bits;
  UINTX Data;
} PMREQCOUNT_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMCMDCOUNT_MC1LMSCH_REG                           0x000001E8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // counts every command on DDR3 interface
    // //
    // // This register is paused after CH_FRZE_PM_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register before the WIPE. 
    // 
    // Bits[31:0], RW_V, default = 0x0
    //
    UINTX pwm_cmd_cnt : 32;
  } Bits;
  UINTX Data;
} PMCMDCOUNT_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMRDDATACOUNT_MC1LMSCH_REG                        0x000001EC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // counts every read data
    // //
    // // This register is paused after CH_FRZE_PM_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register before the WIPE. 
    // 
    // Bits[31:0], RW_V, default = 0x0
    //
    UINTX pwm_rd_data_cnt : 32;
  } Bits;
  UINTX Data;
} PMRDDATACOUNT_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMWRITEDATACOUNT_MC1LMSCH_REG                     0x000001F0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // counts every write data request
    // //
    // // This register is paused after CH_FRZE_PM_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register before the WIPE. 
    // 
    // Bits[31:0], RW_V, default = 0x0
    //
    UINTX pwm_wr_data_cnt : 32;
  } Bits;
  UINTX Data;
} PMWRITEDATACOUNT_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ET_CH_AVG_MC1LMSCH_REG                            0x000001F4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Channel Average EnergyAvg(i)=Sum(i)/ET_DIV+Avg(i-1)-Avg(i-1)/ET_DIV
    // PSMI ET Quiecense will freeze the counter for PSMI handler to read/update/restore.
    // PSMI handler code should clear this counter to prevent PSMI induced deadlock when
    // the current counter value is exceeding the threshold but the counter is frozen
    // by the quiesce. PSMI wipe or the clearing the Quiecense bit will resume the counter.
    // 
    // Bits[17:0], RW_V, default = 0x0
    //
    UINTX et_ch_avg : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
  } Bits;
  UINTX Data;
} ET_CH_AVG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ET_CH_SUM_MC1LMSCH_REG                            0x000001F8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Channel energy current sum counter. When the ET_SAMPLE_PERIOD counter is counting
    // zero, the current sum (i.e. sum(i)) is used in the above Avg(i) calculation. The
    // ET_CH_SUM is reset in the next DCLK. The ET_CH_SUM is sized to be sufficient for
    // worst case scenario to avoid overflowing within valid ET_SAMPLE_PERIOD range.
    // 
    // Bits[17:0], RW_V, default = 0x0
    //
    UINTX et_ch_sum : 18;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
  } Bits;
  UINTX Data;
} ET_CH_SUM_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define ET_CH_TH_MC1LMSCH_REG                             0x000001FC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The 16b ET_CH_LO_TH field is actually the high order 16b of the 18b threshold
    // value, i.e. ET_CH_LO_TH[17:2]. 00b bits are the two least significant bits of
    // the 18b threshold. 
    // Channel energy low threshold.de-assert electrical throttling when ET_CH_AVG[17:0]
    // is less than or equal to ET_CH_LO_TH[17:0]. 
    // Note: firmware may dynamically change and restore the programmed threshold. Updating
    // the threshold should take effect in the next DCLK. 
    // 
    // Bits[15:0], RW, default = 0xFFFF
    //
    UINTX et_ch_lo_th : 16;
    //
    // The 16b ET_CH_HI_TH field is actually the high order 16b of the 18b threshold
    // value, i.e. ET_CH_HI_TH[17:2]. 00b bits are the two least significant bits of
    // the 18b threshold. 
    // Channel energy high threshold.Assert electrical throttling when ET_CH_AVG[17:0]
    // is greater than ET_CH_HI_TH[17:0]. 
    // Note: firmware may dynamically change and restore the programmed threshold. Updating
    // the threshold should take effect in the next DCLK. 
    // 
    // Bits[31:16], RW, default = 0xFFFF
    //
    UINTX et_ch_hi_th : 16;
  } Bits;
  UINTX Data;
} ET_CH_TH_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define MCTHRVISACFG_MC1LMSCH_REG                         0x00000350
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RWS_L, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RWS_L, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RWS_L, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RWS_L, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RWS_L, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCTHRVISACFG_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMDDRTWRITEDATACOUNT_MC1LMSCH_REG                 0x00000650
#ifndef ASM_INC
typedef union {
  struct {
    //
    // counts every write data request
    // //
    // // This register is paused after CH_FRZE_PM_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register before the WIPE. 
    // 
    // Bits[31:0], RW_V, default = 0x0
    //
    UINTX pwm_wr_data_cnt : 32;
  } Bits;
  UINTX Data;
} PMDDRTWRITEDATACOUNT_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMDDRTRDDATACOUNT_MC1LMSCH_REG                    0x00000654
#ifndef ASM_INC
typedef union {
  struct {
    //
    // counts every read data
    // //
    // // This register is paused after CH_FRZE_PM_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register before the WIPE. 
    // 
    // Bits[31:0], RW_V, default = 0x0
    //
    UINTX pwm_rd_data_cnt : 32;
  } Bits;
  UINTX Data;
} PMDDRTRDDATACOUNT_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMSUM_0_MC1LMSCH_REG                              0x00000658
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per DIMM energy counter including only read and write command weight accumulation.
    // PCODE should read this field every ~1ms. 
    // This register is paused after CH_FRZE_OLTT_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register after setting the CH_FORCERW bit
    // in EPMCCTRL_PSMI_QSC_CNTL register. 
    // Lock is the inverse of the CH_FORCERW.
    // 
    // Bits[31:0], RW_LV, default = 0x0
    //
    UINTX dimm : 32;
  } Bits;
  UINTX Data;
} PMSUM_0_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMSUM_1_MC1LMSCH_REG                              0x0000065C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Per DIMM energy counter including only read and write command weight accumulation.
    // PCODE should read this field every ~1ms. 
    // This register is paused after CH_FRZE_OLTT_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register after setting the CH_FORCERW bit
    // in EPMCCTRL_PSMI_QSC_CNTL register. 
    // Lock is the inverse of the CH_FORCERW.
    // 
    // Bits[31:0], RW_LV, default = 0x0
    //
    UINTX dimm : 32;
  } Bits;
  UINTX Data;
} PMSUM_1_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMSUM_DDRT_WEIGHT_MC1LMSCH_REG                    0x00000660
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Energy contribution of DDRT write command to DIMM 0.
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINTX wr_cmd_0 : 8;
    //
    // Energy contribution of DDRT read command to DIMM 0.
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINTX rd_cmd_0 : 8;
    //
    // Energy contribution of DDRT write command to DIMM 1.
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX wr_cmd_1 : 8;
    //
    // Energy contribution of DDRT read command to DIMM 1.
    // 
    // Bits[31:24], RW, default = 0x0
    //
    UINTX rd_cmd_1 : 8;
  } Bits;
  UINTX Data;
} PMSUM_DDRT_WEIGHT_MC1LMSCH_STRUCT;
#endif // ASM_INC

#define PMSUM_MC1LMSCH_REG                                0x00000664
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  Includes energy terms for DDR4 ACT, REF, Read CAS, and Write CAS, and also DDRT
    // read and write commands.  Also includes energy terms for ODT and CKE. 
    // This register is paused after CH_FRZE_OLTT_CNTR is set and resume counting during
    // PSMI wipe. PSMI handler can clear this register after setting the CH_FORCERW bit
    // in EPMCCTRL_PSMI_QSC_CNTL register. 
    // Lock is the inverse of the CH_FORCERW.
    // 
    // Bits[31:0], RW_LV, default = 0x0
    //
    UINTX channel : 32;
  } Bits;
  UINTX Data;
} PMSUM_MC1LMSCH_STRUCT;
#endif // ASM_INC


#endif // _MC1LMSCH_H_
