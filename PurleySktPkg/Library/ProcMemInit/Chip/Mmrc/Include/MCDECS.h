/*++

Copyright (c) 2005-2015 Intel Corporation. All rights reserved
This software and associated documentation (if any) is furnished
under a license and may only be used or copied in accordance
with the terms of the license. Except as permitted by such
license, no part of this software or documentation may be
reproduced, stored in a retrieval system, or transmitted in any
form or by any means without the express written consent of
Intel Corporation.

Module Name:

    File name:    MCDECS.h
    Input File:   SKX_MRC_for CTE updt-2015ww15.3.xlsx

Abstract:

    THIS FILE IS AUTO-GENERATED BY THE MMRC TOOL. DO NOT CHANGE THIS CODE.

    If edits are needed in this file, they must be done via the MMRC tool.

    If there is additional project-specific data required by the MMRC, it
    can be placed in MCDECS.h, which is used for non-tool-generated
    data

    Includes register defines specific to a project.

--*/
#ifndef _MCDECS_H_
#define _MCDECS_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define VID_MCDECS_REG                                    0x00000000
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The value is assigned by PCI-SIG to Intel.
    // 
    // Bits[15:0], RO, default = 0x8086
    //
    UINTX vendor_identification_number : 16;
  } Bits;
  UINTX Data;
} VID_MCDECS_STRUCT;
#endif // ASM_INC

#define DID_MCDECS_REG                                    0x00000002
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  
    // Start (h)	End (h)	Device
    // 0x203F		0x203F	
    // 0x2040		0x204B	MC
    // 0x204C		0x204F	M3KTI
    // 0x2054		0x2054	CHASADALL
    // 0x2055		0x2055	CHAUTILALL
    // 0x2056		0x2056	CHAUTILALL1
    // 0x2057		0x2057	CHAPMAALL
    // 0x2058		0x205B	KTI
    // 0x2066		0x2067	M2MEM
    // 0x2068		0x206F	MC DDRIO
    // 0x2078		0x207F	VCU
    // 0x2080		0x2087	PCU
    // 0x2088		0x2088	
    // 0x2089		0x2089	
    // 0x208A		0x208A	
    // 0x208B		0x208B	
    // 0x208C		0x208C	
    // 0x208D		0x208D	CHAUTIL
    // 0x208E		0x208E	CHASAD
    // 0x208F		0x208F	CMSCHA
    // 0x2090		0x209F	RSVD FOR PCU FUNCTION 3
    // 	
    // 
    // Bits[15:0], RO, default = 0x2044
    //
    UINTX device_identification_number : 16;
  } Bits;
  UINTX Data;
} DID_MCDECS_STRUCT;
#endif // ASM_INC

#define PCICMD_MCDECS_REG                                 0x00000004
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Hardwired to 0 since these devices don't decode any IO BARs
    // 
    // Bits[0:0], RO, default = 0x0
    //
    UINTX io_space_enable : 1;
    //
    // Hardwired to 0 since these devices don't decode any memory BARs
    // 
    // Bits[1:1], RO, default = 0x0
    //
    UINTX memory_space_enable : 1;
    //
    // Hardwired to 0 since these devices don't generate any transactions
    // 
    // Bits[2:2], RO, default = 0x0
    //
    UINTX bus_master_enable : 1;
    //
    // Not applicable. Hardwired to 0.
    // 
    // Bits[3:3], RO, default = 0x0
    //
    UINTX special_cycle_enable : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[4:4], RO, default = 0x0
    //
    UINTX memory_write_and_invalidate_enable : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[5:5], RO, default = 0x0
    //
    UINTX vga_palette_snoop_enable : 1;
    //
    // This bit has no impact on error reporting from these devices
    // 
    // Bits[6:6], RO, default = 0x0
    //
    UINTX parity_error_response : 1;
    //
    // Not applicable to internal devices. Hardwired to 0.
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX idsel_stepping_wait_cycle_control : 1;
    //
    // This bit has no impact on error reporting from these devices
    // 
    // Bits[8:8], RO, default = 0x0
    //
    UINTX serr_enable : 1;
    //
    // Not applicable to PCI Express and is hardwired to 0
    // 
    // Bits[9:9], RO, default = 0x0
    //
    UINTX fast_back_to_back_enable : 1;
    //
    // N/A for these devices
    // 
    // Bits[10:10], RO, default = 0x0
    //
    UINTX intx_disable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
  } Bits;
  UINTX Data;
} PCICMD_MCDECS_STRUCT;
#endif // ASM_INC

#define PCISTS_MCDECS_REG                                 0x00000006
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // Reflects the state of the INTA# signal at the input of the enable/disable circuit.
    //  This bit is set by HW to 1 when the INTA# is asserted.  This bit is reset by
    // HW to 0 after the interrupt is cleared (independent of the state of the Interrupt
    // Disable bit in the 0.4.0.PCICMD register). 
    // Hardwired to 0 on the processor
    // 
    // Bits[3:3], RO, default = 0x0
    //
    UINTX intx_status : 1;
    //
    // This bit indicates the presence of a capabilities list structure. When set to
    // 1, indicates the register at 34h provides an offset into the function. 
    // 
    // Bits[4:4], RO, default = 0x1
    //
    UINTX capabilities_list : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[5:5], RO, default = 0x0
    //
    UINTX x66mhz_capable : 1;
    //
    // Reserved
    // 
    // Bits[6:6], RO, default = 0x0
    //
    UINTX reserved : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[7:7], RO, default = 0x0
    //
    UINTX fast_back_to_back : 1;
    //
    // Hardwired to 0
    // 
    // Bits[8:8], RO, default = 0x0
    //
    UINTX master_data_parity_error : 1;
    //
    // Not applicable to PCI Express. Hardwired to 0.
    // 
    // Bits[10:9], RO, default = 0x0
    //
    UINTX devsel_timing : 2;
    //
    // Hardwired to 0
    // 
    // Bits[11:11], RO, default = 0x0
    //
    UINTX signaled_target_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[12:12], RO, default = 0x0
    //
    UINTX received_target_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[13:13], RO, default = 0x0
    //
    UINTX received_master_abort : 1;
    //
    // Hardwired to 0
    // 
    // Bits[14:14], RO, default = 0x0
    //
    UINTX signaled_system_error : 1;
    //
    // This bit is set when the device receives a packet on the primary side with an
    // uncorrectable data error (including a packet with poison bit set) or an uncorrectable
    // address/control parity error. The setting of this bit is regardless of the Parity
    // Error Response bit (PERRE) in the PCICMD register. 
    // 
    // Bits[15:15], RO_V, default = 0x0
    //
    UINTX detected_parity_error : 1;
  } Bits;
  UINTX Data;
} PCISTS_MCDECS_STRUCT;
#endif // ASM_INC

#define RID_MCDECS_REG                                    0x00000008
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Reflects the Uncore Revision ID after reset.
    // Reflects the Compatibility Revision ID after BIOS writes 0x69 to any RID register
    // in the processor uncore. 
    //         
    // 
    // Bits[7:0], RO_V, default = 0x0
    //
    UINTX revision_id : 8;
  } Bits;
  UINTX Data;
} RID_MCDECS_STRUCT;
#endif // ASM_INC

#define CCR_MCDECS_REG                                    0x00000009
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A
    // 
    // Bits[7:0], RO_V, default = 0x0
    //
    UINTX register_level_programming_interface : 8;
    //
    // The value changes dependent upon the dev/func accessed. A table of the values
    // can be found in the Class-code tab of the msgch spread-sheet  
    // 	  Most dev-func will return 8'h80 for this field except for the following dev-func0,func1,...
    // combinations. The following exceptions will return 8'h01. Please refer to /src/uncore/ncu/f_ccr_reg.vh
    // for the full lookingup table. 
    //           bus-0, dev-8 func-1 
    //           bus-3, dev-14 to 16, func-0
    //           bus-3, dev-18, func-0, 1, 4, 5
    //         
    // 
    // Bits[15:8], RO_V, default = 0x80
    //
    UINTX sub_class : 8;
    //
    // The value changes dependent upon the dev-func accessed. A table of the values
    // can be found in the Class-code tab of the msgch spread-sheet  
    // 	  Most bus-dev-func will return 8'h08 for this field except for the following
    // bus-dev-func0,func1,... combinations. The following exceptions will return 8'h11.
    // Please refer to /src/uncore/ncu/f_ccr_reg.vhfor the full lookingup table. 
    //           bus-0, dev-8 func-1 
    //           bus-3, dev-14 to 16, func-0
    //           bus-3, dev-18, func-0, 1, 4, 5
    //         
    // 
    // Bits[23:16], RO_V, default = 0x8
    //
    UINTX base_class : 8;
  } Bits;
  UINTX Data;
} CCR_MCDECS_STRUCT;
#endif // ASM_INC

#define CLSR_MCDECS_REG                                   0x0000000C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Size of Cacheline
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX cacheline_size : 8;
  } Bits;
  UINTX Data;
} CLSR_MCDECS_STRUCT;
#endif // ASM_INC

#define PLAT_MCDECS_REG                                   0x0000000D
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Not applicable to PCI-Express. Hardwired to 00h.
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX primary_latency_timer : 8;
  } Bits;
  UINTX Data;
} PLAT_MCDECS_STRUCT;
#endif // ASM_INC

#define HDR_MCDECS_REG                                    0x0000000E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Type 0 header
    // 
    // Bits[6:0], RO, default = 0x0
    //
    UINTX configuration_layout : 7;
    //
    // This bit defaults to 1b since all these devices are multi-function
    // 
    // Bits[7:7], RO, default = 0x1
    //
    UINTX multi_function_device : 1;
  } Bits;
  UINTX Data;
} HDR_MCDECS_STRUCT;
#endif // ASM_INC

#define BIST_MCDECS_REG                                   0x0000000F
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Not supported. Hardwired to 00h
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX bist_tests : 8;
  } Bits;
  UINTX Data;
} BIST_MCDECS_STRUCT;
#endif // ASM_INC

#define SVID_MCDECS_REG                                   0x0000002C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The default value specifies Intel but can be set to any value once after reset.
    // 
    // Bits[15:0], RW_O, default = 0x8086
    //
    UINTX subsystem_vendor_identification_number : 16;
  } Bits;
  UINTX Data;
} SVID_MCDECS_STRUCT;
#endif // ASM_INC

#define SDID_MCDECS_REG                                   0x0000002E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Assigned by the subsystem vendor to uniquely identify the subsystem
    // 
    // Bits[15:0], RW_O, default = 0x0
    //
    UINTX subsystem_device_identification_number : 16;
  } Bits;
  UINTX Data;
} SDID_MCDECS_STRUCT;
#endif // ASM_INC

#define CAPPTR_MCDECS_REG                                 0x00000034
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Points to the first capability structure for the device which is the PCIe capability.
    // 
    // Bits[7:0], RO, default = 0x40
    //
    UINTX capability_pointer : 8;
  } Bits;
  UINTX Data;
} CAPPTR_MCDECS_STRUCT;
#endif // ASM_INC

#define INTL_MCDECS_REG                                   0x0000003C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A for these devices
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX interrupt_line : 8;
  } Bits;
  UINTX Data;
} INTL_MCDECS_STRUCT;
#endif // ASM_INC

#define INTPIN_MCDECS_REG                                 0x0000003D
#ifndef ASM_INC
typedef union {
  struct {
    //
    // N/A since these devices do not generate any interrupt on their own
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX interrupt_pin : 8;
  } Bits;
  UINTX Data;
} INTPIN_MCDECS_STRUCT;
#endif // ASM_INC

#define MINGNT_MCDECS_REG                                 0x0000003E
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The device does not burst as a PCI compliant master.
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX mgv : 8;
  } Bits;
  UINTX Data;
} MINGNT_MCDECS_STRUCT;
#endif // ASM_INC

#define MAXLAT_MCDECS_REG                                 0x0000003F
#ifndef ASM_INC
typedef union {
  struct {
    //
    // The device has no specific requirements for how often it needs to access the PCI
    // bus. 
    // 
    // Bits[7:0], RO, default = 0x0
    //
    UINTX mlv : 8;
  } Bits;
  UINTX Data;
} MAXLAT_MCDECS_STRUCT;
#endif // ASM_INC

#define PXPCAP_MCDECS_REG                                 0x00000040
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Provides the PCI Express capability ID assigned by PCI-SIG.
    // 
    // Bits[7:0], RO, default = 0x10
    //
    UINTX capability_id : 8;
    //
    // Pointer to the next capability. Set to 0 to indicate there are no more capability
    // structures. 
    // 
    // Bits[15:8], RO, default = 0x0
    //
    UINTX next_ptr : 8;
    //
    // PCI Express Capability is Compliant with Version 1.0 of the PCI Express Spec.
    // Note:
    // This capability structure is not compliant with Versions beyond 1.0, since they
    // require additional capability registers to be reserved. The only purpose for this
    // capability structure is to make enhanced configuration space available. Minimizing
    // the size of this structure is accomplished by reporting version 1.0 compliancy
    // and reporting that this is an integrated root port device. As such, only three
    // Dwords of configuration space are required for this structure. 
    // 
    // Bits[19:16], RO, default = 0x1
    //
    UINTX capability_version : 4;
    //
    // Device type is Root Complex Integrated Endpoint
    // 
    // Bits[23:20], RO, default = 0x9
    //
    UINTX device_port_type : 4;
    //
    // N/A for integrated endpoints
    // 
    // Bits[24:24], RO, default = 0x0
    //
    UINTX slot_implemented : 1;
    //
    // N/A for this device
    // 
    // Bits[29:25], RO, default = 0x0
    //
    UINTX interrupt_message_number : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} PXPCAP_MCDECS_STRUCT;
#endif // ASM_INC

#define DIMMMTR_0_MCDECS_REG                              0x00000080
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 00 - 10 bits
    // 01 - 11 bits
    // 10 - 12 bits
    // 11 - reserved
    // 
    // Bits[1:0], RWS_LB, default = 0x0
    //
    UINTX ca_width : 2;
    //
    // 000 - reserved 
    // 001 - 13 bits
    // 010 - 14 bits
    // 011 - 15 bits
    // 100 - 16 bits
    // 101 - 17 bits
    // 110 - 18 bits
    // 111: reserved
    // 
    // Bits[4:2], RWS_LB, default = 0x3
    //
    UINTX ra_width : 3;
    //
    // 000 - Reserved
    // 001 - 2Gb
    // 010 - 4Gb
    // 011 - 8Gb
    // 100 - 16Gb
    // 101 - 12Gb
    // 
    // 
    // Bits[7:5], RWS_LB, default = 0x0
    //
    UINTX ddr3_dnsty : 3;
    //
    // 00 - x4
    // 01 - x8
    // 10 - x16
    // 11 - reserved
    // 
    // 
    // Bits[9:8], RWS_LB, default = 0x0
    //
    UINTX ddr3_width : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 
    // 00 - SR
    // 01 - DR
    // 10 - QR
    // 11 - reserved
    // 
    // 
    // Bits[13:12], RWS_LB, default = 0x0
    //
    UINTX rank_cnt : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //             DDR4 DIMM populated if set; otherwise, unpopulated.
    //             Should be set to 0 when this slot is populated with a DDR-T DIMM.
    //         
    // 
    // Bits[15:15], RWS_LB, default = 0x0
    //
    UINTX dimm_pop : 1;
    //
    // RANK Disable Control to disable refresh and ZQCAL operation. This bit setting
    // must be set consistently with TERM_RNK_MSK, i.e. both corresponding bits cannot
    // be set at the same time. In the other word, a disabled rank must not be selected
    // for the terminaton rank. 
    // RANK_DISABLE[3], i.e. bit 19: rank 3 disable. Note DIMMMTR_2.RANK_DISABLE[3] is
    // don't care since DIMM 2 must not be quad-rank 
    // RANK_DISABLE[2], i.e. bit 18: rank 2 disable. Note DIMMMTR_2.RANK_DISABLE[2] is
    // don't care since DIMM 2 must not be quad-rank 
    // RANK_DISABLE[1], i.e. bit 17: rank 1 disable
    // RANK_DISABLE[0], i.e. bit 16: rank 0 disable
    // when set, no refresh will be perform on this rank. ODT termination is not affected
    // by this bit. 
    // Note that patrols are disabled by dimm*_pat_rank_disable of amap register now
    // and not affected by this bit field. 
    // 
    // Bits[19:16], RWS_LB, default = 0x0
    //
    UINTX rank_disable : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // When set, will enable High Density Reduced Load mode which will transmit Row address
    // bits 17:16 on chip select lines 
    // 7:6 and 3:2.
    // 
    // Bits[21:21], RWS_LB, default = 0x0
    //
    UINTX hdrl : 1;
    //
    // When set, will enable parity calculation to include address bits 17:16 which are
    // sent on chip select lines 
    // 7:6 and 3:2.
    // 
    // Bits[22:22], RWS_LB, default = 0x0
    //
    UINTX hdrl_parity : 1;
    //
    // Number of sub ranks per chip select per dimm of DDR4 3DS and non3ds_lrdimm (this
    // is a dimm 
    // specific field. There are restriction on rank_cnt field if this field is nonzero
    // fro 3ds devices. 
    // Can not mix 2 chip_select parts and 1 chip_select part on the same channel)
    // 00- 3ds/non3ds_lrdimm ddr4 multiple ranks/chip select disabled
    // 01- 2 ranks per chip select
    // 10- 4 ranks per chip select
    // 11- 8 ranks per chip select
    // 
    // Bits[24:23], RWS_LB, default = 0x0
    //
    UINTX ddr4_3dsnumranks_cs : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 7;
  } Bits;
  UINTX Data;
} DIMMMTR_0_MCDECS_STRUCT;
#endif // ASM_INC

#define DIMMMTR_1_MCDECS_REG                              0x00000084
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 00 - 10 bits
    // 01 - 11 bits
    // 10 - 12 bits
    // 11 - reserved
    // 
    // Bits[1:0], RWS_LB, default = 0x0
    //
    UINTX ca_width : 2;
    //
    // 000 - reserved 
    // 001 - 13 bits
    // 010 - 14 bits
    // 011 - 15 bits
    // 100 - 16 bits
    // 101 - 17 bits
    // 110 - 18 bits
    // 111: reserved
    // 
    // Bits[4:2], RWS_LB, default = 0x3
    //
    UINTX ra_width : 3;
    //
    // 000 - Reserved
    // 001 - 2Gb
    // 010 - 4Gb
    // 011 - 8Gb
    // 100 - 16Gb
    // 101 - 12Gb
    // 
    // 
    // Bits[7:5], RWS_LB, default = 0x0
    //
    UINTX ddr3_dnsty : 3;
    //
    // 00 - x4
    // 01 - x8
    // 10 - x16
    // 11 - reserved
    // 
    // 
    // Bits[9:8], RWS_LB, default = 0x0
    //
    UINTX ddr3_width : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 
    // 00 - SR
    // 01 - DR
    // 10 - QR
    // 11 - reserved
    // 
    // 
    // Bits[13:12], RWS_LB, default = 0x0
    //
    UINTX rank_cnt : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //             DDR4 DIMM populated if set; otherwise, unpopulated.
    //             Should be set to 0 when this slot is populated with a DDR-T DIMM.
    //         
    // 
    // Bits[15:15], RWS_LB, default = 0x0
    //
    UINTX dimm_pop : 1;
    //
    // RANK Disable Control to disable refresh and ZQCAL operation. This bit setting
    // must be set consistently with TERM_RNK_MSK, i.e. both corresponding bits cannot
    // be set at the same time. In the other word, a disabled rank must not be selected
    // for the terminaton rank. 
    // RANK_DISABLE[3], i.e. bit 19: rank 3 disable. Note DIMMMTR_2.RANK_DISABLE[3] is
    // don't care since DIMM 2 must not be quad-rank 
    // RANK_DISABLE[2], i.e. bit 18: rank 2 disable. Note DIMMMTR_2.RANK_DISABLE[2] is
    // don't care since DIMM 2 must not be quad-rank 
    // RANK_DISABLE[1], i.e. bit 17: rank 1 disable
    // RANK_DISABLE[0], i.e. bit 16: rank 0 disable
    // when set, no refresh will be perform on this rank. ODT termination is not affected
    // by this bit. 
    // Note that patrols are disabled by dimm*_pat_rank_disable of amap register now
    // and not affected by this bit field. 
    // 
    // Bits[19:16], RWS_LB, default = 0x0
    //
    UINTX rank_disable : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[22:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // N/A
    // 
    // Bits[24:23], RWS_LB, default = 0x0
    //
    UINTX ddr4_3dsnumranks_cs : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 7;
  } Bits;
  UINTX Data;
} DIMMMTR_1_MCDECS_STRUCT;
#endif // ASM_INC

#define DIMMMTR_2_MCDECS_REG                              0x00000088
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 00 - 10 bits
    // 01 - 11 bits
    // 10 - 12 bits
    // 11 - reserved
    // 
    // Bits[1:0], RWS_LB, default = 0x0
    //
    UINTX ca_width : 2;
    //
    // 000 - reserved 
    // 001 - 13 bits
    // 010 - 14 bits
    // 011 - 15 bits
    // 100 - 16 bits
    // 101 - 17 bits
    // 110 - 18 bits
    // 111: reserved
    // 
    // Bits[4:2], RWS_LB, default = 0x3
    //
    UINTX ra_width : 3;
    //
    // 000 - Reserved
    // 001 - 2Gb
    // 010 - 4Gb
    // 011 - 8Gb
    // 100 - 16Gb
    // 101 - 12Gb
    // 
    // 
    // Bits[7:5], RWS_LB, default = 0x0
    //
    UINTX ddr3_dnsty : 3;
    //
    // 00 - x4
    // 01 - x8
    // 10 - x16
    // 11 - reserved
    // 
    // 
    // Bits[9:8], RWS_LB, default = 0x0
    //
    UINTX ddr3_width : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // 
    // 00 - SR
    // 01 - DR
    // 10 - QR
    // 11 - reserved
    // 
    // 
    // Bits[13:12], RWS_LB, default = 0x0
    //
    UINTX rank_cnt : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:14], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //             DDR4 DIMM populated if set; otherwise, unpopulated.
    //             Should be set to 0 when this slot is populated with a DDR-T DIMM.
    //         
    // 
    // Bits[15:15], RWS_LB, default = 0x0
    //
    UINTX dimm_pop : 1;
    //
    // RANK Disable Control to disable refresh and ZQCAL operation. This bit setting
    // must be set consistently with TERM_RNK_MSK, i.e. both corresponding bits cannot
    // be set at the same time. In the other word, a disabled rank must not be selected
    // for the terminaton rank. 
    // RANK_DISABLE[3], i.e. bit 19: rank 3 disable. Note DIMMMTR_2.RANK_DISABLE[3] is
    // don't care since DIMM 2 must not be quad-rank 
    // RANK_DISABLE[2], i.e. bit 18: rank 2 disable. Note DIMMMTR_2.RANK_DISABLE[2] is
    // don't care since DIMM 2 must not be quad-rank 
    // RANK_DISABLE[1], i.e. bit 17: rank 1 disable
    // RANK_DISABLE[0], i.e. bit 16: rank 0 disable
    // when set, no refresh will be perform on this rank. ODT termination is not affected
    // by this bit. 
    // Note that patrols are disabled by dimm*_pat_rank_disable of amap register now
    // and not affected by this bit field. 
    // 
    // Bits[19:16], RWS_LB, default = 0x0
    //
    UINTX rank_disable : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[22:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 3;
    //
    // N/A
    // 
    // Bits[24:23], RWS_LB, default = 0x0
    //
    UINTX ddr4_3dsnumranks_cs : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 7;
  } Bits;
  UINTX Data;
} DIMMMTR_2_MCDECS_STRUCT;
#endif // ASM_INC

#define AMAP_MCDECS_REG                                   0x0000008C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable DDR4 fine grain bank interleaving. 
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX fine_grain_bank_interleaving : 1;
    //
    // When setting to 1, force additional 1 cycle latency in decoding logic (same latency
    // as 3 channel mode); expected to set to 1 when channel mirroring is enabled. 
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX force_lat : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 13;
    //
    // This field is similar to dimmmtr_*.rank_disable; but it affects only patrol operations.
    // Each bit controls 1 Chip_select's patrol in a given dimm. If 1, patrol engine
    // will skip that 
    // ChipSelect; other wise it will patrol it if dimm is populted and all other patrol
    // conditions are 
    // true. This is intended to be used after rank_sparing to skip patrol of the spared
    // rank. 
    // 
    // Bits[18:15], RW_LB, default = 0x0
    //
    UINTX dimm0_pat_rank_disable : 4;
    //
    // This field is similar to dimmmtr_*.rank_disable; but it affects only patrol operations.
    // Each bit controls 1 Chip_select's patrol in a given dimm. If 1, patrol engine
    // will skip that 
    // ChipSelect; other wise it will patrol it if dimm is populted and all other patrol
    // conditions are 
    // true. This is intended to be used after rank_sparing to skip patrol of the spared
    // rank. 
    // 
    // Bits[22:19], RW_LB, default = 0x0
    //
    UINTX dimm1_pat_rank_disable : 4;
    //
    // This field is similar to dimmmtr_*.rank_disable; but it affects only patrol operations.
    // Each bit controls 1 Chip_select's patrol in a given dimm. If 1, patrol engine
    // will skip that 
    // ChipSelect; other wise it will patrol it if dimm is populted and all other patrol
    // conditions are 
    // true. This is intended to be used after rank_sparing to skip patrol of the spared
    // rank. 
    // 
    // Bits[26:23], RW_LB, default = 0x0
    //
    UINTX dimm2_pat_rank_disable : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 5;
  } Bits;
  UINTX Data;
} AMAP_MCDECS_STRUCT;
#endif // ASM_INC

#define TADCHNILVOFFSET_0_MCDECS_REG                      0x00000090
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  socket interleave wayness
    //                         00 = 1 way,
    //                         01 = 2 way,
    //                         10 = 4 way,
    //                         11 = 8 way.
    //           
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    //  Channel interleave wayness
    //                         00 = 1 way
    //                         01 = 2 way
    //                         10 = 3 way
    //           
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // when set, the skt_wayness will be treated as skt_way*3, with the div3 that thsi
    // implies on the system address at the granularity specified by imc_granularity
    // (used for EX only) 
    //           
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the ch_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM,
    // DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
    //               b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT
    // PMem) 
    //               b'11   reserved
    //               Note:  using the same ch_granularity encoding for both DDRT and
    // DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //           
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} TADCHNILVOFFSET_0_MCDECS_STRUCT;
#endif // ASM_INC

#define TADCHNILVOFFSET_1_MCDECS_REG                      0x00000094
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  socket interleave wayness
    //                         00 = 1 way,
    //                         01 = 2 way,
    //                         10 = 4 way,
    //                         11 = 8 way.
    //           
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    //  Channel interleave wayness
    //                         00 = 1 way
    //                         01 = 2 way
    //                         10 = 3 way
    //           
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the ch_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM,
    // DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
    //               b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT
    // PMem) 
    //               b'11   reserved
    //               Note:  using the same ch_granularity encoding for both DDRT and
    // DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //           
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} TADCHNILVOFFSET_1_MCDECS_STRUCT;
#endif // ASM_INC

#define TADCHNILVOFFSET_2_MCDECS_REG                      0x00000098
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  socket interleave wayness
    //                         00 = 1 way,
    //                         01 = 2 way,
    //                         10 = 4 way,
    //                         11 = 8 way.
    //           
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    //  Channel interleave wayness
    //                         00 = 1 way
    //                         01 = 2 way
    //                         10 = 3 way
    //           
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the ch_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM,
    // DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
    //               b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT
    // PMem) 
    //               b'11   reserved
    //               Note:  using the same ch_granularity encoding for both DDRT and
    // DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //           
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} TADCHNILVOFFSET_2_MCDECS_STRUCT;
#endif // ASM_INC

#define TADCHNILVOFFSET_3_MCDECS_REG                      0x0000009C
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  socket interleave wayness
    //                         00 = 1 way,
    //                         01 = 2 way,
    //                         10 = 4 way,
    //                         11 = 8 way.
    //           
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    //  Channel interleave wayness
    //                         00 = 1 way
    //                         01 = 2 way
    //                         10 = 3 way
    //           
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the ch_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM,
    // DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
    //               b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT
    // PMem) 
    //               b'11   reserved
    //               Note:  using the same ch_granularity encoding for both DDRT and
    // DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //           
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} TADCHNILVOFFSET_3_MCDECS_STRUCT;
#endif // ASM_INC

#define TADCHNILVOFFSET_4_MCDECS_REG                      0x000000A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  socket interleave wayness
    //                         00 = 1 way,
    //                         01 = 2 way,
    //                         10 = 4 way,
    //                         11 = 8 way.
    //           
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    //  Channel interleave wayness
    //                         00 = 1 way
    //                         01 = 2 way
    //                         10 = 3 way
    //           
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the ch_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM,
    // DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
    //               b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT
    // PMem) 
    //               b'11   reserved
    //               Note:  using the same ch_granularity encoding for both DDRT and
    // DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //           
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} TADCHNILVOFFSET_4_MCDECS_STRUCT;
#endif // ASM_INC

#define TADCHNILVOFFSET_5_MCDECS_REG                      0x000000A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  socket interleave wayness
    //                         00 = 1 way,
    //                         01 = 2 way,
    //                         10 = 4 way,
    //                         11 = 8 way.
    //           
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    //  Channel interleave wayness
    //                         00 = 1 way
    //                         01 = 2 way
    //                         10 = 3 way
    //           
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the ch_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM,
    // DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
    //               b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT
    // PMem) 
    //               b'11   reserved
    //               Note:  using the same ch_granularity encoding for both DDRT and
    // DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //           
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} TADCHNILVOFFSET_5_MCDECS_STRUCT;
#endif // ASM_INC

#define TADCHNILVOFFSET_6_MCDECS_REG                      0x000000A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  socket interleave wayness
    //                         00 = 1 way,
    //                         01 = 2 way,
    //                         10 = 4 way,
    //                         11 = 8 way.
    //           
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    //  Channel interleave wayness
    //                         00 = 1 way
    //                         01 = 2 way
    //                         10 = 3 way
    //           
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the ch_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM,
    // DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
    //               b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT
    // PMem) 
    //               b'11   reserved
    //               Note:  using the same ch_granularity encoding for both DDRT and
    // DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //           
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} TADCHNILVOFFSET_6_MCDECS_STRUCT;
#endif // ASM_INC

#define TADCHNILVOFFSET_7_MCDECS_REG                      0x000000AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    //  socket interleave wayness
    //                         00 = 1 way,
    //                         01 = 2 way,
    //                         10 = 4 way,
    //                         11 = 8 way.
    //           
    // 
    // Bits[1:0], RW_LB, default = 0x0
    //
    UINTX skt_ways : 2;
    //
    //  Channel interleave wayness
    //                         00 = 1 way
    //                         01 = 2 way
    //                         10 = 3 way
    //           
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX chn_ways : 2;
    //
    // channel interleave 0 offset, i.e. CHANNELOFFSET[45:26] == channel interleave i
    // offset, 64MB granularity . 
    // 
    // Bits[23:4], RW_LB, default = 0x0
    //
    UINTX tad_offset : 20;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX chn_idx_offset : 2;
    //
    // This field should be removed for SKX.  
    // 
    // Bits[26:26], RW_LB, default = 0x0
    //
    UINTX imc_wayness_x3 : 1;
    //
    // 
    //               Specifies the granularity of the skt_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for 1LM only)
    //               b'10   4KB (based off PA[12] and up) (used for 2LM, PMem, and Block/DDRT_CSR)
    //               b'11   1GB (based off PA[30] and up) {used for PMem only, though
    // the standard PMem mode will be 4KB) 
    //           
    // 
    // Bits[28:27], RW_LB, default = 0x0
    //
    UINTX skt_granularity : 2;
    //
    // 
    //               Specifies the granularity of the ch_way interleave
    //               b'00   64B (based off PA[6] and up)  (used for DDR4 legacy 1LM only)
    //               b'01  256B (based off PA[8] and up)  (used for DDR4 1LM, DDR4 2LM,
    // DDRT Block, and DDRT 2LM.  the latter only in mirror mode) 
    //               b'10   4KB (based off PA[12] and up) (used for DDRT 2LM and DDRT
    // PMem) 
    //               b'11   reserved
    //               Note:  using the same ch_granularity encoding for both DDRT and
    // DDR4 even though 64B only applies for DDR4 and 4KB only applies for DDRT. 
    //           
    // 
    // Bits[30:29], RW_LB, default = 0x0
    //
    UINTX ch_granularity : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
  } Bits;
  UINTX Data;
} TADCHNILVOFFSET_7_MCDECS_STRUCT;
#endif // ASM_INC

#define MEM_SIZE_CONTROL_MCDECS_REG                       0x000000C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Enable address crop for fast div-3
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX enable : 1;
    //
    // Per Channel Near Memory Capacity.
    // 4'h0 - 4GB
    // 4'h1 - 8GB
    // 4'h2 - 16GB
    // 4'h3 - 32GB
    // 4'h4 - 64GB
    // 4'h5 - 128GB
    // 4'h6 - 256GB
    // 4'h7 - 512GB
    // 4'b1xxx - Reserved
    // This field can be programmed on the per-channel basis.
    // 
    // 
    // Bits[4:1], RW_LB, default = 0x0
    //
    UINTX nm_chn_cap : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 27;
  } Bits;
  UINTX Data;
} MEM_SIZE_CONTROL_MCDECS_STRUCT;
#endif // ASM_INC

#define PXPENHCAP_MCDECS_REG                              0x00000100
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Indicates there are no capability structures in the enhanced configuration space.
    // 
    // Bits[15:0], RO, default = 0x0
    //
    UINTX capability_id : 16;
    //
    // Indicates there are no capability structures in the enhanced configuration space.
    // 
    // Bits[19:16], RO, default = 0x0
    //
    UINTX capability_version : 4;
    //
    // N/A
    // 
    // Bits[31:20], RO, default = 0x0
    //
    UINTX next_capability_offset : 12;
  } Bits;
  UINTX Data;
} PXPENHCAP_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRWAYNESSLIMIT_0_MCDECS_REG                      0x00000108
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[0:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // RIR[4:0].LIMIT[39:29] == highest address of the range in channel address space,
    // 384GB in lock-step/192GB in independent channel, 512MB granularity.  
    // 
    // Bits[11:1], RW_LB, default = 0x0
    //
    UINTX rir_limit : 11;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 16;
    //
    // rank interleave wayness00 = 1 way,
    //            01 = 2 way,
    //            10 = 4 way,
    //            11 = 8 way.
    // 
    // Bits[29:28], RW_LB, default = 0x0
    //
    UINTX rir_way : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Range Valid when set; otherwise, invalid
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX rir_val : 1;
  } Bits;
  UINTX Data;
} RIRWAYNESSLIMIT_0_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRWAYNESSLIMIT_1_MCDECS_REG                      0x0000010C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[0:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // RIR[4:0].LIMIT[39:29] == highest address of the range in channel address space,
    // 384GB in lock-step/192GB in independent channel, 512MB granularity.  
    // 
    // Bits[11:1], RW_LB, default = 0x0
    //
    UINTX rir_limit : 11;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 16;
    //
    // rank interleave wayness00 = 1 way,
    //            01 = 2 way,
    //            10 = 4 way,
    //            11 = 8 way.
    // 
    // Bits[29:28], RW_LB, default = 0x0
    //
    UINTX rir_way : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Range Valid when set; otherwise, invalid
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX rir_val : 1;
  } Bits;
  UINTX Data;
} RIRWAYNESSLIMIT_1_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRWAYNESSLIMIT_2_MCDECS_REG                      0x00000110
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[0:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // RIR[4:0].LIMIT[39:29] == highest address of the range in channel address space,
    // 384GB in lock-step/192GB in independent channel, 512MB granularity.  
    // 
    // Bits[11:1], RW_LB, default = 0x0
    //
    UINTX rir_limit : 11;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 16;
    //
    // rank interleave wayness00 = 1 way,
    //            01 = 2 way,
    //            10 = 4 way,
    //            11 = 8 way.
    // 
    // Bits[29:28], RW_LB, default = 0x0
    //
    UINTX rir_way : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Range Valid when set; otherwise, invalid
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX rir_val : 1;
  } Bits;
  UINTX Data;
} RIRWAYNESSLIMIT_2_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRWAYNESSLIMIT_3_MCDECS_REG                      0x00000114
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[0:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // RIR[4:0].LIMIT[39:29] == highest address of the range in channel address space,
    // 384GB in lock-step/192GB in independent channel, 512MB granularity.  
    // 
    // Bits[11:1], RW_LB, default = 0x0
    //
    UINTX rir_limit : 11;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:12], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 16;
    //
    // rank interleave wayness00 = 1 way,
    //            01 = 2 way,
    //            10 = 4 way,
    //            11 = 8 way.
    // 
    // Bits[29:28], RW_LB, default = 0x0
    //
    UINTX rir_way : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // Range Valid when set; otherwise, invalid
    // 
    // Bits[31:31], RW_LB, default = 0x0
    //
    UINTX rir_val : 1;
  } Bits;
  UINTX Data;
} RIRWAYNESSLIMIT_3_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV0OFFSET_0_MCDECS_REG                        0x00000120
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET0[39:26] == rank interleave 0 offset, 64MB granularity 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset0 : 14;
    //
    // target rank ID for rank interleave 0 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt0 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV0OFFSET_0_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV0OFFSET_1_MCDECS_REG                        0x00000124
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET0[39:26] == rank interleave 0 offset, 64MB granularity 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset0 : 14;
    //
    // target rank ID for rank interleave 0 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt0 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV0OFFSET_1_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV0OFFSET_2_MCDECS_REG                        0x00000128
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET0[39:26] == rank interleave 0 offset, 64MB granularity 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset0 : 14;
    //
    // target rank ID for rank interleave 0 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt0 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV0OFFSET_2_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV0OFFSET_3_MCDECS_REG                        0x0000012C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET0[39:26] == rank interleave 0 offset, 64MB granularity 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset0 : 14;
    //
    // target rank ID for rank interleave 0 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt0 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV0OFFSET_3_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV1OFFSET_0_MCDECS_REG                        0x00000130
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET1[39:26] == rank interleave 1 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    //         
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset1 : 14;
    //
    // target rank ID for rank interleave 1 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt1 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV1OFFSET_0_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV1OFFSET_1_MCDECS_REG                        0x00000134
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET1[39:26] == rank interleave 1 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    //         
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset1 : 14;
    //
    // target rank ID for rank interleave 1 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt1 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV1OFFSET_1_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV1OFFSET_2_MCDECS_REG                        0x00000138
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET1[39:26] == rank interleave 1 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    //         
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset1 : 14;
    //
    // target rank ID for rank interleave 1 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt1 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV1OFFSET_2_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV1OFFSET_3_MCDECS_REG                        0x0000013C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET1[39:26] == rank interleave 1 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    //         
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset1 : 14;
    //
    // target rank ID for rank interleave 1 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt1 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV1OFFSET_3_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV2OFFSET_0_MCDECS_REG                        0x00000140
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET2[39:26] == rank interleave 2 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset2 : 14;
    //
    // target rank ID for rank interleave 2 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt2 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV2OFFSET_0_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV2OFFSET_1_MCDECS_REG                        0x00000144
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET2[39:26] == rank interleave 2 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset2 : 14;
    //
    // target rank ID for rank interleave 2 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt2 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV2OFFSET_1_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV2OFFSET_2_MCDECS_REG                        0x00000148
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET2[39:26] == rank interleave 2 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset2 : 14;
    //
    // target rank ID for rank interleave 2 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt2 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV2OFFSET_2_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV2OFFSET_3_MCDECS_REG                        0x0000014C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET2[39:26] == rank interleave 2 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset2 : 14;
    //
    // target rank ID for rank interleave 2 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt2 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV2OFFSET_3_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV3OFFSET_0_MCDECS_REG                        0x00000150
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET3[39:26] == rank interleave 3 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset3 : 14;
    //
    // target rank ID for rank interleave 3 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV3OFFSET_0_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV3OFFSET_1_MCDECS_REG                        0x00000154
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET3[39:26] == rank interleave 3 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset3 : 14;
    //
    // target rank ID for rank interleave 3 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV3OFFSET_1_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV3OFFSET_2_MCDECS_REG                        0x00000158
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET3[39:26] == rank interleave 3 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset3 : 14;
    //
    // target rank ID for rank interleave 3 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV3OFFSET_2_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV3OFFSET_3_MCDECS_REG                        0x0000015C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET3[39:26] == rank interleave 3 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset3 : 14;
    //
    // target rank ID for rank interleave 3 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV3OFFSET_3_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV4OFFSET_0_MCDECS_REG                        0x00000160
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET4[39:26] == rank interleave 4 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset4 : 14;
    //
    // target rank ID for rank interleave 4 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt4 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV4OFFSET_0_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV4OFFSET_1_MCDECS_REG                        0x00000164
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET4[39:26] == rank interleave 4 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset4 : 14;
    //
    // target rank ID for rank interleave 4 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt4 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV4OFFSET_1_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV4OFFSET_2_MCDECS_REG                        0x00000168
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET4[39:26] == rank interleave 4 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset4 : 14;
    //
    // target rank ID for rank interleave 4 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt4 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV4OFFSET_2_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV4OFFSET_3_MCDECS_REG                        0x0000016C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET4[39:26] == rank interleave 4 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset4 : 14;
    //
    // target rank ID for rank interleave 4 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt4 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV4OFFSET_3_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV5OFFSET_0_MCDECS_REG                        0x00000170
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET5[39:26] == rank interleave 5 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset5 : 14;
    //
    // target rank ID for rank interleave 5 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt5 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV5OFFSET_0_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV5OFFSET_1_MCDECS_REG                        0x00000174
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET5[39:26] == rank interleave 5 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset5 : 14;
    //
    // target rank ID for rank interleave 5 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt5 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV5OFFSET_1_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV5OFFSET_2_MCDECS_REG                        0x00000178
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET5[39:26] == rank interleave 5 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset5 : 14;
    //
    // target rank ID for rank interleave 5 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt5 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV5OFFSET_2_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV5OFFSET_3_MCDECS_REG                        0x0000017C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET5[39:26] == rank interleave 5 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset5 : 14;
    //
    // target rank ID for rank interleave 5 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt5 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV5OFFSET_3_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV6OFFSET_0_MCDECS_REG                        0x00000180
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET6[39:26] == rank interleave 6 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset6 : 14;
    //
    // target rank ID for rank interleave 6 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt6 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV6OFFSET_0_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV6OFFSET_1_MCDECS_REG                        0x00000184
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET6[39:26] == rank interleave 6 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset6 : 14;
    //
    // target rank ID for rank interleave 6 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt6 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV6OFFSET_1_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV6OFFSET_2_MCDECS_REG                        0x00000188
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET6[39:26] == rank interleave 6 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset6 : 14;
    //
    // target rank ID for rank interleave 6 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt6 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV6OFFSET_2_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV6OFFSET_3_MCDECS_REG                        0x0000018C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET6[39:26] == rank interleave 6 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset6 : 14;
    //
    // target rank ID for rank interleave 6 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt6 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV6OFFSET_3_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV7OFFSET_0_MCDECS_REG                        0x00000190
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET7[39:26] == rank interleave 0 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset7 : 14;
    //
    // target rank ID for rank interleave 7 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt7 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV7OFFSET_0_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV7OFFSET_1_MCDECS_REG                        0x00000194
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET7[39:26] == rank interleave 0 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset7 : 14;
    //
    // target rank ID for rank interleave 7 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt7 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV7OFFSET_1_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV7OFFSET_2_MCDECS_REG                        0x00000198
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET7[39:26] == rank interleave 0 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset7 : 14;
    //
    // target rank ID for rank interleave 7 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt7 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV7OFFSET_2_MCDECS_STRUCT;
#endif // ASM_INC

#define RIRILV7OFFSET_3_MCDECS_REG                        0x0000019C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
    //
    // RIR[5:0].RANKOFFSET7[39:26] == rank interleave 0 offset, 64MB granularity 
    //             (The processor's minimum rank size is 512MB. 512MB/8 interleave =
    // 64MB per 8-way interleave.) 
    // 
    // Bits[15:2], RW_LB, default = 0x0
    //
    UINTX rir_offset7 : 14;
    //
    // target rank ID for rank interleave 7 (used for 1/2/4/8-way RIR interleaving).
    // 
    // Bits[19:16], RW_LB, default = 0x0
    //
    UINTX rir_rnk_tgt7 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 12;
  } Bits;
  UINTX Data;
} RIRILV7OFFSET_3_MCDECS_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_ADDR_MATCH_LO_MCDECS_REG                 0x000001C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Addr Match Lower: 32-bits (Match Addr[34:3])
    // 
    // Bits[31:0], RWS, default = 0x0
    //
    UINTX addr_match_lower : 32;
  } Bits;
  UINTX Data;
} RSP_FUNC_ADDR_MATCH_LO_MCDECS_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_ADDR_MATCH_HI_MCDECS_REG                 0x000001C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Addr Match Higher : 11-Bits (Match Addr[45:35])
    // 
    // Bits[10:0], RWS, default = 0x0
    //
    UINTX addr_match_higher : 11;
    //
    // Enabling the Address Match Response Function when set.
    // 
    // Bits[11:11], RWS_LV, default = 0x0
    //
    UINTX rsp_func_addr_match_en : 1;
    //
    // The enable bit RSP_FUNC_ADDR_MATCH_EN will not be self cleared after match if
    // this field is set. Continuous address matching. 
    // 
    // Bits[12:12], RWS, default = 0x0
    //
    UINTX rsp_func_addr_match_always : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 3;
    //
    // HTID comparison value for array dump. Note array dump function is only enabled
    // when the WPQ_DUMP_CFG2.VALID or the RPQ_DUMP_CFG2.VALID are enabled. 
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX htid_match : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Additional match configuration: Bit 0 matches with Mirror field; Bit 1 matches
    // with mirr_pri (primary channel); Bit 2 matches with demand scrub request 
    // 
    // Bits[27:25], RWS, default = 0x0
    //
    UINTX mirror_match : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} RSP_FUNC_ADDR_MATCH_HI_MCDECS_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_ADDR_MASK_LO_MCDECS_REG                  0x000001C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Address Mask to deselect (when set) the corresponding Addr[34:3] for the address
    // match. 
    // 
    // Bits[31:0], RWS, default = 0xFFFFFFFF
    //
    UINTX addr_mask_lower : 32;
  } Bits;
  UINTX Data;
} RSP_FUNC_ADDR_MASK_LO_MCDECS_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_ADDR_MASK_HI_MCDECS_REG                  0x000001CC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Address Mask to deselect (when set) the corresponding Addr[45:35] for the address
    // match. 
    // 
    // Bits[10:0], RWS, default = 0x7FF
    //
    UINTX addr_mask_higher : 11;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 5;
    //
    // HTID mask comparison value for array dump
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINTX htid_mask : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Additional mask to deselect (when set) the corresponding bits in mirror_mask field.
    // Bit 0 is mask for Mirror field; Bit 1 is mask for mirr_pri (primary channel);
    // Bit 2 is mask for demand scrub request 
    // 
    // Bits[27:25], RWS, default = 0x7
    //
    UINTX mirror_mask : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 4;
  } Bits;
  UINTX Data;
} RSP_FUNC_ADDR_MASK_HI_MCDECS_STRUCT;
#endif // ASM_INC

#define RSP_FUNC_RANK_BANK_MATCH_MCDECS_REG               0x000001D0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Bank to match
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINTX bank : 4;
    //
    // Rank to match
    // 
    // Bits[6:4], RW, default = 0x0
    //
    UINTX rank : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 23;
    //
    // Disable any injection matching on Patrol or Spare transactions. This applies to
    // rank/bank match and system address match. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINTX dis_patspr : 1;
    //
    // Enable rank and bank matching
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINTX en : 1;
  } Bits;
  UINTX Data;
} RSP_FUNC_RANK_BANK_MATCH_MCDECS_STRUCT;
#endif // ASM_INC

#define MCDECSVISACFG_MCDECS_REG                          0x000001E0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RWS_L, default = 0x0
    //
    UINTX lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RWS_L, default = 0x0
    //
    UINTX lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RWS_L, default = 0x0
    //
    UINTX lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RWS_L, default = 0x0
    //
    UINTX lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RWS_L, default = 0x0
    //
    UINTX clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} MCDECSVISACFG_MCDECS_STRUCT;
#endif // ASM_INC

#define ECC_MODE_RANK0_MCDECS_REG                         0x00000210
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This field specifies the ECC in use for this rank, for portions of
    // the rank not participating in an ADDDC region. 
    //             0 = No failure
    //             1 = Parity substitution.  EP:  Detect only, EX:  Single bit correction
    //             This field is set by software at the beginning of a sparing flow.
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} ECC_MODE_RANK0_MCDECS_STRUCT;
#endif // ASM_INC

#define ECC_MODE_RANK1_MCDECS_REG                         0x00000211
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This field specifies the ECC in use for this rank, for portions of
    // the rank not participating in an ADDDC region. 
    //             0 = No failure
    //             1 = Parity substitution.  EP:  Detect only, EX:  Single bit correction
    //             This field is set by software at the beginning of a sparing flow.
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} ECC_MODE_RANK1_MCDECS_STRUCT;
#endif // ASM_INC

#define ECC_MODE_RANK2_MCDECS_REG                         0x00000212
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This field specifies the ECC in use for this rank, for portions of
    // the rank not participating in an ADDDC region. 
    //             0 = No failure
    //             1 = Parity substitution.  EP:  Detect only, EX:  Single bit correction
    //             This field is set by software at the beginning of a sparing flow.
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} ECC_MODE_RANK2_MCDECS_STRUCT;
#endif // ASM_INC

#define ECC_MODE_RANK3_MCDECS_REG                         0x00000213
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This field specifies the ECC in use for this rank, for portions of
    // the rank not participating in an ADDDC region. 
    //             0 = No failure
    //             1 = Parity substitution.  EP:  Detect only, EX:  Single bit correction
    //             This field is set by software at the beginning of a sparing flow.
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} ECC_MODE_RANK3_MCDECS_STRUCT;
#endif // ASM_INC

#define ECC_MODE_RANK4_MCDECS_REG                         0x00000214
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This field specifies the ECC in use for this rank, for portions of
    // the rank not participating in an ADDDC region. 
    //             0 = No failure
    //             1 = Parity substitution.  EP:  Detect only, EX:  Single bit correction
    //             This field is set by software at the beginning of a sparing flow.
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} ECC_MODE_RANK4_MCDECS_STRUCT;
#endif // ASM_INC

#define ECC_MODE_RANK5_MCDECS_REG                         0x00000215
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This field specifies the ECC in use for this rank, for portions of
    // the rank not participating in an ADDDC region. 
    //             0 = No failure
    //             1 = Parity substitution.  EP:  Detect only, EX:  Single bit correction
    //             This field is set by software at the beginning of a sparing flow.
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} ECC_MODE_RANK5_MCDECS_STRUCT;
#endif // ASM_INC

#define ECC_MODE_RANK6_MCDECS_REG                         0x00000216
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This field specifies the ECC in use for this rank, for portions of
    // the rank not participating in an ADDDC region. 
    //             0 = No failure
    //             1 = Parity substitution.  EP:  Detect only, EX:  Single bit correction
    //             This field is set by software at the beginning of a sparing flow.
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} ECC_MODE_RANK6_MCDECS_STRUCT;
#endif // ASM_INC

#define ECC_MODE_RANK7_MCDECS_REG                         0x00000217
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This field specifies the ECC in use for this rank, for portions of
    // the rank not participating in an ADDDC region. 
    //             0 = No failure
    //             1 = Parity substitution.  EP:  Detect only, EX:  Single bit correction
    //             This field is set by software at the beginning of a sparing flow.
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX mode : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 7;
  } Bits;
  UINTX Data;
} ECC_MODE_RANK7_MCDECS_STRUCT;
#endif // ASM_INC

#define ADDDC_REGION0_CONTROL_MCDECS_REG                  0x00000230
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This bit specifies whether the ADDDC region is in use.
    //             0=ADDDC not enabled for this region
    //             1=ADDDC enabled for this region
    //             This bit should be set by software before the beginning of the ADDDC
    // sparing copy flow. 
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX region_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //             Granularity for this ADDDC region:
    //             00=bank
    //             01=rank
    //             10=reserved 
    //             11=reserved
    //         
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX region_size : 2;
    //
    // 
    //             This field specifies the Chip Select (rank) to match when determining
    // if this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  The value in this field is encoded (Chip Selects are normally 1-hot), corresponding
    // to CS0-CS7.  When the failed region is a DIMM, two region registers should be
    // programmed corresponding to both Chip Selects of the failed DIMM. 
    //         
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX failed_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //             This field specifies the subrank to match when determining if this
    // is the failed region participating in ADDDC.  Only used when region_size=bank.
    //         
    // 
    // Bits[10:8], RW_LB, default = 0x0
    //
    UINTX failed_c : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // 
    //             This field specifies the bank address to match when determining if
    // this is the failed region participating in ADDDC.  Only used when region_size=bank.
    //         
    // 
    // Bits[13:12], RW_LB, default = 0x0
    //
    UINTX failed_ba : 2;
    //
    // 
    //             This field specifies the bank group to match when determining if this
    // is the failed region participating in ADDDC.  Only used when region_size=bank.
    //         
    // 
    // Bits[15:14], RW_LB, default = 0x0
    //
    UINTX failed_bg : 2;
    //
    // 
    //             This field specifies the Chip Select (rank) to match when determining
    // if this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  The value in this field is encoded (Chip Selects are normally 1-hot), corresponding
    // to CS0-CS7.  When the failed region is a DIMM, two region registers should be
    // programmed corresponding to both Chip Selects of the failed DIMM. 
    //         
    // 
    // Bits[18:16], RW_LB, default = 0x0
    //
    UINTX nonfailed_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // 
    //             This field specifies the subrank to match when determining if this
    // is the failed region participating in ADDDC.  Only used when region_size=bank.
    //         
    // 
    // Bits[22:20], RW_LB, default = 0x0
    //
    UINTX nonfailed_c : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // 
    //             This field specifies the bank address to match when determining if
    // this is the failed region participating in ADDDC.  Only used when region_size=bank.
    //         
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX nonfailed_ba : 2;
    //
    // 
    //             This field specifies the bank group to match when determining if this
    // is the failed region participating in ADDDC.  Only used when region_size=bank.
    //         
    // 
    // Bits[27:26], RW_LB, default = 0x0
    //
    UINTX nonfailed_bg : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // 
    //             This field specifies that ADDDC spare copy is on-going for this region.
    //             This bit should be set by BIOS before starting the ADDDC sparing copy
    // flow. 
    //             This bit should be cleared by hardware at the end of the sparing copy
    // flow. 
    //         
    // 
    // Bits[29:29], RW_LBV, default = 0x0
    //
    UINTX copy_in_progress : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 2;
  } Bits;
  UINTX Data;
} ADDDC_REGION0_CONTROL_MCDECS_STRUCT;
#endif // ASM_INC

#define ADDDC_REGION1_CONTROL_MCDECS_REG                  0x00000234
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This bit specifies whether the ADDDC region is in use.
    //             0=ADDDC not enabled for this region
    //             1=ADDDC enabled for this region
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX region_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //             Granularity for this ADDDC region:
    //             00=bank
    //             01=rank
    //             10=reserved 
    //             11=reserved
    //         
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX region_size : 2;
    //
    // 
    //             This field specifies the Chip Select (rank) to match when determining
    // if this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  The value in this field is encoded (Chip Selects are normally 1-hot), corresponding
    // to CS0-CS7.  When the failed region is a DIMM, two region registers should be
    // programmed corresponding to both Chip Selects of the failed DIMM. 
    //         
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX failed_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //             This field specifies the subrank to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[10:8], RW_LB, default = 0x0
    //
    UINTX failed_c : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // 
    //             This field specifies the bank address to match when determining if
    // this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[13:12], RW_LB, default = 0x0
    //
    UINTX failed_ba : 2;
    //
    // 
    //             This field specifies the bank group to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[15:14], RW_LB, default = 0x0
    //
    UINTX failed_bg : 2;
    //
    // 
    //             This field specifies the Chip Select (rank) to match when determining
    // if this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  The value in this field is encoded (Chip Selects are normally 1-hot), corresponding
    // to CS0-CS7.  When the failed region is a DIMM, two region registers should be
    // programmed corresponding to both Chip Selects of the failed DIMM. 
    //         
    // 
    // Bits[18:16], RW_LB, default = 0x0
    //
    UINTX nonfailed_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // 
    //             This field specifies the subrank to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[22:20], RW_LB, default = 0x0
    //
    UINTX nonfailed_c : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // 
    //             This field specifies the bank address to match when determining if
    // this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX nonfailed_ba : 2;
    //
    // 
    //             This field specifies the bank group to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[27:26], RW_LB, default = 0x0
    //
    UINTX nonfailed_bg : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // 
    //           This field specifies that ADDDC spare copy is on-going for this region
    //         
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX copy_in_progress : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 2;
  } Bits;
  UINTX Data;
} ADDDC_REGION1_CONTROL_MCDECS_STRUCT;
#endif // ASM_INC

#define ADDDC_REGION2_CONTROL_MCDECS_REG                  0x00000238
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This bit specifies whether the ADDDC region is in use.
    //             0=ADDDC not enabled for this region
    //             1=ADDDC enabled for this region
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX region_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //             Granularity for this ADDDC region:
    //             00=bank
    //             01=rank
    //             10=reserved 
    //             11=reserved
    //         
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX region_size : 2;
    //
    // 
    //             This field specifies the Chip Select (rank) to match when determining
    // if this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  The value in this field is encoded (Chip Selects are normally 1-hot), corresponding
    // to CS0-CS7.  When the failed region is a DIMM, two region registers should be
    // programmed corresponding to both Chip Selects of the failed DIMM. 
    //         
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX failed_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //             This field specifies the subrank to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[10:8], RW_LB, default = 0x0
    //
    UINTX failed_c : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // 
    //             This field specifies the bank address to match when determining if
    // this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[13:12], RW_LB, default = 0x0
    //
    UINTX failed_ba : 2;
    //
    // 
    //             This field specifies the bank group to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[15:14], RW_LB, default = 0x0
    //
    UINTX failed_bg : 2;
    //
    // 
    //             This field specifies the Chip Select (rank) to match when determining
    // if this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  The value in this field is encoded (Chip Selects are normally 1-hot), corresponding
    // to CS0-CS7.  When the failed region is a DIMM, two region registers should be
    // programmed corresponding to both Chip Selects of the failed DIMM. 
    //         
    // 
    // Bits[18:16], RW_LB, default = 0x0
    //
    UINTX nonfailed_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // 
    //             This field specifies the subrank to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[22:20], RW_LB, default = 0x0
    //
    UINTX nonfailed_c : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // 
    //             This field specifies the bank address to match when determining if
    // this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX nonfailed_ba : 2;
    //
    // 
    //             This field specifies the bank group to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[27:26], RW_LB, default = 0x0
    //
    UINTX nonfailed_bg : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // 
    //           This field specifies that ADDDC spare copy is on-going for this region
    //         
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX copy_in_progress : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 2;
  } Bits;
  UINTX Data;
} ADDDC_REGION2_CONTROL_MCDECS_STRUCT;
#endif // ASM_INC

#define ADDDC_REGION3_CONTROL_MCDECS_REG                  0x0000023C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             This bit specifies whether the ADDDC region is in use.
    //             0=ADDDC not enabled for this region
    //             1=ADDDC enabled for this region
    //         
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX region_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // 
    //             Granularity for this ADDDC region:
    //             00=bank
    //             01=rank
    //             10=reserved 
    //             11=reserved
    //         
    // 
    // Bits[3:2], RW_LB, default = 0x0
    //
    UINTX region_size : 2;
    //
    // 
    //             This field specifies the Chip Select (rank) to match when determining
    // if this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  The value in this field is encoded (Chip Selects are normally 1-hot), corresponding
    // to CS0-CS7.  When the failed region is a DIMM, two region registers should be
    // programmed corresponding to both Chip Selects of the failed DIMM. 
    //         
    // 
    // Bits[6:4], RW_LB, default = 0x0
    //
    UINTX failed_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // 
    //             This field specifies the subrank to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[10:8], RW_LB, default = 0x0
    //
    UINTX failed_c : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 1;
    //
    // 
    //             This field specifies the bank address to match when determining if
    // this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[13:12], RW_LB, default = 0x0
    //
    UINTX failed_ba : 2;
    //
    // 
    //             This field specifies the bank group to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[15:14], RW_LB, default = 0x0
    //
    UINTX failed_bg : 2;
    //
    // 
    //             This field specifies the Chip Select (rank) to match when determining
    // if this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  The value in this field is encoded (Chip Selects are normally 1-hot), corresponding
    // to CS0-CS7.  When the failed region is a DIMM, two region registers should be
    // programmed corresponding to both Chip Selects of the failed DIMM. 
    //         
    // 
    // Bits[18:16], RW_LB, default = 0x0
    //
    UINTX nonfailed_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 1;
    //
    // 
    //             This field specifies the subrank to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[22:20], RW_LB, default = 0x0
    //
    UINTX nonfailed_c : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_4 : 1;
    //
    // 
    //             This field specifies the bank address to match when determining if
    // this is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[25:24], RW_LB, default = 0x0
    //
    UINTX nonfailed_ba : 2;
    //
    // 
    //             This field specifies the bank group to match when determining if this
    // is the failed region participating in either ADDDC or Static Virtual Lockstep.
    //  Only used when region_size=bank. 
    //         
    // 
    // Bits[27:26], RW_LB, default = 0x0
    //
    UINTX nonfailed_bg : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:28], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_5 : 1;
    //
    // 
    //           This field specifies that ADDDC spare copy is on-going for this region
    //         
    // 
    // Bits[29:29], RW_LB, default = 0x0
    //
    UINTX copy_in_progress : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_6 : 2;
  } Bits;
  UINTX Data;
} ADDDC_REGION3_CONTROL_MCDECS_STRUCT;
#endif // ASM_INC

#define SCRATCHPAD2_MCDECS_REG                            0x00000240
#ifndef ASM_INC
typedef union {
  struct {
    //
    // SCRATCHPAD2
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINTX scratchpad2 : 32;
  } Bits;
  UINTX Data;
} SCRATCHPAD2_MCDECS_STRUCT;
#endif // ASM_INC

#define MCDECS_CHKN_BIT_MCDECS_REG                        0x00000244
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Disable RCB Clock Gate in DECS
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX dis_mcdecs_pri_rcb_gate : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 31;
  } Bits;
  UINTX Data;
} MCDECS_CHKN_BIT_MCDECS_STRUCT;
#endif // ASM_INC

#define MCDECS_RCB_GATE_CTL_MCDECS_REG                    0x00000248
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Time clock keeps running after triggering events
    // 
    // Bits[9:0], RW_LB, default = 0x40
    //
    UINTX rcb_gate_mcdecs_timer : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:10], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 22;
  } Bits;
  UINTX Data;
} MCDECS_RCB_GATE_CTL_MCDECS_STRUCT;
#endif // ASM_INC

#define MCDECS_ERR_LOG_MCDECS_REG                         0x0000024C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Error indication when critical chunk bit is set for ADDDC or PlusOne transaction
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX critical_chunk_err : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:1], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 31;
  } Bits;
  UINTX Data;
} MCDECS_ERR_LOG_MCDECS_STRUCT;
#endif // ASM_INC

#define MCDECS_CHICKEN_BITS_MCDECS_REG                    0x00000300
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Disable clock gating addr_decode
    // 
    // Bits[0:0], RW_LB, default = 0x0
    //
    UINTX dis_ck_gate_addr_dec : 1;
    //
    // Converts isoch writes to non isoch in decoder
    // 
    // Bits[1:1], RW_LB, default = 0x0
    //
    UINTX dis_isoch_wr : 1;
    //
    // Converts isoch reads to non isoch in decoder
    // 
    // Bits[2:2], RW_LB, default = 0x0
    //
    UINTX dis_isoch_rd : 1;
    //
    // Reserved Unused
    // 
    // Bits[3:3], RW_LB, default = 0x0
    //
    UINTX defeature_2 : 1;
    //
    // Reserved Unused
    // 
    // Bits[4:4], RW_LB, default = 0x0
    //
    UINTX defeature_3 : 1;
    //
    // Enable ADDDC format for CPGC transactions. Use for x8 virtual lockstep mode only.
    // 
    // Bits[5:5], RW_LB, default = 0x0
    //
    UINTX en_cpgc_adddc : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:6], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 2;
  } Bits;
  UINTX Data;
} MCDECS_CHICKEN_BITS_MCDECS_STRUCT;
#endif // ASM_INC

#define MCDDRTCFG_MCDECS_REG                              0x00000400
#ifndef ASM_INC
typedef union {
  struct {
    //
    // 
    //             DDR-T DIMM populated if set; otherwise, unpopulated.
    //             Should be set to 0 when this slot is populated with a DDR4 DIMM.
    //         
    // 
    // Bits[0:0], RW_L, default = 0x0
    //
    UINTX slot0 : 1;
    //
    // 
    //             DDR-T DIMM populated if set; otherwise, unpopulated.
    //             Should be set to 0 when this slot is populated with a DDR4 DIMM.
    //         
    // 
    // Bits[1:1], RW_L, default = 0x0
    //
    UINTX slot1 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:2], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 30;
  } Bits;
  UINTX Data;
} MCDDRTCFG_MCDECS_STRUCT;
#endif // ASM_INC


#endif // _MCDECS_H_
